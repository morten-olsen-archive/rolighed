module.exports =
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 9681:
/***/ ((module) => {

"use strict";
module.exports = {"i8":"1.1.2"};

/***/ }),

/***/ 108:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CiaoService = exports.InternalServiceEvent = exports.ServiceEvent = exports.ServiceState = exports.ServiceType = void 0;
const tslib_1 = __nccwpck_require__(4290);
const assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
const debug_1 = tslib_1.__importDefault(__nccwpck_require__(7984));
const events_1 = __nccwpck_require__(8614);
const net_1 = tslib_1.__importDefault(__nccwpck_require__(1631));
const AAAARecord_1 = __nccwpck_require__(8584);
const ARecord_1 = __nccwpck_require__(1540);
const NSECRecord_1 = __nccwpck_require__(2991);
const PTRRecord_1 = __nccwpck_require__(8517);
const SRVRecord_1 = __nccwpck_require__(1701);
const TXTRecord_1 = __nccwpck_require__(1930);
const ResourceRecord_1 = __nccwpck_require__(7761);
const index_1 = __nccwpck_require__(8381);
const NetworkManager_1 = __nccwpck_require__(8730);
const dns_equal_1 = __nccwpck_require__(7338);
const domainFormatter = tslib_1.__importStar(__nccwpck_require__(9783));
const domain_formatter_1 = __nccwpck_require__(9783);
const debug = debug_1.default("ciao:CiaoService");
const numberedServiceNamePattern = /^(.*) \((\d+)\)$/; // matches a name lik "My Service (2)"
const numberedHostnamePattern = /^(.*)-\((\d+)\)(\.\w{2,}.)$/; // matches a hostname like "My-Computer-(2).local."
/**
 * This enum defines some commonly used service types.
 * This is also referred to as service name (as of RFC 6763).
 * A service name must not be longer than 15 characters (RFC 6763 7.2).
 */
var ServiceType;
(function (ServiceType) {
    // noinspection JSUnusedGlobalSymbols
    ServiceType["AIRDROP"] = "airdrop";
    ServiceType["AIRPLAY"] = "airplay";
    ServiceType["AIRPORT"] = "airport";
    ServiceType["COMPANION_LINK"] = "companion-link";
    ServiceType["DACP"] = "dacp";
    ServiceType["HAP"] = "hap";
    ServiceType["HOMEKIT"] = "homekit";
    ServiceType["HTTP"] = "http";
    ServiceType["HTTP_ALT"] = "http_alt";
    ServiceType["IPP"] = "ipp";
    ServiceType["IPPS"] = "ipps";
    ServiceType["RAOP"] = "raop";
    ServiceType["scanner"] = "scanner";
    ServiceType["TOUCH_ABLE"] = "touch-able";
    ServiceType["DNS_SD"] = "dns-sd";
    ServiceType["PRINTER"] = "printer";
})(ServiceType = exports.ServiceType || (exports.ServiceType = {}));
/**
 * @private
 */
var ServiceState;
(function (ServiceState) {
    ServiceState["UNANNOUNCED"] = "unannounced";
    ServiceState["PROBING"] = "probing";
    ServiceState["PROBED"] = "probed";
    ServiceState["ANNOUNCING"] = "announcing";
    ServiceState["ANNOUNCED"] = "announced";
})(ServiceState = exports.ServiceState || (exports.ServiceState = {}));
/**
 * Events thrown by a CiaoService
 */
var ServiceEvent;
(function (ServiceEvent) {
    /**
     * Event is called when the Prober identifies that the name for the service is already used
     * and thus resolve the name conflict by adjusting the name (e.g. adding '(2)' to the name).
     * This change must be persisted and thus a listener must hook up to this event
     * in order for the name to be persisted.
     */
    ServiceEvent["NAME_CHANGED"] = "name-change";
    /**
     * Event is called when the Prober identifies that the hostname for the service is already used
     * and thus resolve the name conflict by adjusting the hostname (e.g. adding '(2)' to the hostname).
     * The name change must be persisted. As the hostname is an optional parameter, it is derived
     * from the service name if not supplied.
     * If you supply a custom hostname (not automatically derived from the service name) you must
     * hook up a listener to this event in order for the hostname to be persisted.
     */
    ServiceEvent["HOSTNAME_CHANGED"] = "hostname-change";
})(ServiceEvent = exports.ServiceEvent || (exports.ServiceEvent = {}));
/**
 * Events thrown by a CiaoService, internal use only!
 * @private
 */
var InternalServiceEvent;
(function (InternalServiceEvent) {
    InternalServiceEvent["PUBLISH"] = "publish";
    InternalServiceEvent["UNPUBLISH"] = "unpublish";
    InternalServiceEvent["REPUBLISH"] = "republish";
    InternalServiceEvent["RECORD_UPDATE"] = "records-update";
    InternalServiceEvent["RECORD_UPDATE_ON_INTERFACE"] = "records-update-interface";
})(InternalServiceEvent = exports.InternalServiceEvent || (exports.InternalServiceEvent = {}));
/**
 * The CiaoService class represents a service which can be advertised on the network.
 *
 * A service is identified by it's fully qualified domain name (FQDN), which consist of
 * the service name, the service type, the protocol and the service domain (.local by default).
 *
 * The service defines a hostname and a port where the advertised service can be reached.
 *
 * Additionally a TXT record can be published, which can contain information (in form of key-value pairs),
 * which might be useful to a querier.
 *
 * A CiaoService class is always bound to a {@link Responder} and can be created using the
 * {@link Responder.createService} method in the Responder class.
 * Once the instance is created, {@link advertise} can be called to announce the service on the network.
 */
class CiaoService extends events_1.EventEmitter {
    /**
     * Constructs a new service. Please use {@link Responder.createService} to create new service.
     * When calling the constructor a callee must listen to certain events in order to provide
     * correct functionality.
     * @private used by the Responder instance to create a new service
     */
    constructor(networkManager, options) {
        super();
        /**
         * this field is entirely controlled by the Responder class
         * @private use by the Responder to set the current service state
         */
        this.serviceState = "unannounced" /* UNANNOUNCED */;
        this.destroyed = false;
        assert_1.default(networkManager, "networkManager is required");
        assert_1.default(options, "parameters options is required");
        assert_1.default(options.name, "service options parameter 'name' is required");
        assert_1.default(options.type, "service options parameter 'type' is required");
        assert_1.default(options.type.length <= 15, "service options parameter 'type' must not be longer than 15 characters");
        this.networkManager = networkManager;
        this.name = options.name;
        this.type = options.type;
        this.subTypes = options.subtypes;
        this.protocol = options.protocol || "tcp" /* TCP */;
        this.serviceDomain = options.domain || "local";
        this.fqdn = this.formatFQDN();
        this.loweredFqdn = dns_equal_1.dnsLowerCase(this.fqdn);
        this.typePTR = domainFormatter.stringify({
            type: this.type,
            protocol: this.protocol,
            domain: this.serviceDomain,
        });
        this.loweredTypePTR = dns_equal_1.dnsLowerCase(this.typePTR);
        if (this.subTypes) {
            this.subTypePTRs = this.subTypes.map(subtype => domainFormatter.stringify({
                subtype: subtype,
                type: this.type,
                protocol: this.protocol,
                domain: this.serviceDomain,
            })).map(dns_equal_1.dnsLowerCase);
        }
        this.hostname = domainFormatter.formatHostname(options.hostname || this.name, this.serviceDomain)
            .replace(/ /g, "-"); // replacing all spaces with dashes in the hostname
        this.loweredHostname = dns_equal_1.dnsLowerCase(this.hostname);
        this.port = options.port;
        if (options.restrictedAddresses) {
            assert_1.default(options.restrictedAddresses.length, "The service property 'restrictedAddresses' cannot be an empty array!");
            this.restrictedAddresses = new Map();
            for (const entry of options.restrictedAddresses) {
                if (net_1.default.isIP(entry)) {
                    if (entry === "0.0.0.0" || entry === "::") {
                        throw new Error(`[${this.fqdn}] Unspecified ip address (${entry}) cannot be used to restrict on to!`);
                    }
                    const interfaceName = NetworkManager_1.NetworkManager.resolveInterface(entry);
                    if (!interfaceName) {
                        throw new Error(`[${this.fqdn}] Could not restrict service to address ${entry} as we could not resolve it to an interface name!`);
                    }
                    const current = this.restrictedAddresses.get(interfaceName);
                    if (current) {
                        // empty interface signals "catch all" was already configured for this
                        if (current.length && !current.includes(entry)) {
                            current.push(entry);
                        }
                    }
                    else {
                        this.restrictedAddresses.set(interfaceName, [entry]);
                    }
                }
                else {
                    this.restrictedAddresses.set(entry, []); // empty array signals "use all addresses for interface"
                }
            }
        }
        this.disableIpv6 = options.disabledIpv6;
        this.txt = options.txt ? CiaoService.txtBuffersFromRecord(options.txt) : [];
        // checks if hostname or name are already numbered and adjusts the numbers if necessary
        this.incrementName(true);
    }
    /**
     * This method start the advertising process of the service:
     *  - The service name (and hostname) will be probed unique on all interfaces (as defined in RFC 6762 8.1).
     *  - Once probed unique the service will be announced (as defined in RFC 6762 8.3).
     *
     *  The returned promise resolves once the last announcement packet was successfully sent on all network interfaces.
     *  The promise might be rejected caused by one of the following reasons:
     *    - A probe query could not be sent successfully
     *    - Prober could not find a unique service name while trying for a minute (timeout)
     *    - One of the announcement packets could not be sent successfully
     */
    advertise() {
        assert_1.default(!this.destroyed, "Cannot publish destroyed service!");
        assert_1.default(this.port, "Service port must be defined before advertising the service on the network!");
        if (this.listeners("name-change" /* NAME_CHANGED */).length === 0) {
            debug("[%s] WARN: No listeners found for a potential name change on the 'name-change' event!", this.name);
        }
        return new Promise((resolve, reject) => {
            this.emit("publish" /* PUBLISH */, error => error ? reject(error) : resolve());
        });
    }
    /**
     * This method will remove the advertisement for the service on all connected network interfaces.
     * If the service is still in the Probing state, probing will simply be cancelled.
     *
     * @returns Promise will resolve once the last goodbye packet was sent out
     */
    end() {
        assert_1.default(!this.destroyed, "Cannot end destroyed service!");
        if (this.serviceState === "unannounced" /* UNANNOUNCED */) {
            return Promise.resolve();
        }
        return new Promise((resolve, reject) => {
            this.emit("unpublish" /* UNPUBLISH */, error => error ? reject(error) : resolve());
        });
    }
    /**
     * This method must be called if you want to free the memory used by this service.
     * The service instance is not usable anymore after this call.
     *
     * If the service is still announced, the service will first be removed
     * from the network by calling {@link end}.
     *
     * @returns
     */
    async destroy() {
        await this.end();
        this.destroyed = true;
        this.removeAllListeners();
    }
    /**
     * @returns The fully qualified domain name of the service, used to identify the service.
     */
    getFQDN() {
        return this.fqdn;
    }
    /**
     * @returns The service type pointer.
     */
    getTypePTR() {
        return this.typePTR;
    }
    /**
     * @returns Array of subtype pointers (undefined if no subtypes are specified).
     */
    getLowerCasedSubtypePTRs() {
        return this.subTypePTRs;
    }
    /**
     * @returns The current hostname of the service.
     */
    getHostname() {
        return this.hostname;
    }
    /**
     * @returns The port the service is advertising for.
     * {@code -1} is returned when the port is not yet set.
     */
    getPort() {
        return this.port || -1;
    }
    /**
     * @returns The current TXT of the service represented as Buffer array.
     * @private There is not need for this to be public API
     */
    getTXT() {
        return this.txt;
    }
    /**
     * @private used for internal comparison {@link dnsLowerCase}
     */
    getLowerCasedFQDN() {
        return this.loweredFqdn;
    }
    /**
     * @private used for internal comparison {@link dnsLowerCase}
     */
    getLowerCasedTypePTR() {
        return this.loweredTypePTR;
    }
    /**
     * @private used for internal comparison {@link dnsLowerCase}
     */
    getLowerCasedHostname() {
        return this.loweredHostname;
    }
    /**
     * Sets or updates the txt of the service.
     *
     * @param {ServiceTxt} txt - The updated txt record.
     * @param {boolean} silent - If set to true no announcement is sent for the updated record.
     */
    updateTxt(txt, silent = false) {
        assert_1.default(!this.destroyed, "Cannot update destroyed service!");
        assert_1.default(txt, "txt cannot be undefined");
        this.txt = CiaoService.txtBuffersFromRecord(txt);
        debug("[%s] Updating txt record%s...", this.name, silent ? " silently" : "");
        if (this.serviceState === "announcing" /* ANNOUNCING */) {
            this.rebuildServiceRecords();
            if (silent) {
                return;
            }
            if (this.currentAnnouncer.hasSentLastAnnouncement()) {
                // if the announcer hasn't sent the last announcement, the above call of rebuildServiceRecords will
                // result in updated records on the next announcement. Otherwise we still need to announce the updated records
                this.currentAnnouncer.awaitAnnouncement().then(() => {
                    this.queueTxtUpdate();
                });
            }
        }
        else if (this.serviceState === "announced" /* ANNOUNCED */) {
            this.rebuildServiceRecords();
            if (silent) {
                return;
            }
            this.queueTxtUpdate();
        }
    }
    queueTxtUpdate() {
        if (this.txtTimer) {
            return;
        }
        else {
            // we debounce txt updates, otherwise if api users would spam txt updates, we would receive the txt record
            // while we already update our txt to the next call, thus causing a conflict being detected.
            // We would then continue with Probing (to ensure uniqueness) and could then receive following spammed updates as conflicts
            // and we would change our name without it being necessary
            this.txtTimer = setTimeout(() => {
                this.txtTimer = undefined;
                if (this.serviceState !== "announced" /* ANNOUNCED */) { // stuff changed in the last 50 milliseconds
                    return;
                }
                this.emit("records-update" /* RECORD_UPDATE */, {
                    answers: [this.txtRecord()],
                    additionals: [this.serviceNSECRecord()],
                });
            }, 50);
        }
    }
    /**
     * Sets or updates the port of the service.
     * A new port number can only be set when the service is still UNANNOUNCED.
     * Otherwise an assertion error will be thrown.
     *
     * @param {number} port - The new port number.
     */
    updatePort(port) {
        assert_1.default(this.serviceState === "unannounced" /* UNANNOUNCED */, "Port number cannot be changed when service is already advertised!");
        this.port = port;
    }
    /**
     * This method updates the name of the service.
     * @param name - The new service name.
     * @private Currently not public API and only used for bonjour conformance testing.
     */
    updateName(name) {
        if (this.serviceState === "unannounced" /* UNANNOUNCED */) {
            this.name = name;
            this.fqdn = this.formatFQDN();
            this.loweredFqdn = dns_equal_1.dnsLowerCase(this.fqdn);
            return Promise.resolve();
        }
        else {
            return this.end() // send goodbye packets for the current name
                .then(() => {
                this.name = name;
                this.fqdn = this.formatFQDN();
                this.loweredFqdn = dns_equal_1.dnsLowerCase(this.fqdn);
                // service records are going to be rebuilt on the advertise step
                return this.advertise();
            });
        }
    }
    static txtBuffersFromRecord(txt) {
        const result = [];
        Object.entries(txt).forEach(([key, value]) => {
            const entry = key + "=" + value;
            result.push(Buffer.from(entry));
        });
        return result;
    }
    /**
     * @param networkUpdate
     * @private
     */
    handleNetworkInterfaceUpdate(networkUpdate) {
        assert_1.default(!this.destroyed, "Cannot update network of destroyed service!");
        // this will currently only be called when service is ANNOUNCED or in ANNOUNCING state
        if (this.serviceState !== "announced" /* ANNOUNCED */) {
            if (this.serviceState === "announcing" /* ANNOUNCING */) {
                this.rebuildServiceRecords();
                if (this.currentAnnouncer.hasSentLastAnnouncement()) {
                    // if the announcer hasn't sent the last announcement, the above call of rebuildServiceRecords will
                    // result in updated records on the next announcement. Otherwise we still need to announce the updated records
                    this.currentAnnouncer.awaitAnnouncement().then(() => {
                        this.handleNetworkInterfaceUpdate(networkUpdate);
                    });
                }
            }
            return; // service records are rebuilt short before the announce step
        }
        // we don't care about removed interfaces. We can't sent goodbye records on a non existing interface
        this.rebuildServiceRecords();
        // records for a removed interface are now no longer present after the call above
        // records for a new interface got now built by the call above
        /* logic disabled for now
        if (networkUpdate.changes) {
          // we could optimize this and don't send the announcement of records if we have also added a new interface
          // Though probing will take at least 750 ms and thus sending it out immediately will get the information out faster.
    
          for (const change of networkUpdate.changes) {
            if (!this.advertisesOnInterface(change.name, true)) {
              continue;
            }
    
            let restrictedAddresses: IPAddress[] | undefined = this.restrictedAddresses? this.restrictedAddresses.get(change.name): undefined;
            if (restrictedAddresses && restrictedAddresses.length === 0) {
              restrictedAddresses = undefined;
            }
            const records: ResourceRecord[] = [];
    
            if (change.outdatedIpv4 && (!restrictedAddresses || restrictedAddresses.includes(change.outdatedIpv4))) {
              records.push(new ARecord(this.hostname, change.outdatedIpv4, true, 0));
              // records.push(new PTRRecord(formatReverseAddressPTRName(change.outdatedIpv4), this.hostname, false, 0));
            }
            if (change.outdatedIpv6 && !this.disableIpv6 && (!restrictedAddresses || restrictedAddresses.includes(change.outdatedIpv6))) {
              records.push(new AAAARecord(this.hostname, change.outdatedIpv6, true, 0));
              // records.push(new PTRRecord(formatReverseAddressPTRName(change.outdatedIpv6), this.hostname, false, 0));
            }
            if (change.outdatedGloballyRoutableIpv6 && !this.disableIpv6 && (!restrictedAddresses || restrictedAddresses.includes(change.outdatedGloballyRoutableIpv6))) {
              records.push(new AAAARecord(this.hostname, change.outdatedGloballyRoutableIpv6, true, 0));
              // records.push(new PTRRecord(formatReverseAddressPTRName(change.outdatedGloballyRoutableIpv6), this.hostname, false, 0));
            }
            if (change.outdatedUniqueLocalIpv6 && !this.disableIpv6 && (!restrictedAddresses || restrictedAddresses.includes(change.outdatedUniqueLocalIpv6))) {
              records.push(new AAAARecord(this.hostname, change.outdatedUniqueLocalIpv6, true, 0));
              // records.push(new PTRRecord(formatReverseAddressPTRName(change.outdatedUniqueLocalIpv6), this.hostname, false, 0));
            }
    
            if (change.updatedIpv4 && (!restrictedAddresses || restrictedAddresses.includes(change.updatedIpv4))) {
              records.push(new ARecord(this.hostname, change.updatedIpv4, true));
              // records.push(new PTRRecord(formatReverseAddressPTRName(change.updatedIpv4), this.hostname));
            }
            if (change.updatedIpv6 && !this.disableIpv6 && (!restrictedAddresses || restrictedAddresses.includes(change.updatedIpv6))) {
              records.push(new AAAARecord(this.hostname, change.updatedIpv6, true));
              // records.push(new PTRRecord(formatReverseAddressPTRName(change.updatedIpv6), this.hostname));
            }
            if (change.updatedGloballyRoutableIpv6 && !this.disableIpv6 && (!restrictedAddresses || restrictedAddresses.includes(change.updatedGloballyRoutableIpv6))) {
              records.push(new AAAARecord(this.hostname, change.updatedGloballyRoutableIpv6, true));
              // records.push(new PTRRecord(formatReverseAddressPTRName(change.updatedGloballyRoutableIpv6), this.hostname));
            }
            if (change.updatedUniqueLocalIpv6 && !this.disableIpv6 && (!restrictedAddresses || restrictedAddresses.includes(change.updatedUniqueLocalIpv6))) {
              records.push(new AAAARecord(this.hostname, change.updatedUniqueLocalIpv6, true));
              // records.push(new PTRRecord(formatReverseAddressPTRName(change.updatedUniqueLocalIpv6), this.hostname));
            }
    
            this.emit(InternalServiceEvent.RECORD_UPDATE_ON_INTERFACE, change.name, records);
          }
        }
        */
        if (networkUpdate.added || networkUpdate.changes) {
            // a new network interface got added. We must return into probing state,
            // as we don't know if we still own uniqueness for our service name on the new network.
            // To make things easy and keep the SAME name on all networks, we probe on ALL interfaces.
            // in this moment the new socket won't be bound. Though probing steps are delayed,
            // thus, when sending the first request, the socket will be bound and we don't need to wait here
            this.emit("republish" /* REPUBLISH */, error => {
                if (error) {
                    console.log("FATAL Error occurred trying to reannounce service " + this.fqdn + "! We can't recover from this!");
                    console.log(error.stack);
                    process.exit(1); // we have a service which should be announced, though we failed to reannounce.
                    // if this should ever happen in reality, whe might want to introduce a more sophisticated recovery
                    // for situations where it makes sense
                }
            });
        }
    }
    /**
     * This method is called by the Prober when encountering a conflict on the network.
     * It advices the service to change its name, like incrementing a number appended to the name.
     * So "My Service" will become "My Service (2)", and "My Service (2)" would become "My Service (3)"
     * @private must only be called by the {@link Prober}
     */
    incrementName(nameCheckOnly) {
        if (this.serviceState !== "unannounced" /* UNANNOUNCED */) {
            throw new Error("Service name can only be incremented when in state UNANNOUNCED!");
        }
        const oldName = this.name;
        const oldHostname = this.hostname;
        let nameBase;
        let nameNumber;
        let hostnameBase;
        let hostnameTLD;
        let hostnameNumber;
        const nameMatcher = this.name.match(numberedServiceNamePattern);
        if (nameMatcher) { // if it matched. Extract the current nameNumber
            nameBase = nameMatcher[1];
            nameNumber = parseInt(nameMatcher[2]);
            assert_1.default(nameNumber, `Failed to extract name number from ${this.name}. Resulted in ${nameNumber}`);
        }
        else {
            nameBase = this.name;
            nameNumber = 1;
        }
        const hostnameMatcher = this.hostname.match(numberedHostnamePattern);
        if (hostnameMatcher) { // if it matched. Extract the current nameNumber
            hostnameBase = hostnameMatcher[1];
            hostnameTLD = hostnameMatcher[3];
            hostnameNumber = parseInt(hostnameMatcher[2]);
            assert_1.default(hostnameNumber, `Failed to extract hostname number from ${this.hostname}. Resulted in ${hostnameNumber}`);
        }
        else {
            // we need to substring, to not match the root label "."
            const lastDot = this.hostname.substring(0, this.hostname.length - 1).lastIndexOf(".");
            hostnameBase = this.hostname.slice(0, lastDot);
            hostnameTLD = this.hostname.slice(lastDot);
            hostnameNumber = 1;
        }
        if (!nameCheckOnly) {
            // increment the numbers
            nameNumber++;
            hostnameNumber++;
        }
        const newNumber = Math.max(nameNumber, hostnameNumber);
        // reassemble the name
        this.name = newNumber === 1 ? nameBase : `${nameBase} (${newNumber})`;
        this.hostname = newNumber === 1 ? `${hostnameBase}${hostnameTLD}` : `${hostnameBase}-(${newNumber})${hostnameTLD}`;
        this.loweredHostname = dns_equal_1.dnsLowerCase(this.hostname);
        this.fqdn = this.formatFQDN(); // update the fqdn
        this.loweredFqdn = dns_equal_1.dnsLowerCase(this.fqdn);
        // we must inform the user that the names changed, so the new names can be persisted
        // This is done after the Probing finish, as multiple name changes could happen in one probing session
        // It is the responsibility of the Prober to call the informAboutNameUpdates function
        if (this.name !== oldName || this.hostname !== oldHostname) {
            debug("[%s] Service changed name '%s' -> '%s', '%s' -> '%s'", this.name, oldName, this.name, oldHostname, this.hostname);
        }
        if (!nameCheckOnly) {
            this.rebuildServiceRecords(); // rebuild all services
        }
    }
    /**
     * @private called by the Prober once finished with probing to signal a (or more)
     *   name change(s) happened {@see incrementName}.
     */
    informAboutNameUpdates() {
        // we trust the prober that this function is only called when the name was actually changed
        const nameCalled = this.emit("name-change" /* NAME_CHANGED */, this.name);
        const hostnameCalled = this.emit("hostname-change" /* HOSTNAME_CHANGED */, domainFormatter.removeTLD(this.hostname));
        // at least one event should be listened to. We can figure out the number from one or another
        if (!nameCalled && !hostnameCalled) {
            console.warn(`CIAO: [${this.name}] Service changed name but nobody was listening on the 'name-change' event!`);
        }
    }
    formatFQDN() {
        if (this.serviceState !== "unannounced" /* UNANNOUNCED */) {
            throw new Error("Name can't be changed after service was already announced!");
        }
        const fqdn = domainFormatter.stringify({
            name: this.name,
            type: this.type,
            protocol: this.protocol,
            domain: this.serviceDomain,
        });
        assert_1.default(fqdn.length <= 255, "A fully qualified domain name cannot be longer than 255 characters");
        return fqdn;
    }
    /**
     * @private called once the service data/state is updated and the records should be updated with the new data
     */
    rebuildServiceRecords() {
        assert_1.default(this.port, "port must be set before building records");
        debug("[%s] Rebuilding service records...", this.name);
        const aRecordMap = {};
        const aaaaRecordMap = {};
        const aaaaRoutableRecordMap = {};
        const aaaaUniqueLocalRecordMap = {};
        const reverseAddressMap = {};
        let subtypePTRs = undefined;
        for (const [name, networkInterface] of this.networkManager.getInterfaceMap()) {
            if (!this.advertisesOnInterface(name, true)) {
                continue;
            }
            let restrictedAddresses = this.restrictedAddresses ? this.restrictedAddresses.get(name) : undefined;
            if (restrictedAddresses && restrictedAddresses.length === 0) {
                restrictedAddresses = undefined;
            }
            if (networkInterface.ipv4 && (!restrictedAddresses || restrictedAddresses.includes(networkInterface.ipv4))) {
                aRecordMap[name] = new ARecord_1.ARecord(this.hostname, networkInterface.ipv4, true);
                reverseAddressMap[networkInterface.ipv4] = new PTRRecord_1.PTRRecord(domain_formatter_1.formatReverseAddressPTRName(networkInterface.ipv4), this.hostname);
            }
            if (networkInterface.ipv6 && !this.disableIpv6 && (!restrictedAddresses || restrictedAddresses.includes(networkInterface.ipv6))) {
                aaaaRecordMap[name] = new AAAARecord_1.AAAARecord(this.hostname, networkInterface.ipv6, true);
                reverseAddressMap[networkInterface.ipv6] = new PTRRecord_1.PTRRecord(domain_formatter_1.formatReverseAddressPTRName(networkInterface.ipv6), this.hostname);
            }
            if (networkInterface.globallyRoutableIpv6 && !this.disableIpv6 && (!restrictedAddresses || restrictedAddresses.includes(networkInterface.globallyRoutableIpv6))) {
                aaaaRoutableRecordMap[name] = new AAAARecord_1.AAAARecord(this.hostname, networkInterface.globallyRoutableIpv6, true);
                reverseAddressMap[networkInterface.globallyRoutableIpv6] = new PTRRecord_1.PTRRecord(domain_formatter_1.formatReverseAddressPTRName(networkInterface.globallyRoutableIpv6), this.hostname);
            }
            if (networkInterface.uniqueLocalIpv6 && !this.disableIpv6 && (!restrictedAddresses || restrictedAddresses.includes(networkInterface.uniqueLocalIpv6))) {
                aaaaUniqueLocalRecordMap[name] = new AAAARecord_1.AAAARecord(this.hostname, networkInterface.uniqueLocalIpv6, true);
                reverseAddressMap[networkInterface.uniqueLocalIpv6] = new PTRRecord_1.PTRRecord(domain_formatter_1.formatReverseAddressPTRName(networkInterface.uniqueLocalIpv6), this.hostname);
            }
        }
        if (this.subTypePTRs) {
            subtypePTRs = [];
            for (const ptr of this.subTypePTRs) {
                subtypePTRs.push(new PTRRecord_1.PTRRecord(ptr, this.fqdn));
            }
        }
        this.serviceRecords = {
            ptr: new PTRRecord_1.PTRRecord(this.typePTR, this.fqdn),
            subtypePTRs: subtypePTRs,
            metaQueryPtr: new PTRRecord_1.PTRRecord(index_1.Responder.SERVICE_TYPE_ENUMERATION_NAME, this.typePTR),
            srv: new SRVRecord_1.SRVRecord(this.fqdn, this.hostname, this.port, true),
            txt: new TXTRecord_1.TXTRecord(this.fqdn, this.txt, true),
            serviceNSEC: new NSECRecord_1.NSECRecord(this.fqdn, this.fqdn, [16 /* TXT */, 33 /* SRV */], 4500, true),
            a: aRecordMap,
            aaaa: aaaaRecordMap,
            aaaaR: aaaaRoutableRecordMap,
            aaaaULA: aaaaUniqueLocalRecordMap,
            reverseAddressPTRs: reverseAddressMap,
            addressNSEC: new NSECRecord_1.NSECRecord(this.hostname, this.hostname, [1 /* A */, 28 /* AAAA */], 120, true),
        };
    }
    /**
     * Returns if the given service is advertising on the provided network interface.
     *
     * @param name - The desired interface name.
     * @param skipAddressCheck - If true it is not checked if the service actually has
     *   an address record for the given interface.
     * @private returns if the service should be advertised on the given service
     */
    advertisesOnInterface(name, skipAddressCheck) {
        var _a, _b, _c, _d;
        return !this.restrictedAddresses || this.restrictedAddresses.has(name) && (skipAddressCheck ||
            // must have at least one address record on the given interface
            !!((_a = this.serviceRecords) === null || _a === void 0 ? void 0 : _a.a[name]) || !!((_b = this.serviceRecords) === null || _b === void 0 ? void 0 : _b.aaaa[name])
            || !!((_c = this.serviceRecords) === null || _c === void 0 ? void 0 : _c.aaaaR[name]) || !!((_d = this.serviceRecords) === null || _d === void 0 ? void 0 : _d.aaaaULA[name]));
    }
    /**
     * @private used to get a copy of the main PTR record
     */
    ptrRecord() {
        return this.serviceRecords.ptr.clone();
    }
    /**
     * @private used to get a copy of the array of sub-type PTR records
     */
    subtypePtrRecords() {
        return this.serviceRecords.subtypePTRs ? ResourceRecord_1.ResourceRecord.clone(this.serviceRecords.subtypePTRs) : [];
    }
    /**
     * @private used to get a copy of the meta-query PTR record
     */
    metaQueryPtrRecord() {
        return this.serviceRecords.metaQueryPtr.clone();
    }
    /**
     * @private used to get a copy of the SRV record
     */
    srvRecord() {
        return this.serviceRecords.srv.clone();
    }
    /**
     * @private used to get a copy of the TXT record
     */
    txtRecord() {
        return this.serviceRecords.txt.clone();
    }
    /**
     * @private used to get a copy of the A record
     */
    aRecord(name) {
        const record = this.serviceRecords.a[name];
        return record ? record.clone() : undefined;
    }
    /**
     * @private used to get a copy of the AAAA record for the link-local ipv6 address
     */
    aaaaRecord(name) {
        const record = this.serviceRecords.aaaa[name];
        return record ? record.clone() : undefined;
    }
    /**
     * @private used to get a copy of the AAAA record for the routable ipv6 address
     */
    aaaaRoutableRecord(name) {
        const record = this.serviceRecords.aaaaR[name];
        return record ? record.clone() : undefined;
    }
    /**
     * @private used to get a copy of the AAAA fore the unique local ipv6 address
     */
    aaaaUniqueLocalRecord(name) {
        const record = this.serviceRecords.aaaaULA[name];
        return record ? record.clone() : undefined;
    }
    /**
     * @private used to get a copy of the A and AAAA records
     */
    allAddressRecords() {
        const records = [];
        Object.values(this.serviceRecords.a).forEach(record => {
            records.push(record.clone());
        });
        Object.values(this.serviceRecords.aaaa).forEach(record => {
            records.push(record.clone());
        });
        Object.values(this.serviceRecords.aaaaR).forEach(record => {
            records.push(record.clone());
        });
        Object.values(this.serviceRecords.aaaaULA).forEach(record => {
            records.push(record.clone());
        });
        return records;
    }
    /**
     * @private used to get a copy of the address NSEC record
     */
    addressNSECRecord() {
        return this.serviceRecords.addressNSEC.clone();
    }
    /**
     * @private user to get a copy of the service NSEC record
     */
    serviceNSECRecord(shortenTTL = false) {
        const record = this.serviceRecords.serviceNSEC.clone();
        if (shortenTTL) {
            record.ttl = 120;
        }
        return record;
    }
    /**
     * @param address - The IP address to check.
     * @private used to check if given address is exposed by this service
     */
    hasAddress(address) {
        return !!this.serviceRecords.reverseAddressPTRs[address];
    }
}
exports.CiaoService = CiaoService;
//# sourceMappingURL=CiaoService.js.map

/***/ }),

/***/ 9668:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MDNSServer = exports.SendResultFormatError = exports.SendResultFailedRatio = void 0;
const tslib_1 = __nccwpck_require__(4290);
const assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
const debug_1 = tslib_1.__importDefault(__nccwpck_require__(7984));
const dgram_1 = tslib_1.__importDefault(__nccwpck_require__(6200));
const DNSPacket_1 = __nccwpck_require__(3646);
const NetworkManager_1 = __nccwpck_require__(8730);
const domain_formatter_1 = __nccwpck_require__(9783);
const errors_1 = __nccwpck_require__(8487);
const promise_utils_1 = __nccwpck_require__(3620);
const debug = debug_1.default("ciao:MDNSServer");
/**
 * Returns the ration of rejected SendResults in the array.
 * A ratio of 0 indicates all sends were successful.
 * A ration of 1 indicates all sends failed.
 * A number in between signals that some of the sends failed.
 *
 * @param results - Array of {@link SendResult}
 */
function SendResultFailedRatio(results) {
    if (results.length === 0) {
        return 0;
    }
    let failedCount = 0;
    for (const result of results) {
        if (result.status !== "fulfilled") {
            failedCount++;
        }
    }
    return failedCount / results.length;
}
exports.SendResultFailedRatio = SendResultFailedRatio;
function SendResultFormatError(results, prefix, includeStack = false) {
    let failedCount = 0;
    for (const result of results) {
        if (result.status !== "fulfilled") {
            failedCount++;
        }
    }
    if (!prefix) {
        prefix = "Failed to send packets";
    }
    if (failedCount < results.length) {
        prefix += ` (${failedCount}/${results.length}):`;
    }
    else {
        prefix += ":";
    }
    if (includeStack) {
        let string = "=============================\n" + prefix;
        for (const result of results) {
            if (result.status === "rejected") {
                string += "\n--------------------\n" +
                    "Failed to send packet on interface " + result.interface + ": " + result.reason.stack;
            }
            else if (result.status === "timeout") {
                string += "\n--------------------\n" +
                    "Sending packet on interface " + result.interface + " timed out!";
            }
        }
        string += "\n=============================";
        return string;
    }
    else {
        let string = prefix;
        for (const result of results) {
            if (result.status === "rejected") {
                string += "\n- Failed to send packet on interface " + result.interface + ": " + result.reason.message;
            }
            else if (result.status === "timeout") {
                string += "\n- Sending packet on interface " + result.interface + " timed out!";
            }
        }
        return string;
    }
}
exports.SendResultFormatError = SendResultFormatError;
/**
 * This class can be used to create a mdns server to send and receive mdns packets on the local network.
 *
 * Currently only udp4 sockets will be advertised.
 */
class MDNSServer {
    constructor(handler, options) {
        this.sockets = new Map();
        this.sentPackets = new Map();
        // RFC 6762 15.1. If we are not the first responder bound to 5353 we can't receive unicast responses
        // thus the QU flag must not be used in queries. Responders are only affected when sending probe queries.
        // Probe queries should be sent with QU set, though can't be sent with QU when we can't receive unicast responses.
        this.suppressUnicastResponseFlag = false;
        this.bound = false;
        this.closed = false;
        assert_1.default(handler, "handler cannot be undefined");
        this.handler = handler;
        this.networkManager = new NetworkManager_1.NetworkManager({
            interface: options && options.interface,
            excludeIpv6: options && options.disableIpv6,
            excludeIpv6Only: true,
        });
        this.networkManager.on("network-update" /* NETWORK_UPDATE */, this.handleUpdatedNetworkInterfaces.bind(this));
    }
    getNetworkManager() {
        return this.networkManager;
    }
    getBoundInterfaceNames() {
        return this.sockets.keys();
    }
    async bind() {
        if (this.closed) {
            throw new Error("Cannot rebind closed server!");
        }
        // RFC 6762 15.1. suggest that we probe if we are not the only socket.
        // though as ciao will probably always be installed besides an existing mdns responder, we just assume that without probing
        // As it only affects probe queries, impact isn't that big.
        this.suppressUnicastResponseFlag = true;
        // wait for the first network interfaces to be discovered
        await this.networkManager.waitForInit();
        const promises = [];
        for (const [name, networkInterface] of this.networkManager.getInterfaceMap()) {
            const socket = this.createDgramSocket(name, true);
            const promise = this.bindSocket(socket, networkInterface, "IPv4" /* IPv4 */)
                .catch(reason => {
                // TODO if bind errors we probably will never bind again
                console.log("Could not bind detected network interface: " + reason.stack);
            });
            promises.push(promise);
        }
        return Promise.all(promises).then(() => {
            this.bound = true;
            // map void[] to void
        });
    }
    shutdown() {
        this.networkManager.shutdown();
        for (const socket of this.sockets.values()) {
            socket.close();
        }
        this.bound = false;
        this.closed = true;
        this.sockets.clear();
    }
    sendQueryBroadcast(query, service) {
        const packets = DNSPacket_1.DNSPacket.createDNSQueryPackets(query);
        if (packets.length > 1) {
            debug("Query broadcast is split into %d packets!", packets.length);
        }
        const promises = [];
        for (const packet of packets) {
            promises.push(this.sendOnAllNetworksForService(packet, service));
        }
        return Promise.all(promises).then((values) => {
            const results = [];
            for (const value of values) { // replace with .flat method when we have node >= 11.0.0 requirement
                results.concat(value);
            }
            return results;
        });
    }
    sendResponseBroadcast(response, service) {
        const packet = DNSPacket_1.DNSPacket.createDNSResponsePacketsFromRRSet(response);
        return this.sendOnAllNetworksForService(packet, service);
    }
    sendResponse(response, endpointOrInterface, callback) {
        this.send(response, endpointOrInterface).then(result => {
            if (result.status === "rejected") {
                if (callback) {
                    callback(new Error("Encountered socket error on " + result.reason.name + ": " + result.reason.message));
                }
                else {
                    MDNSServer.logSocketError(result.interface, result.reason);
                }
            }
            else if (callback) {
                callback();
            }
        });
    }
    sendOnAllNetworksForService(packet, service) {
        this.checkUnicastResponseFlag(packet);
        const message = packet.encode();
        this.assertBeforeSend(message, "IPv4" /* IPv4 */);
        const promises = [];
        for (const [name, socket] of this.sockets) {
            if (!service.advertisesOnInterface(name)) {
                // i don't like the fact that we put the check inside the MDNSServer, as it should be independent of the above layer.
                // Though I think this is currently the easiest approach.
                continue;
            }
            const promise = new Promise(resolve => {
                socket.send(message, MDNSServer.MDNS_PORT, MDNSServer.MULTICAST_IPV4, error => {
                    if (error) {
                        if (!MDNSServer.isSilencedSocketError(error)) {
                            resolve({
                                status: "rejected",
                                interface: name,
                                reason: error,
                            });
                            return;
                        }
                    }
                    else {
                        this.maintainSentPacketsInterface(name, message);
                    }
                    resolve({
                        status: "fulfilled",
                        interface: name,
                    });
                });
            });
            promises.push(Promise.race([
                promise,
                promise_utils_1.PromiseTimeout(MDNSServer.SEND_TIMEOUT).then(() => ({
                    status: "timeout",
                    interface: name,
                })),
            ]));
        }
        return Promise.all(promises);
    }
    send(packet, endpointOrInterface) {
        this.checkUnicastResponseFlag(packet);
        const message = packet.encode();
        this.assertBeforeSend(message, "IPv4" /* IPv4 */);
        let address;
        let port;
        let name;
        if (typeof endpointOrInterface === "string") { // its a network interface name
            address = MDNSServer.MULTICAST_IPV4;
            port = MDNSServer.MDNS_PORT;
            name = endpointOrInterface;
        }
        else {
            address = endpointOrInterface.address;
            port = endpointOrInterface.port;
            name = endpointOrInterface.interface;
        }
        const socket = this.sockets.get(name);
        if (!socket) {
            throw new errors_1.InterfaceNotFoundError(`Could not find socket for given network interface '${name}'`);
        }
        return new Promise(resolve => {
            socket.send(message, port, address, error => {
                if (error) {
                    if (!MDNSServer.isSilencedSocketError(error)) {
                        resolve({
                            status: "rejected",
                            interface: name,
                            reason: error,
                        });
                        return;
                    }
                }
                else {
                    this.maintainSentPacketsInterface(name, message);
                }
                resolve({
                    status: "fulfilled",
                    interface: name,
                });
            });
        });
    }
    checkUnicastResponseFlag(packet) {
        if (this.suppressUnicastResponseFlag && packet.type === 0 /* QUERY */) {
            packet.questions.forEach(record => record.unicastResponseFlag = false);
        }
    }
    assertBeforeSend(message, family) {
        if (this.closed) {
            throw new errors_1.ServerClosedError("Cannot send packets on a closed mdns server!");
        }
        assert_1.default(this.bound, "Cannot send packets before server is not bound!");
        const ipHeaderSize = family === "IPv4" /* IPv4 */ ? MDNSServer.DEFAULT_IP4_HEADER : MDNSServer.DEFAULT_IP6_HEADER;
        // RFC 6762 17.
        assert_1.default(ipHeaderSize + MDNSServer.UDP_HEADER + message.length <= 9000, "DNS cannot exceed the size of 9000 bytes even with IP Fragmentation!");
    }
    maintainSentPacketsInterface(name, packet) {
        const base64 = packet.toString("base64");
        const packets = this.sentPackets.get(name);
        if (!packets) {
            this.sentPackets.set(name, [base64]);
        }
        else {
            packets.push(base64);
        }
    }
    checkIfPacketWasPreviouslySentFromUs(name, packet) {
        const base64 = packet.toString("base64");
        const packets = this.sentPackets.get(name);
        if (packets) {
            const index = packets.indexOf(base64);
            if (index !== -1) {
                packets.splice(index, 1);
                return true;
            }
        }
        return false;
    }
    createDgramSocket(name, reuseAddr = false, type = "udp4") {
        const socket = dgram_1.default.createSocket({
            type: type,
            reuseAddr: reuseAddr,
        });
        socket.on("message", this.handleMessage.bind(this, name));
        socket.on("error", error => {
            if (!MDNSServer.isSilencedSocketError(error)) {
                MDNSServer.logSocketError(name, error);
            }
        });
        return socket;
    }
    bindSocket(socket, networkInterface, family) {
        return new Promise((resolve, reject) => {
            const errorHandler = (error) => reject(new Error("Failed to bind on interface " + networkInterface.name + ": " + error.message));
            socket.once("error", errorHandler);
            socket.on("close", () => {
                this.sockets.delete(networkInterface.name);
            });
            socket.bind(MDNSServer.MDNS_PORT, () => {
                socket.setRecvBufferSize(800 * 1024); // setting max recv buffer size to 800KiB (Pi will max out at 352KiB)
                socket.removeListener("error", errorHandler);
                const multicastAddress = family === "IPv4" /* IPv4 */ ? MDNSServer.MULTICAST_IPV4 : MDNSServer.MULTICAST_IPV6;
                const interfaceAddress = family === "IPv4" /* IPv4 */ ? networkInterface.ipv4 : networkInterface.ipv6;
                assert_1.default(interfaceAddress, "Interface address for " + networkInterface.name + " cannot be undefined!");
                try {
                    socket.addMembership(multicastAddress, interfaceAddress);
                    socket.setMulticastInterface(interfaceAddress);
                    socket.setMulticastTTL(MDNSServer.MDNS_TTL); // outgoing multicast datagrams
                    socket.setTTL(MDNSServer.MDNS_TTL); // outgoing unicast datagrams
                    socket.setMulticastLoopback(true); // We can't disable multicast loopback, as otherwise queriers on the same host won't receive our packets
                    this.sockets.set(networkInterface.name, socket);
                    resolve();
                }
                catch (error) {
                    try {
                        socket.close();
                    }
                    catch (error) {
                        debug("Error while closing socket which failed to bind. Error may be expected: " + error.message);
                    }
                    reject(new Error("Error binding socket on " + networkInterface.name + ": " + error.stack));
                }
            });
        });
    }
    handleMessage(name, buffer, rinfo) {
        if (!this.bound) {
            return;
        }
        const networkInterface = this.networkManager.getInterface(name);
        if (!networkInterface) {
            debug("Received packet on non existing network interface: %s!", name);
            return;
        }
        if (this.checkIfPacketWasPreviouslySentFromUs(networkInterface.name, buffer)) {
            // multicastLoopback is enabled for every interface, meaning we would receive our own response
            // packets here. Thus we silence them. We can't disable multicast loopback, as otherwise
            // queriers on the same host won't receive our packets
            return;
        }
        const ip4Netaddress = domain_formatter_1.getNetAddress(rinfo.address, networkInterface.ip4Netmask);
        // We have the following problem on linux based platforms:
        // When setting up a socket like above (binding on 0.0.0.0:5353) and then adding membership for 224.0.0.251 for
        // A CERTAIN! interface, we will nonetheless receive packets from ALL other interfaces even the loopback interfaces.
        // This is not the case on platforms like e.g. macOS. There stuff is properly filtered, and we only receive packets
        // for the given interface we specified in our membership.
        // This has the problem, that when receiving packets from other interfaces, that we leak out addresses which don't
        // exists on the given interface. We can't do much about it, as in typically multiple subnet networks, it is valid
        // that we receive a packet from a ip address which doesn't belong into the subnet of our given interface.
        // What we can do at least, is the following two things:
        // * if we are listening on the loopback interface, we filter out any traffic which doesn't belong to the loopback interface
        // * if we receive a packet from the loopback interface, we filter those out as well.
        // With that we at least ensure that the loopback address is never sent out to the network.
        // This is what we do below:
        if (networkInterface.loopback) {
            if (ip4Netaddress !== networkInterface.ipv4Netaddress) {
                return;
            }
        }
        else if (this.networkManager.isLoopbackNetaddressV4(ip4Netaddress)) {
            debug("Received packet on interface '%s' which is not coming from the same subnet: %o", name, { address: rinfo.address, netaddress: ip4Netaddress, interface: networkInterface.ipv4 });
            return;
        }
        let packet;
        try {
            packet = DNSPacket_1.DNSPacket.decode(rinfo, buffer);
        }
        catch (error) {
            debug("Received a malformed packet from %o on interface %s. This might or might not be a problem. " +
                "Here is the received packet for debugging purposes '%s'. " +
                "Packet decoding failed with %s", rinfo, name, buffer.toString("base64"), error.stack);
            return;
        }
        if (packet.opcode !== 0 /* QUERY */) {
            // RFC 6762 18.3 we MUST ignore messages with opcodes other than zero (QUERY)
            return;
        }
        if (packet.rcode !== 0 /* NoError */) {
            // RFC 6762 18.3 we MUST ignore messages with response code other than zero (NoError)
            return;
        }
        const endpoint = {
            address: rinfo.address,
            port: rinfo.port,
            interface: name,
        };
        if (packet.type === 0 /* QUERY */) {
            try {
                this.handler.handleQuery(packet, endpoint);
            }
            catch (error) {
                console.warn("Error occurred handling incoming (on " + name + ") dns query packet: " + error.stack);
            }
        }
        else if (packet.type === 1 /* RESPONSE */) {
            if (rinfo.port !== MDNSServer.MDNS_PORT) {
                // RFC 6762 6.  Multicast DNS implementations MUST silently ignore any Multicast DNS responses
                //    they receive where the source UDP port is not 5353.
                return;
            }
            try {
                this.handler.handleResponse(packet, endpoint);
            }
            catch (error) {
                console.warn("Error occurred handling incoming (on " + name + ") dns response packet: " + error.stack);
            }
        }
    }
    static isSilencedSocketError(error) {
        // silence those errors
        // they happen when the host is not reachable (EADDRNOTAVAIL for 224.0.0.251 or EHOSTDOWN for any unicast traffic)
        // caused by yet undetected network changes.
        // as we listen to 0.0.0.0 and the socket stays valid, this is not a problem
        const silenced = error.message.includes("EADDRNOTAVAIL") || error.message.includes("EHOSTDOWN")
            || error.message.includes("ENETUNREACH") || error.message.includes("EHOSTUNREACH")
            || error.message.includes("EPERM") || error.message.includes("EINVAL");
        if (silenced) {
            debug("Silenced and ignored error (This is/should not be a problem, this message is only for informational purposes): " + error.message);
        }
        return silenced;
    }
    static logSocketError(name, error) {
        console.warn(`Encountered MDNS socket error on socket '${name}' : ${error.stack}`);
        return;
    }
    handleUpdatedNetworkInterfaces(networkUpdate) {
        if (networkUpdate.removed) {
            for (const networkInterface of networkUpdate.removed) {
                const socket = this.sockets.get(networkInterface.name);
                this.sockets.delete(networkInterface.name);
                if (socket) {
                    socket.close();
                }
            }
        }
        if (networkUpdate.changes) {
            for (const change of networkUpdate.changes) {
                const socket = this.sockets.get(change.name);
                assert_1.default(socket, "Couldn't find socket for network change!");
                if (!change.outdatedIpv4 && change.updatedIpv4) {
                    // this does currently not happen, as we exclude ipv6 only interfaces
                    // thus such a change would be happening through the ADDED array
                    assert_1.default.fail("Reached illegal state! IPv4 address changed from undefined to defined!");
                }
                else if (change.outdatedIpv4 && !change.updatedIpv4) {
                    // this does currently not happen, as we exclude ipv6 only interfaces
                    // thus such a change would be happening through the REMOVED array
                    assert_1.default.fail("Reached illegal state! IPV4 address change from defined to undefined!");
                }
                else if (change.outdatedIpv4 && change.updatedIpv4) {
                    try {
                        socket.dropMembership(MDNSServer.MULTICAST_IPV4, change.outdatedIpv4);
                    }
                    catch (error) {
                        debug("Thrown expected error when dropping outdated address membership: " + error.message);
                    }
                    try {
                        socket.addMembership(MDNSServer.MULTICAST_IPV4, change.updatedIpv4);
                    }
                    catch (error) {
                        debug("Thrown expected error when adding new address membership: " + error.message);
                    }
                    socket.setMulticastInterface(change.updatedIpv4);
                }
            }
        }
        if (networkUpdate.added) {
            for (const networkInterface of networkUpdate.added) {
                const socket = this.createDgramSocket(networkInterface.name, true);
                this.bindSocket(socket, networkInterface, "IPv4" /* IPv4 */).catch(reason => {
                    // TODO if bind errors we probably will never bind again
                    console.log("Could not bind detected network interface: " + reason.stack);
                });
            }
        }
    }
}
exports.MDNSServer = MDNSServer;
MDNSServer.DEFAULT_IP4_HEADER = 20;
MDNSServer.DEFAULT_IP6_HEADER = 40;
MDNSServer.UDP_HEADER = 8;
MDNSServer.MDNS_PORT = 5353;
MDNSServer.MDNS_TTL = 255;
MDNSServer.MULTICAST_IPV4 = "224.0.0.251";
MDNSServer.MULTICAST_IPV6 = "FF02::FB";
MDNSServer.SEND_TIMEOUT = 200; // milliseconds
//# sourceMappingURL=MDNSServer.js.map

/***/ }),

/***/ 8730:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NetworkManager = exports.NetworkManagerEvent = exports.WifiState = exports.IPFamily = void 0;
const tslib_1 = __nccwpck_require__(4290);
const assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
const child_process_1 = tslib_1.__importDefault(__nccwpck_require__(3129));
const debug_1 = tslib_1.__importDefault(__nccwpck_require__(7984));
const events_1 = __nccwpck_require__(8614);
const fast_deep_equal_1 = tslib_1.__importDefault(__nccwpck_require__(7689));
const net_1 = tslib_1.__importDefault(__nccwpck_require__(1631));
const os_1 = tslib_1.__importDefault(__nccwpck_require__(2087));
const domain_formatter_1 = __nccwpck_require__(9783);
const debug = debug_1.default("ciao:NetworkManager");
var IPFamily;
(function (IPFamily) {
    IPFamily["IPv4"] = "IPv4";
    IPFamily["IPv6"] = "IPv6";
})(IPFamily = exports.IPFamily || (exports.IPFamily = {}));
var WifiState;
(function (WifiState) {
    WifiState[WifiState["UNDEFINED"] = 0] = "UNDEFINED";
    WifiState[WifiState["NOT_A_WIFI_INTERFACE"] = 1] = "NOT_A_WIFI_INTERFACE";
    WifiState[WifiState["NOT_ASSOCIATED"] = 2] = "NOT_ASSOCIATED";
    WifiState[WifiState["CONNECTED"] = 3] = "CONNECTED";
})(WifiState = exports.WifiState || (exports.WifiState = {}));
var NetworkManagerEvent;
(function (NetworkManagerEvent) {
    NetworkManagerEvent["NETWORK_UPDATE"] = "network-update";
})(NetworkManagerEvent = exports.NetworkManagerEvent || (exports.NetworkManagerEvent = {}));
/**
 * The NetworkManager maintains a representation of the network interfaces define on the host system.
 * It periodically checks for updated network information.
 *
 * The NetworkManager makes the following decision when checking for interfaces:
 * * First of all it gathers the default network interface of the system (by checking the routing table of the os)
 * * The following interfaces are going to be tracked:
 *   * The loopback interface
 *   * All interfaces which match the subnet of the default interface
 *   * All interfaces which contain a globally unique (aka globally routable) ipv6 address
 */
class NetworkManager extends events_1.EventEmitter {
    constructor(options) {
        super();
        this.currentInterfaces = new Map();
        /**
         * A subset of our network interfaces, holding only loopback interfaces (or what node considers "internal").
         */
        this.loopbackInterfaces = new Map();
        this.setMaxListeners(100); // we got one listener for every Responder, 100 should be fine for now
        if (options && options.interface) {
            let interfaces;
            if (typeof options.interface === "string") {
                interfaces = [options.interface];
            }
            else if (Array.isArray(options.interface)) {
                interfaces = options.interface;
            }
            else {
                throw new Error("Found invalid type for 'interfaces' NetworkManager option!");
            }
            const restrictedInterfaces = [];
            for (const iface of interfaces) {
                if (net_1.default.isIP(iface)) {
                    const interfaceName = NetworkManager.resolveInterface(iface);
                    if (interfaceName) {
                        restrictedInterfaces.push(interfaceName);
                    }
                    else {
                        console.log("CIAO: Interface was specified as ip (%s), though couldn't find a matching interface for the given address.", options.interface);
                    }
                }
                else {
                    restrictedInterfaces.push(iface);
                }
            }
            if (restrictedInterfaces.length === 0) {
                console.log("CIAO: 'restrictedInterfaces' array was empty. Going to fallback to bind on all available interfaces.");
            }
            else {
                this.restrictedInterfaces = restrictedInterfaces;
            }
        }
        this.excludeIpv6 = !!(options && options.excludeIpv6);
        this.excludeIpv6Only = this.excludeIpv6 || !!(options && options.excludeIpv6Only);
        if (options) {
            debug("Created NetworkManager with options: %s", JSON.stringify(options));
        }
        this.initPromise = new Promise(resolve => {
            this.getCurrentNetworkInterfaces().then(map => {
                this.currentInterfaces = map;
                const otherInterfaces = Object.keys(os_1.default.networkInterfaces());
                const interfaceNames = [];
                for (const name of this.currentInterfaces.keys()) {
                    interfaceNames.push(name);
                    const index = otherInterfaces.indexOf(name);
                    if (index !== -1) {
                        otherInterfaces.splice(index, 1);
                    }
                }
                debug("Initial networks [%s] ignoring [%s]", interfaceNames.join(", "), otherInterfaces.join(", "));
                this.initPromise = undefined;
                resolve();
                this.scheduleNextJob();
            });
        });
    }
    async waitForInit() {
        if (this.initPromise) {
            await this.initPromise;
        }
    }
    shutdown() {
        if (this.currentTimer) {
            clearTimeout(this.currentTimer);
            this.currentTimer = undefined;
        }
        this.removeAllListeners();
    }
    getInterfaceMap() {
        if (this.initPromise) {
            assert_1.default.fail("Not yet initialized!");
        }
        return this.currentInterfaces;
    }
    getInterface(name) {
        if (this.initPromise) {
            assert_1.default.fail("Not yet initialized!");
        }
        return this.currentInterfaces.get(name);
    }
    isLoopbackNetaddressV4(netaddress) {
        for (const networkInterface of this.loopbackInterfaces.values()) {
            if (networkInterface.ipv4Netaddress === netaddress) {
                return true;
            }
        }
        return false;
    }
    scheduleNextJob() {
        this.currentTimer = setTimeout(this.checkForNewInterfaces.bind(this), NetworkManager.POLLING_TIME);
        this.currentTimer.unref(); // this timer won't prevent shutdown
    }
    async checkForNewInterfaces() {
        const latestInterfaces = await this.getCurrentNetworkInterfaces();
        if (!this.currentTimer) { // if the timer is undefined, NetworkManager was shut down
            return;
        }
        let added = undefined;
        let removed = undefined;
        let changes = undefined;
        for (const [name, networkInterface] of latestInterfaces) {
            const currentInterface = this.currentInterfaces.get(name);
            if (currentInterface) { // the interface could potentially have changed
                if (!fast_deep_equal_1.default(currentInterface, networkInterface)) {
                    // indeed the interface changed
                    const change = {
                        name: name,
                    };
                    if (currentInterface.ipv4 !== networkInterface.ipv4) { // check for changed ipv4
                        if (currentInterface.ipv4) {
                            change.outdatedIpv4 = currentInterface.ipv4;
                        }
                        if (networkInterface.ipv4) {
                            change.updatedIpv4 = networkInterface.ipv4;
                        }
                    }
                    if (currentInterface.ipv6 !== networkInterface.ipv6) { // check for changed link-local ipv6
                        if (currentInterface.ipv6) {
                            change.outdatedIpv6 = currentInterface.ipv6;
                        }
                        if (networkInterface.ipv6) {
                            change.updatedIpv6 = networkInterface.ipv6;
                        }
                    }
                    if (currentInterface.globallyRoutableIpv6 !== networkInterface.globallyRoutableIpv6) { // check for changed routable ipv6
                        if (currentInterface.globallyRoutableIpv6) {
                            change.outdatedGloballyRoutableIpv6 = currentInterface.globallyRoutableIpv6;
                        }
                        if (networkInterface.globallyRoutableIpv6) {
                            change.updatedGloballyRoutableIpv6 = networkInterface.globallyRoutableIpv6;
                        }
                    }
                    if (currentInterface.uniqueLocalIpv6 !== networkInterface.uniqueLocalIpv6) { // check for changed ula
                        if (currentInterface.uniqueLocalIpv6) {
                            change.outdatedUniqueLocalIpv6 = currentInterface.uniqueLocalIpv6;
                        }
                        if (networkInterface.uniqueLocalIpv6) {
                            change.updatedUniqueLocalIpv6 = networkInterface.uniqueLocalIpv6;
                        }
                    }
                    this.currentInterfaces.set(name, networkInterface);
                    if (networkInterface.loopback) {
                        this.loopbackInterfaces.set(name, networkInterface);
                    }
                    (changes !== null && changes !== void 0 ? changes : (changes = [])).push(change);
                }
            }
            else { // new interface was added/started
                this.currentInterfaces.set(name, networkInterface);
                if (networkInterface.loopback) {
                    this.currentInterfaces.set(name, networkInterface);
                }
                (added !== null && added !== void 0 ? added : (added = [])).push(networkInterface);
            }
        }
        // at this point we updated any existing interfaces and added all new interfaces
        // thus if the length of below is not the same interface must have been removed
        // this check ensures that we do not unnecessarily loop twice through our interfaces
        if (this.currentInterfaces.size !== latestInterfaces.size) {
            for (const [name, networkInterface] of this.currentInterfaces) {
                if (!latestInterfaces.has(name)) { // interface was removed
                    this.currentInterfaces.delete(name);
                    this.loopbackInterfaces.delete(name);
                    (removed !== null && removed !== void 0 ? removed : (removed = [])).push(networkInterface);
                }
            }
        }
        if (added || removed || changes) { // emit an event only if anything changed
            const addedString = added ? added.map(iface => iface.name).join(",") : "";
            const removedString = removed ? removed.map(iface => iface.name).join(",") : "";
            const changesString = changes ? changes.map(iface => {
                let string = `{ name: ${iface.name} `;
                if (iface.outdatedIpv4 || iface.updatedIpv4) {
                    string += `, ${iface.outdatedIpv4} -> ${iface.updatedIpv4} `;
                }
                if (iface.outdatedIpv6 || iface.updatedIpv6) {
                    string += `, ${iface.outdatedIpv6} -> ${iface.updatedIpv6} `;
                }
                if (iface.outdatedGloballyRoutableIpv6 || iface.updatedGloballyRoutableIpv6) {
                    string += `, ${iface.outdatedGloballyRoutableIpv6} -> ${iface.updatedGloballyRoutableIpv6} `;
                }
                if (iface.outdatedUniqueLocalIpv6 || iface.updatedUniqueLocalIpv6) {
                    string += `, ${iface.outdatedUniqueLocalIpv6} -> ${iface.updatedUniqueLocalIpv6} `;
                }
                return string + "}";
            }).join(",") : "";
            debug("Detected network changes: added: [%s], removed: [%s], changes: [%s]!", addedString, removedString, changesString);
            this.emit("network-update" /* NETWORK_UPDATE */, {
                added: added,
                removed: removed,
                changes: changes,
            });
        }
        this.scheduleNextJob();
    }
    async getCurrentNetworkInterfaces() {
        let names;
        if (this.restrictedInterfaces) {
            names = this.restrictedInterfaces;
            const loopback = NetworkManager.getLoopbackInterface();
            if (!names.includes(loopback)) {
                names.push(loopback);
            }
        }
        else {
            try {
                names = await NetworkManager.getNetworkInterfaceNames();
            }
            catch (error) {
                debug(`WARNING Detecting network interfaces for platform '${os_1.default.platform()}' failed. Trying to assume network interfaces! (${error.message})`);
                // fallback way of gathering network interfaces (remember, there are docker images where the arp command is not installed)
                names = NetworkManager.assumeNetworkInterfaceNames();
            }
        }
        const interfaces = new Map();
        const networkInterfaces = os_1.default.networkInterfaces();
        for (const name of names) {
            const infos = networkInterfaces[name];
            if (!infos) {
                continue;
            }
            let ipv4Info = undefined;
            let ipv6Info = undefined;
            let routableIpv6Info = undefined;
            let uniqueLocalIpv6Info = undefined;
            let internal = false;
            for (const info of infos) {
                if (info.internal) {
                    internal = true;
                }
                if (info.family === "IPv4" && !ipv4Info) {
                    ipv4Info = info;
                }
                else if (info.family === "IPv6") {
                    if (this.excludeIpv6) {
                        continue;
                    }
                    if (info.scopeid && !ipv6Info) { // we only care about non zero scope (aka link-local ipv6)
                        ipv6Info = info;
                    }
                    else if (info.scopeid === 0) { // global routable ipv6
                        if (info.address.startsWith("fc") || info.address.startsWith("fd")) {
                            if (!uniqueLocalIpv6Info) {
                                uniqueLocalIpv6Info = info;
                            }
                        }
                        else if (!routableIpv6Info) {
                            routableIpv6Info = info;
                        }
                    }
                }
                if (ipv4Info && ipv6Info && routableIpv6Info && uniqueLocalIpv6Info) {
                    break;
                }
            }
            assert_1.default(ipv4Info || ipv6Info, "Could not find valid addresses for interface '" + name + "'");
            if (this.excludeIpv6Only && !ipv4Info) {
                continue;
            }
            const networkInterface = {
                name: name,
                loopback: internal,
                mac: ((ipv4Info === null || ipv4Info === void 0 ? void 0 : ipv4Info.mac) || (ipv6Info === null || ipv6Info === void 0 ? void 0 : ipv6Info.mac)),
            };
            if (ipv4Info) {
                networkInterface.ipv4 = ipv4Info.address;
                networkInterface.ip4Netmask = ipv4Info.netmask;
                networkInterface.ipv4Netaddress = domain_formatter_1.getNetAddress(ipv4Info.address, ipv4Info.netmask);
            }
            if (ipv6Info) {
                networkInterface.ipv6 = ipv6Info.address;
                networkInterface.ipv6Netmask = ipv6Info.netmask;
            }
            if (routableIpv6Info) {
                networkInterface.globallyRoutableIpv6 = routableIpv6Info.address;
                networkInterface.globallyRoutableIpv6Netmask = routableIpv6Info.netmask;
            }
            if (uniqueLocalIpv6Info) {
                networkInterface.uniqueLocalIpv6 = uniqueLocalIpv6Info.address;
                networkInterface.uniqueLocalIpv6Netmask = uniqueLocalIpv6Info.netmask;
            }
            interfaces.set(name, networkInterface);
        }
        return interfaces;
    }
    static resolveInterface(address) {
        let interfaceName;
        outer: for (const [name, infoArray] of Object.entries(os_1.default.networkInterfaces())) {
            for (const info of infoArray) {
                if (info.address === address) {
                    interfaceName = name;
                    break outer; // exit out of both loops
                }
            }
        }
        return interfaceName;
    }
    static async getNetworkInterfaceNames() {
        // this function will always include the loopback interface
        let promise;
        switch (os_1.default.platform()) {
            case "win32":
                promise = NetworkManager.getWindowsNetworkInterfaces();
                break;
            case "linux": {
                promise = NetworkManager.getLinuxNetworkInterfaces();
                break;
            }
            case "darwin":
                promise = NetworkManager.getDarwinNetworkInterfaces();
                break;
            case "freebsd": {
                promise = NetworkManager.getFreeBSDNetworkInterfaces();
                break;
            }
            case "openbsd":
            case "sunos": {
                promise = NetworkManager.getOpenBSD_SUNOS_NetworkInterfaces();
                break;
            }
            default:
                debug("Found unsupported platform %s", os_1.default.platform());
                return Promise.reject(new Error("unsupported platform!"));
        }
        let names;
        try {
            names = await promise;
        }
        catch (error) {
            if (error.message !== NetworkManager.NOTHING_FOUND_MESSAGE) {
                throw error;
            }
            names = [];
        }
        const loopback = NetworkManager.getLoopbackInterface();
        if (!names.includes(loopback)) {
            names.unshift(loopback);
        }
        return promise;
    }
    static assumeNetworkInterfaceNames() {
        // this method is a fallback trying to calculate network related interfaces in an platform independent way
        const names = [];
        Object.entries(os_1.default.networkInterfaces()).forEach(([name, infos]) => {
            for (const info of infos) {
                // we add the loopback interface or interfaces which got a unique (global or local) ipv6 address
                // we currently don't just add all interfaces with ipv4 addresses as are often interfaces like VPNs, container/vms related
                // unique global or unique local ipv6 addresses give an indication that we are truly connected to "the Internet"
                // as something like SLAAC must be going on
                // in the end
                if (info.internal || info.family === "IPv4" || info.family === "IPv6" && info.scopeid === 0) {
                    if (!names.includes(name)) {
                        names.push(name);
                    }
                    break;
                }
            }
        });
        return names;
    }
    static getLoopbackInterface() {
        for (const [name, infos] of Object.entries(os_1.default.networkInterfaces())) {
            for (const info of infos) {
                if (info.internal) {
                    return name;
                }
            }
        }
        throw new Error("Could not detect loopback interface!");
    }
    static getWindowsNetworkInterfaces() {
        // does not return loopback interface
        return new Promise((resolve, reject) => {
            child_process_1.default.exec("arp -a | findstr /C:\"---\"", (error, stdout) => {
                if (error) {
                    reject(error);
                    return;
                }
                const lines = stdout.split(os_1.default.EOL);
                const addresses = [];
                for (let i = 0; i < lines.length - 1; i++) {
                    const line = lines[i].trim().split(" ");
                    if (line[line.length - 3]) {
                        addresses.push(line[line.length - 3]);
                    }
                    else {
                        debug(`WINDOWS: Failed to read interface name from line ${i}: '${lines[i]}'`);
                    }
                }
                const names = [];
                for (const address of addresses) {
                    const name = NetworkManager.resolveInterface(address);
                    if (name) {
                        if (!names.includes(name)) {
                            names.push(name);
                        }
                    }
                    else {
                        debug(`WINDOWS: Couldn't resolve to an interface name from '${address}'`);
                    }
                }
                if (names.length) {
                    resolve(names);
                }
                else {
                    reject(new Error(NetworkManager.NOTHING_FOUND_MESSAGE));
                }
            });
        });
    }
    static getDarwinNetworkInterfaces() {
        /*
         * Previous efforts used the routing table to get all relevant network interfaces.
         * Particularly using "netstat -r -f inet -n".
         * First attempt was to use the "default" interface to the 0.0.0.0 catch all route using "route get 0.0.0.0".
         * Though this fails when the router isn't connected to the internet, thus no "internet route" exists.
         */
        // does not return loopback interface
        return new Promise((resolve, reject) => {
            // for ipv6 "ndp -a -n |grep -v permanent" with filtering for "expired"
            child_process_1.default.exec("arp -a -n -l", async (error, stdout) => {
                if (error) {
                    reject(error);
                    return;
                }
                const lines = stdout.split(os_1.default.EOL);
                const names = [];
                for (let i = 1; i < lines.length - 1; i++) {
                    const interfaceName = lines[i].trim().split(NetworkManager.SPACE_PATTERN)[4];
                    if (!interfaceName) {
                        debug(`DARWIN: Failed to read interface name from line ${i}: '${lines[i]}'`);
                        continue;
                    }
                    if (!names.includes(interfaceName)) {
                        names.push(interfaceName);
                    }
                }
                const promises = [];
                for (const name of names) {
                    const promise = NetworkManager.getDarwinWifiNetworkState(name).then(state => {
                        if (state !== 1 /* NOT_A_WIFI_INTERFACE */ && state !== 3 /* CONNECTED */) {
                            // removing wifi networks which are not connected to any networks
                            const index = names.indexOf(name);
                            if (index !== -1) {
                                names.splice(index, 1);
                            }
                        }
                    });
                    promises.push(promise);
                }
                await Promise.all(promises);
                if (names.length) {
                    resolve(names);
                }
                else {
                    reject(new Error(NetworkManager.NOTHING_FOUND_MESSAGE));
                }
            });
        });
    }
    static getLinuxNetworkInterfaces() {
        // does not return loopback interface
        return new Promise((resolve, reject) => {
            // we use "ip neigh" here instead of the aliases like "ip neighbour" or "ip neighbor"
            // as those were only added like 5 years ago https://github.com/shemminger/iproute2/commit/ede723964a065992bf9d0dbe3f780e65ca917872
            child_process_1.default.exec("ip neigh show", (error, stdout) => {
                if (error) {
                    if (error.message.includes("ip: not found")) {
                        debug("LINUX: ip was not found on the system. Falling back to assuming network interfaces!");
                        resolve(NetworkManager.assumeNetworkInterfaceNames());
                        return;
                    }
                    reject(error);
                    return;
                }
                const lines = stdout.split(os_1.default.EOL);
                const names = [];
                for (let i = 0; i < lines.length - 1; i++) {
                    const parts = lines[i].trim().split(NetworkManager.SPACE_PATTERN);
                    let devIndex = 0;
                    for (; devIndex < parts.length; devIndex++) {
                        if (parts[devIndex] === "dev") {
                            // the next index marks the interface name
                            break;
                        }
                    }
                    if (devIndex >= parts.length) {
                        debug(`LINUX: Out of bounds when reading interface name from line ${i}: '${lines[i]}'`);
                        continue;
                    }
                    const interfaceName = parts[devIndex + 1];
                    if (!interfaceName) {
                        debug(`LINUX: Failed to read interface name from line ${i}: '${lines[i]}'`);
                        continue;
                    }
                    if (!names.includes(interfaceName)) {
                        names.push(interfaceName);
                    }
                }
                if (names.length) {
                    resolve(names);
                }
                else {
                    reject(new Error(NetworkManager.NOTHING_FOUND_MESSAGE));
                }
            });
        });
    }
    static getFreeBSDNetworkInterfaces() {
        // does not return loopback interface
        return new Promise((resolve, reject) => {
            child_process_1.default.exec("arp -a -n", (error, stdout) => {
                if (error) {
                    reject(error);
                    return;
                }
                const lines = stdout.split(os_1.default.EOL);
                const names = [];
                for (let i = 0; i < lines.length - 1; i++) {
                    const interfaceName = lines[i].trim().split(NetworkManager.SPACE_PATTERN)[5];
                    if (!interfaceName) {
                        debug(`FreeBSD: Failed to read interface name from line ${i}: '${lines[i]}'`);
                        continue;
                    }
                    if (!names.includes(interfaceName)) {
                        names.push(interfaceName);
                    }
                }
                if (names.length) {
                    resolve(names);
                }
                else {
                    reject(new Error(NetworkManager.NOTHING_FOUND_MESSAGE));
                }
            });
        });
    }
    static getOpenBSD_SUNOS_NetworkInterfaces() {
        // does not return loopback interface
        return new Promise((resolve, reject) => {
            // for ipv6 something like "ndp -a -n | grep R" (grep for reachable; maybe exclude permanent?)
            child_process_1.default.exec("arp -a -n", (error, stdout) => {
                if (error) {
                    reject(error);
                    return;
                }
                const lines = stdout.split(os_1.default.EOL);
                const names = [];
                for (let i = 1; i < lines.length - 1; i++) {
                    const interfaceName = lines[i].trim().split(NetworkManager.SPACE_PATTERN)[2];
                    if (!interfaceName) {
                        debug(`${os_1.default.platform()}: Failed to read interface name from line ${i}: '${lines[i]}'`);
                        continue;
                    }
                    if (!names.includes(interfaceName)) {
                        names.push(interfaceName);
                    }
                }
                if (names.length) {
                    resolve(names);
                }
                else {
                    reject(new Error(NetworkManager.NOTHING_FOUND_MESSAGE));
                }
            });
        });
    }
    static getDarwinWifiNetworkState(name) {
        return new Promise(resolve => {
            /*
               * networksetup outputs the following in the listed scenarios:
               *
               * executed for an interface which is not a Wi-Fi interface:
               * "<name> is not a Wi-Fi interface.
               * Error: Error obtaining wireless information."
               *
               * executed for a turned off Wi-Fi interface:
               * "You are not associated with an AirPort network.
               * Wi-Fi power is currently off."
               *
               * executed for a turned on Wi-Fi interface which is not connected:
               * "You are not associated with an AirPort network."
               *
               * executed for a connected Wi-Fi interface:
               * "Current Wi-Fi Network: <network name>"
               *
               * Other messages handled here.
               * "All Wi-Fi network services are disabled": encountered on macOS VM machines
               */
            child_process_1.default.exec("networksetup -getairportnetwork " + name, (error, stdout) => {
                if (error) {
                    if (stdout.includes("not a Wi-Fi interface")) {
                        resolve(1 /* NOT_A_WIFI_INTERFACE */);
                        return;
                    }
                    console.log(`CIAO WARN: While checking networksetup for ${name} encountered an error (${error.message}) with output: ${stdout.replace(os_1.default.EOL, "; ")}`);
                    resolve(0 /* UNDEFINED */);
                    return;
                }
                let wifiState = 0 /* UNDEFINED */;
                if (stdout.includes("not a Wi-Fi interface")) {
                    wifiState = 1 /* NOT_A_WIFI_INTERFACE */;
                }
                else if (stdout.includes("Current Wi-Fi Network")) {
                    wifiState = 3 /* CONNECTED */;
                }
                else if (stdout.includes("not associated")) {
                    wifiState = 2 /* NOT_ASSOCIATED */;
                }
                else if (stdout.includes("All Wi-Fi network services are disabled")) {
                    // typically encountered on a macOS VM or something not having a WiFi card
                    wifiState = 1 /* NOT_A_WIFI_INTERFACE */;
                }
                else {
                    console.log(`CIAO WARN: While checking networksetup for ${name} encountered an unknown output: ${stdout.replace(os_1.default.EOL, "; ")}`);
                }
                resolve(wifiState);
            });
        });
    }
}
exports.NetworkManager = NetworkManager;
NetworkManager.SPACE_PATTERN = /\s+/g;
NetworkManager.NOTHING_FOUND_MESSAGE = "no interfaces found";
NetworkManager.POLLING_TIME = 15 * 1000; // 15 seconds
//# sourceMappingURL=NetworkManager.js.map

/***/ }),

/***/ 4237:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Responder = void 0;
const tslib_1 = __nccwpck_require__(4290);
const assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
const debug_1 = tslib_1.__importDefault(__nccwpck_require__(7984));
const CiaoService_1 = __nccwpck_require__(108);
const DNSPacket_1 = __nccwpck_require__(3646);
const Question_1 = __nccwpck_require__(8505);
const AAAARecord_1 = __nccwpck_require__(8584);
const ARecord_1 = __nccwpck_require__(1540);
const PTRRecord_1 = __nccwpck_require__(8517);
const SRVRecord_1 = __nccwpck_require__(1701);
const TXTRecord_1 = __nccwpck_require__(1930);
const MDNSServer_1 = __nccwpck_require__(9668);
const Announcer_1 = __nccwpck_require__(3674);
const Prober_1 = __nccwpck_require__(4735);
const QueryResponse_1 = __nccwpck_require__(389);
const QueuedResponse_1 = __nccwpck_require__(5369);
const TruncatedQuery_1 = __nccwpck_require__(540);
const errors_1 = __nccwpck_require__(8487);
const promise_utils_1 = __nccwpck_require__(3620);
const sorted_array_1 = __nccwpck_require__(204);
const debug = debug_1.default("ciao:Responder");
const queuedResponseComparator = (a, b) => {
    return a.estimatedTimeToBeSent - b.estimatedTimeToBeSent;
};
var ConflictType;
(function (ConflictType) {
    ConflictType[ConflictType["NO_CONFLICT"] = 0] = "NO_CONFLICT";
    ConflictType[ConflictType["CONFLICTING_RDATA"] = 1] = "CONFLICTING_RDATA";
    ConflictType[ConflictType["CONFLICTING_TTL"] = 2] = "CONFLICTING_TTL";
})(ConflictType || (ConflictType = {}));
/**
 * A Responder instance represents a running MDNSServer and a set of advertised services.
 *
 * It will handle any service related operations, like advertising, sending goodbye packets or sending record updates.
 * It handles answering questions arriving on the multicast address.
 */
class Responder {
    constructor(options) {
        this.refCount = 1;
        this.optionsString = "";
        this.bound = false;
        /**
         * Announced services is indexed by the {@link dnsLowerCase} if the fqdn (as of RFC 1035 3.1).
         * As soon as the probing step is finished the service is added to the announced services Map.
         */
        this.announcedServices = new Map();
        /**
         * map representing all our shared PTR records.
         * Typically we hold stuff like '_services._dns-sd._udp.local' (RFC 6763 9.), '_hap._tcp.local'.
         * Also pointers for every subtype like '_printer._sub._http._tcp.local' are inserted here.
         *
         * For every pointer we may hold multiple entries (like multiple services can advertise on _hap._tcp.local).
         * The key as well as all values are {@link dnsLowerCase}
         */
        this.servicePointer = new Map();
        this.truncatedQueries = {}; // indexed by <ip>:<port>
        this.delayedMulticastResponses = [];
        this.server = new MDNSServer_1.MDNSServer(this, options);
        this.promiseChain = this.start();
        this.server.getNetworkManager().on("network-update" /* NETWORK_UPDATE */, this.handleNetworkUpdate.bind(this));
        this.ignoreUnicastResponseFlag = options === null || options === void 0 ? void 0 : options.ignoreUnicastResponseFlag;
        if (options === null || options === void 0 ? void 0 : options.periodicBroadcasts) {
            this.broadcastInterval = setTimeout(this.handlePeriodicBroadcasts.bind(this), 30000).unref();
        }
    }
    /**
     * Refer to {@link getResponder} in the index file
     *
     * @private should not be used directly. Please use the getResponder method defined in index file.
     */
    static getResponder(options) {
        const optionsString = options ? JSON.stringify(options) : "";
        const responder = this.INSTANCES.get(optionsString);
        if (responder) {
            responder.refCount++;
            return responder;
        }
        else {
            const responder = new Responder(options);
            this.INSTANCES.set(optionsString, responder);
            responder.optionsString = optionsString;
            return responder;
        }
    }
    handlePeriodicBroadcasts() {
        this.broadcastInterval = undefined;
        debug("Sending periodic announcement on " + Array.from(this.server.getNetworkManager().getInterfaceMap().keys()).join(", "));
        for (const networkInterface of this.server.getNetworkManager().getInterfaceMap().values()) {
            const question = new Question_1.Question("_hap._tcp.local.", 12 /* PTR */, false);
            const responses = this.answerQuestion(question, {
                port: 5353,
                address: (networkInterface.ipv4Netaddress || networkInterface.globallyRoutableIpv6 || networkInterface.uniqueLocalIpv6 || networkInterface.ipv6),
                interface: networkInterface.name,
            });
            QueryResponse_1.QueryResponse.combineResponses(responses);
            for (const response of responses) {
                if (!response.hasAnswers()) {
                    continue;
                }
                this.server.sendResponse(response.asPacket(), networkInterface.name);
            }
        }
        this.broadcastInterval = setTimeout(this.handlePeriodicBroadcasts.bind(this), Math.random() * 3000 + 27000).unref();
    }
    /**
     * Creates a new CiaoService instance and links it to this Responder instance.
     *
     * @param {ServiceOptions} options - Defines all information about the service which should be created.
     * @returns The newly created {@link CiaoService} instance can be used to advertise and manage the created service.
     */
    createService(options) {
        const service = new CiaoService_1.CiaoService(this.server.getNetworkManager(), options);
        service.on("publish" /* PUBLISH */, this.advertiseService.bind(this, service));
        service.on("unpublish" /* UNPUBLISH */, this.unpublishService.bind(this, service));
        service.on("republish" /* REPUBLISH */, this.republishService.bind(this, service));
        service.on("records-update" /* RECORD_UPDATE */, this.handleServiceRecordUpdate.bind(this, service));
        service.on("records-update-interface" /* RECORD_UPDATE_ON_INTERFACE */, this.handleServiceRecordUpdateOnInterface.bind(this, service));
        return service;
    }
    /**
     * This method should be called when you want to unpublish all service exposed by this Responder.
     * This method SHOULD be called before the node application exists, so any host on the
     * network is informed of the shutdown of this machine.
     * Calling the shutdown method is mandatory for a clean termination (sending goodbye packets).
     *
     * The shutdown method must only be called ONCE.
     *
     * @returns The Promise resolves once all goodbye packets were sent
     * (or immediately if any other users have a reference to this Responder instance).
     */
    shutdown() {
        this.refCount--; // we trust the user here, that the shutdown will not be executed twice or something :thinking:
        if (this.refCount > 0) {
            return Promise.resolve();
        }
        if (this.currentProber) {
            // Services which are in Probing step aren't included in announcedServices Map
            // thus we need to cancel them as well
            this.currentProber.cancel();
        }
        if (this.broadcastInterval) {
            clearTimeout(this.broadcastInterval);
        }
        Responder.INSTANCES.delete(this.optionsString);
        debug("Shutting down Responder...");
        const promises = [];
        for (const service of this.announcedServices.values()) {
            promises.push(this.unpublishService(service));
        }
        // eslint-disable-next-line
        return Promise.all(promises).then(() => {
            this.server.shutdown();
            this.bound = false;
        });
    }
    getAnnouncedServices() {
        return this.announcedServices.values();
    }
    start() {
        if (this.bound) {
            throw new Error("Server is already bound!");
        }
        this.bound = true;
        return this.server.bind();
    }
    advertiseService(service, callback) {
        if (service.serviceState === "announced" /* ANNOUNCED */) {
            throw new Error("Can't publish a service that is already announced. Received " + service.serviceState + " for service " + service.getFQDN());
        }
        else if (service.serviceState === "probing" /* PROBING */) {
            return this.promiseChain.then(() => {
                if (service.currentAnnouncer) {
                    return service.currentAnnouncer.awaitAnnouncement();
                }
            });
        }
        else if (service.serviceState === "announcing" /* ANNOUNCING */) {
            assert_1.default(service.currentAnnouncer, "Service is in state ANNOUNCING though has no linked announcer!");
            if (service.currentAnnouncer.isSendingGoodbye()) {
                return service.currentAnnouncer.awaitAnnouncement().then(() => this.advertiseService(service, callback));
            }
            else {
                return service.currentAnnouncer.cancel().then(() => this.advertiseService(service, callback));
            }
        }
        debug("[%s] Going to advertise service...", service.getFQDN()); // TODO include restricted addresses and stuff
        // multicast loopback is not enabled for our sockets, though we do some stuff, so Prober will handle potential
        // name conflicts with our own services:
        //  - One Responder will always run ONE prober: no need to handle simultaneous probe tiebreaking
        //  - Prober will call the Responder to generate responses to its queries to
        //      resolve name conflicts the same way as with other services on the network
        this.promiseChain = this.promiseChain // we synchronize all ongoing probes here
            .then(() => service.rebuildServiceRecords()) // build the records the first time for the prober
            .then(() => this.probe(service)); // probe errors are catch below
        return this.promiseChain.then(() => {
            // we are not returning the promise returned by announced here, only PROBING is synchronized
            this.announce(service).catch(reason => {
                // handle announce errors
                console.log(`[${service.getFQDN()}] failed announcing with reason: ${reason}. Trying again in 2 seconds!`);
                return promise_utils_1.PromiseTimeout(2000).then(() => this.advertiseService(service, () => {
                    // empty
                }));
            });
            callback(); // service is considered announced. After the call to the announce() method the service state is set to ANNOUNCING
        }, reason => {
            /*
             * I know seems unintuitive to place the probe error handling below here, miles away from the probe method call.
             * Trust me it makes sense (encountered regression now two times in a row).
             * 1. We can't put it in the THEN call above, since then errors simply won't be handled from the probe method call.
             *  (CANCEL error would be passed through and would result in some unwanted stack trace)
             * 2. We can't add a catch call above, since otherwise we would silence the CANCEL would be silenced and announce
             *  would be called anyways.
             */
            // handle probe error
            if (reason === Prober_1.Prober.CANCEL_REASON) {
                callback();
            }
            else { // other errors are only thrown when sockets error occur
                console.log(`[${service.getFQDN()}] failed probing with reason: ${reason}. Trying again in 2 seconds!`);
                return promise_utils_1.PromiseTimeout(2000).then(() => this.advertiseService(service, callback));
            }
        });
    }
    republishService(service, callback, delayAnnounce = false) {
        if (service.serviceState !== "announced" /* ANNOUNCED */ && service.serviceState !== "announcing" /* ANNOUNCING */) {
            throw new Error("Can't unpublish a service which isn't announced yet. Received " + service.serviceState + " for service " + service.getFQDN());
        }
        debug("[%s] Readvertising service...", service.getFQDN());
        if (service.serviceState === "announcing" /* ANNOUNCING */) {
            assert_1.default(service.currentAnnouncer, "Service is in state ANNOUNCING though has no linked announcer!");
            const promise = service.currentAnnouncer.isSendingGoodbye()
                ? service.currentAnnouncer.awaitAnnouncement()
                : service.currentAnnouncer.cancel();
            return promise.then(() => this.advertiseService(service, callback));
        }
        // first of all remove it from our advertisedService Map and remove all of the maintained PTRs
        this.clearService(service);
        service.serviceState = "unannounced" /* UNANNOUNCED */; // the service is now considered unannounced
        // and now we basically just announce the service by doing probing and the announce step
        if (delayAnnounce) {
            return promise_utils_1.PromiseTimeout(1000)
                .then(() => this.advertiseService(service, callback));
        }
        else {
            return this.advertiseService(service, callback);
        }
    }
    unpublishService(service, callback) {
        if (service.serviceState === "unannounced" /* UNANNOUNCED */) {
            throw new Error("Can't unpublish a service which isn't announced yet. Received " + service.serviceState + " for service " + service.getFQDN());
        }
        if (service.serviceState === "announced" /* ANNOUNCED */ || service.serviceState === "announcing" /* ANNOUNCING */) {
            if (service.serviceState === "announcing" /* ANNOUNCING */) {
                assert_1.default(service.currentAnnouncer, "Service is in state ANNOUNCING though has no linked announcer!");
                if (service.currentAnnouncer.isSendingGoodbye()) {
                    return service.currentAnnouncer.awaitAnnouncement(); // we are already sending a goodbye
                }
                return service.currentAnnouncer.cancel().then(() => {
                    service.serviceState = "announced" /* ANNOUNCED */; // unpublishService requires announced state
                    return this.unpublishService(service, callback);
                });
            }
            debug("[%s] Removing service from the network", service.getFQDN());
            this.clearService(service);
            service.serviceState = "unannounced" /* UNANNOUNCED */;
            let promise = this.goodbye(service);
            if (callback) {
                promise = promise.then(() => callback(), reason => {
                    console.log(`[${service.getFQDN()}] failed goodbye with reason: ${reason}.`);
                    callback();
                });
            }
            return promise;
        }
        else if (service.serviceState === "probing" /* PROBING */) {
            debug("[%s] Canceling probing", service.getFQDN());
            if (this.currentProber && this.currentProber.getService() === service) {
                this.currentProber.cancel();
                this.currentProber = undefined;
            }
            service.serviceState = "unannounced" /* UNANNOUNCED */;
        }
        callback && callback();
        return Promise.resolve();
    }
    clearService(service) {
        const serviceFQDN = service.getLowerCasedFQDN();
        const typePTR = service.getLowerCasedTypePTR();
        const subtypePTRs = service.getLowerCasedSubtypePTRs(); // possibly undefined
        this.removePTR(Responder.SERVICE_TYPE_ENUMERATION_NAME, typePTR);
        this.removePTR(typePTR, serviceFQDN);
        if (subtypePTRs) {
            for (const ptr of subtypePTRs) {
                this.removePTR(ptr, serviceFQDN);
            }
        }
        this.announcedServices.delete(service.getLowerCasedFQDN());
    }
    addPTR(ptr, name) {
        // we don't call lower case here, as we expect the caller to have done that already
        // name = dnsLowerCase(name); // worst case is that the meta query ptr record contains lower cased destination
        const names = this.servicePointer.get(ptr);
        if (names) {
            if (!names.includes(name)) {
                names.push(name);
            }
        }
        else {
            this.servicePointer.set(ptr, [name]);
        }
    }
    removePTR(ptr, name) {
        const names = this.servicePointer.get(ptr);
        if (names) {
            const index = names.indexOf(name);
            if (index !== -1) {
                names.splice(index, 1);
            }
            if (names.length === 0) {
                this.servicePointer.delete(ptr);
            }
        }
    }
    probe(service) {
        if (service.serviceState !== "unannounced" /* UNANNOUNCED */) {
            throw new Error("Can't probe for a service which is announced already. Received " + service.serviceState + " for service " + service.getFQDN());
        }
        service.serviceState = "probing" /* PROBING */;
        assert_1.default(this.currentProber === undefined, "Tried creating new Prober when there already was one active!");
        this.currentProber = new Prober_1.Prober(this, this.server, service);
        return this.currentProber.probe()
            .then(() => {
            this.currentProber = undefined;
            service.serviceState = "probed" /* PROBED */;
        }, reason => {
            service.serviceState = "unannounced" /* UNANNOUNCED */;
            this.currentProber = undefined;
            return Promise.reject(reason); // forward reason
        });
    }
    announce(service) {
        if (service.serviceState !== "probed" /* PROBED */) {
            throw new Error("Cannot announce service which was not probed unique. Received " + service.serviceState + " for service " + service.getFQDN());
        }
        assert_1.default(service.currentAnnouncer === undefined, "Service " + service.getFQDN() + " is already announcing!");
        service.serviceState = "announcing" /* ANNOUNCING */;
        const announcer = new Announcer_1.Announcer(this.server, service, {
            repetitions: 3,
        });
        service.currentAnnouncer = announcer;
        const serviceFQDN = service.getLowerCasedFQDN();
        const typePTR = service.getLowerCasedTypePTR();
        const subtypePTRs = service.getLowerCasedSubtypePTRs(); // possibly undefined
        this.addPTR(Responder.SERVICE_TYPE_ENUMERATION_NAME, typePTR);
        this.addPTR(typePTR, serviceFQDN);
        if (subtypePTRs) {
            for (const ptr of subtypePTRs) {
                this.addPTR(ptr, serviceFQDN);
            }
        }
        this.announcedServices.set(serviceFQDN, service);
        return announcer.announce().then(() => {
            service.serviceState = "announced" /* ANNOUNCED */;
            service.currentAnnouncer = undefined;
        }, reason => {
            service.serviceState = "unannounced" /* UNANNOUNCED */;
            service.currentAnnouncer = undefined;
            this.clearService(service); // also removes entry from announcedServices
            if (reason !== Announcer_1.Announcer.CANCEL_REASON) {
                // forward reason if it is not a cancellation.
                // We do not forward cancel reason. Announcements only get cancelled if we have something "better" to do.
                // So the race is already handled by us.
                return Promise.reject(reason);
            }
        });
    }
    handleServiceRecordUpdate(service, response, callback) {
        var _a;
        // when updating we just repeat the announce step
        if (service.serviceState !== "announced" /* ANNOUNCED */) { // different states are already handled in CiaoService where this event handler is fired
            throw new Error("Cannot update txt of service which is not announced yet. Received " + service.serviceState + " for service " + service.getFQDN());
        }
        debug("[%s] Updating %d record(s) for given service!", service.getFQDN(), response.answers.length + (((_a = response.additionals) === null || _a === void 0 ? void 0 : _a.length) || 0));
        // TODO we should do a announcement at this point "in theory"
        this.server.sendResponseBroadcast(response, service).then(results => {
            const failRatio = MDNSServer_1.SendResultFailedRatio(results);
            if (failRatio === 1) {
                console.log(MDNSServer_1.SendResultFormatError(results, `Failed to send records update for '${service.getFQDN()}'`), true);
                if (callback) {
                    callback(new Error("Updating records failed as of socket errors!"));
                }
                return; // all failed => updating failed
            }
            if (failRatio > 0) {
                // some queries on some interfaces failed, but not all. We log that but consider that to be a success
                // at this point we are not responsible for removing stale network interfaces or something
                debug(MDNSServer_1.SendResultFormatError(results, `Some of the record updates for '${service.getFQDN()}' failed`));
                // SEE no return here
            }
            if (callback) {
                callback();
            }
        });
    }
    handleServiceRecordUpdateOnInterface(service, name, records, callback) {
        // when updating we just repeat the announce step
        if (service.serviceState !== "announced" /* ANNOUNCED */) { // different states are already handled in CiaoService where this event handler is fired
            throw new Error("Cannot update txt of service which is not announced yet. Received " + service.serviceState + " for service " + service.getFQDN());
        }
        debug("[%s] Updating %d record(s) for given service on interface %s!", service.getFQDN(), records.length, name);
        const packet = DNSPacket_1.DNSPacket.createDNSResponsePacketsFromRRSet({ answers: records });
        this.server.sendResponse(packet, name, callback);
    }
    goodbye(service) {
        assert_1.default(service.currentAnnouncer === undefined, "Service " + service.getFQDN() + " is already announcing!");
        service.serviceState = "announcing" /* ANNOUNCING */;
        const announcer = new Announcer_1.Announcer(this.server, service, {
            repetitions: 1,
            goodbye: true,
        });
        service.currentAnnouncer = announcer;
        return announcer.announce().then(() => {
            service.serviceState = "unannounced" /* UNANNOUNCED */;
            service.currentAnnouncer = undefined;
        }, reason => {
            // just assume unannounced. we won't be answering anymore, so the record will be flushed from cache sometime.
            service.serviceState = "unannounced" /* UNANNOUNCED */;
            service.currentAnnouncer = undefined;
            return Promise.reject(reason);
        });
    }
    handleNetworkUpdate(change) {
        for (const service of this.announcedServices.values()) {
            service.handleNetworkInterfaceUpdate(change);
        }
    }
    /**
     * @private method called by the MDNSServer when an incoming query needs ot be handled
     */
    handleQuery(packet, endpoint) {
        const start = new Date().getTime();
        const endpointId = endpoint.address + ":" + endpoint.port + ":" + endpoint.interface; // used to match truncated queries
        const previousQuery = this.truncatedQueries[endpointId];
        if (previousQuery) {
            const truncatedQueryResult = previousQuery.appendDNSPacket(packet);
            switch (truncatedQueryResult) {
                case 1 /* ABORT */: // returned when we detect, that continuously TC queries are sent
                    delete this.truncatedQueries[endpointId];
                    debug("[%s] Aborting to wait for more truncated queries. Waited a total of %d ms receiving %d queries", endpointId, previousQuery.getTotalWaitTime(), previousQuery.getArrivedPacketCount());
                    return;
                case 2 /* AGAIN_TRUNCATED */:
                    debug("[%s] Received a query marked as truncated, waiting for more to arrive", endpointId);
                    return; // wait for the next packet
                case 3 /* FINISHED */:
                    delete this.truncatedQueries[endpointId];
                    packet = previousQuery.getPacket(); // replace packet with the complete deal
                    debug("[%s] Last part of the truncated query arrived. Received %d packets taking a total of %d ms", endpointId, previousQuery.getArrivedPacketCount(), previousQuery.getTotalWaitTime());
                    break;
            }
        }
        else if (packet.flags.truncation) {
            // RFC 6763 18.5 truncate flag indicates that additional known-answer records follow shortly
            debug("Received truncated query from " + JSON.stringify(endpoint) + " waiting for more to come!");
            const truncatedQuery = new TruncatedQuery_1.TruncatedQuery(packet);
            this.truncatedQueries[endpointId] = truncatedQuery;
            truncatedQuery.on("timeout" /* TIMEOUT */, () => {
                // called when more than 400-500ms pass until the next packet arrives
                debug("[%s] Timeout passed since the last truncated query was received. Discarding %d packets received in %d ms.", endpointId, truncatedQuery.getArrivedPacketCount(), truncatedQuery.getTotalWaitTime());
                delete this.truncatedQueries[endpointId];
            });
            return; // wait for the next query
        }
        const isUnicastQuerier = endpoint.port !== MDNSServer_1.MDNSServer.MDNS_PORT; // explained below
        const isProbeQuery = packet.authorities.size > 0;
        let udpPayloadSize = undefined; // payload size supported by the querier
        for (const record of packet.additionals.values()) {
            if (record.type === 41 /* OPT */) {
                udpPayloadSize = record.udpPayloadSize;
                break;
            }
        }
        // responses must not include questions RFC 6762 6.
        // known answer suppression according to RFC 6762 7.1.
        const multicastResponses = [];
        const unicastResponses = [];
        // gather answers for all the questions
        packet.questions.forEach(question => {
            const responses = this.answerQuestion(question, endpoint, packet.answers);
            if (isUnicastQuerier || question.unicastResponseFlag && !this.ignoreUnicastResponseFlag) {
                unicastResponses.push(...responses);
            }
            else {
                multicastResponses.push(...responses);
            }
        });
        if (this.currentProber) {
            this.currentProber.handleQuery(packet, endpoint);
        }
        if (isUnicastQuerier) {
            // we are dealing with a legacy unicast dns query (RFC 6762 6.7.)
            //  * MUSTS: response via unicast, repeat query ID, repeat questions, clear cache flush bit
            //  * SHOULDS: ttls should not be greater than 10s as legacy resolvers don't take part in the cache coherency mechanism
            for (let i = 0; i < unicastResponses.length; i++) {
                const response = unicastResponses[i];
                // only add questions to the first packet (will be combined anyways) and we must ensure
                // each packet stays unique in it's records
                response.markLegacyUnicastResponse(packet.id, i === 0 ? Array.from(packet.questions.values()) : undefined);
            }
        }
        // RFC 6762 6.4. Response aggregation:
        //    When possible, a responder SHOULD, for the sake of network
        //    efficiency, aggregate as many responses as possible into a single
        //    Multicast DNS response message.  For example, when a responder has
        //    several responses it plans to send, each delayed by a different
        //    interval, then earlier responses SHOULD be delayed by up to an
        //    additional 500 ms if that will permit them to be aggregated with
        //    other responses scheduled to go out a little later.
        QueryResponse_1.QueryResponse.combineResponses(multicastResponses, udpPayloadSize);
        QueryResponse_1.QueryResponse.combineResponses(unicastResponses, udpPayloadSize);
        if (isUnicastQuerier && unicastResponses.length > 1) {
            // RFC 6762 18.5. In legacy unicast response messages, the TC bit has the same meaning
            //    as in conventional Unicast DNS: it means that the response was too
            //    large to fit in a single packet, so the querier SHOULD reissue its
            //    query using TCP in order to receive the larger response.
            unicastResponses.splice(1, unicastResponses.length - 1); // discard all other
            unicastResponses[0].markTruncated();
        }
        for (const unicastResponse of unicastResponses) {
            if (!unicastResponse.hasAnswers()) {
                continue;
            }
            this.server.sendResponse(unicastResponse.asPacket(), endpoint);
            const time = new Date().getTime() - start;
            debug("Sending response via unicast to %s (took %d ms): %s", JSON.stringify(endpoint), time, unicastResponse.asString(udpPayloadSize));
        }
        for (const multicastResponse of multicastResponses) {
            if (!multicastResponse.hasAnswers()) {
                continue;
            }
            if ((multicastResponse.containsSharedAnswer() || packet.questions.size > 1) && !isProbeQuery) {
                // We must delay the response on a interval of 20-120ms if we can't assure that we are the only one responding (shared records).
                // This is also the case if there are multiple questions. If multiple questions are asked
                // we probably could not answer them all (because not all of them were directed to us).
                // All those conditions are overridden if this is a probe query. To those queries we must respond instantly!
                const time = new Date().getTime() - start;
                this.enqueueDelayedMulticastResponse(multicastResponse.asPacket(), endpoint.interface, time);
            }
            else {
                // otherwise the response is sent immediately, if there isn't any packet in the queue
                // so first step is, check if there is a packet in the queue we are about to send out
                // which can be combined with our current packet without adding a delay > 500ms
                let sentWithLaterPacket = false;
                for (let i = 0; i < this.delayedMulticastResponses.length; i++) {
                    const delayedResponse = this.delayedMulticastResponses[i];
                    if (delayedResponse.getTimeTillSent() > QueuedResponse_1.QueuedResponse.MAX_DELAY) {
                        // all packets following won't be compatible either
                        break;
                    }
                    if (delayedResponse.combineWithUniqueResponseIfPossible(multicastResponse, endpoint.interface)) {
                        const time = new Date().getTime() - start;
                        sentWithLaterPacket = true;
                        debug("Multicast response on interface %s containing unique records (took %d ms) was combined with response which is sent out later", endpoint.interface, time);
                        break;
                    }
                }
                if (!sentWithLaterPacket) {
                    this.server.sendResponse(multicastResponse.asPacket(), endpoint.interface);
                    const time = new Date().getTime() - start;
                    debug("Sending response via multicast on network %s (took %d ms): %s", endpoint.interface, time, multicastResponse.asString(udpPayloadSize));
                }
            }
        }
    }
    /**
     * @private method called by the MDNSServer when an incoming response needs to be handled
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    handleResponse(packet, endpoint) {
        // any questions in a response must be ignored RFC 6762 6.
        if (this.currentProber) { // if there is a probing process running currently, just forward all messages to it
            this.currentProber.handleResponse(packet, endpoint);
        }
        for (const service of this.announcedServices.values()) {
            let conflictingRData = false;
            let ttlConflicts = 0; // we currently do a full blown announcement with all records, we could in the future track which records have invalid ttl
            for (const record of packet.answers.values()) {
                const type = Responder.checkRecordConflictType(service, record, endpoint);
                if (type === 1 /* CONFLICTING_RDATA */) {
                    conflictingRData = true;
                    break; // we will republish in any case
                }
                else if (type === 2 /* CONFLICTING_TTL */) {
                    ttlConflicts++;
                }
            }
            if (!conflictingRData) {
                for (const record of packet.additionals.values()) {
                    const type = Responder.checkRecordConflictType(service, record, endpoint);
                    if (type === 1 /* CONFLICTING_RDATA */) {
                        conflictingRData = true;
                        break; // we will republish in any case
                    }
                    else if (type === 2 /* CONFLICTING_TTL */) {
                        ttlConflicts++;
                    }
                }
            }
            if (conflictingRData) {
                // noinspection JSIgnoredPromiseFromCall
                this.republishService(service, error => {
                    if (error) {
                        console.log(`FATAL Error occurred trying to resolve conflict for service ${service.getFQDN()}! We can't recover from this!`);
                        console.log(error.stack);
                        process.exit(1); // we have a service which should be announced, though we failed to reannounce.
                        // if this should ever happen in reality, whe might want to introduce a more sophisticated recovery
                        // for situations where it makes sense
                    }
                }, true);
            }
            else if (ttlConflicts && !service.currentAnnouncer) {
                service.serviceState = "announcing" /* ANNOUNCING */; // all code above doesn't expect a Announcer object in state ANNOUNCED
                const announcer = new Announcer_1.Announcer(this.server, service, {
                    repetitions: 1,
                });
                service.currentAnnouncer = announcer;
                announcer.announce().then(() => {
                    service.currentAnnouncer = undefined;
                    service.serviceState = "announced" /* ANNOUNCED */;
                }, reason => {
                    service.currentAnnouncer = undefined;
                    service.serviceState = "announced" /* ANNOUNCED */;
                    if (reason === Announcer_1.Announcer.CANCEL_REASON) {
                        return; // nothing to worry about
                    }
                    console.warn("When trying to resolve a ttl conflict on the network, we were unable to send our response packet: " + reason.message);
                });
            }
        }
    }
    static checkRecordConflictType(service, record, endpoint) {
        // RFC 6762 9. Conflict Resolution:
        //    A conflict occurs when a Multicast DNS responder has a unique record
        //    for which it is currently authoritative, and it receives a Multicast
        //    DNS response message containing a record with the same name, rrtype
        //    and rrclass, but inconsistent rdata.  What may be considered
        //    inconsistent is context sensitive, except that resource records with
        //    identical rdata are never considered inconsistent, even if they
        //    originate from different hosts.  This is to permit use of proxies and
        //    other fault-tolerance mechanisms that may cause more than one
        //    responder to be capable of issuing identical answers on the network.
        //
        //    A common example of a resource record type that is intended to be
        //    unique, not shared between hosts, is the address record that maps a
        //    host's name to its IP address.  Should a host witness another host
        //    announce an address record with the same name but a different IP
        //    address, then that is considered inconsistent, and that address
        //    record is considered to be in conflict.
        //
        //    Whenever a Multicast DNS responder receives any Multicast DNS
        //    response (solicited or otherwise) containing a conflicting resource
        //    record in any of the Resource Record Sections, the Multicast DNS
        //    responder MUST immediately reset its conflicted unique record to
        //    probing state, and go through the startup steps described above in
        //    Section 8, "Probing and Announcing on Startup".  The protocol used in
        //    the Probing phase will determine a winner and a loser, and the loser
        //    MUST cease using the name, and reconfigure.
        if (!service.advertisesOnInterface(endpoint.interface)) {
            return 0 /* NO_CONFLICT */;
        }
        const recordName = record.getLowerCasedName();
        if (recordName === service.getLowerCasedFQDN()) {
            if (record.type === 33 /* SRV */) {
                const srvRecord = record;
                if (srvRecord.getLowerCasedHostname() !== service.getLowerCasedHostname()) {
                    debug("[%s] Noticed conflicting record on the network. SRV with hostname: %s", service.getFQDN(), srvRecord.hostname);
                    return 1 /* CONFLICTING_RDATA */;
                }
                else if (srvRecord.port !== service.getPort()) {
                    debug("[%s] Noticed conflicting record on the network. SRV with port: %s", service.getFQDN(), srvRecord.port);
                    return 1 /* CONFLICTING_RDATA */;
                }
                if (srvRecord.ttl < SRVRecord_1.SRVRecord.DEFAULT_TTL / 2) {
                    return 2 /* CONFLICTING_TTL */;
                }
            }
            else if (record.type === 16 /* TXT */) {
                const txtRecord = record;
                const txt = service.getTXT();
                if (txt.length !== txtRecord.txt.length) { // length differs, can't be the same data
                    debug("[%s] Noticed conflicting record on the network. TXT with differing data length", service.getFQDN());
                    return 1 /* CONFLICTING_RDATA */;
                }
                for (let i = 0; i < txt.length; i++) {
                    const buffer0 = txt[i];
                    const buffer1 = txtRecord.txt[i];
                    if (buffer0.length !== buffer1.length || buffer0.toString("hex") !== buffer1.toString("hex")) {
                        debug("[%s] Noticed conflicting record on the network. TXT with differing data.", service.getFQDN());
                        return 1 /* CONFLICTING_RDATA */;
                    }
                }
                if (txtRecord.ttl < TXTRecord_1.TXTRecord.DEFAULT_TTL / 2) {
                    return 2 /* CONFLICTING_TTL */;
                }
            }
        }
        else if (recordName === service.getLowerCasedHostname()) {
            if (record.type === 1 /* A */) {
                const aRecord = record;
                if (!service.hasAddress(aRecord.ipAddress)) {
                    // if the service doesn't expose the listed address we have a conflict
                    debug("[%s] Noticed conflicting record on the network. A with ip address: %s", service.getFQDN(), aRecord.ipAddress);
                    return 1 /* CONFLICTING_RDATA */;
                }
                if (aRecord.ttl < ARecord_1.ARecord.DEFAULT_TTL / 2) {
                    return 2 /* CONFLICTING_TTL */;
                }
            }
            else if (record.type === 28 /* AAAA */) {
                const aaaaRecord = record;
                if (!service.hasAddress(aaaaRecord.ipAddress)) {
                    // if the service doesn't expose the listed address we have a conflict
                    debug("[%s] Noticed conflicting record on the network. AAAA with ip address: %s", service.getFQDN(), aaaaRecord.ipAddress);
                    return 1 /* CONFLICTING_RDATA */;
                }
                if (aaaaRecord.ttl < AAAARecord_1.AAAARecord.DEFAULT_TTL / 2) {
                    return 2 /* CONFLICTING_TTL */;
                }
            }
        }
        else if (record.type === 12 /* PTR */) {
            const ptrRecord = record;
            if (recordName === service.getLowerCasedTypePTR()) {
                if (ptrRecord.getLowerCasedPTRName() === service.getLowerCasedFQDN() && ptrRecord.ttl < PTRRecord_1.PTRRecord.DEFAULT_TTL / 2) {
                    return 2 /* CONFLICTING_TTL */;
                }
            }
            else if (recordName === Responder.SERVICE_TYPE_ENUMERATION_NAME) {
                // nothing to do here, i guess
            }
            else {
                const subTypes = service.getLowerCasedSubtypePTRs();
                if (subTypes && subTypes.includes(recordName)
                    && ptrRecord.getLowerCasedPTRName() === service.getLowerCasedFQDN() && ptrRecord.ttl < PTRRecord_1.PTRRecord.DEFAULT_TTL / 2) {
                    return 2 /* CONFLICTING_TTL */;
                }
            }
        }
        return 0 /* NO_CONFLICT */;
    }
    enqueueDelayedMulticastResponse(packet, interfaceName, time) {
        const response = new QueuedResponse_1.QueuedResponse(packet, interfaceName);
        response.calculateRandomDelay();
        sorted_array_1.sortedInsert(this.delayedMulticastResponses, response, queuedResponseComparator);
        // run combine/delay checks
        for (let i = 0; i < this.delayedMulticastResponses.length; i++) {
            const response0 = this.delayedMulticastResponses[i];
            // search for any packets sent out after this packet
            for (let j = i + 1; j < this.delayedMulticastResponses.length; j++) {
                const response1 = this.delayedMulticastResponses[j];
                if (!response0.delayWouldBeInTimelyManner(response1)) {
                    // all packets following won't be compatible either
                    break;
                }
                if (response0.combineWithNextPacketIfPossible(response1)) {
                    // combine was a success and the packet got delay
                    // remove the packet from the queue
                    const index = this.delayedMulticastResponses.indexOf(response0);
                    if (index !== -1) {
                        this.delayedMulticastResponses.splice(index, 1);
                    }
                    i--; // reduce i, as one element got removed from the queue
                    break;
                }
                // otherwise we continue with maybe some packets further ahead
            }
        }
        if (!response.delayed) {
            // only set timer if packet got not delayed
            response.scheduleResponse(() => {
                const index = this.delayedMulticastResponses.indexOf(response);
                if (index !== -1) {
                    this.delayedMulticastResponses.splice(index, 1);
                }
                try {
                    this.server.sendResponse(response.getPacket(), interfaceName);
                    debug("Sending (delayed %dms) response via multicast on network interface %s (took %d ms): %s", Math.round(response.getTimeSinceCreation()), interfaceName, time, response.getPacket().asLoggingString());
                }
                catch (error) {
                    if (error.name === errors_1.ERR_INTERFACE_NOT_FOUND) {
                        debug("Multicast response (delayed %dms) was cancelled as the network interface %s is no longer available!", Math.round(response.getTimeSinceCreation()), interfaceName);
                    }
                    else if (error.name === errors_1.ERR_SERVER_CLOSED) {
                        debug("Multicast response (delayed %dms) was cancelled as the server is about to be shutdown!", Math.round(response.getTimeSinceCreation()));
                    }
                    else {
                        throw error;
                    }
                }
            });
        }
    }
    answerQuestion(question, endpoint, knownAnswers) {
        // RFC 6762 6: The determination of whether a given record answers a given question
        //    is made using the standard DNS rules: the record name must match the
        //    question name, the record rrtype must match the question qtype unless
        //    the qtype is "ANY" (255) or the rrtype is "CNAME" (5), and the record
        //    rrclass must match the question qclass unless the qclass is "ANY" (255).
        if (question.class !== 1 /* IN */ && question.class !== 255 /* ANY */) {
            // We just publish answers with IN class. So only IN or ANY questions classes will match
            return [];
        }
        const serviceResponses = [];
        let metaQueryResponse = undefined;
        if (question.type === 12 /* PTR */ || question.type === 255 /* ANY */ || question.type === 5 /* CNAME */) {
            const destinations = this.servicePointer.get(question.getLowerCasedName()); // look up the pointer, all entries are dnsLowerCased
            if (destinations) {
                // if it's a pointer name, we handle it here
                for (const data of destinations) {
                    // check if the PTR is pointing towards a service, like in questions for PTR '_hap._tcp.local'
                    // if that's the case, let the question be answered by the service itself
                    const service = this.announcedServices.get(data);
                    if (service) {
                        if (service.advertisesOnInterface(endpoint.interface)) {
                            // call the method for original question, so additionals get added properly
                            const response = Responder.answerServiceQuestion(service, question, endpoint, knownAnswers);
                            if (response.hasAnswers()) {
                                serviceResponses.push(response);
                            }
                        }
                    }
                    else {
                        if (!metaQueryResponse) {
                            metaQueryResponse = new QueryResponse_1.QueryResponse(knownAnswers);
                            serviceResponses.unshift(metaQueryResponse);
                        }
                        // it's probably question for PTR '_services._dns-sd._udp.local'
                        // the PTR will just point to something like '_hap._tcp.local' thus no additional records need to be included
                        metaQueryResponse.addAnswer(new PTRRecord_1.PTRRecord(question.name, data));
                        // we may send out meta queries on interfaces where there aren't any services, because they are
                        //  restricted to other interfaces.
                    }
                }
                return serviceResponses; // if we got in this if-body, it was a pointer name and we handled it correctly
            } /* else if (loweredQuestionName.endsWith(".in-addr.arpa") || loweredQuestionName.endsWith(".ip6.arpa")) { // reverse address lookup
                const address = ipAddressFromReversAddressName(loweredQuestionName);
      
                for (const service of this.announcedServices.values()) {
                  const record = service.reverseAddressMapping(address);
                  if (record) {
                    mainResponse.addAnswer(record);
                  }
                }
              }
              We won't actually respond to reverse address queries.
              This typically confuses responders like avahi, which then over and over try to increment the hostname.
              */
        }
        for (const service of this.announcedServices.values()) {
            if (!service.advertisesOnInterface(endpoint.interface)) {
                continue;
            }
            const response = Responder.answerServiceQuestion(service, question, endpoint, knownAnswers);
            if (response.hasAnswers()) {
                serviceResponses.push(response);
            }
        }
        return serviceResponses;
    }
    static answerServiceQuestion(service, question, endpoint, knownAnswers) {
        // This assumes to be called from answerQuestion inside the Responder class and thus that certain
        // preconditions or special cases are already covered.
        // For one we assume classes are already matched.
        const response = new QueryResponse_1.QueryResponse(knownAnswers);
        const loweredQuestionName = question.getLowerCasedName();
        const askingAny = question.type === 255 /* ANY */ || question.type === 5 /* CNAME */;
        const addAnswer = response.addAnswer.bind(response);
        const addAdditional = response.addAdditional.bind(response);
        // RFC 6762 6.2. In the event that a device has only IPv4 addresses but no IPv6
        //    addresses, or vice versa, then the appropriate NSEC record SHOULD be
        //    placed into the additional section, so that queriers can know with
        //    certainty that the device has no addresses of that kind.
        if (loweredQuestionName === service.getLowerCasedTypePTR()) {
            if (askingAny || question.type === 12 /* PTR */) {
                const added = response.addAnswer(service.ptrRecord());
                if (added) {
                    // only add additionals if answer is not suppressed by the known answer section
                    // RFC 6763 12.1: include additionals: srv, txt, a, aaaa
                    response.addAdditional(service.txtRecord(), service.srvRecord());
                    this.addAddressRecords(service, endpoint, 1 /* A */, addAdditional);
                    this.addAddressRecords(service, endpoint, 28 /* AAAA */, addAdditional);
                    response.addAdditional(service.serviceNSECRecord(), service.addressNSECRecord());
                }
            }
        }
        else if (loweredQuestionName === service.getLowerCasedFQDN()) {
            if (askingAny) {
                response.addAnswer(service.txtRecord());
                const addedSrv = response.addAnswer(service.srvRecord());
                if (addedSrv) {
                    // RFC 6763 12.2: include additionals: a, aaaa
                    this.addAddressRecords(service, endpoint, 1 /* A */, addAdditional);
                    this.addAddressRecords(service, endpoint, 28 /* AAAA */, addAdditional);
                    response.addAdditional(service.serviceNSECRecord(), service.addressNSECRecord());
                }
            }
            else if (question.type === 33 /* SRV */) {
                const added = response.addAnswer(service.srvRecord());
                if (added) {
                    // RFC 6763 12.2: include additionals: a, aaaa
                    this.addAddressRecords(service, endpoint, 1 /* A */, addAdditional);
                    this.addAddressRecords(service, endpoint, 28 /* AAAA */, addAdditional);
                    response.addAdditional(service.serviceNSECRecord(true), service.addressNSECRecord());
                }
            }
            else if (question.type === 16 /* TXT */) {
                response.addAnswer(service.txtRecord());
                response.addAdditional(service.serviceNSECRecord());
                // RFC 6763 12.3: not any other additionals
            }
        }
        else if (loweredQuestionName === service.getLowerCasedHostname() || loweredQuestionName + "local." === service.getLowerCasedHostname()) {
            if (askingAny) {
                this.addAddressRecords(service, endpoint, 1 /* A */, addAnswer);
                this.addAddressRecords(service, endpoint, 28 /* AAAA */, addAnswer);
                response.addAdditional(service.addressNSECRecord());
            }
            else if (question.type === 1 /* A */) {
                // RFC 6762 6.2 When a Multicast DNS responder places an IPv4 or IPv6 address record
                //    (rrtype "A" or "AAAA") into a response message, it SHOULD also place
                //    any records of the other address type with the same name into the
                //    additional section, if there is space in the message.
                const added = this.addAddressRecords(service, endpoint, 1 /* A */, addAnswer);
                if (added) {
                    this.addAddressRecords(service, endpoint, 28 /* AAAA */, addAdditional);
                }
                response.addAdditional(service.addressNSECRecord()); // always add the negative response, always assert dominance
            }
            else if (question.type === 28 /* AAAA */) {
                // RFC 6762 6.2 When a Multicast DNS responder places an IPv4 or IPv6 address record
                //    (rrtype "A" or "AAAA") into a response message, it SHOULD also place
                //    any records of the other address type with the same name into the
                //    additional section, if there is space in the message.
                const added = this.addAddressRecords(service, endpoint, 28 /* AAAA */, addAnswer);
                if (added) {
                    this.addAddressRecords(service, endpoint, 1 /* A */, addAdditional);
                }
                response.addAdditional(service.addressNSECRecord()); // always add the negative response, always assert dominance
            }
        }
        else if (service.getLowerCasedSubtypePTRs()) {
            if (askingAny || question.type === 12 /* PTR */) {
                const dnsLowerSubTypes = service.getLowerCasedSubtypePTRs();
                const index = dnsLowerSubTypes.indexOf(loweredQuestionName);
                if (index !== -1) { // we have a sub type for the question
                    const records = service.subtypePtrRecords();
                    const record = records[index];
                    assert_1.default(loweredQuestionName === record.name, "Question Name didn't match selected sub type ptr record!");
                    const added = response.addAnswer(record);
                    if (added) {
                        // RFC 6763 12.1: include additionals: srv, txt, a, aaaa
                        response.addAdditional(service.txtRecord(), service.srvRecord());
                        this.addAddressRecords(service, endpoint, 1 /* A */, addAdditional);
                        this.addAddressRecords(service, endpoint, 28 /* AAAA */, addAdditional);
                        response.addAdditional(service.serviceNSECRecord(), service.addressNSECRecord());
                    }
                }
            }
        }
        return response;
    }
    /**
     * This method is a helper method to reduce the complexity inside {@link answerServiceQuestion}.
     * The method calculates which A and AAAA records to be added for a given {@code endpoint} using
     * the records from the provided {@code service}.
     * It will add the records by calling the provided {@code dest} method.
     *
     * @param {CiaoService} service - service which records to be use
     * @param {EndpointInfo} endpoint - endpoint information providing the interface
     * @param {RType.A | RType.AAAA} type - defines the type of records to be added
     * @param {RecordAddMethod} dest - defines the destination which the records should be added
     * @returns true if any records got added
     */
    static addAddressRecords(service, endpoint, type, dest) {
        if (type === 1 /* A */) {
            const record = service.aRecord(endpoint.interface);
            return record ? dest(record) : false;
        }
        else if (type === 28 /* AAAA */) {
            const record = service.aaaaRecord(endpoint.interface);
            const routableRecord = service.aaaaRoutableRecord(endpoint.interface);
            const ulaRecord = service.aaaaUniqueLocalRecord(endpoint.interface);
            let addedAny = false;
            if (record) {
                addedAny = dest(record);
            }
            if (routableRecord) {
                const added = dest(routableRecord);
                addedAny = addedAny || added;
            }
            if (ulaRecord) {
                const added = dest(ulaRecord);
                addedAny = addedAny || added;
            }
            return addedAny;
        }
        else {
            assert_1.default.fail("Illegal argument!");
        }
    }
}
exports.Responder = Responder;
/**
 * @private
 */
Responder.SERVICE_TYPE_ENUMERATION_NAME = "_services._dns-sd._udp.local.";
Responder.INSTANCES = new Map();
//# sourceMappingURL=Responder.js.map

/***/ }),

/***/ 9814:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NonCompressionLabelCoder = exports.DNSLabelCoder = void 0;
const tslib_1 = __nccwpck_require__(4290);
const assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
class DNSLabelCoder {
    constructor(legacyUnicastEncoding) {
        this.trackedLengths = [];
        this.writtenNames = [];
        this.legacyUnicastEncoding = legacyUnicastEncoding || false;
    }
    initBuf(buffer) {
        this.buffer = buffer;
    }
    initRRLocation(recordOffset, rDataOffset, rDataLength) {
        this.startOfRR = recordOffset;
        this.startOfRData = rDataOffset;
        this.rDataLength = rDataLength;
    }
    clearRRLocation() {
        this.startOfRR = undefined;
        this.startOfRData = undefined;
        this.rDataLength = undefined;
    }
    getUncompressedNameLength(name) {
        if (name === ".") {
            return 1; // root label takes one zero byte
        }
        assert_1.default(name.endsWith("."), "Supplied illegal name which doesn't end with the root label!");
        let length = 0;
        const labels = name.split(".");
        for (let i = 0; i < labels.length; i++) {
            const label = labels[i];
            if (!label && i < labels.length - 1) {
                assert_1.default.fail("Label " + i + " in name '" + name + "' was empty");
            }
            length += DNSLabelCoder.getLabelLength(label);
        }
        return length;
    }
    getNameLength(name) {
        if (DNSLabelCoder.DISABLE_COMPRESSION) {
            return this.getUncompressedNameLength(name);
        }
        if (name === ".") {
            return 1; // root label takes one zero byte and is not compressible
        }
        assert_1.default(name.endsWith("."), "Supplied illegal name which doesn't end with the root label!");
        const labelLengths = name.split(".")
            .map(label => DNSLabelCoder.getLabelLength(label));
        const nameLength = {
            name: name,
            length: 0,
            labelLengths: labelLengths,
        };
        let candidateSharingLongestSuffix = undefined;
        let longestSuffixLength = 0; // amount of labels which are identical
        // pointers MUST only point to PRIOR label locations
        for (let i = 0; i < this.trackedLengths.length; i++) {
            const element = this.trackedLengths[i];
            const suffixLength = DNSLabelCoder.computeLabelSuffixLength(element.name, name);
            // it is very important that this is an GREATER and not just a GREATER EQUAL!!!!
            // don't change anything unless you fully understand all implications (0, and big comment block below)
            if (suffixLength > longestSuffixLength) {
                candidateSharingLongestSuffix = element;
                longestSuffixLength = suffixLength;
            }
        }
        let length = 0;
        if (candidateSharingLongestSuffix) {
            // in theory it is possible that the candidate has an pointer which "fromIndex" is smaller than the
            // the "toIndex" we are pointing to below. This could result in that we point to a location which
            // never gets written into the buffer, thus we can't point to it.
            // But as we always start in order (with the first element in our array; see for loop above)
            // we will always find the label first, which such a theoretical candidate is also pointing at
            const pointingFromIndex = labelLengths.length - 1 - longestSuffixLength; // -1 as the empty root label is always included
            for (let i = 0; i < pointingFromIndex; i++) {
                length += labelLengths[i];
            }
            length += 2; // 2 byte for the pointer
        }
        else {
            for (let i = 0; i < labelLengths.length; i++) {
                length += labelLengths[i];
            }
        }
        nameLength.length = length;
        this.trackedLengths.push(nameLength);
        return nameLength.length;
    }
    encodeUncompressedName(name, offset) {
        if (!this.buffer) {
            assert_1.default.fail("Illegal state. Buffer not initialized!");
        }
        return DNSLabelCoder.encodeUncompressedName(name, this.buffer, offset);
    }
    static encodeUncompressedName(name, buffer, offset) {
        assert_1.default(name.endsWith("."), "Name does not end with the root label");
        const oldOffset = offset;
        const labels = name === "."
            ? [""]
            : name.split(".");
        for (let i = 0; i < labels.length; i++) {
            const label = labels[i];
            if (label === "") {
                assert_1.default(i === labels.length - 1, "Encountered root label being not at the end of the domain name");
                buffer.writeUInt8(0, offset++); // write a terminating zero
                break;
            }
            // write length byte followed by the label data
            const length = buffer.write(label, offset + 1);
            buffer.writeUInt8(length, offset);
            offset += length + 1;
        }
        return offset - oldOffset; // written bytes
    }
    encodeName(name, offset) {
        if (DNSLabelCoder.DISABLE_COMPRESSION) {
            return this.encodeUncompressedName(name, offset);
        }
        if (!this.buffer) {
            assert_1.default.fail("Illegal state. Buffer not initialized!");
        }
        if (name === ".") {
            this.buffer.writeUInt8(0, offset); // write a terminating zero
            return 1;
        }
        const oldOffset = offset;
        const labels = name.split(".");
        const writtenName = {
            name: name,
            writtenLabels: new Array(labels.length).fill(-1),
        };
        let candidateSharingLongestSuffix = undefined;
        let longestSuffixLength = 0; // amount of labels which are identical
        for (let i = 0; i < this.writtenNames.length; i++) {
            const element = this.writtenNames[i];
            const suffixLength = DNSLabelCoder.computeLabelSuffixLength(element.name, name);
            // it is very important that this is an GREATER and not just a GREATER EQUAL!!!!
            // don't change anything unless you fully understand all implications (0, and big comment block below)
            if (suffixLength > longestSuffixLength) {
                candidateSharingLongestSuffix = element;
                longestSuffixLength = suffixLength;
            }
        }
        if (candidateSharingLongestSuffix) {
            // in theory it is possible that the candidate has an pointer which "fromIndex" is smaller than the
            // the "toIndex" we are pointing to below. This could result in that we point to a location which
            // never gets written into the buffer, thus we can't point to it.
            // But as we always start in order (with the first element in our array; see for loop above)
            // we will always find the label first, which such a theoretical candidate is also pointing at
            const pointingFromIndex = labels.length - 1 - longestSuffixLength; // -1 as the empty root label is always included
            const pointingToIndex = candidateSharingLongestSuffix.writtenLabels.length - 1 - longestSuffixLength;
            for (let i = 0; i < pointingFromIndex; i++) {
                writtenName.writtenLabels[i] = offset;
                offset += DNSLabelCoder.writeLabel(labels[i], this.buffer, offset);
            }
            const pointerDestination = candidateSharingLongestSuffix.writtenLabels[pointingToIndex];
            assert_1.default(pointerDestination !== -1, "Label which was pointed at wasn't yet written to the buffer!");
            assert_1.default(pointerDestination <= DNSLabelCoder.NOT_POINTER_MASK, "Pointer exceeds to length of a maximum of 14 bits");
            assert_1.default(pointerDestination < offset, "Pointer can only point to a prior location");
            const pointer = DNSLabelCoder.POINTER_MASK | pointerDestination;
            this.buffer.writeUInt16BE(pointer, offset);
            offset += 2;
        }
        else {
            for (let i = 0; i < labels.length; i++) {
                writtenName.writtenLabels[i] = offset;
                offset += DNSLabelCoder.writeLabel(labels[i], this.buffer, offset);
            }
        }
        this.writtenNames.push(writtenName);
        return offset - oldOffset; // written bytes
    }
    decodeName(offset, resolvePointers = true) {
        if (!this.buffer) {
            assert_1.default.fail("Illegal state. Buffer not initialized!");
        }
        const oldOffset = offset;
        let name = "";
        for (;;) {
            const length = this.buffer.readUInt8(offset++);
            if (length === 0) { // zero byte to terminate the name
                name += ".";
                break; // root label marks end of name
            }
            const labelTypePattern = length & DNSLabelCoder.POINTER_MASK_ONE_BYTE;
            if (labelTypePattern) {
                if (labelTypePattern === DNSLabelCoder.POINTER_MASK_ONE_BYTE) {
                    // we got a pointer here
                    const pointer = this.buffer.readUInt16BE(offset - 1) & DNSLabelCoder.NOT_POINTER_MASK; // extract the offset
                    offset++; // increment for the second byte of the pointer
                    if (!resolvePointers) {
                        name += name ? ".~" : "~";
                        break;
                    }
                    // if we would allow pointers to a later location, we MUST ensure that we don't end up in a endless loop
                    assert_1.default(pointer < oldOffset, "Pointer at " + (offset - 2) + " MUST point to a prior location!");
                    name += (name ? "." : "") + this.decodeName(pointer).data; // recursively decode the rest of the name
                    break; // pointer marks end of name
                }
                else if (labelTypePattern === DNSLabelCoder.LOCAL_COMPRESSION_ONE_BYTE) {
                    let localPointer = this.buffer.readUInt16BE(offset - 1) & DNSLabelCoder.NOT_POINTER_MASK;
                    offset++; // increment for the second byte of the pointer;
                    if (!resolvePointers) {
                        name += name ? ".~" : "~";
                        break;
                    }
                    if (localPointer >= 0 && localPointer < 255) { // 255 is reserved
                        assert_1.default(this.startOfRR !== undefined, "Cannot decompress locally compressed name as record is not initialized!");
                        localPointer += this.startOfRR;
                        assert_1.default(localPointer < oldOffset, "LocalPointer <255 at " + (offset - 2) + " MUST point to a prior location!");
                        name += (name ? "." : "") + this.decodeName(localPointer).data; // recursively decode the rest of the name
                    }
                    else if (localPointer >= 256) {
                        assert_1.default(this.startOfRData !== undefined && this.rDataLength !== undefined, "Cannot decompress locally compressed name as record is not initialized!");
                        localPointer -= -256; // subtract the offset 256
                        localPointer += this.startOfRData;
                        assert_1.default(localPointer < oldOffset, "LocationPoint >265 at " + (offset + 2) + " MUST point to a prior location!");
                        name += (name ? "." : "") + this.decodeName(localPointer).data; // recursively decode the rest of the name
                    }
                    else {
                        assert_1.default.fail("Encountered unknown pointer range " + localPointer);
                    }
                    break; // pointer marks end of name
                }
                else if (labelTypePattern === DNSLabelCoder.EXTENDED_LABEL_TYPE_ONE_BYTE) {
                    const extendedLabelType = length & DNSLabelCoder.NOT_POINTER_MASK_ONE_BYTE;
                    assert_1.default.fail("Received extended label type " + extendedLabelType + " at " + (offset - 1));
                }
                else {
                    assert_1.default.fail("Encountered unknown pointer type: " + Buffer.from([labelTypePattern >> 6]).toString("hex") + " (with original byte " +
                        Buffer.from([length]).toString("hex") + ")");
                }
            }
            const label = this.buffer.toString("utf-8", offset, offset + length);
            offset += length;
            name += (name ? "." : "") + label;
        }
        return {
            data: name,
            readBytes: offset - oldOffset,
        };
    }
    static getLabelLength(label) {
        if (!label) { // empty label aka root label
            return 1; // root label takes one zero byte
        }
        else {
            const byteLength = Buffer.byteLength(label);
            assert_1.default(byteLength <= 63, "Label cannot be longer than 63 bytes (" + label + ")");
            return 1 + byteLength; // length byte + label data
        }
    }
    static writeLabel(label, buffer, offset) {
        if (!label) {
            buffer.writeUInt8(0, offset);
            return 1;
        }
        else {
            const length = buffer.write(label, offset + 1);
            buffer.writeUInt8(length, offset);
            return length + 1;
        }
    }
    static computeLabelSuffixLength(a, b) {
        assert_1.default(a.length !== 0 && b.length !== 0, "Encountered empty name when comparing suffixes!");
        const lastAIndex = a.length - 1;
        const lastBIndex = b.length - 1;
        let equalLabels = 0;
        let exitByBreak = false;
        // we start with i=1 as the last character will always be the root label terminator "."
        for (let i = 1; i <= lastAIndex && i <= lastBIndex; i++) {
            // we are comparing both strings backwards
            const aChar = a.charAt(lastAIndex - i);
            const bChar = b.charAt(lastBIndex - i);
            assert_1.default(!!aChar && !!bChar, "Seemingly encountered out of bounds trying to calculate suffixes");
            if (aChar !== bChar) {
                exitByBreak = true;
                break; // encountered the first character to differ
            }
            else if (aChar === ".") {
                // we reached the label terminator, thus we count up the labels which are equal
                equalLabels++;
            }
        }
        if (!exitByBreak) {
            equalLabels++; // accommodate for the top level label (fqdn doesn't start with a dot)
        }
        return equalLabels;
    }
}
exports.DNSLabelCoder = DNSLabelCoder;
DNSLabelCoder.DISABLE_COMPRESSION = false;
// RFC 1035 4.1.4. Message compression:
//  In order to reduce the size of messages, the domain system utilizes a
//   compression scheme which eliminates the repetition of domain names in a
//   message.  In this scheme, an entire domain name or a list of labels at
//   the end of a domain name is replaced with a pointer to a PRIOR occurrence
//   of the same name.
//
//  The compression scheme allows a domain name in a message to be
//  represented as either:
//    - a sequence of labels ending in a zero octet
//    - a pointer
//    - a sequence of labels ending with a pointer
// RFC 6762 name compression for rdata should be used in: NS, CNAME, PTR, DNAME, SOA, MX, AFSDB, RT, KX, RP, PX, SRV, NSEC
DNSLabelCoder.POINTER_MASK = 0xC000; // 2 bytes, starting with 11
DNSLabelCoder.POINTER_MASK_ONE_BYTE = 0xC0; // same deal as above, just on a 1 byte level
DNSLabelCoder.LOCAL_COMPRESSION_ONE_BYTE = 0x80; // "10" label type https://tools.ietf.org/html/draft-ietf-dnsind-local-compression-05#section-4
DNSLabelCoder.EXTENDED_LABEL_TYPE_ONE_BYTE = 0x40; // "01" edns extended label type https://tools.ietf.org/html/rfc6891#section-4.2
DNSLabelCoder.NOT_POINTER_MASK = 0x3FFF;
DNSLabelCoder.NOT_POINTER_MASK_ONE_BYTE = 0x3F;
class NonCompressionLabelCoder extends DNSLabelCoder {
    getNameLength(name) {
        return this.getUncompressedNameLength(name);
    }
    encodeName(name, offset) {
        return this.encodeUncompressedName(name, offset);
    }
}
exports.NonCompressionLabelCoder = NonCompressionLabelCoder;
NonCompressionLabelCoder.INSTANCE = new NonCompressionLabelCoder();
//# sourceMappingURL=DNSLabelCoder.js.map

/***/ }),

/***/ 3646:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DNSPacket = exports.PacketType = exports.QClass = exports.RClass = exports.QType = exports.RType = exports.RCode = exports.OpCode = void 0;
const tslib_1 = __nccwpck_require__(4290);
const assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
const fast_deep_equal_1 = tslib_1.__importDefault(__nccwpck_require__(7689));
const dns_string_utils_1 = __nccwpck_require__(90);
const DNSLabelCoder_1 = __nccwpck_require__(9814);
const Question_1 = __nccwpck_require__(8505);
__nccwpck_require__(9273);
const ResourceRecord_1 = __nccwpck_require__(7761);
var OpCode;
(function (OpCode) {
    OpCode[OpCode["QUERY"] = 0] = "QUERY";
    // incomplete list
})(OpCode = exports.OpCode || (exports.OpCode = {}));
var RCode;
(function (RCode) {
    RCode[RCode["NoError"] = 0] = "NoError";
    // incomplete list
})(RCode = exports.RCode || (exports.RCode = {}));
var RType;
(function (RType) {
    RType[RType["A"] = 1] = "A";
    RType[RType["CNAME"] = 5] = "CNAME";
    RType[RType["PTR"] = 12] = "PTR";
    RType[RType["TXT"] = 16] = "TXT";
    RType[RType["AAAA"] = 28] = "AAAA";
    RType[RType["SRV"] = 33] = "SRV";
    RType[RType["OPT"] = 41] = "OPT";
    RType[RType["NSEC"] = 47] = "NSEC";
    // incomplete list
})(RType = exports.RType || (exports.RType = {}));
var QType;
(function (QType) {
    QType[QType["A"] = 1] = "A";
    QType[QType["CNAME"] = 5] = "CNAME";
    QType[QType["PTR"] = 12] = "PTR";
    QType[QType["TXT"] = 16] = "TXT";
    QType[QType["AAAA"] = 28] = "AAAA";
    QType[QType["SRV"] = 33] = "SRV";
    // OPT = 41, // RFC 6891
    QType[QType["NSEC"] = 47] = "NSEC";
    QType[QType["ANY"] = 255] = "ANY";
    // incomplete list
})(QType = exports.QType || (exports.QType = {}));
var RClass;
(function (RClass) {
    RClass[RClass["IN"] = 1] = "IN";
    // incomplete list
})(RClass = exports.RClass || (exports.RClass = {}));
var QClass;
(function (QClass) {
    QClass[QClass["IN"] = 1] = "IN";
    QClass[QClass["ANY"] = 255] = "ANY";
    // incomplete list
})(QClass = exports.QClass || (exports.QClass = {}));
var PacketType;
(function (PacketType) {
    PacketType[PacketType["QUERY"] = 0] = "QUERY";
    PacketType[PacketType["RESPONSE"] = 1] = "RESPONSE";
})(PacketType = exports.PacketType || (exports.PacketType = {}));
function isQuery(query) {
    return "answers" in query;
}
function isProbeQuery(query) {
    return "authorities" in query;
}
class DNSPacket {
    constructor(definition) {
        this.questions = new Map();
        this.answers = new Map();
        this.authorities = new Map();
        this.additionals = new Map();
        this.estimatedEncodingLength = 0; // upper bound for the resulting encoding length, should only be called via the getter
        this.lastCalculatedLength = 0;
        this.lengthDirty = true;
        this.id = definition.id || 0;
        this.legacyUnicastEncoding = definition.legacyUnicast || false;
        this.type = definition.type;
        this.opcode = definition.opcode || 0 /* QUERY */;
        this.flags = definition.flags || {};
        this.rcode = definition.rCode || 0 /* NoError */;
        if (this.type === 1 /* RESPONSE */) {
            this.flags.authoritativeAnswer = true; // RFC 6763 18.4 AA is always set for responses in mdns
        }
        if (definition.questions) {
            this.addQuestions(...definition.questions);
        }
        if (definition.answers) {
            this.addAnswers(...definition.answers);
        }
        if (definition.authorities) {
            this.addAuthorities(...definition.authorities);
        }
        if (definition.additionals) {
            this.addAdditionals(...definition.additionals);
        }
    }
    static createDNSQueryPacket(definition, udpPayloadSize = this.UDP_PAYLOAD_SIZE_IPV4) {
        const packets = this.createDNSQueryPackets(definition, udpPayloadSize);
        assert_1.default(packets.length === 1, "Cannot user short method createDNSQueryPacket when query packets are more than one: is " + packets.length);
        return packets[0];
    }
    static createDNSQueryPackets(definition, udpPayloadSize = this.UDP_PAYLOAD_SIZE_IPV4) {
        const packets = [];
        // packet is like the "main" packet
        const packet = new DNSPacket({
            type: 0 /* QUERY */,
            questions: definition.questions,
            additionals: isQuery(definition) ? definition.additionals : undefined,
        });
        packets.push(packet);
        if (packet.getEstimatedEncodingLength() > udpPayloadSize) {
            const compressedLength = packet.getEncodingLength(); // calculating the real length will update the estimated property as well
            if (compressedLength > udpPayloadSize) {
                // if we are still above the payload size we have a problem
                assert_1.default.fail("Cannot send query where already the query section is exceeding the udpPayloadSize (" + compressedLength + ">" + udpPayloadSize + ")!");
            }
        }
        // related https://en.wikipedia.org/wiki/Knapsack_problem
        if (isQuery(definition) && definition.answers) {
            let currentPacket = packet;
            let i = 0;
            const answers = definition.answers.concat([]); // concat basically creates a copy of the array
            // sort the answers ascending on their encoding length; otherwise we would need to check if a packets fits in a previously created packet
            answers.sort((a, b) => {
                return a.getEncodingLength(DNSLabelCoder_1.NonCompressionLabelCoder.INSTANCE) - b.getEncodingLength(DNSLabelCoder_1.NonCompressionLabelCoder.INSTANCE);
            });
            // in the loop below, we check if we need to truncate the list of known-answers in the query
            while (i < answers.length) {
                for (; i < answers.length; i++) {
                    const answer = answers[i];
                    const estimatedSize = answer.getEncodingLength(DNSLabelCoder_1.NonCompressionLabelCoder.INSTANCE);
                    if (packet.getEstimatedEncodingLength() + estimatedSize <= udpPayloadSize) { // size check on estimated calculations
                        currentPacket.addAnswers(answer);
                    }
                    else if (packet.getEncodingLength() + estimatedSize <= udpPayloadSize) { // check if the record may fit when message compression is used.
                        // we may still have a false positive here, as the currently can't compute the REAL encoding for the answer
                        // record, thus we rely on the estimated size
                        currentPacket.addAnswers(answer);
                    }
                    else {
                        if (currentPacket.questions.size === 0 && currentPacket.answers.size === 0) {
                            // we encountered a record which is to big and can't fit in a udpPayloadSize sized packet
                            // RFC 6762 17. In the case of a single Multicast DNS resource record that is too
                            //    large to fit in a single MTU-sized multicast response packet, a
                            //    Multicast DNS responder SHOULD send the resource record alone, in a
                            //    single IP datagram, using multiple IP fragments.
                            packet.addAnswers(answer);
                        }
                        break;
                    }
                }
                if (i < answers.length) { // if there are more records left, we need to truncate the packet again
                    currentPacket.flags.truncation = true; // first of all, mark the previous packet as truncated
                    currentPacket = new DNSPacket({ type: 0 /* QUERY */ });
                    packets.push(currentPacket);
                }
            }
        }
        else if (isProbeQuery(definition) && definition.authorities) {
            packet.addAuthorities(...definition.authorities);
            const compressedLength = packet.getEncodingLength();
            if (compressedLength > udpPayloadSize) {
                assert_1.default.fail(`Probe query packet exceeds the mtu size (${compressedLength}>${udpPayloadSize}). Can't split probe queries at the moment!`);
            }
        } // otherwise, the packet consist of only questions
        return packets;
    }
    static createDNSResponsePacketsFromRRSet(definition, udpPayloadSize = this.UDP_PAYLOAD_SIZE_IPV4) {
        const packet = new DNSPacket({
            id: definition.id,
            legacyUnicast: definition.legacyUnicast,
            type: 1 /* RESPONSE */,
            flags: { authoritativeAnswer: true },
            // possible questions sent back to an unicast querier (unicast dns contain only one question, so no size problem here)
            questions: definition.questions,
            answers: definition.answers,
            additionals: definition.additionals,
        });
        if (packet.getEncodingLength() > udpPayloadSize) {
            assert_1.default.fail("Couldn't construct a dns response packet from a rr set which fits in an udp payload sized packet!");
        }
        return packet;
    }
    canBeCombinedWith(packet, udpPayloadSize = DNSPacket.UDP_PAYLOAD_SIZE_IPV4) {
        // packet header must be identical
        return this.id === packet.id && this.type === packet.type
            && this.opcode === packet.opcode && fast_deep_equal_1.default(this.flags, packet.flags)
            && this.rcode === packet.rcode
            // and the data must fit into a udpPayloadSize sized packet
            && this.getEncodingLength() + packet.getEncodingLength() <= udpPayloadSize;
    }
    combineWith(packet) {
        this.setLegacyUnicastEncoding(this.legacyUnicastEncoding || packet.legacyUnicastEncoding);
        this.addRecords(this.questions, packet.questions.values());
        this.addRecords(this.answers, packet.answers.values(), this.additionals);
        this.addRecords(this.authorities, packet.authorities.values());
        this.addRecords(this.additionals, packet.additionals.values());
    }
    addQuestions(...questions) {
        return this.addRecords(this.questions, questions);
    }
    addAnswers(...answers) {
        return this.addRecords(this.answers, answers, this.additionals);
    }
    addAuthorities(...authorities) {
        return this.addRecords(this.authorities, authorities);
    }
    addAdditionals(...additionals) {
        return this.addRecords(this.additionals, additionals);
    }
    addRecords(recordList, added, removeFromWhenAdded) {
        let addedAny = false;
        for (const record of added) {
            if (recordList.has(record.asString())) {
                continue;
            }
            if (this.estimatedEncodingLength) {
                this.estimatedEncodingLength += record.getEncodingLength(DNSLabelCoder_1.NonCompressionLabelCoder.INSTANCE);
            }
            recordList.set(record.asString(), record);
            addedAny = true;
            this.lengthDirty = true;
            if (removeFromWhenAdded) {
                removeFromWhenAdded.delete(record.asString());
            }
        }
        return addedAny;
    }
    setLegacyUnicastEncoding(legacyUnicastEncoding) {
        if (this.legacyUnicastEncoding !== legacyUnicastEncoding) {
            this.lengthDirty = true; // above option changes length of SRV records
        }
        this.legacyUnicastEncoding = legacyUnicastEncoding;
    }
    legacyUnicastEncodingEnabled() {
        return this.legacyUnicastEncoding;
    }
    getEstimatedEncodingLength() {
        if (this.estimatedEncodingLength) {
            return this.estimatedEncodingLength;
        }
        const labelCoder = DNSLabelCoder_1.NonCompressionLabelCoder.INSTANCE;
        let length = DNSPacket.DNS_PACKET_HEADER_SIZE;
        for (const record of this.questions.values()) {
            length += record.getEncodingLength(labelCoder);
        }
        for (const record of this.answers.values()) {
            length += record.getEncodingLength(labelCoder);
        }
        for (const record of this.authorities.values()) {
            length += record.getEncodingLength(labelCoder);
        }
        for (const record of this.additionals.values()) {
            length += record.getEncodingLength(labelCoder);
        }
        this.estimatedEncodingLength = length;
        return length;
    }
    getEncodingLength(coder) {
        if (!this.lengthDirty) {
            return this.lastCalculatedLength;
        }
        const labelCoder = coder || new DNSLabelCoder_1.DNSLabelCoder(this.legacyUnicastEncoding);
        let length = DNSPacket.DNS_PACKET_HEADER_SIZE;
        for (const record of this.questions.values()) {
            length += record.getEncodingLength(labelCoder);
        }
        for (const record of this.answers.values()) {
            length += record.getEncodingLength(labelCoder);
        }
        for (const record of this.authorities.values()) {
            length += record.getEncodingLength(labelCoder);
        }
        for (const record of this.additionals.values()) {
            length += record.getEncodingLength(labelCoder);
        }
        this.lengthDirty = false; // reset dirty flag
        this.lastCalculatedLength = length;
        this.estimatedEncodingLength = length;
        return length;
    }
    encode() {
        const labelCoder = new DNSLabelCoder_1.DNSLabelCoder(this.legacyUnicastEncoding);
        const length = this.getEncodingLength(labelCoder);
        const buffer = Buffer.allocUnsafe(length);
        labelCoder.initBuf(buffer);
        let offset = 0;
        buffer.writeUInt16BE(this.id, offset);
        offset += 2;
        let flags = (this.type << 15) | (this.opcode << 11) | this.rcode;
        if (this.flags.authoritativeAnswer) {
            flags |= DNSPacket.AUTHORITATIVE_ANSWER_MASK;
        }
        if (this.flags.truncation) {
            flags |= DNSPacket.TRUNCATION_MASK;
        }
        if (this.flags.recursionDesired) {
            flags |= DNSPacket.RECURSION_DESIRED_MASK;
        }
        if (this.flags.recursionAvailable) {
            flags |= DNSPacket.RECURSION_AVAILABLE_MASK;
        }
        if (this.flags.zero) {
            flags |= DNSPacket.ZERO_HEADER_MASK;
        }
        if (this.flags.authenticData) {
            flags |= DNSPacket.AUTHENTIC_DATA_MASK;
        }
        if (this.flags.checkingDisabled) {
            flags |= DNSPacket.CHECKING_DISABLED_MASK;
        }
        buffer.writeUInt16BE(flags, offset);
        offset += 2;
        buffer.writeUInt16BE(this.questions.size, offset);
        offset += 2;
        buffer.writeUInt16BE(this.answers.size, offset);
        offset += 2;
        buffer.writeUInt16BE(this.authorities.size, offset);
        offset += 2;
        buffer.writeUInt16BE(this.additionals.size, offset);
        offset += 2;
        for (const question of this.questions.values()) {
            const length = question.encode(labelCoder, buffer, offset);
            offset += length;
        }
        for (const record of this.answers.values()) {
            const length = record.encode(labelCoder, buffer, offset);
            offset += length;
        }
        for (const record of this.authorities.values()) {
            const length = record.encode(labelCoder, buffer, offset);
            offset += length;
        }
        for (const record of this.additionals.values()) {
            const length = record.encode(labelCoder, buffer, offset);
            offset += length;
        }
        assert_1.default(offset === buffer.length, "Bytes written didn't match the buffer size!");
        return buffer;
    }
    static decode(context, buffer, offset = 0) {
        const labelCoder = new DNSLabelCoder_1.DNSLabelCoder();
        labelCoder.initBuf(buffer);
        const id = buffer.readUInt16BE(offset);
        offset += 2;
        const flags = buffer.readUInt16BE(offset);
        offset += 2;
        const questionLength = buffer.readUInt16BE(offset);
        offset += 2;
        const answerLength = buffer.readUInt16BE(offset);
        offset += 2;
        const authoritiesLength = buffer.readUInt16BE(offset);
        offset += 2;
        const additionalsLength = buffer.readUInt16BE(offset);
        offset += 2;
        const questions = [];
        const answers = [];
        const authorities = [];
        const additionals = [];
        offset += DNSPacket.decodeList(context, labelCoder, buffer, offset, questionLength, Question_1.Question.decode.bind(Question_1.Question), questions);
        offset += DNSPacket.decodeList(context, labelCoder, buffer, offset, answerLength, ResourceRecord_1.ResourceRecord.decode.bind(ResourceRecord_1.ResourceRecord), answers);
        offset += DNSPacket.decodeList(context, labelCoder, buffer, offset, authoritiesLength, ResourceRecord_1.ResourceRecord.decode.bind(ResourceRecord_1.ResourceRecord), authorities);
        offset += DNSPacket.decodeList(context, labelCoder, buffer, offset, additionalsLength, ResourceRecord_1.ResourceRecord.decode.bind(ResourceRecord_1.ResourceRecord), additionals);
        assert_1.default(offset === buffer.length, "Didn't read the full buffer (offset=" + offset + ", length=" + buffer.length + ")");
        const qr = (flags >> 15);
        const opcode = ((flags >> 11) & 0xf);
        const rCode = (flags & 0xf);
        const packetFlags = {};
        if (flags & this.AUTHORITATIVE_ANSWER_MASK) {
            packetFlags.authoritativeAnswer = true;
        }
        if (flags & this.TRUNCATION_MASK) {
            packetFlags.truncation = true;
        }
        if (flags & this.RECURSION_DESIRED_MASK) {
            packetFlags.recursionDesired = true;
        }
        if (flags & this.RECURSION_AVAILABLE_MASK) {
            packetFlags.recursionAvailable = true;
        }
        if (flags & this.ZERO_HEADER_MASK) {
            packetFlags.zero = true;
        }
        if (flags & this.AUTHENTIC_DATA_MASK) {
            packetFlags.authenticData = true;
        }
        if (flags & this.CHECKING_DISABLED_MASK) {
            packetFlags.checkingDisabled = true;
        }
        return new DNSPacket({
            id: id,
            type: qr,
            opcode: opcode,
            rCode: rCode,
            flags: packetFlags,
            questions: questions,
            answers: answers,
            authorities: authorities,
            additionals: additionals,
        });
    }
    static decodeList(context, coder, buffer, offset, length, decoder, destination) {
        const oldOffset = offset;
        for (let i = 0; i < length; i++) {
            const decoded = decoder(context, coder, buffer, offset);
            offset += decoded.readBytes;
            if (decoded.data) { // if the rdata is not supported by us or we encountered an parsing error, we ignore the record
                destination.push(decoded.data);
            }
        }
        return offset - oldOffset;
    }
    asLoggingString(udpPayloadSize) {
        let answerString = "";
        let additionalsString = "";
        for (const record of this.answers.values()) {
            if (answerString) {
                answerString += ",";
            }
            answerString += dns_string_utils_1.dnsTypeToString(record.type);
        }
        for (const record of this.additionals.values()) {
            if (additionalsString) {
                additionalsString += ",";
            }
            additionalsString += dns_string_utils_1.dnsTypeToString(record.type);
        }
        const optionsStrings = [];
        if (this.legacyUnicastEncodingEnabled()) {
            optionsStrings.push("U");
        }
        if (udpPayloadSize) {
            optionsStrings.push("UPS: " + udpPayloadSize);
        }
        const optionsString = optionsStrings.length !== 0 ? ` (${optionsStrings})` : "";
        return `[${answerString}] answers and [${additionalsString}] additionals with size ${this.getEncodingLength()}B${optionsString}`;
    }
}
exports.DNSPacket = DNSPacket;
DNSPacket.UDP_PAYLOAD_SIZE_IPV4 = (process.env.CIAO_UPS ? parseInt(process.env.CIAO_UPS) : 1440);
// noinspection JSUnusedGlobalSymbols
DNSPacket.UDP_PAYLOAD_SIZE_IPV6 = (process.env.CIAO_UPS ? parseInt(process.env.CIAO_UPS) : 1440);
DNSPacket.AUTHORITATIVE_ANSWER_MASK = 0x400;
DNSPacket.TRUNCATION_MASK = 0x200;
DNSPacket.RECURSION_DESIRED_MASK = 0x100;
DNSPacket.RECURSION_AVAILABLE_MASK = 0x80;
DNSPacket.ZERO_HEADER_MASK = 0x40;
DNSPacket.AUTHENTIC_DATA_MASK = 0x20;
DNSPacket.CHECKING_DISABLED_MASK = 0x10;
// 2 bytes ID, 2 bytes flags, 2 bytes question count, 2 bytes answer count, 2 bytes authorities count; 2 bytes additionals count
DNSPacket.DNS_PACKET_HEADER_SIZE = 12;
//# sourceMappingURL=DNSPacket.js.map

/***/ }),

/***/ 8505:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Question = void 0;
const dns_equal_1 = __nccwpck_require__(7338);
class Question {
    constructor(name, type, unicastResponseFlag = false, clazz = 1 /* IN */) {
        this.unicastResponseFlag = false;
        if (!name.endsWith(".")) {
            name += ".";
        }
        this.name = name;
        this.type = type;
        this.class = clazz;
        this.unicastResponseFlag = unicastResponseFlag;
    }
    getLowerCasedName() {
        return this.lowerCasedName || (this.lowerCasedName = dns_equal_1.dnsLowerCase(this.name));
    }
    getEncodingLength(coder) {
        return coder.getNameLength(this.name) + 4; // 2 bytes type; 2 bytes class
    }
    encode(coder, buffer, offset) {
        const oldOffset = offset;
        const nameLength = coder.encodeName(this.name, offset);
        offset += nameLength;
        buffer.writeUInt16BE(this.type, offset);
        offset += 2;
        let qClass = this.class;
        if (this.unicastResponseFlag) {
            qClass |= Question.QU_MASK;
        }
        buffer.writeUInt16BE(qClass, offset);
        offset += 2;
        return offset - oldOffset; // written bytes
    }
    clone() {
        return new Question(this.name, this.type, this.unicastResponseFlag, this.class);
    }
    asString() {
        return `Q ${this.name} ${this.type} ${this.class}`;
    }
    static decode(context, coder, buffer, offset) {
        const oldOffset = offset;
        const decodedName = coder.decodeName(offset);
        offset += decodedName.readBytes;
        const type = buffer.readUInt16BE(offset);
        offset += 2;
        const qClass = buffer.readUInt16BE(offset);
        offset += 2;
        const clazz = (qClass & this.NOT_QU_MASK);
        const quFlag = !!(qClass & this.QU_MASK);
        const question = new Question(decodedName.data, type, quFlag, clazz);
        return {
            data: question,
            readBytes: offset - oldOffset,
        };
    }
}
exports.Question = Question;
Question.QU_MASK = 0x8000; // 2 bytes, first bit set
Question.NOT_QU_MASK = 0x7FFF;
//# sourceMappingURL=Question.js.map

/***/ }),

/***/ 7761:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ResourceRecord = void 0;
const tslib_1 = __nccwpck_require__(4290);
const assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
const debug_1 = tslib_1.__importDefault(__nccwpck_require__(7984));
const dns_equal_1 = __nccwpck_require__(7338);
const dns_string_utils_1 = __nccwpck_require__(90);
const DNSLabelCoder_1 = __nccwpck_require__(9814);
const debug = debug_1.default("ciao:decoder");
class ResourceRecord {
    constructor(name, type, ttl = ResourceRecord.RR_DEFAULT_TTL, flushFlag = false, clazz = 1 /* IN */) {
        this.flushFlag = false;
        if (typeof name === "string") {
            if (!name.endsWith(".")) {
                name = name + ".";
            }
            this.name = name;
            this.type = type;
            this.class = clazz;
            this.ttl = ttl;
            this.flushFlag = flushFlag;
        }
        else {
            this.name = name.name;
            this.type = name.type;
            this.class = name.class;
            this.ttl = name.ttl;
            this.flushFlag = name.flushFlag;
        }
    }
    getLowerCasedName() {
        return this.lowerCasedName || (this.lowerCasedName = dns_equal_1.dnsLowerCase(this.name));
    }
    getEncodingLength(coder) {
        return coder.getNameLength(this.name)
            + 10 // 2 bytes TYPE; 2 bytes class, 4 bytes TTL, 2 bytes RDLength
            + this.getRDataEncodingLength(coder);
    }
    encode(coder, buffer, offset) {
        const oldOffset = offset;
        const nameLength = coder.encodeName(this.name, offset);
        offset += nameLength;
        buffer.writeUInt16BE(this.type, offset);
        offset += 2;
        let rClass = this.class;
        if (this.flushFlag) {
            // for pseudo records like OPT, TSIG, TKEY, SIG0 the top bit should not be interpreted as the flush flag
            // though we do not support those (OPT seems to be the only used, though no idea for what [by Apple for mdns])
            rClass |= ResourceRecord.FLUSH_MASK;
        }
        buffer.writeUInt16BE(rClass, offset);
        offset += 2;
        buffer.writeUInt32BE(this.ttl, offset);
        offset += 4;
        const dataLength = this.encodeRData(coder, buffer, offset + 2);
        buffer.writeUInt16BE(dataLength, offset);
        offset += 2 + dataLength;
        return offset - oldOffset; // written bytes
    }
    getRawData() {
        const coder = DNSLabelCoder_1.NonCompressionLabelCoder.INSTANCE; // this forces uncompressed names
        const length = this.getRDataEncodingLength(coder);
        const buffer = Buffer.allocUnsafe(length);
        coder.initBuf(buffer);
        const writtenBytes = this.encodeRData(coder, buffer, 0);
        assert_1.default(writtenBytes === buffer.length, "Didn't completely write to the buffer! (" + writtenBytes + "!=" + buffer.length + ")");
        coder.initBuf(); // reset buffer to undefined
        return buffer;
    }
    static clone(records) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        return records.map(record => record.clone());
    }
    getRecordRepresentation() {
        return {
            name: this.name,
            type: this.type,
            class: this.class,
            ttl: this.ttl,
            flushFlag: this.flushFlag,
        };
    }
    /**
     * Returns if the this and the supplied record are the same (ignoring ttl and flush flag)
     * @param record
     */
    aboutEqual(record) {
        return this.type === record.type && this.name === record.name && this.class === record.class
            && this.dataEquals(record);
    }
    representsSameData(record) {
        return this.type === record.type && this.name === record.name && this.class === record.class;
    }
    asString() {
        // same as aboutEqual, ttl is not included
        return `RR ${this.name} ${this.type} ${this.class} ${this.dataAsString()}`;
    }
    static decode(context, coder, buffer, offset) {
        const oldOffset = offset;
        const decodedHeader = this.decodeRecordHeader(coder, buffer, offset);
        offset += decodedHeader.readBytes;
        const header = decodedHeader.data;
        const rrDecoder = this.typeToRecordDecoder.get(header.type);
        if (!rrDecoder) {
            return { readBytes: (offset + header.rDataLength) - oldOffset };
        }
        coder.initRRLocation(oldOffset, offset, header.rDataLength); // defines record offset and rdata offset for local compression
        const rdata = buffer.slice(0, offset + header.rDataLength);
        let decodedRecord;
        try {
            // we slice the buffer (below), so out of bounds error are instantly detected
            decodedRecord = rrDecoder(coder, header, rdata, offset);
        }
        catch (error) {
            debug(`Received malformed rdata section for ${dns_string_utils_1.dnsTypeToString(header.type)} ${header.name} ${header.ttl} \
from ${context.address}:${context.port} with data '${rdata.slice(offset).toString("hex")}': ${error.stack}`);
            return { readBytes: (offset + header.rDataLength) - oldOffset };
        }
        offset += decodedRecord.readBytes;
        coder.clearRRLocation();
        return {
            data: decodedRecord.data,
            readBytes: offset - oldOffset,
        };
    }
    static decodeRecordHeader(coder, buffer, offset) {
        const oldOffset = offset;
        const decodedName = coder.decodeName(offset);
        offset += decodedName.readBytes;
        const type = buffer.readUInt16BE(offset);
        offset += 2;
        const rClass = buffer.readUInt16BE(offset);
        offset += 2;
        let clazz;
        let flushFlag = false;
        if (type !== 41 /* OPT */) {
            clazz = (rClass & this.NOT_FLUSH_MASK);
            flushFlag = !!(rClass & this.FLUSH_MASK);
        }
        else {
            // OPT class field encodes udpPayloadSize field
            clazz = rClass;
        }
        const ttl = buffer.readUInt32BE(offset);
        offset += 4;
        const rDataLength = buffer.readUInt16BE(offset);
        offset += 2;
        const rHeader = {
            name: decodedName.data,
            type: type,
            class: clazz,
            ttl: ttl,
            flushFlag: flushFlag,
            rDataLength: rDataLength,
        };
        return {
            data: rHeader,
            readBytes: offset - oldOffset,
        };
    }
}
exports.ResourceRecord = ResourceRecord;
ResourceRecord.typeToRecordDecoder = new Map();
ResourceRecord.FLUSH_MASK = 0x8000; // 2 bytes, first bit set
ResourceRecord.NOT_FLUSH_MASK = 0x7FFF;
ResourceRecord.RR_DEFAULT_TTL_SHORT = 120; // 120 seconds
ResourceRecord.RR_DEFAULT_TTL = 4500; // 75 minutes
//# sourceMappingURL=ResourceRecord.js.map

/***/ }),

/***/ 90:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dnsTypeToString = void 0;
function dnsTypeToString(type) {
    switch (type) {
        case 1:
            return "A";
        case 5:
            return "CNAME";
        case 12:
            return "PTR";
        case 16:
            return "TXT";
        case 28:
            return "AAAA";
        case 33:
            return "SRV";
        case 41:
            return "OPT";
        case 47:
            return "NSEC";
        case 255:
            return "ANY";
    }
    return "UNSUPPORTED_" + type;
}
exports.dnsTypeToString = dnsTypeToString;
//# sourceMappingURL=dns-string-utils.js.map

/***/ }),

/***/ 8584:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AAAARecord = void 0;
const tslib_1 = __nccwpck_require__(4290);
const assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
const net_1 = tslib_1.__importDefault(__nccwpck_require__(1631));
const domain_formatter_1 = __nccwpck_require__(9783);
const ResourceRecord_1 = __nccwpck_require__(7761);
class AAAARecord extends ResourceRecord_1.ResourceRecord {
    constructor(name, ipAddress, flushFlag, ttl) {
        if (typeof name === "string") {
            super(name, 28 /* AAAA */, ttl || AAAARecord.RR_DEFAULT_TTL_SHORT, flushFlag);
        }
        else {
            assert_1.default(name.type === 28 /* AAAA */);
            super(name);
        }
        assert_1.default(net_1.default.isIPv6(ipAddress), "IP address is not in v6 format!");
        this.ipAddress = ipAddress;
    }
    getRDataEncodingLength() {
        return 16; // 16 byte ipv6 address
    }
    encodeRData(coder, buffer, offset) {
        const oldOffset = offset;
        const address = domain_formatter_1.enlargeIPv6(this.ipAddress);
        const bytes = address.split(":");
        assert_1.default(bytes.length === 8, "invalid ip address");
        for (const byte of bytes) {
            const number = parseInt(byte, 16);
            buffer.writeUInt16BE(number, offset);
            offset += 2;
        }
        return offset - oldOffset; // written bytes
    }
    static decodeData(coder, header, buffer, offset) {
        const oldOffset = offset;
        const ipBytes = new Array(8);
        for (let i = 0; i < 8; i++) {
            const number = buffer.readUInt16BE(offset);
            offset += 2;
            ipBytes[i] = number.toString(16);
        }
        const ipAddress = domain_formatter_1.shortenIPv6(ipBytes.join(":"));
        return {
            data: new AAAARecord(header, ipAddress),
            readBytes: offset - oldOffset,
        };
    }
    clone() {
        return new AAAARecord(this.getRecordRepresentation(), this.ipAddress);
    }
    dataAsString() {
        return this.ipAddress;
    }
    dataEquals(record) {
        return this.ipAddress === record.ipAddress;
    }
}
exports.AAAARecord = AAAARecord;
AAAARecord.DEFAULT_TTL = 120;
//# sourceMappingURL=AAAARecord.js.map

/***/ }),

/***/ 1540:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ARecord = void 0;
const tslib_1 = __nccwpck_require__(4290);
const assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
const net_1 = tslib_1.__importDefault(__nccwpck_require__(1631));
const ResourceRecord_1 = __nccwpck_require__(7761);
class ARecord extends ResourceRecord_1.ResourceRecord {
    constructor(name, ipAddress, flushFlag, ttl) {
        if (typeof name === "string") {
            super(name, 1 /* A */, ttl || ARecord.RR_DEFAULT_TTL_SHORT, flushFlag);
        }
        else {
            assert_1.default(name.type === 1 /* A */);
            super(name);
        }
        assert_1.default(net_1.default.isIPv4(ipAddress), "IP address is not in v4 format!");
        this.ipAddress = ipAddress;
    }
    getRDataEncodingLength() {
        return 4; // 4 byte ipv4 address
    }
    encodeRData(coder, buffer, offset) {
        const oldOffset = offset;
        const bytes = this.ipAddress.split(".");
        assert_1.default(bytes.length === 4, "invalid ip address");
        for (const byte of bytes) {
            const number = parseInt(byte, 10);
            buffer.writeUInt8(number, offset++);
        }
        return offset - oldOffset; // written bytes
    }
    static decodeData(coder, header, buffer, offset) {
        const oldOffset = offset;
        const ipBytes = new Array(4);
        for (let i = 0; i < 4; i++) {
            const byte = buffer.readUInt8(offset++);
            ipBytes[i] = byte.toString(10);
        }
        const ipAddress = ipBytes.join(".");
        return {
            data: new ARecord(header, ipAddress),
            readBytes: offset - oldOffset,
        };
    }
    clone() {
        return new ARecord(this.getRecordRepresentation(), this.ipAddress);
    }
    dataAsString() {
        return this.ipAddress;
    }
    dataEquals(record) {
        return this.ipAddress === record.ipAddress;
    }
}
exports.ARecord = ARecord;
ARecord.DEFAULT_TTL = 120;
//# sourceMappingURL=ARecord.js.map

/***/ }),

/***/ 9981:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CNAMERecord = void 0;
const tslib_1 = __nccwpck_require__(4290);
const assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
const dns_equal_1 = __nccwpck_require__(7338);
const ResourceRecord_1 = __nccwpck_require__(7761);
class CNAMERecord extends ResourceRecord_1.ResourceRecord {
    constructor(name, cname, flushFlag, ttl) {
        if (typeof name === "string") {
            super(name, 5 /* CNAME */, ttl, flushFlag);
        }
        else {
            assert_1.default(name.type === 5 /* CNAME */);
            super(name);
        }
        if (!cname.endsWith(".")) {
            cname += ".";
        }
        this.cname = cname;
    }
    getLowerCasedCName() {
        return this.lowerCasedCName || (this.lowerCasedCName = dns_equal_1.dnsLowerCase(this.cname));
    }
    getRDataEncodingLength(coder) {
        return coder.getNameLength(this.cname);
    }
    encodeRData(coder, buffer, offset) {
        const oldOffset = offset;
        const cnameLength = coder.encodeName(this.cname, offset);
        offset += cnameLength;
        return offset - oldOffset; // written bytes
    }
    static decodeData(coder, header, buffer, offset) {
        const oldOffset = offset;
        const decodedName = coder.decodeName(offset);
        offset += decodedName.readBytes;
        return {
            data: new CNAMERecord(header, decodedName.data),
            readBytes: offset - oldOffset,
        };
    }
    clone() {
        return new CNAMERecord(this.getRecordRepresentation(), this.cname);
    }
    dataAsString() {
        return this.cname;
    }
    dataEquals(record) {
        return this.getLowerCasedCName() === record.getLowerCasedCName();
    }
}
exports.CNAMERecord = CNAMERecord;
CNAMERecord.DEFAULT_TTL = ResourceRecord_1.ResourceRecord.RR_DEFAULT_TTL;
//# sourceMappingURL=CNAMERecord.js.map

/***/ }),

/***/ 2991:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NSECRecord = void 0;
const tslib_1 = __nccwpck_require__(4290);
const assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
const fast_deep_equal_1 = tslib_1.__importDefault(__nccwpck_require__(7689));
const dns_equal_1 = __nccwpck_require__(7338);
const ResourceRecord_1 = __nccwpck_require__(7761);
class NSECRecord extends ResourceRecord_1.ResourceRecord {
    constructor(name, nextDomainName, rrtypes, ttl, flushFlag) {
        if (typeof name === "string") {
            super(name, 47 /* NSEC */, ttl || NSECRecord.RR_DEFAULT_TTL_SHORT, flushFlag);
        }
        else {
            assert_1.default(name.type === 47 /* NSEC */);
            super(name);
        }
        if (!nextDomainName.endsWith(".")) {
            nextDomainName += ".";
        }
        this.nextDomainName = nextDomainName;
        this.rrTypeWindows = NSECRecord.rrTypesToWindowMap(rrtypes);
    }
    getLowerCasedNextDomainName() {
        return this.lowerCasedNextDomainName || (this.lowerCasedNextDomainName = dns_equal_1.dnsLowerCase(this.nextDomainName));
    }
    getRRTypesBitMapEncodingLength() {
        let rrTypesBitMapLength = 0;
        for (const window of this.rrTypeWindows) {
            assert_1.default(window.rrtypes.length > 0, "types array for windowId " + window.windowId + " cannot be empty!");
            rrTypesBitMapLength += 2 // 1 byte for windowId; 1 byte for bitmap length
                + window.bitMapSize;
        }
        return rrTypesBitMapLength;
    }
    getRDataEncodingLength(coder) {
        // RFC 4034 4.1.1. name compression MUST NOT be used for the nextDomainName, though RFC 6762 18.14 specifies it should
        return (coder.legacyUnicastEncoding
            ? coder.getUncompressedNameLength(this.nextDomainName)
            : coder.getUncompressedNameLength(this.nextDomainName)) // we skip compression for NSEC records for now, as Ubiquiti mdns forward can't handle that
            + this.getRRTypesBitMapEncodingLength();
    }
    encodeRData(coder, buffer, offset) {
        const oldOffset = offset;
        const length = coder.legacyUnicastEncoding
            ? coder.encodeUncompressedName(this.nextDomainName, offset)
            : coder.encodeUncompressedName(this.nextDomainName, offset); // we skip compression for NSEC records for now, as Ubiquiti mdns forward can't handle that
        offset += length;
        // RFC 4034 4.1.2. type bit maps field has the following format ( Window Block # | Bitmap Length | Bitmap )+ (with | concatenation)
        // e.g. 0x00 0x01 0x40 => defines the window 0; bitmap length 1; and the bitmap 10000000, meaning the first bit is
        // set for the 0th window => rrTypes = [A]. The bitmap length depends on the rtype with the highest value for the
        // given value (max 32 bytes per bitmap)
        for (const window of this.rrTypeWindows) {
            buffer.writeUInt8(window.windowId, offset++);
            buffer.writeUInt8(window.bitMapSize, offset++);
            const bitmap = Buffer.alloc(window.bitMapSize);
            for (const type of window.rrtypes) {
                const byteNum = (type & 0xFF) >> 3; // basically floored division by 8
                let mask = bitmap.readUInt8(byteNum);
                mask |= 1 << (7 - (type & 0x7)); // OR with 1 shifted according to the lowest 3 bits
                bitmap.writeUInt8(mask, byteNum);
            }
            bitmap.copy(buffer, offset);
            offset += bitmap.length;
        }
        return offset - oldOffset;
    }
    static decodeData(coder, header, buffer, offset) {
        const oldOffset = offset;
        /**
         * Quick note to the line below. We base "false" as the second argument to decodeName, telling
         * it to not resolve pointers.
         * We discovered that especially UniFi routers with a VLAN setup and mdns forwarding enabled,
         * fail to properly encode pointers inside the nextDomainName field.
         * Those pointers simply point to random points in the record data, resulting in decoding to fail.
         * As the field doesn't have any meaning and we simply don't use it, we just skip decoding for now.
         */
        const decodedNextDomainName = coder.decodeName(offset, false);
        offset += decodedNextDomainName.readBytes;
        const rrTypes = [];
        while (offset < buffer.length) {
            const windowId = buffer.readUInt8(offset++);
            const bitMapLength = buffer.readUInt8(offset++);
            const upperRType = windowId << 8;
            for (let block = 0; block < bitMapLength; block++) {
                const byte = buffer.readUInt8(offset++);
                for (let bit = 0; bit < 8; bit++) { // iterate over every bit
                    if (byte & (1 << (7 - bit))) { // check if bit is set
                        const rType = upperRType | (block << 3) | bit; // OR upperWindowNum | basically block * 8 | bit number
                        rrTypes.push(rType);
                    }
                }
            }
        }
        return {
            data: new NSECRecord(header, decodedNextDomainName.data, rrTypes),
            readBytes: offset - oldOffset,
        };
    }
    clone() {
        return new NSECRecord(this.getRecordRepresentation(), this.nextDomainName, NSECRecord.windowsToRRTypes(this.rrTypeWindows));
    }
    dataAsString() {
        return `${this.nextDomainName} [${NSECRecord.windowsToRRTypes(this.rrTypeWindows).map(rtype => "" + rtype).join(",")}]`;
    }
    dataEquals(record) {
        return this.getLowerCasedNextDomainName() === record.getLowerCasedNextDomainName() && fast_deep_equal_1.default(this.rrTypeWindows, record.rrTypeWindows);
    }
    static rrTypesToWindowMap(rrtypes) {
        const rrTypeWindows = [];
        for (const rrtype of rrtypes) {
            const windowId = rrtype >> 8;
            let window = undefined;
            for (const window0 of rrTypeWindows) {
                if (window0.windowId === windowId) {
                    window = window0;
                    break;
                }
            }
            if (!window) {
                window = {
                    windowId: windowId,
                    bitMapSize: Math.ceil((rrtype & 0xFF) / 8),
                    rrtypes: [rrtype],
                };
                rrTypeWindows.push(window);
            }
            else {
                window.rrtypes.push(rrtype);
                const bitMapSize = Math.ceil((rrtype & 0xFF) / 8);
                if (bitMapSize > window.bitMapSize) {
                    window.bitMapSize = bitMapSize;
                }
            }
        }
        // sort by windowId
        rrTypeWindows.sort((a, b) => a.windowId - b.windowId);
        rrTypeWindows.forEach(window => window.rrtypes.sort((a, b) => a - b));
        return rrTypeWindows;
    }
    static windowsToRRTypes(windows) {
        const rrtypes = [];
        for (const window of windows) {
            rrtypes.push(...window.rrtypes);
        }
        return rrtypes;
    }
}
exports.NSECRecord = NSECRecord;
//# sourceMappingURL=NSECRecord.js.map

/***/ }),

/***/ 6693:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OPTRecord = void 0;
const tslib_1 = __nccwpck_require__(4290);
const assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
const fast_deep_equal_1 = tslib_1.__importDefault(__nccwpck_require__(7689));
const ResourceRecord_1 = __nccwpck_require__(7761);
class OPTRecord extends ResourceRecord_1.ResourceRecord {
    constructor(udpPayloadSize, options, extendedRCode, flags, ednsVersion, ttl) {
        if (typeof udpPayloadSize === "number") {
            super(".", 41 /* OPT */, ttl, false, udpPayloadSize);
            this.udpPayloadSize = udpPayloadSize;
        }
        else {
            assert_1.default(udpPayloadSize.type === 41 /* OPT */);
            super(udpPayloadSize);
            this.udpPayloadSize = udpPayloadSize.class;
        }
        this.extendedRCode = extendedRCode || 0;
        this.ednsVersion = ednsVersion || OPTRecord.EDNS_VERSION;
        this.flags = {
            dnsSecOK: (flags === null || flags === void 0 ? void 0 : flags.dnsSecOK) || false,
            zero: (flags === null || flags === void 0 ? void 0 : flags.zero) || 0,
            ...flags,
        };
        this.options = options || [];
    }
    getRDataEncodingLength() {
        let length = 0;
        for (const option of this.options) {
            length += 2 + 2 + option.data.length; // 2 byte code; 2 byte length prefix; binary data
        }
        return length;
    }
    encodeRData(coder, buffer, offset) {
        const oldOffset = offset;
        const classOffset = offset - 8;
        const ttlOffset = offset - 6;
        // just to be sure
        buffer.writeUInt16BE(this.udpPayloadSize, classOffset);
        buffer.writeUInt8(this.extendedRCode, ttlOffset);
        buffer.writeUInt8(this.ednsVersion, ttlOffset + 1);
        let flags = this.flags.zero || 0;
        if (this.flags.dnsSecOK) {
            flags |= OPTRecord.DNS_SEC_OK_MASK;
        }
        buffer.writeUInt16BE(flags, ttlOffset + 2);
        for (const option of this.options) {
            buffer.writeUInt16BE(option.code, offset);
            offset += 2;
            buffer.writeUInt16BE(option.data.length, offset);
            offset += 2;
            option.data.copy(buffer, offset);
            offset += option.data.length;
        }
        return offset - oldOffset; // written bytes
    }
    static decodeData(coder, header, buffer, offset) {
        const oldOffset = offset;
        const classOffset = offset - 8;
        const ttlOffset = offset - 6;
        const udpPayloadSize = buffer.readUInt16BE(classOffset);
        const extendedRCode = buffer.readUInt8(ttlOffset);
        const ednsVersion = buffer.readUInt8(ttlOffset + 1);
        const flagsField = buffer.readUInt16BE(ttlOffset + 2);
        const flags = {
            dnsSecOK: !!(flagsField & OPTRecord.DNS_SEC_OK_MASK),
            zero: flagsField & OPTRecord.NOT_DNS_SEC_OK_MASK,
        };
        const options = [];
        while (offset < buffer.length) {
            const code = buffer.readUInt16BE(offset);
            offset += 2;
            const length = buffer.readUInt16BE(offset);
            offset += 2;
            const data = buffer.slice(offset, offset + length);
            offset += length;
            options.push({
                code: code,
                data: data,
            });
        }
        header.class = udpPayloadSize;
        header.ttl = 4500; // default
        return {
            data: new OPTRecord(header, options, extendedRCode, flags, ednsVersion),
            readBytes: offset - oldOffset,
        };
    }
    clone() {
        return new OPTRecord(this.getRecordRepresentation(), this.options, this.extendedRCode, this.flags, this.ednsVersion);
    }
    dataAsString() {
        return `${this.udpPayloadSize} ${this.extendedRCode} ${this.ednsVersion} ${JSON.stringify(this.flags)} [${this.options
            .map(opt => `${opt.code} ${opt.data.toString("base64")}`).join(",")}]`;
    }
    dataEquals(record) {
        return this.udpPayloadSize === record.udpPayloadSize && this.extendedRCode === record.extendedRCode
            && this.ednsVersion === record.ednsVersion
            && OPTRecord.optionsEquality(this.options, record.options) && fast_deep_equal_1.default(this.flags, record.flags);
    }
    static optionsEquality(a, b) {
        // deepEquals on buffers doesn't really work
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0; i < a.length; i++) {
            if (a[i].code !== b[i].code) {
                return false;
            }
            else if (a[i].data.toString("hex") !== b[i].data.toString("hex")) {
                return false;
            }
        }
        return true;
    }
}
exports.OPTRecord = OPTRecord;
OPTRecord.EDNS_VERSION = 0;
OPTRecord.DNS_SEC_OK_MASK = 0x8000; // 2 bytes, first bit set
OPTRecord.NOT_DNS_SEC_OK_MASK = 0x7FFF;
//# sourceMappingURL=OPTRecord.js.map

/***/ }),

/***/ 8517:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PTRRecord = void 0;
const tslib_1 = __nccwpck_require__(4290);
const assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
const dns_equal_1 = __nccwpck_require__(7338);
const ResourceRecord_1 = __nccwpck_require__(7761);
class PTRRecord extends ResourceRecord_1.ResourceRecord {
    constructor(name, ptrName, flushFlag, ttl) {
        if (typeof name === "string") {
            super(name, 12 /* PTR */, ttl, flushFlag);
        }
        else {
            assert_1.default(name.type === 12 /* PTR */);
            super(name);
        }
        if (!ptrName.endsWith(".")) {
            ptrName += ".";
        }
        this.ptrName = ptrName;
    }
    getLowerCasedPTRName() {
        return this.lowerCasedPtrName || (this.lowerCasedPtrName = dns_equal_1.dnsLowerCase(this.ptrName));
    }
    getRDataEncodingLength(coder) {
        return coder.getNameLength(this.ptrName);
    }
    encodeRData(coder, buffer, offset) {
        const oldOffset = offset;
        const ptrNameLength = coder.encodeName(this.ptrName, offset);
        offset += ptrNameLength;
        return offset - oldOffset; // written bytes
    }
    static decodeData(coder, header, buffer, offset) {
        const oldOffset = offset;
        const decodedName = coder.decodeName(offset);
        offset += decodedName.readBytes;
        return {
            data: new PTRRecord(header, decodedName.data),
            readBytes: offset - oldOffset,
        };
    }
    clone() {
        return new PTRRecord(this.getRecordRepresentation(), this.ptrName);
    }
    dataAsString() {
        return this.ptrName;
    }
    dataEquals(record) {
        return this.getLowerCasedPTRName() === record.getLowerCasedPTRName();
    }
}
exports.PTRRecord = PTRRecord;
PTRRecord.DEFAULT_TTL = ResourceRecord_1.ResourceRecord.RR_DEFAULT_TTL;
//# sourceMappingURL=PTRRecord.js.map

/***/ }),

/***/ 1701:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SRVRecord = void 0;
const tslib_1 = __nccwpck_require__(4290);
const assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
const dns_equal_1 = __nccwpck_require__(7338);
const ResourceRecord_1 = __nccwpck_require__(7761);
class SRVRecord extends ResourceRecord_1.ResourceRecord {
    constructor(name, hostname, port, flushFlag, ttl) {
        if (typeof name === "string") {
            super(name, 33 /* SRV */, ttl || SRVRecord.RR_DEFAULT_TTL_SHORT, flushFlag);
        }
        else {
            assert_1.default(name.type === 33 /* SRV */);
            super(name);
        }
        if (!hostname.endsWith(".")) {
            this.hostname = hostname + ".";
        }
        else {
            this.hostname = hostname;
        }
        this.port = port;
        // priority and weight are not supported to encode or read
        this.priority = 0;
        this.weight = 0;
    }
    getLowerCasedHostname() {
        return this.lowerCasedHostname || (this.lowerCasedHostname = dns_equal_1.dnsLowerCase(this.hostname));
    }
    getRDataEncodingLength(coder) {
        return 6 // 2 byte priority; 2 byte weight; 2 byte port;
            // as of RFC 2782 name compression MUST NOT be used for the hostname, though RFC 6762 18.14 specifies it should
            + (coder.legacyUnicastEncoding
                ? coder.getUncompressedNameLength(this.hostname)
                : coder.getNameLength(this.hostname));
    }
    encodeRData(coder, buffer, offset) {
        const oldOffset = offset;
        buffer.writeUInt16BE(this.priority, offset);
        offset += 2;
        buffer.writeUInt16BE(this.weight, offset);
        offset += 2;
        buffer.writeUInt16BE(this.port, offset);
        offset += 2;
        const hostnameLength = coder.legacyUnicastEncoding
            ? coder.encodeUncompressedName(this.hostname, offset)
            : coder.encodeName(this.hostname, offset);
        offset += hostnameLength;
        return offset - oldOffset; // written bytes
    }
    static decodeData(coder, header, buffer, offset) {
        const oldOffset = offset;
        //const priority = buffer.readUInt16BE(offset);
        offset += 2;
        //const weight = buffer.readUInt16BE(offset);
        offset += 2;
        const port = buffer.readUInt16BE(offset);
        offset += 2;
        const decodedHostname = coder.decodeName(offset);
        offset += decodedHostname.readBytes;
        return {
            data: new SRVRecord(header, decodedHostname.data, port),
            readBytes: offset - oldOffset,
        };
    }
    clone() {
        return new SRVRecord(this.getRecordRepresentation(), this.hostname, this.port);
    }
    dataAsString() {
        return `${this.hostname} ${this.port} ${this.priority} ${this.weight}`;
    }
    dataEquals(record) {
        return this.getLowerCasedHostname() === record.getLowerCasedHostname() && this.port === record.port && this.weight === record.weight && this.priority === record.priority;
    }
}
exports.SRVRecord = SRVRecord;
SRVRecord.DEFAULT_TTL = 120;
//# sourceMappingURL=SRVRecord.js.map

/***/ }),

/***/ 1930:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TXTRecord = void 0;
const tslib_1 = __nccwpck_require__(4290);
const assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
const ResourceRecord_1 = __nccwpck_require__(7761);
class TXTRecord extends ResourceRecord_1.ResourceRecord {
    constructor(name, txt, flushFlag, ttl) {
        if (typeof name === "string") {
            super(name, 16 /* TXT */, ttl, flushFlag);
        }
        else {
            assert_1.default(name.type === 16 /* TXT */);
            super(name);
        }
        this.txt = txt;
    }
    getRDataEncodingLength() {
        let length = 0;
        for (const buffer of this.txt) {
            length += 1 + buffer.length;
            assert_1.default(buffer.length <= 255, "One txt character-string can only have a length of 255 chars");
        }
        return length;
    }
    encodeRData(coder, buffer, offset) {
        const oldOffset = offset;
        for (const txt of this.txt) {
            buffer.writeUInt8(txt.length, offset++);
            txt.copy(buffer, offset);
            offset += txt.length;
        }
        return offset - oldOffset; // written bytes
    }
    clone() {
        return new TXTRecord(this.getRecordRepresentation(), this.txt);
    }
    dataAsString() {
        return `[${this.txt.map(line => `${line.toString("base64")}`).join(",")}]`;
    }
    dataEquals(record) {
        // deepEquals on buffers doesn't really work
        if (this.txt.length !== record.txt.length) {
            return false;
        }
        for (let i = 0; i < this.txt.length; i++) {
            if (this.txt[i].toString("hex") !== record.txt[i].toString("hex")) {
                return false;
            }
        }
        return true;
    }
    static decodeData(coder, header, buffer, offset) {
        const oldOffset = offset;
        const txtData = [];
        while (offset < buffer.length) {
            const length = buffer.readUInt8(offset++);
            txtData.push(buffer.slice(offset, offset + length));
            offset += length;
        }
        return {
            data: new TXTRecord(header, txtData),
            readBytes: offset - oldOffset,
        };
    }
}
exports.TXTRecord = TXTRecord;
TXTRecord.DEFAULT_TTL = ResourceRecord_1.ResourceRecord.RR_DEFAULT_TTL;
//# sourceMappingURL=TXTRecord.js.map

/***/ }),

/***/ 9273:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const ResourceRecord_1 = __nccwpck_require__(7761);
const AAAARecord_1 = __nccwpck_require__(8584);
const ARecord_1 = __nccwpck_require__(1540);
const CNAMERecord_1 = __nccwpck_require__(9981);
const NSECRecord_1 = __nccwpck_require__(2991);
const OPTRecord_1 = __nccwpck_require__(6693);
const PTRRecord_1 = __nccwpck_require__(8517);
const SRVRecord_1 = __nccwpck_require__(1701);
const TXTRecord_1 = __nccwpck_require__(1930);
ResourceRecord_1.ResourceRecord.typeToRecordDecoder.set(28 /* AAAA */, AAAARecord_1.AAAARecord.decodeData);
ResourceRecord_1.ResourceRecord.typeToRecordDecoder.set(1 /* A */, ARecord_1.ARecord.decodeData);
ResourceRecord_1.ResourceRecord.typeToRecordDecoder.set(5 /* CNAME */, CNAMERecord_1.CNAMERecord.decodeData);
ResourceRecord_1.ResourceRecord.typeToRecordDecoder.set(47 /* NSEC */, NSECRecord_1.NSECRecord.decodeData);
ResourceRecord_1.ResourceRecord.typeToRecordDecoder.set(12 /* PTR */, PTRRecord_1.PTRRecord.decodeData);
ResourceRecord_1.ResourceRecord.typeToRecordDecoder.set(33 /* SRV */, SRVRecord_1.SRVRecord.decodeData);
ResourceRecord_1.ResourceRecord.typeToRecordDecoder.set(41 /* OPT */, OPTRecord_1.OPTRecord.decodeData);
ResourceRecord_1.ResourceRecord.typeToRecordDecoder.set(16 /* TXT */, TXTRecord_1.TXTRecord.decodeData);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8381:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getResponder = exports.Protocol = void 0;
const tslib_1 = __nccwpck_require__(4290);
__nccwpck_require__(3418); // registering node-source-map-support for typescript stack traces
const debug_1 = tslib_1.__importDefault(__nccwpck_require__(7984));
// eslint-disable-next-line @typescript-eslint/no-var-requires
const version = __nccwpck_require__(9681)/* .version */ .i8;
if (version.includes("beta") || process.env.BCT) { // enable debug output if beta version or running bonjour conformance testing
    const debug = process.env.DEBUG;
    if (!debug || !debug.includes("ciao")) {
        if (!debug) {
            debug_1.default.enable("ciao:*");
        }
        else {
            debug_1.default.enable(debug + ",ciao:*");
        }
    }
}
__nccwpck_require__(9273);
const Responder_1 = __nccwpck_require__(4237);
tslib_1.__exportStar(__nccwpck_require__(108), exports);
tslib_1.__exportStar(__nccwpck_require__(4237), exports);
function printInitInfo() {
    const debug = debug_1.default("ciao:init");
    debug("Loading ciao v" + version + "...");
}
printInitInfo();
/**
 * Defines the transport protocol of a service.
 *
 * As of RFC 6763 7. TCP must be used for any applications using tcp.
 *  For applications using any other transport protocol UDP must be used.
 *  This applies to all other transport protocols like SCTP, DCCP, RTMFP, etc
 */
var Protocol;
(function (Protocol) {
    Protocol["TCP"] = "tcp";
    Protocol["UDP"] = "udp";
})(Protocol = exports.Protocol || (exports.Protocol = {}));
/**
 * This method is used to get a responder for the provided (optional) set of options.
 *
 * Ciao tries to create as few Responder instances as possible.
 * Thus, it will share the same Responder instance for the same set of options.
 *
 * @param options - If specified, the options will be passed to the underlying mdns server.
 * @returns A Responder instance for the given options. Might be shared with others using the same options.
 */
function getResponder(options) {
    return Responder_1.Responder.getResponder(options);
}
exports.getResponder = getResponder;
exports.default = {
    getResponder: getResponder,
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 3674:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Announcer = void 0;
const tslib_1 = __nccwpck_require__(4290);
const assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
const debug_1 = tslib_1.__importDefault(__nccwpck_require__(7984));
const DNSPacket_1 = __nccwpck_require__(3646);
const MDNSServer_1 = __nccwpck_require__(9668);
const promise_utils_1 = __nccwpck_require__(3620);
const debug = debug_1.default("ciao:Announcer");
/**
 * This class is used to execute the announce process for a given service as define in RFC 6762 8.3.
 *
 * The Multicast DNS responder MUST send at least two unsolicited
 * responses, one second apart.  To provide increased robustness against
 * packet loss, a responder MAY send up to eight unsolicited responses,
 * provided that the interval between unsolicited responses increases by
 * at least a factor of two with every response sent.
 *
 */
class Announcer {
    constructor(server, service, options) {
        this.repetitions = 1;
        this.announceIntervalIncreaseFactor = 2; // RFC states a factor of AT LEAST two (could be higher as it seems)
        this.goodbye = false;
        this.sentAnnouncements = 0;
        this.sentLastAnnouncement = false;
        this.nextInterval = 1000;
        this.nextAnnouncementTime = 0;
        assert_1.default(server, "server must be defined");
        assert_1.default(service, "service must be defined");
        this.server = server;
        this.service = service;
        if (options) {
            if (options.repetitions !== undefined) {
                this.repetitions = options.repetitions;
            }
            if (options.goodbye) {
                this.goodbye = true;
            }
        }
        assert_1.default(this.repetitions > 0 && this.repetitions <= 8, "repetitions must in [1;8]");
    }
    announce() {
        debug("[%s] Sending %s for service", this.service.getFQDN(), this.goodbye ? "goodbye" : "announcement");
        if (!this.goodbye) {
            // could happen that the txt record was updated while probing.
            // just to be sure to announce all the latest data, we will rebuild the services.
            this.service.rebuildServiceRecords();
        }
        return (this.promise = new Promise((resolve, reject) => {
            this.promiseResolve = resolve;
            this.promiseReject = reject;
            this.timer = setTimeout(this.sendAnnouncement.bind(this), 0);
            this.timer.unref();
            this.nextAnnouncementTime = new Date().getTime();
        }));
    }
    async cancel() {
        debug("[%s] Canceling %s", this.service.getFQDN(), this.goodbye ? "goodbye" : "announcement");
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = undefined;
        }
        this.promiseReject(Announcer.CANCEL_REASON);
        // the promise handlers are not called instantly, thus we give the opportunity to wait for the
        // program originally doing the announcement to clean up
        return this.awaitAnnouncement().catch(reason => {
            if (reason !== Announcer.CANCEL_REASON) {
                return Promise.reject(reason);
            }
        });
    }
    hasSentLastAnnouncement() {
        return this.sentLastAnnouncement;
    }
    async awaitAnnouncement() {
        await this.promise;
    }
    isSendingGoodbye() {
        return this.goodbye;
    }
    sendAnnouncement() {
        // minimum required is to send two unsolicited responses, one second apart
        // we could announce up to 8 times in total (time between messages must increase by two every message)
        debug("[%s] Sending %s number %d", this.service.getFQDN(), this.goodbye ? "goodbye" : "announcement", this.sentAnnouncements + 1);
        // we rebuild every time,
        const records = [
            this.service.ptrRecord(), ...this.service.subtypePtrRecords(),
            this.service.srvRecord(), this.service.txtRecord(),
        ];
        if (this.goodbye) {
            for (const record of records) {
                record.ttl = 0; // setting ttl to zero to indicate "goodbye"
            }
        }
        else {
            records.push(this.service.metaQueryPtrRecord());
        }
        if (this.sentAnnouncements + 1 >= this.repetitions) {
            this.sentLastAnnouncement = true;
        }
        Announcer.sendResponseAddingAddressRecords(this.server, this.service, records, this.goodbye).then(results => {
            const failRatio = MDNSServer_1.SendResultFailedRatio(results);
            if (failRatio === 1) {
                console.error(MDNSServer_1.SendResultFormatError(results, `[${this.service.getFQDN()}] Failed to send ${this.goodbye ? "goodbye" : "announcement"} requests`), true);
                this.promiseReject(new Error(`${this.goodbye ? "Goodbye" : "Announcement"} failed as of socket errors!`));
                return; // all failed => thus announcement failed
            }
            if (failRatio > 0) {
                // some queries on some interfaces failed, but not all. We log that but consider that to be a success
                // at this point we are not responsible for removing stale network interfaces or something
                debug(MDNSServer_1.SendResultFormatError(results, `Some of the ${this.goodbye ? "goodbye" : "announcement"} requests for '${this.service.getFQDN()}' encountered an error`));
                // SEE no return here
            }
            if (this.service.serviceState !== "announcing" /* ANNOUNCING */) {
                debug("[%s] Service is no longer in announcing state. Stopping. (Received %s)", this.service.getFQDN(), this.service.serviceState);
                return;
            }
            this.sentAnnouncements++;
            if (this.sentAnnouncements >= this.repetitions) {
                this.promiseResolve();
            }
            else {
                this.timer = setTimeout(this.sendAnnouncement.bind(this), this.nextInterval);
                this.timer.unref();
                this.nextAnnouncementTime = new Date().getTime() + this.nextInterval;
                this.nextInterval *= this.announceIntervalIncreaseFactor;
            }
        });
    }
    static sendResponseAddingAddressRecords(server, service, records, goodbye) {
        const promises = [];
        for (const name of server.getBoundInterfaceNames()) {
            if (!service.advertisesOnInterface(name)) {
                continue;
            }
            const answer = records.concat([]);
            const aRecord = service.aRecord(name);
            const aaaaRecord = service.aaaaRecord(name);
            const aaaaRoutableRecord = service.aaaaRoutableRecord(name);
            const aaaaUniqueLocalRecord = service.aaaaUniqueLocalRecord(name);
            //const reversMappings: PTRRecord[] = service.reverseAddressMappings(networkInterface);
            const nsecRecord = service.addressNSECRecord();
            const serviceNsecRecord = service.serviceNSECRecord();
            if (aRecord) {
                if (goodbye) {
                    aRecord.ttl = 0;
                }
                answer.push(aRecord);
            }
            if (aaaaRecord) {
                if (goodbye) {
                    aaaaRecord.ttl = 0;
                }
                answer.push(aaaaRecord);
            }
            if (aaaaRoutableRecord) {
                if (goodbye) {
                    aaaaRoutableRecord.ttl = 0;
                }
                answer.push(aaaaRoutableRecord);
            }
            if (aaaaUniqueLocalRecord) {
                if (goodbye) {
                    aaaaUniqueLocalRecord.ttl = 0;
                }
                answer.push(aaaaUniqueLocalRecord);
            }
            /*
            for (const reversMapping of reversMappings) {
              if (goodbye) {
                reversMapping.ttl = 0;
              }
              answer.push(reversMapping);
            }
            */
            if (goodbye) {
                nsecRecord.ttl = 0;
                serviceNsecRecord.ttl = 0;
            }
            const additionals = [];
            additionals.push(nsecRecord, serviceNsecRecord);
            const packet = DNSPacket_1.DNSPacket.createDNSResponsePacketsFromRRSet({
                answers: answer,
                additionals: additionals,
            });
            promises.push(Promise.race([
                server.send(packet, name),
                promise_utils_1.PromiseTimeout(MDNSServer_1.MDNSServer.SEND_TIMEOUT).then(() => ({
                    status: "timeout",
                    interface: name,
                })),
            ]));
        }
        return Promise.all(promises);
    }
}
exports.Announcer = Announcer;
Announcer.CANCEL_REASON = "CIAO ANNOUNCEMENT CANCELLED";
//# sourceMappingURL=Announcer.js.map

/***/ }),

/***/ 4735:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Prober = void 0;
const tslib_1 = __nccwpck_require__(4290);
const assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
const debug_1 = tslib_1.__importDefault(__nccwpck_require__(7984));
const Question_1 = __nccwpck_require__(8505);
const MDNSServer_1 = __nccwpck_require__(9668);
const tiebreaking = tslib_1.__importStar(__nccwpck_require__(7156));
const tiebreaking_1 = __nccwpck_require__(7156);
const PROBE_INTERVAL = 250; // 250ms as defined in RFC 6762 8.1.
const LIMITED_PROBE_INTERVAL = 1000;
const debug = debug_1.default("ciao:Prober");
/**
 * This class is used to execute the probing process for a given service as defined
 * in RFC 6762 8.1.
 * This ensure that the we advertise the service under a unique name.
 * It also provides a conflict resolution algorithm if multiple clients probing
 * for the same name are detected.
 */
class Prober {
    constructor(responder, server, service) {
        this.records = [];
        this.currentInterval = PROBE_INTERVAL;
        this.serviceEncounteredNameChange = false;
        this.sentFirstProbeQuery = false; // we MUST ignore responses received BEFORE the first probe is sent
        this.sentQueriesForCurrentTry = 0;
        this.sentQueries = 0;
        assert_1.default(responder, "responder must be defined");
        assert_1.default(server, "server must be defined");
        assert_1.default(service, "service must be defined");
        this.responder = responder;
        this.server = server;
        this.service = service;
    }
    getService() {
        return this.service;
    }
    /**
     * This method is called to start the actual probing process.
     * Once the service is considered unique on the network and can be announced the promise returns.
     * While probing multiple name changes can happen
     *
     * @returns a promise which returns when the service is considered unique on the network
     */
    probe() {
        /*
         * Probing is basically the following process: We send three "probe" queries to check
         * if the desired service name is already on the network.
         * The request are sent with a delay of 250ms between them and the first
         * request starting with a random delay.
         * If we don't receive any response to our requests we consider the probing to be successful
         * and continue with announcing our service.
         */
        debug("Starting to probe for '%s'...", this.service.getFQDN());
        return new Promise((resolve, reject) => {
            this.promiseResolve = resolve;
            this.promiseReject = reject;
            this.timer = setTimeout(this.sendProbeRequest.bind(this), Math.random() * PROBE_INTERVAL);
            this.timer.unref();
        });
    }
    cancel() {
        this.clear();
        this.promiseReject(Prober.CANCEL_REASON);
    }
    clear() {
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = undefined;
        }
        // reset all values to default (so the Prober can be reused if it wasn't successful)
        this.sentFirstProbeQuery = false;
        this.sentQueriesForCurrentTry = 0;
    }
    /**
     * End the current ongoing probing requests. If
     * @param success
     */
    endProbing(success) {
        // reset all values to default (so the Prober can be reused if it wasn't successful)
        this.clear();
        if (success) {
            debug("Probing for '%s' finished successfully", this.service.getFQDN());
            this.promiseResolve();
            if (this.serviceEncounteredNameChange) {
                this.service.informAboutNameUpdates();
            }
        }
    }
    sendProbeRequest() {
        if (this.sentQueriesForCurrentTry === 0) { // this is the first query sent, init some stuff
            // RFC 6762 8.2. When a host is probing for a group of related records with the same
            //    name (e.g., the SRV and TXT record describing a DNS-SD service), only
            //    a single question need be placed in the Question Section, since query
            //    type "ANY" (255) is used, which will elicit answers for all records
            //    with that name.  However, for tiebreaking to work correctly in all
            //    cases, the Authority Section must contain *all* the records and
            //    proposed rdata being probed for uniqueness.
            // it states *all* records, though we include ALL A/AAAA records as well, even
            // though it may not be relevant data if the probe query is published on different interfaces.
            // Having the same "format" probed on all interfaces, the simultaneous probe tiebreaking
            // algorithm can work correctly. Otherwise we would conflict with ourselfs in a situation were
            // a device is connected to the same network via WiFi and Ethernet.
            this.records = [
                this.service.srvRecord(), this.service.txtRecord(),
                this.service.ptrRecord(), ...this.service.subtypePtrRecords(),
                ...this.service.allAddressRecords(),
            ].sort(tiebreaking_1.rrComparator); // we sort them for the tiebreaking algorithm
            this.records.forEach(record => record.flushFlag = false);
        }
        if (this.sentQueriesForCurrentTry >= 3) {
            // we sent three requests and it seems like we weren't canceled, so we have a success right here
            this.endProbing(true);
            return;
        }
        if (this.sentQueries >= 15) {
            this.currentInterval = LIMITED_PROBE_INTERVAL;
        }
        debug("Sending prober query number %d for '%s'...", this.sentQueriesForCurrentTry + 1, this.service.getFQDN());
        assert_1.default(this.records.length > 0, "Tried sending probing request for zero record length!");
        const questions = [
            // probes SHOULD be send with unicast response flag as of the RFC
            // MDNServer might overwrite the QU flag to false, as we can't use unicast if there is another responder on the machine
            new Question_1.Question(this.service.getFQDN(), 255 /* ANY */, true),
            new Question_1.Question(this.service.getHostname(), 255 /* ANY */, true),
        ];
        this.server.sendQueryBroadcast({
            questions: questions,
            // TODO certified homekit accessories only include the main service PTR record
            authorities: this.records,
        }, this.service).then(results => {
            const failRatio = MDNSServer_1.SendResultFailedRatio(results);
            if (failRatio === 1) {
                console.error(MDNSServer_1.SendResultFormatError(results, `Failed to send probe queries for '${this.service.getFQDN()}'`), true);
                this.endProbing(false);
                this.promiseReject(new Error("Probing failed as of socket errors!"));
                return; // all failed => thus probing failed
            }
            if (failRatio > 0) {
                // some queries on some interfaces failed, but not all. We log that but consider that to be a success
                // at this point we are not responsible for removing stale network interfaces or something
                debug(MDNSServer_1.SendResultFormatError(results, `Some of the probe queries for '${this.service.getFQDN()}' encountered an error`));
                // SEE no return here
            }
            if (this.service.serviceState !== "probing" /* PROBING */) {
                debug("Service '%s' is no longer in probing state. Stopping.", this.service.getFQDN());
                return;
            }
            this.sentFirstProbeQuery = true;
            this.sentQueriesForCurrentTry++;
            this.sentQueries++;
            this.timer = setTimeout(this.sendProbeRequest.bind(this), this.currentInterval);
            this.timer.unref();
            this.checkLocalConflicts();
        });
    }
    checkLocalConflicts() {
        let containsAnswer = false;
        for (const service of this.responder.getAnnouncedServices()) {
            if (service.getLowerCasedFQDN() === this.service.getLowerCasedFQDN() || service.getLowerCasedHostname() === this.service.getLowerCasedHostname()) {
                containsAnswer = true;
                break;
            }
        }
        if (containsAnswer) {
            debug("Probing for '%s' failed as of local service. Doing a name change", this.service.getFQDN());
            this.handleNameChange();
        }
    }
    handleResponse(packet, endpoint) {
        if (!this.sentFirstProbeQuery || !this.service.advertisesOnInterface(endpoint.interface)) {
            return;
        }
        let containsAnswer = false;
        // search answers and additionals for answers to our probe queries
        for (const record of packet.answers.values()) {
            if (record.getLowerCasedName() === this.service.getLowerCasedFQDN() || record.getLowerCasedName() === this.service.getLowerCasedHostname()) {
                containsAnswer = true;
                break;
            }
        }
        for (const record of packet.additionals.values()) {
            if (record.getLowerCasedName() === this.service.getLowerCasedFQDN() || record.getLowerCasedName() === this.service.getLowerCasedHostname()) {
                containsAnswer = true;
                break;
            }
        }
        if (containsAnswer) { // abort and cancel probes
            debug("Probing for '%s' failed. Doing a name change", this.service.getFQDN());
            this.handleNameChange();
        }
    }
    handleNameChange() {
        this.endProbing(false); // reset the prober
        this.service.serviceState = "unannounced" /* UNANNOUNCED */;
        this.service.incrementName();
        this.service.serviceState = "probing" /* PROBING */;
        this.serviceEncounteredNameChange = true;
        this.timer = setTimeout(this.sendProbeRequest.bind(this), 1000);
        this.timer.unref();
    }
    handleQuery(packet, endpoint) {
        if (!this.sentFirstProbeQuery || !this.service.advertisesOnInterface(endpoint.interface)) {
            return;
        }
        // if we are currently probing and receiving a query which is also a probing query
        // which matches the desired name we run the tiebreaking algorithm to decide on the winner
        let needsTiebreaking = false;
        for (const question of packet.questions.values()) {
            if (question.getLowerCasedName() === this.service.getLowerCasedFQDN() || question.getLowerCasedName() === this.service.getLowerCasedHostname()) {
                needsTiebreaking = true;
                break;
            }
        }
        if (needsTiebreaking) {
            this.doTiebreaking(packet);
        }
    }
    doTiebreaking(packet) {
        if (!this.sentFirstProbeQuery) { // ignore queries if we are not sending
            return;
        }
        // first of all check if the contents of authorities answers our query
        let conflict = packet.authorities.size === 0;
        for (const record of packet.authorities.values()) {
            if (record.getLowerCasedName() === this.service.getLowerCasedFQDN() || record.getLowerCasedName() === this.service.getLowerCasedHostname()) {
                conflict = true;
                break;
            }
        }
        if (!conflict) {
            return;
        }
        // now run the actual tiebreaking algorithm to decide the winner
        // tiebreaking is actually run pretty often, as we always receive our own packets
        // first of all build our own records
        const answers = this.records; // already sorted
        const opponent = Array.from(packet.authorities.values()).sort(tiebreaking.rrComparator);
        const result = tiebreaking.runTiebreaking(answers, opponent);
        if (result === 1 /* HOST */) {
            debug("'%s' won the tiebreak. We gonna ignore the other probing request!", this.service.getFQDN());
        }
        else if (result === -1 /* OPPONENT */) {
            debug("'%s' lost the tiebreak. We are waiting a second and try to probe again...", this.service.getFQDN());
            this.endProbing(false); // cancel the current probing
            // wait 1 second and probe again (this is to guard against stale probe packets)
            // If it wasn't a stale probe packet, the other host will correctly respond to our probe queries by then
            this.timer = setTimeout(this.sendProbeRequest.bind(this), 1000);
            this.timer.unref();
        }
        else {
            //debug("Tiebreaking for '%s' detected exact same records on the network. There is actually no conflict!", this.service.getFQDN());
        }
    }
}
exports.Prober = Prober;
Prober.CANCEL_REASON = "CIAO PROBING CANCELLED";
//# sourceMappingURL=Prober.js.map

/***/ }),

/***/ 389:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QueryResponse = void 0;
const DNSPacket_1 = __nccwpck_require__(3646);
class QueryResponse {
    constructor(knownAnswers) {
        this.sharedAnswer = false;
        this.dnsPacket = new DNSPacket_1.DNSPacket({ type: 1 /* RESPONSE */ });
        this.knownAnswers = knownAnswers;
    }
    asPacket() {
        return this.dnsPacket;
    }
    asString(udpPayloadSize) {
        return this.dnsPacket.asLoggingString(udpPayloadSize);
    }
    containsSharedAnswer() {
        return this.sharedAnswer;
    }
    addAnswer(...records) {
        let addedAny = false;
        for (const record of records) {
            if (this.isKnownAnswer(record)) {
                // record is a known answer to the querier
                continue;
            }
            const added = this.dnsPacket.addAnswers(record);
            if (added) {
                addedAny = true;
                if (!record.flushFlag) {
                    this.sharedAnswer = true;
                }
            }
        }
        return addedAny;
    }
    addAdditional(...records) {
        let addedAny = false;
        for (const record of records) {
            if (this.isKnownAnswer(record)) {
                // check if the additional record is a known answer, otherwise there is no need to send it
                continue;
            }
            if (this.dnsPacket.answers.has(record.asString())) {
                continue; // if it is already in the answer section, don't include it in additionals
            }
            const added = this.dnsPacket.addAdditionals(record);
            if (added) {
                addedAny = true;
            }
        }
        return addedAny;
    }
    markLegacyUnicastResponse(id, questions) {
        // we are dealing with a legacy unicast dns query (RFC 6762 6.7.)
        //  * MUSTS: response via unicast, repeat query ID, repeat questions (actually it should just be one), clear cache flush bit
        //  * SHOULDS: ttls should not be greater than 10s as legacy resolvers don't take part in the cache coherency mechanism
        this.dnsPacket.id = id;
        if (questions) {
            this.dnsPacket.addQuestions(...questions);
        }
        this.dnsPacket.answers.forEach(answers => {
            answers.flushFlag = false;
            answers.ttl = 10;
        });
        this.dnsPacket.additionals.forEach(answers => {
            answers.flushFlag = false;
            answers.ttl = 10;
        });
        this.dnsPacket.setLegacyUnicastEncoding(true); // legacy unicast also affects the encoder (must not use compression for the SRV record) so we need to tell him
    }
    markTruncated() {
        this.dnsPacket.flags.truncation = true;
    }
    hasAnswers() {
        // we may still have additionals, though there is no reason when answers is empty
        // removeKnownAnswer may have removed all answers and only additionals are known.
        return this.dnsPacket.answers.size > 0;
    }
    isKnownAnswer(record) {
        if (!this.knownAnswers) {
            return false;
        }
        const knownAnswer = this.knownAnswers.get(record.asString());
        // we will still send the response if the known answer has half of the original ttl according to RFC 6762 7.1.
        // so only if the ttl is more than half than the original ttl we consider it a valid known answer
        return knownAnswer !== undefined && knownAnswer.ttl > record.ttl / 2;
    }
    static combineResponses(responses, udpPayloadSize) {
        for (let i = 0; i < responses.length - 1; i++) {
            const current = responses[i];
            const currentPacket = current.dnsPacket;
            const next = responses[i + 1];
            const nextPacket = next.dnsPacket;
            if (currentPacket.canBeCombinedWith(nextPacket, udpPayloadSize)) {
                // combine the packet with next one
                currentPacket.combineWith(nextPacket);
                // remove next from the array
                responses.splice(i + 1, 1);
                // we won't combine the known answer section, with current implementation they will always be the same
                current.sharedAnswer = current.sharedAnswer || next.sharedAnswer;
                // decrement i, so we check again if the "current" packet can be combined with the packet after "next"
                i--;
            }
        }
    }
}
exports.QueryResponse = QueryResponse;
//# sourceMappingURL=QueryResponse.js.map

/***/ }),

/***/ 5369:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QueuedResponse = void 0;
/**
 * Represents a delay response packet which is going to be sent over multicast.
 */
class QueuedResponse {
    constructor(packet, interfaceName) {
        this.timeOfCreation = new Date().getTime(); // epoch time millis
        this.estimatedTimeToBeSent = 0; // epoch time millis
        this.delay = -1;
        this.packet = packet;
        this.interfaceName = interfaceName;
    }
    getPacket() {
        return this.packet;
    }
    /**
     * This method returns the total delay of the represented dns response packet.
     * If this QueuedResponse consists of already combined packets
     * (meaning other packets already got delayed in order to be sent out with this packet),
     * the totalDelay will represent the maximum delay of any contained packet.
     *
     * @returns The total delay.
     */
    getTimeSinceCreation() {
        return new Date().getTime() - this.timeOfCreation;
    }
    getTimeTillSent() {
        return Math.max(0, this.estimatedTimeToBeSent - new Date().getTime());
    }
    calculateRandomDelay() {
        this.delay = Math.random() * 100 + 20; // delay of 20ms - 120ms
        this.estimatedTimeToBeSent = new Date().getTime() + this.delay;
    }
    scheduleResponse(callback) {
        this.timer = setTimeout(callback, this.delay);
        this.timer.unref(); // timer doesn't prevent termination
    }
    delayWouldBeInTimelyManner(next) {
        const delay = next.estimatedTimeToBeSent - this.timeOfCreation;
        return delay <= QueuedResponse.MAX_DELAY;
    }
    /**
     * Combines this queue response packet with the {@code next} queued response packet if those can be combined.
     * Packets can be combined if the udpPayloadSize allows for it AND if the current packet
     * won't be delayed more than 500 ms from it's time of creation AND the packets get sent on the same interface.
     *
     * @param next - A queued response which is schedule AFTER the current queued response.
     * @returns {@code true} will be returned if the queued response was combined with the specified {@code next} response.
     */
    combineWithNextPacketIfPossible(next) {
        // below check, which is commented out would be necessary, current implementation will check that
        // with function above, thus there is no need to check again.
        /*
        if (!this.delayWouldBeInTimelyManner(next)) {
          return false;
        }
        */
        if (this.interfaceName !== next.interfaceName) {
            // can't combine packets which get sent via different interfaces
            return false;
        }
        if (!next.packet.canBeCombinedWith(this.packet)) {
            // packets can't be combined
            return false;
        }
        next.packet.combineWith(this.packet);
        next.timeOfCreation = Math.min(this.timeOfCreation, next.timeOfCreation);
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = undefined;
        }
        this.delayed = true;
        return true;
    }
    combineWithUniqueResponseIfPossible(response, interfaceName) {
        if (this.interfaceName !== interfaceName) {
            // can't combine packets which get sent via different interfaces
            return false;
        }
        if (!this.packet.canBeCombinedWith(response.asPacket())) {
            return false; // packets can't be combined
        }
        this.packet.combineWith(response.asPacket());
        return true;
    }
}
exports.QueuedResponse = QueuedResponse;
QueuedResponse.MAX_DELAY = 500; // milliseconds
//# sourceMappingURL=QueuedResponse.js.map

/***/ }),

/***/ 540:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TruncatedQuery = exports.TruncatedQueryEvent = exports.TruncatedQueryResult = void 0;
const events_1 = __nccwpck_require__(8614);
var TruncatedQueryResult;
(function (TruncatedQueryResult) {
    TruncatedQueryResult[TruncatedQueryResult["ABORT"] = 1] = "ABORT";
    TruncatedQueryResult[TruncatedQueryResult["AGAIN_TRUNCATED"] = 2] = "AGAIN_TRUNCATED";
    TruncatedQueryResult[TruncatedQueryResult["FINISHED"] = 3] = "FINISHED";
})(TruncatedQueryResult = exports.TruncatedQueryResult || (exports.TruncatedQueryResult = {}));
var TruncatedQueryEvent;
(function (TruncatedQueryEvent) {
    TruncatedQueryEvent["TIMEOUT"] = "timeout";
})(TruncatedQueryEvent = exports.TruncatedQueryEvent || (exports.TruncatedQueryEvent = {}));
class TruncatedQuery extends events_1.EventEmitter {
    constructor(packet) {
        super();
        this.arrivedPackets = 1; // just for the stats
        this.timeOfArrival = new Date().getTime();
        this.packet = packet;
        this.timer = this.resetTimer();
    }
    getPacket() {
        return this.packet;
    }
    getArrivedPacketCount() {
        return this.arrivedPackets;
    }
    getTotalWaitTime() {
        return new Date().getTime() - this.timeOfArrival;
    }
    appendDNSPacket(packet) {
        this.packet.combineWith(packet);
        this.arrivedPackets++;
        if (packet.flags.truncation) { // if the appended packet is again truncated, restart the timeout
            const time = new Date().getTime();
            if (time - this.timeOfArrival > 5 * 1000) { // if the first packet, is more than 5 seconds old, we abort
                return 1 /* ABORT */;
            }
            this.resetTimer();
            return 2 /* AGAIN_TRUNCATED */;
        }
        else {
            clearTimeout(this.timer);
            this.removeAllListeners();
            return 3 /* FINISHED */;
        }
    }
    resetTimer() {
        if (this.timer) {
            clearTimeout(this.timer);
        }
        // timeout in time interval between 400-500ms
        return this.timer = setTimeout(this.timeout.bind(this), 400 + Math.random() * 100);
    }
    timeout() {
        this.emit("timeout" /* TIMEOUT */);
        this.removeAllListeners();
    }
}
exports.TruncatedQuery = TruncatedQuery;
//# sourceMappingURL=TruncatedQuery.js.map

/***/ }),

/***/ 7338:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// name equality checks according to RFC 1035 3.1
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dnsLowerCase = void 0;
const asciiPattern = /[A-Z]/g;
function dnsLowerCase(value) {
    return value.replace(asciiPattern, s => s.toLowerCase());
}
exports.dnsLowerCase = dnsLowerCase;
//# sourceMappingURL=dns-equal.js.map

/***/ }),

/***/ 9783:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getNetAddress = exports.ipAddressFromReversAddressName = exports.formatReverseAddressPTRName = exports.shortenIPv6 = exports.enlargeIPv6 = exports.removeTLD = exports.formatHostname = exports.stringify = exports.parseFQDN = void 0;
const tslib_1 = __nccwpck_require__(4290);
const assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
const net_1 = tslib_1.__importDefault(__nccwpck_require__(1631));
function isProtocol(part) {
    return part === "_" + "tcp" /* TCP */ || part === "_" + "udp" /* UDP */;
}
function isSub(part) {
    return part === "_sub";
}
function removePrefixedUnderscore(part) {
    return part.startsWith("_") ? part.slice(1) : part;
}
function isSubTypePTRParts(parts) {
    return "subtype" in parts;
}
function parseFQDN(fqdn) {
    const parts = fqdn.split(".");
    assert_1.default(parts.length >= 3, "Received illegal fqdn: " + fqdn);
    let i = parts.length - 1;
    let domain = "";
    while (!isProtocol(parts[i])) {
        domain = removePrefixedUnderscore(parts[i]) + (domain ? "." + domain : "");
        i--;
    }
    assert_1.default(i >= 1, "Failed to parse illegal fqdn: " + fqdn);
    const protocol = removePrefixedUnderscore(parts[i--]);
    const type = removePrefixedUnderscore(parts[i--]);
    if (i < 0) {
        return {
            domain: domain,
            protocol: protocol,
            type: type,
        };
    }
    else if (isSub(parts[i])) {
        i--; // skip "_sub";
        assert_1.default(i === 0, "Received illegal formatted sub type fqdn: " + fqdn);
        const subtype = removePrefixedUnderscore(parts[i]);
        return {
            domain: domain,
            protocol: protocol,
            type: type,
            subtype: subtype,
        };
    }
    else {
        // the name can contain dots as of RFC 6763 4.1.1.
        const name = removePrefixedUnderscore(parts.slice(0, i + 1).join("."));
        return {
            domain: domain,
            protocol: protocol,
            type: type,
            name: name,
        };
    }
}
exports.parseFQDN = parseFQDN;
function stringify(parts) {
    assert_1.default(parts.type, "type cannot be undefined");
    assert_1.default(parts.type.length <= 15, "type must not be longer than 15 characters");
    let prefix;
    if (isSubTypePTRParts(parts)) {
        prefix = `_${parts.subtype}._sub.`;
    }
    else {
        prefix = parts.name ? `${parts.name}.` : "";
    }
    return `${prefix}_${parts.type}._${parts.protocol || "tcp" /* TCP */}.${parts.domain || "local"}.`;
}
exports.stringify = stringify;
function formatHostname(hostname, domain = "local") {
    assert_1.default(!hostname.endsWith("."), "hostname must not end with the root label!");
    const tld = "." + domain;
    return (!hostname.endsWith(tld) ? hostname + tld : hostname) + ".";
}
exports.formatHostname = formatHostname;
function removeTLD(hostname) {
    if (hostname.endsWith(".")) { // check for the DNS root label
        hostname = hostname.substring(0, hostname.length - 1);
    }
    const lastDot = hostname.lastIndexOf(".");
    return hostname.slice(0, lastDot);
}
exports.removeTLD = removeTLD;
function enlargeIPv6(address) {
    assert_1.default(net_1.default.isIPv6(address), "Illegal argument. Must be ipv6 address!");
    // we are not supporting ipv4-mapped ipv6 addresses here
    assert_1.default(!address.includes("."), "ipv4-mapped ipv6 addresses are currently unsupported!");
    const split = address.split(":");
    if (split[0] === "") {
        split.splice(0, 1);
        while (split.length < 8) {
            split.unshift("0000");
        }
    }
    else if (split[split.length - 1] === "") {
        split.splice(split.length - 1, 1);
        while (split.length < 8) {
            split.push("0000");
        }
    }
    else if (split.length < 8) {
        let emptySection;
        for (emptySection = 0; emptySection < split.length; emptySection++) {
            if (split[emptySection] === "") { // find the first empty section
                break;
            }
        }
        const replacements = new Array(9 - split.length).fill("0000");
        split.splice(emptySection, 1, ...replacements);
    }
    for (let i = 0; i < split.length; i++) {
        const element = split[i];
        if (element.length < 4) {
            const zeros = new Array(4 - element.length).fill("0").join("");
            split.splice(i, 1, zeros + element);
        }
    }
    const result = split.join(":");
    assert_1.default(split.length <= 8, `Resulting ipv6 address has more than 8 sections (${result})!`);
    return result;
}
exports.enlargeIPv6 = enlargeIPv6;
function shortenIPv6(address) {
    if (typeof address === "string") {
        address = address.split(":");
    }
    for (let i = 0; i < address.length; i++) {
        const part = address[i];
        let j = 0;
        for (; j < Math.min(3, part.length - 1); j++) { // search for the first index which is non zero, but leaving at least one zero
            if (part.charAt(j) !== "0") {
                break;
            }
        }
        address[i] = part.substr(j);
    }
    let longestBlockOfZerosIndex = -1;
    let longestBlockOfZerosLength = 0;
    for (let i = 0; i < address.length; i++) { // this is not very optimized, but it works
        if (address[i] !== "0") {
            continue;
        }
        let zerosCount = 1;
        let j = i + 1;
        for (; j < address.length; j++) {
            if (address[j] === "0") {
                zerosCount++;
            }
            else {
                break;
            }
        }
        if (zerosCount > longestBlockOfZerosLength) {
            longestBlockOfZerosIndex = i;
            longestBlockOfZerosLength = zerosCount;
        }
        i = j; // skipp all the zeros we already checked + the the one after that, we know that's not a zero
    }
    if (longestBlockOfZerosIndex !== -1) {
        const startOrEnd = longestBlockOfZerosIndex === 0 || (longestBlockOfZerosIndex + longestBlockOfZerosLength === 8);
        address[longestBlockOfZerosIndex] = startOrEnd ? ":" : "";
        if (longestBlockOfZerosLength > 1) {
            address.splice(longestBlockOfZerosIndex + 1, longestBlockOfZerosLength - 1);
        }
    }
    const result = address.join(":");
    if (result === ":") { // special case for the unspecified address
        return "::";
    }
    return result;
}
exports.shortenIPv6 = shortenIPv6;
function formatReverseAddressPTRName(address) {
    if (net_1.default.isIPv4(address)) {
        const split = address.split(".").reverse();
        return split.join(".") + ".in-addr.arpa";
    }
    else if (net_1.default.isIPv6(address)) {
        address = enlargeIPv6(address).toUpperCase();
        const nibbleSplit = address.replace(/:/g, "").split("").reverse();
        assert_1.default(nibbleSplit.length === 32, "Encountered invalid ipv6 address length! " + nibbleSplit.length);
        return nibbleSplit.join(".") + ".ip6.arpa";
    }
    else {
        throw new Error("Supplied illegal ip address format: " + address);
    }
}
exports.formatReverseAddressPTRName = formatReverseAddressPTRName;
function ipAddressFromReversAddressName(name) {
    name = name.toLowerCase();
    if (name.endsWith(".in-addr.arpa")) {
        const split = name.replace(".in-addr.arpa", "").split(".").reverse();
        return split.join(".");
    }
    else if (name.endsWith(".ip6.arpa")) {
        const split = name.replace(".ip6.arpa", "").split(".").reverse();
        assert_1.default(split.length === 32, "Encountered illegal length for .ip6.arpa split!");
        const parts = [];
        for (let i = 0; i < split.length; i += 4) {
            parts.push(split.slice(i, i + 4).join(""));
        }
        return shortenIPv6(parts.join(":"));
    }
    else {
        throw new Error("Supplied unknown reverse address name format: " + name);
    }
}
exports.ipAddressFromReversAddressName = ipAddressFromReversAddressName;
function getNetAddress(address, netmask) {
    assert_1.default(net_1.default.isIP(address) === net_1.default.isIP(netmask), "IP address version must match. Netmask cannot have a version different from the address!");
    if (net_1.default.isIPv4(address)) {
        const addressParts = address.split(".");
        const netmaskParts = netmask.split(".");
        const netAddressParts = new Array(4);
        for (let i = 0; i < addressParts.length; i++) {
            const addressNum = parseInt(addressParts[i]);
            const netmaskNum = parseInt(netmaskParts[i]);
            netAddressParts[i] = (addressNum & netmaskNum).toString();
        }
        return netAddressParts.join(".");
    }
    else if (net_1.default.isIPv6(address)) {
        const addressParts = enlargeIPv6(address).split(":");
        const netmaskParts = enlargeIPv6(netmask).split(":");
        const netAddressParts = new Array(8);
        for (let i = 0; i < addressParts.length; i++) {
            const addressNum = parseInt(addressParts[i], 16);
            const netmaskNum = parseInt(netmaskParts[i], 16);
            netAddressParts[i] = (addressNum & netmaskNum).toString(16);
        }
        return shortenIPv6(enlargeIPv6(netAddressParts.join(":")));
    }
    else {
        throw new Error("Illegal argument. Address is not an ip address!");
    }
}
exports.getNetAddress = getNetAddress;
//# sourceMappingURL=domain-formatter.js.map

/***/ }),

/***/ 8487:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServerClosedError = exports.InterfaceNotFoundError = exports.ERR_SERVER_CLOSED = exports.ERR_INTERFACE_NOT_FOUND = void 0;
exports.ERR_INTERFACE_NOT_FOUND = "ERR_INTERFACE_NOT_FOUND";
exports.ERR_SERVER_CLOSED = "ERR_SERVER_CLOSED";
class InterfaceNotFoundError extends Error {
    constructor(message) {
        super(message);
        this.name = "ERR_INTERFACE_NOT_FOUND";
    }
}
exports.InterfaceNotFoundError = InterfaceNotFoundError;
class ServerClosedError extends Error {
    constructor(message) {
        super(message);
        this.name = exports.ERR_SERVER_CLOSED;
    }
}
exports.ServerClosedError = ServerClosedError;
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ 3620:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromiseTimeout = void 0;
function PromiseTimeout(timeout) {
    return new Promise(resolve => {
        setTimeout(() => resolve(), timeout);
    });
}
exports.PromiseTimeout = PromiseTimeout;
//# sourceMappingURL=promise-utils.js.map

/***/ }),

/***/ 204:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sortedInsert = void 0;
/**
 * Insert into sorted array using binary search.
 *
 * @param array - An already sorted array.
 * @param element - The element to be inserted.
 * @param comparator - Comparator to determine the order for the elements.
 */
function sortedInsert(array, element, comparator) {
    let low = 0;
    let high = array.length - 1;
    let destination = -1; // if it doesn't change, we insert at position 0 (array is empty)
    while (low < high) {
        const mid = Math.floor((low + high) / 2);
        const comparison = comparator(element, array[mid]);
        if (comparison === 0) {
            destination = mid + 1; // we currently don't care in which order items are sorted which have the same "order key"
            break;
        }
        if (comparison < 0) { // meaning element < array[mid]
            high = mid - 1;
        }
        else { // meaning element > array[mid]
            low = mid + 1;
        }
    }
    if (array.length === 0) {
        destination = 0;
    }
    else if (destination < 0) {
        if (comparator(element, array[low]) > 0) {
            destination = low + 1;
        }
        else {
            destination = low;
        }
    }
    // abuse splice method to insert at destination
    array.splice(destination, 0, element);
}
exports.sortedInsert = sortedInsert;
//# sourceMappingURL=sorted-array.js.map

/***/ }),

/***/ 7156:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runTiebreaking = exports.TiebreakingResult = exports.rrComparator = void 0;
function rrComparator(recordA, recordB) {
    if (recordA.class !== recordB.class) {
        return recordA.class - recordB.class;
    }
    if (recordA.type !== recordB.type) {
        return recordA.type - recordB.type;
    }
    // now follows a raw comparison of the binary data
    const aData = recordA.getRawData();
    const bData = recordB.getRawData();
    const maxLength = Math.max(aData.length, bData.length); // get the biggest length
    for (let i = 0; i < maxLength; i++) {
        if (i >= aData.length && i < bData.length) { // a ran out of data and b still holds data
            return -1;
        }
        else if (i >= bData.length && i < aData.length) { // b ran out of data and a still hold data
            return 1;
        }
        const aByte = aData.readUInt8(i);
        const bByte = bData.readUInt8(i);
        if (aByte !== bByte) {
            return aByte < bByte ? -1 : 1;
        }
    }
    // if we reach here we have a tie. both records represent the SAME data.
    return 0;
}
exports.rrComparator = rrComparator;
var TiebreakingResult;
(function (TiebreakingResult) {
    /**
     * The opponent is considered the winner
     */
    TiebreakingResult[TiebreakingResult["OPPONENT"] = -1] = "OPPONENT";
    /**
     * Both try to expose the exact same data
     */
    TiebreakingResult[TiebreakingResult["TIE"] = 0] = "TIE";
    /**
     * The host is considered the winner
     */
    TiebreakingResult[TiebreakingResult["HOST"] = 1] = "HOST";
})(TiebreakingResult = exports.TiebreakingResult || (exports.TiebreakingResult = {}));
/**
 * Runs the tiebreaking algorithm to resolve the race condition of simultaneous probing.
 * The input sets MUST already be sorted.
 *
 * @param {ResourceRecord[]} host - sorted list of records the host wants to publish
 * @param {ResourceRecord[]} opponent - sorted list of records the opponent wants to publish
 * @returns the result {@see TiebreakingResult} of the tiebreaking algorithm
 */
function runTiebreaking(host, opponent) {
    const maxLength = Math.max(host.length, opponent.length);
    for (let i = 0; i < maxLength; i++) {
        if (i >= host.length && i < opponent.length) { // host runs out of records and opponent still has some
            return -1 /* OPPONENT */; // opponent wins
        }
        else if (i >= opponent.length && i < host.length) { // opponent runs out of records and host still has some
            return 1 /* HOST */; // host wins
        }
        const recordComparison = rrComparator(host[i], opponent[i]);
        if (recordComparison !== 0) {
            return recordComparison;
        }
    }
    return 0 /* TIE */; // they expose the exact same data
}
exports.runTiebreaking = runTiebreaking;
//# sourceMappingURL=tiebreaking.js.map

/***/ }),

/***/ 2901:
/***/ ((module) => {


/**
 * Array#filter.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @param {Object=} self
 * @return {Array}
 * @throw TypeError
 */

module.exports = function (arr, fn, self) {
  if (arr.filter) return arr.filter(fn, self);
  if (void 0 === arr || null === arr) throw new TypeError;
  if ('function' != typeof fn) throw new TypeError;
  var ret = [];
  for (var i = 0; i < arr.length; i++) {
    if (!hasOwn.call(arr, i)) continue;
    var val = arr[i];
    if (fn.call(self, val, i, arr)) ret.push(val);
  }
  return ret;
};

var hasOwn = Object.prototype.hasOwnProperty;


/***/ }),

/***/ 9945:
/***/ ((module) => {

"use strict";


/**
 * Expose `arrayFlatten`.
 */
module.exports = flatten
module.exports.from = flattenFrom
module.exports.depth = flattenDepth
module.exports.fromDepth = flattenFromDepth

/**
 * Flatten an array.
 *
 * @param  {Array} array
 * @return {Array}
 */
function flatten (array) {
  if (!Array.isArray(array)) {
    throw new TypeError('Expected value to be an array')
  }

  return flattenFrom(array)
}

/**
 * Flatten an array-like structure.
 *
 * @param  {Array} array
 * @return {Array}
 */
function flattenFrom (array) {
  return flattenDown(array, [])
}

/**
 * Flatten an array-like structure with depth.
 *
 * @param  {Array}  array
 * @param  {number} depth
 * @return {Array}
 */
function flattenDepth (array, depth) {
  if (!Array.isArray(array)) {
    throw new TypeError('Expected value to be an array')
  }

  return flattenFromDepth(array, depth)
}

/**
 * Flatten an array-like structure with depth.
 *
 * @param  {Array}  array
 * @param  {number} depth
 * @return {Array}
 */
function flattenFromDepth (array, depth) {
  if (typeof depth !== 'number') {
    throw new TypeError('Expected the depth to be a number')
  }

  return flattenDownDepth(array, [], depth)
}

/**
 * Flatten an array indefinitely.
 *
 * @param  {Array} array
 * @param  {Array} result
 * @return {Array}
 */
function flattenDown (array, result) {
  for (var i = 0; i < array.length; i++) {
    var value = array[i]

    if (Array.isArray(value)) {
      flattenDown(value, result)
    } else {
      result.push(value)
    }
  }

  return result
}

/**
 * Flatten an array with depth.
 *
 * @param  {Array}  array
 * @param  {Array}  result
 * @param  {number} depth
 * @return {Array}
 */
function flattenDownDepth (array, result, depth) {
  depth--

  for (var i = 0; i < array.length; i++) {
    var value = array[i]

    if (depth > -1 && Array.isArray(value)) {
      flattenDownDepth(value, result, depth)
    } else {
      result.push(value)
    }
  }

  return result
}


/***/ }),

/***/ 3308:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var filter = __nccwpck_require__(2901);

module.exports = function availableTypedArrays() {
	return filter([
		'BigInt64Array',
		'BigUint64Array',
		'Float32Array',
		'Float64Array',
		'Int16Array',
		'Int32Array',
		'Int8Array',
		'Uint16Array',
		'Uint32Array',
		'Uint8Array',
		'Uint8ClampedArray'
	], function (typedArray) {
		return typeof global[typedArray] === 'function';
	});
};


/***/ }),

/***/ 262:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { Buffer } = __nccwpck_require__(4293)
const symbol = Symbol.for('BufferList')

function BufferList (buf) {
  if (!(this instanceof BufferList)) {
    return new BufferList(buf)
  }

  BufferList._init.call(this, buf)
}

BufferList._init = function _init (buf) {
  Object.defineProperty(this, symbol, { value: true })

  this._bufs = []
  this.length = 0

  if (buf) {
    this.append(buf)
  }
}

BufferList.prototype._new = function _new (buf) {
  return new BufferList(buf)
}

BufferList.prototype._offset = function _offset (offset) {
  if (offset === 0) {
    return [0, 0]
  }

  let tot = 0

  for (let i = 0; i < this._bufs.length; i++) {
    const _t = tot + this._bufs[i].length
    if (offset < _t || i === this._bufs.length - 1) {
      return [i, offset - tot]
    }
    tot = _t
  }
}

BufferList.prototype._reverseOffset = function (blOffset) {
  const bufferId = blOffset[0]
  let offset = blOffset[1]

  for (let i = 0; i < bufferId; i++) {
    offset += this._bufs[i].length
  }

  return offset
}

BufferList.prototype.get = function get (index) {
  if (index > this.length || index < 0) {
    return undefined
  }

  const offset = this._offset(index)

  return this._bufs[offset[0]][offset[1]]
}

BufferList.prototype.slice = function slice (start, end) {
  if (typeof start === 'number' && start < 0) {
    start += this.length
  }

  if (typeof end === 'number' && end < 0) {
    end += this.length
  }

  return this.copy(null, 0, start, end)
}

BufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {
  if (typeof srcStart !== 'number' || srcStart < 0) {
    srcStart = 0
  }

  if (typeof srcEnd !== 'number' || srcEnd > this.length) {
    srcEnd = this.length
  }

  if (srcStart >= this.length) {
    return dst || Buffer.alloc(0)
  }

  if (srcEnd <= 0) {
    return dst || Buffer.alloc(0)
  }

  const copy = !!dst
  const off = this._offset(srcStart)
  const len = srcEnd - srcStart
  let bytes = len
  let bufoff = (copy && dstStart) || 0
  let start = off[1]

  // copy/slice everything
  if (srcStart === 0 && srcEnd === this.length) {
    if (!copy) {
      // slice, but full concat if multiple buffers
      return this._bufs.length === 1
        ? this._bufs[0]
        : Buffer.concat(this._bufs, this.length)
    }

    // copy, need to copy individual buffers
    for (let i = 0; i < this._bufs.length; i++) {
      this._bufs[i].copy(dst, bufoff)
      bufoff += this._bufs[i].length
    }

    return dst
  }

  // easy, cheap case where it's a subset of one of the buffers
  if (bytes <= this._bufs[off[0]].length - start) {
    return copy
      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
      : this._bufs[off[0]].slice(start, start + bytes)
  }

  if (!copy) {
    // a slice, we need something to copy in to
    dst = Buffer.allocUnsafe(len)
  }

  for (let i = off[0]; i < this._bufs.length; i++) {
    const l = this._bufs[i].length - start

    if (bytes > l) {
      this._bufs[i].copy(dst, bufoff, start)
      bufoff += l
    } else {
      this._bufs[i].copy(dst, bufoff, start, start + bytes)
      bufoff += l
      break
    }

    bytes -= l

    if (start) {
      start = 0
    }
  }

  // safeguard so that we don't return uninitialized memory
  if (dst.length > bufoff) return dst.slice(0, bufoff)

  return dst
}

BufferList.prototype.shallowSlice = function shallowSlice (start, end) {
  start = start || 0
  end = typeof end !== 'number' ? this.length : end

  if (start < 0) {
    start += this.length
  }

  if (end < 0) {
    end += this.length
  }

  if (start === end) {
    return this._new()
  }

  const startOffset = this._offset(start)
  const endOffset = this._offset(end)
  const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1)

  if (endOffset[1] === 0) {
    buffers.pop()
  } else {
    buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1])
  }

  if (startOffset[1] !== 0) {
    buffers[0] = buffers[0].slice(startOffset[1])
  }

  return this._new(buffers)
}

BufferList.prototype.toString = function toString (encoding, start, end) {
  return this.slice(start, end).toString(encoding)
}

BufferList.prototype.consume = function consume (bytes) {
  // first, normalize the argument, in accordance with how Buffer does it
  bytes = Math.trunc(bytes)
  // do nothing if not a positive number
  if (Number.isNaN(bytes) || bytes <= 0) return this

  while (this._bufs.length) {
    if (bytes >= this._bufs[0].length) {
      bytes -= this._bufs[0].length
      this.length -= this._bufs[0].length
      this._bufs.shift()
    } else {
      this._bufs[0] = this._bufs[0].slice(bytes)
      this.length -= bytes
      break
    }
  }

  return this
}

BufferList.prototype.duplicate = function duplicate () {
  const copy = this._new()

  for (let i = 0; i < this._bufs.length; i++) {
    copy.append(this._bufs[i])
  }

  return copy
}

BufferList.prototype.append = function append (buf) {
  if (buf == null) {
    return this
  }

  if (buf.buffer) {
    // append a view of the underlying ArrayBuffer
    this._appendBuffer(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength))
  } else if (Array.isArray(buf)) {
    for (let i = 0; i < buf.length; i++) {
      this.append(buf[i])
    }
  } else if (this._isBufferList(buf)) {
    // unwrap argument into individual BufferLists
    for (let i = 0; i < buf._bufs.length; i++) {
      this.append(buf._bufs[i])
    }
  } else {
    // coerce number arguments to strings, since Buffer(number) does
    // uninitialized memory allocation
    if (typeof buf === 'number') {
      buf = buf.toString()
    }

    this._appendBuffer(Buffer.from(buf))
  }

  return this
}

BufferList.prototype._appendBuffer = function appendBuffer (buf) {
  this._bufs.push(buf)
  this.length += buf.length
}

BufferList.prototype.indexOf = function (search, offset, encoding) {
  if (encoding === undefined && typeof offset === 'string') {
    encoding = offset
    offset = undefined
  }

  if (typeof search === 'function' || Array.isArray(search)) {
    throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.')
  } else if (typeof search === 'number') {
    search = Buffer.from([search])
  } else if (typeof search === 'string') {
    search = Buffer.from(search, encoding)
  } else if (this._isBufferList(search)) {
    search = search.slice()
  } else if (Array.isArray(search.buffer)) {
    search = Buffer.from(search.buffer, search.byteOffset, search.byteLength)
  } else if (!Buffer.isBuffer(search)) {
    search = Buffer.from(search)
  }

  offset = Number(offset || 0)

  if (isNaN(offset)) {
    offset = 0
  }

  if (offset < 0) {
    offset = this.length + offset
  }

  if (offset < 0) {
    offset = 0
  }

  if (search.length === 0) {
    return offset > this.length ? this.length : offset
  }

  const blOffset = this._offset(offset)
  let blIndex = blOffset[0] // index of which internal buffer we're working on
  let buffOffset = blOffset[1] // offset of the internal buffer we're working on

  // scan over each buffer
  for (; blIndex < this._bufs.length; blIndex++) {
    const buff = this._bufs[blIndex]

    while (buffOffset < buff.length) {
      const availableWindow = buff.length - buffOffset

      if (availableWindow >= search.length) {
        const nativeSearchResult = buff.indexOf(search, buffOffset)

        if (nativeSearchResult !== -1) {
          return this._reverseOffset([blIndex, nativeSearchResult])
        }

        buffOffset = buff.length - search.length + 1 // end of native search window
      } else {
        const revOffset = this._reverseOffset([blIndex, buffOffset])

        if (this._match(revOffset, search)) {
          return revOffset
        }

        buffOffset++
      }
    }

    buffOffset = 0
  }

  return -1
}

BufferList.prototype._match = function (offset, search) {
  if (this.length - offset < search.length) {
    return false
  }

  for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
    if (this.get(offset + searchOffset) !== search[searchOffset]) {
      return false
    }
  }
  return true
}

;(function () {
  const methods = {
    readDoubleBE: 8,
    readDoubleLE: 8,
    readFloatBE: 4,
    readFloatLE: 4,
    readInt32BE: 4,
    readInt32LE: 4,
    readUInt32BE: 4,
    readUInt32LE: 4,
    readInt16BE: 2,
    readInt16LE: 2,
    readUInt16BE: 2,
    readUInt16LE: 2,
    readInt8: 1,
    readUInt8: 1,
    readIntBE: null,
    readIntLE: null,
    readUIntBE: null,
    readUIntLE: null
  }

  for (const m in methods) {
    (function (m) {
      if (methods[m] === null) {
        BufferList.prototype[m] = function (offset, byteLength) {
          return this.slice(offset, offset + byteLength)[m](0, byteLength)
        }
      } else {
        BufferList.prototype[m] = function (offset = 0) {
          return this.slice(offset, offset + methods[m])[m](0)
        }
      }
    }(m))
  }
}())

// Used internally by the class and also as an indicator of this object being
// a `BufferList`. It's not possible to use `instanceof BufferList` in a browser
// environment because there could be multiple different copies of the
// BufferList class and some `BufferList`s might be `BufferList`s.
BufferList.prototype._isBufferList = function _isBufferList (b) {
  return b instanceof BufferList || BufferList.isBufferList(b)
}

BufferList.isBufferList = function isBufferList (b) {
  return b != null && b[symbol]
}

module.exports = BufferList


/***/ }),

/***/ 5075:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const DuplexStream = __nccwpck_require__(1815).Duplex
const inherits = __nccwpck_require__(6919)
const BufferList = __nccwpck_require__(262)

function BufferListStream (callback) {
  if (!(this instanceof BufferListStream)) {
    return new BufferListStream(callback)
  }

  if (typeof callback === 'function') {
    this._callback = callback

    const piper = function piper (err) {
      if (this._callback) {
        this._callback(err)
        this._callback = null
      }
    }.bind(this)

    this.on('pipe', function onPipe (src) {
      src.on('error', piper)
    })
    this.on('unpipe', function onUnpipe (src) {
      src.removeListener('error', piper)
    })

    callback = null
  }

  BufferList._init.call(this, callback)
  DuplexStream.call(this)
}

inherits(BufferListStream, DuplexStream)
Object.assign(BufferListStream.prototype, BufferList.prototype)

BufferListStream.prototype._new = function _new (callback) {
  return new BufferListStream(callback)
}

BufferListStream.prototype._write = function _write (buf, encoding, callback) {
  this._appendBuffer(buf)

  if (typeof callback === 'function') {
    callback()
  }
}

BufferListStream.prototype._read = function _read (size) {
  if (!this.length) {
    return this.push(null)
  }

  size = Math.min(size, this.length)
  this.push(this.slice(0, size))
  this.consume(size)
}

BufferListStream.prototype.end = function end (chunk) {
  DuplexStream.prototype.end.call(this, chunk)

  if (this._callback) {
    this._callback(null, this.slice())
    this._callback = null
  }
}

BufferListStream.prototype._destroy = function _destroy (err, cb) {
  this._bufs.length = 0
  this.length = 0
  cb(err)
}

BufferListStream.prototype._isBufferList = function _isBufferList (b) {
  return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b)
}

BufferListStream.isBufferList = BufferList.isBufferList

module.exports = BufferListStream
module.exports.BufferListStream = BufferListStream
module.exports.BufferList = BufferList


/***/ }),

/***/ 7170:
/***/ ((module) => {

"use strict";


const codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error
  }

  function getMessage (arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message
    } else {
      return message(arg1, arg2, arg3)
    }
  }

  class NodeError extends Base {
    constructor (arg1, arg2, arg3) {
      super(getMessage(arg1, arg2, arg3));
    }
  }

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;

  codes[code] = NodeError;
}

// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    const len = expected.length;
    expected = expected.map((i) => String(i));
    if (len > 2) {
      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` +
             expected[len - 1];
    } else if (len === 2) {
      return `one of ${thing} ${expected[0]} or ${expected[1]}`;
    } else {
      return `of ${thing} ${expected[0]}`;
    }
  } else {
    return `of ${thing} ${String(expected)}`;
  }
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
	return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
	if (this_len === undefined || this_len > str.length) {
		this_len = str.length;
	}
	return str.substring(this_len - search.length, this_len) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"'
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  let determiner;
  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  let msg;
  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;
  } else {
    const type = includes(name, '.') ? 'property' : 'argument';
    msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, 'type')}`;
  }

  msg += `. Received type ${typeof actual}`;
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented'
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');

module.exports.q = codes;


/***/ }),

/***/ 870:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = __nccwpck_require__(8946);

var Writable = __nccwpck_require__(1200);

__nccwpck_require__(6919)(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

/***/ }),

/***/ 44:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.


module.exports = PassThrough;

var Transform = __nccwpck_require__(5910);

__nccwpck_require__(6919)(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ 8946:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = __nccwpck_require__(8614).EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = __nccwpck_require__(3408);
/*</replacement>*/


var Buffer = __nccwpck_require__(4293).Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = __nccwpck_require__(1669);

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = __nccwpck_require__(8741);

var destroyImpl = __nccwpck_require__(9384);

var _require = __nccwpck_require__(6028),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = __nccwpck_require__(7170)/* .codes */ .q,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

__nccwpck_require__(6919)(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || __nccwpck_require__(870);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __nccwpck_require__(1074)/* .StringDecoder */ .s;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __nccwpck_require__(870);
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __nccwpck_require__(1074)/* .StringDecoder */ .s;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = __nccwpck_require__(8933);
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = __nccwpck_require__(5985);
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}

/***/ }),

/***/ 5910:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.


module.exports = Transform;

var _require$codes = __nccwpck_require__(7170)/* .codes */ .q,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = __nccwpck_require__(870);

__nccwpck_require__(6919)(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}

/***/ }),

/***/ 1200:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: __nccwpck_require__(9209)
};
/*</replacement>*/

/*<replacement>*/

var Stream = __nccwpck_require__(3408);
/*</replacement>*/


var Buffer = __nccwpck_require__(4293).Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = __nccwpck_require__(9384);

var _require = __nccwpck_require__(6028),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = __nccwpck_require__(7170)/* .codes */ .q,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

__nccwpck_require__(6919)(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || __nccwpck_require__(870);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __nccwpck_require__(870); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};

/***/ }),

/***/ 8933:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = __nccwpck_require__(9680);

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;

/***/ }),

/***/ 8741:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = __nccwpck_require__(4293),
    Buffer = _require.Buffer;

var _require2 = __nccwpck_require__(1669),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();

/***/ }),

/***/ 9384:
/***/ ((module) => {

"use strict";
 // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};

/***/ }),

/***/ 9680:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).


var ERR_STREAM_PREMATURE_CLOSE = __nccwpck_require__(7170)/* .codes.ERR_STREAM_PREMATURE_CLOSE */ .q.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;

/***/ }),

/***/ 5985:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ERR_INVALID_ARG_TYPE = __nccwpck_require__(7170)/* .codes.ERR_INVALID_ARG_TYPE */ .q.ERR_INVALID_ARG_TYPE;

function from(Readable, iterable, opts) {
  var iterator;

  if (iterable && typeof iterable.next === 'function') {
    iterator = iterable;
  } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();else throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable);

  var readable = new Readable(_objectSpread({
    objectMode: true
  }, opts)); // Reading boolean to protect against _read
  // being called before last iteration completion.

  var reading = false;

  readable._read = function () {
    if (!reading) {
      reading = true;
      next();
    }
  };

  function next() {
    return _next2.apply(this, arguments);
  }

  function _next2() {
    _next2 = _asyncToGenerator(function* () {
      try {
        var _ref = yield iterator.next(),
            value = _ref.value,
            done = _ref.done;

        if (done) {
          readable.push(null);
        } else if (readable.push((yield value))) {
          next();
        } else {
          reading = false;
        }
      } catch (err) {
        readable.destroy(err);
      }
    });
    return _next2.apply(this, arguments);
  }

  return readable;
}

module.exports = from;

/***/ }),

/***/ 6085:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).


var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = __nccwpck_require__(7170)/* .codes */ .q,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = __nccwpck_require__(9680);
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;

/***/ }),

/***/ 6028:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var ERR_INVALID_OPT_VALUE = __nccwpck_require__(7170)/* .codes.ERR_INVALID_OPT_VALUE */ .q.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};

/***/ }),

/***/ 3408:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(2413);


/***/ }),

/***/ 1815:
/***/ ((module, exports, __nccwpck_require__) => {

var Stream = __nccwpck_require__(2413);
if (process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream.Readable;
  Object.assign(module.exports, Stream);
  module.exports.Stream = Stream;
} else {
  exports = module.exports = __nccwpck_require__(8946);
  exports.Stream = Stream || exports;
  exports.Readable = exports;
  exports.Writable = __nccwpck_require__(1200);
  exports.Duplex = __nccwpck_require__(870);
  exports.Transform = __nccwpck_require__(5910);
  exports.PassThrough = __nccwpck_require__(44);
  exports.finished = __nccwpck_require__(9680);
  exports.pipeline = __nccwpck_require__(6085);
}


/***/ }),

/***/ 1074:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = __nccwpck_require__(3118).Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.s = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ 8227:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Registry = __nccwpck_require__(4483)
const Server = __nccwpck_require__(2240)
const Browser = __nccwpck_require__(6334)

function Bonjour (opts) {
  if (!(this instanceof Bonjour)) { return new Bonjour(opts) }

  this._server = new Server(opts)
  this._registry = new Registry(this._server)
}

Bonjour.prototype = {
  publish: function (opts) {
    return this._registry.publish(opts)
  },

  unpublishAll: function (cb) {
    this._registry.unpublishAll(cb)
  },

  find: function (opts, onup) {
    return new Browser(this._server.mdns, opts, onup)
  },

  findOne: function (opts, cb) {
    const browser = new Browser(this._server.mdns, opts)
    browser.once('up', function (service) {
      browser.stop()
      if (cb) cb(service)
    })
    return browser
  },

  destroy: function () {
    this._registry.destroy()
    this._server.mdns.destroy()
  }
}

module.exports = Bonjour


/***/ }),

/***/ 6334:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const util = __nccwpck_require__(1669)
const EventEmitter = __nccwpck_require__(8614).EventEmitter
const serviceName = __nccwpck_require__(8634)
const dnsEqual = __nccwpck_require__(6000)
const dnsTxt = __nccwpck_require__(2860)

const TLD = '.local'
const WILDCARD = '_services._dns-sd._udp' + TLD

module.exports = Browser

util.inherits(Browser, EventEmitter)

/**
 * Start a browser
 *
 * The browser listens for services by querying for PTR records of a given
 * type, protocol and domain, e.g. _http._tcp.local.
 *
 * If no type is given, a wild card search is performed.
 *
 * An internal list of online services is kept which starts out empty. When
 * ever a new service is discovered, it's added to the list and an "up" event
 * is emitted with that service. When it's discovered that the service is no
 * longer available, it is removed from the list and a "down" event is emitted
 * with that service.
 */
function Browser (mdns, opts, onup) {
  if (typeof opts === 'function') return new Browser(mdns, null, opts)

  EventEmitter.call(this)

  this._mdns = mdns
  this._onresponse = null
  this._serviceMap = {}
  this._txt = dnsTxt(opts.txt)

  if (!opts || !opts.type) {
    this._name = WILDCARD
    this._wildcard = true
  } else {
    this._name = serviceName.stringify(opts.type, opts.protocol || 'tcp') + TLD
    if (opts.name) this._name = opts.name + '.' + this._name
    this._wildcard = false
  }

  this.services = []

  if (onup) this.on('up', onup)

  this.start()
}

Browser.prototype.start = function () {
  if (this._onresponse) return

  const self = this

  // List of names for the browser to listen for. In a normal search this will
  // be the primary name stored on the browser. In case of a wildcard search
  // the names will be determined at runtime as responses come in.
  const nameMap = {}
  if (!this._wildcard) nameMap[this._name] = true

  this._onresponse = function (packet, rinfo) {
    if (self._wildcard) {
      packet.answers.forEach(function (answer) {
        if (answer.type !== 'PTR' || answer.name !== self._name || answer.name in nameMap) return
        nameMap[answer.data] = true
        self._mdns.query(answer.data, 'PTR')
      })
    }

    Object.keys(nameMap).forEach(function (name) {
      // unregister all services shutting down
      goodbyes(name, packet).forEach(self._removeService.bind(self))

      // register all new services
      const matches = buildServicesFor(name, packet, self._txt, rinfo)
      if (matches.length === 0) return

      matches.forEach(function (service) {
        if (self._serviceMap[service.fqdn]) return // ignore already registered services
        self._addService(service)
      })
    })
  }

  this._mdns.on('response', this._onresponse)
  this.update()
}

Browser.prototype.stop = function () {
  if (!this._onresponse) return

  this._mdns.removeListener('response', this._onresponse)
  this._onresponse = null
}

Browser.prototype.update = function () {
  this._mdns.query(this._name, 'PTR')
}

Browser.prototype._addService = function (service) {
  this.services.push(service)
  this._serviceMap[service.fqdn] = true
  this.emit('up', service)
}

Browser.prototype._removeService = function (fqdn) {
  let service, index
  this.services.some(function (s, i) {
    if (dnsEqual(s.fqdn, fqdn)) {
      service = s
      index = i
      return true
    }
    return false
  })
  if (!service) return
  this.services.splice(index, 1)
  delete this._serviceMap[fqdn]
  this.emit('down', service)
}

// PTR records with a TTL of 0 is considered a "goodbye" announcement. I.e. a
// DNS response broadcasted when a service shuts down in order to let the
// network know that the service is no longer going to be available.
//
// For more info see:
// https://tools.ietf.org/html/rfc6762#section-8.4
//
// This function returns an array of all resource records considered a goodbye
// record
function goodbyes (name, packet) {
  return packet.answers.concat(packet.additionals)
    .filter(function (rr) {
      return rr.type === 'PTR' && rr.ttl === 0 && dnsEqual(rr.name, name)
    })
    .map(function (rr) {
      return rr.data
    })
}

function buildServicesFor (name, packet, txt, referer) {
  const records = packet.answers.concat(packet.additionals).filter(function (rr) {
    return rr.ttl > 0 // ignore goodbye messages
  })

  return records
    .filter(function (rr) {
      return rr.type === 'PTR' && dnsEqual(rr.name, name)
    })
    .map(function (ptr) {
      const service = {
        addresses: []
      }

      records
        .filter(function (rr) {
          return (rr.type === 'SRV' || rr.type === 'TXT') && dnsEqual(rr.name, ptr.data)
        })
        .forEach(function (rr) {
          if (rr.type === 'SRV') {
            const parts = rr.name.split('.')
            const name = parts[0]
            const types = serviceName.parse(parts.slice(1, -1).join('.'))
            service.name = name
            service.fqdn = rr.name
            service.host = rr.data.target
            service.referer = referer
            service.port = rr.data.port
            service.type = types.name
            service.protocol = types.protocol
            service.subtypes = types.subtypes
          } else if (rr.type === 'TXT') {
            // rr.data is an Array of Buffer instead of Buffer
            service.rawTxt = rr.data // array of buffers, each representing a block
            service.txt = txt.decodeBlocks(service.rawTxt)
          }
        })

      if (!service.name) return undefined

      records
        .filter(function (rr) {
          return (rr.type === 'A' || rr.type === 'AAAA') && dnsEqual(rr.name, service.host)
        })
        .forEach(function (rr) {
          service.addresses.push(rr.data)
        })

      return service
    })
    .filter(function (rr) {
      return !!rr
    })
}


/***/ }),

/***/ 1361:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const dnsEqual = __nccwpck_require__(6000)

/**
 * Check if a service name is already in use on the network.
 *
 * Used before announcing the new service.
 *
 * To guard against race conditions where multiple services are started
 * simultaneously on the network, wait a random amount of time (between
 * 0 and 250 ms) before probing.
 *
 * TODO: Add support for Simultaneous Probe Tiebreaking:
 * https://tools.ietf.org/html/rfc6762#section-8.2
 */

const Prober = function (mdns, service, cb) {
  this.sent = false
  this.retries = 0
  this.timer = null
  this.cb = cb
  this.mdns = mdns
  this.service = service
  this.bound = this.onMDNSresponse.bind(this)
  this.matchRRBound = this.matchRR.bind(this)
}

Prober.prototype = {

  start: function () {
    this.mdns.on('response', this.bound)
    setTimeout(this.try.bind(this), Math.random() * 250)
  },

  try: function () {
    // abort if the service have or is being stopped in the meantime
    if (!this.service._activated || this.service._destroyed) return

    this.mdns.query(this.service.fqdn, 'ANY', function () {
      // This function will optionally be called with an error object. We'll
      // just silently ignore it and retry as we normally would
      this.sent = true
      this.timer = setTimeout(++this.retries < 3 ? this.try.bind(this) : this.done.bind(this, false), 250)
      this.timer.unref()
    }.bind(this))
  },

  matchRR: function (rr) {
    return dnsEqual(rr.name, this.service.fqdn)
  },

  onMDNSresponse: function (packet) {
    // Apparently conflicting Multicast DNS responses received *before*
    // the first probe packet is sent MUST be silently ignored (see
    // discussion of stale probe packets in RFC 6762 Section 8.2,
    // "Simultaneous Probe Tiebreaking" at
    // https://tools.ietf.org/html/rfc6762#section-8.2
    if (!this.sent) { return }

    if (packet.answers.some(this.matchRRBound) || packet.additionals.some(this.matchRRBound)) { this.done(true) }
  },

  done: function (success) {
    this.mdns.removeListener('response', this.bound)
    clearTimeout(this.timer)
    this.cb(success)
  }

}

module.exports = Prober


/***/ }),

/***/ 4483:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const flatten = __nccwpck_require__(9945)
const Service = __nccwpck_require__(6029)
const Prober = __nccwpck_require__(1361)

const Registry = function (server) {
  this._server = server
  this._services = []
}

Registry.prototype = {

  publish: function (opts) {
    opts = opts || {}
    const service = new Service(opts)
    service.on('service-publish', this._onServicePublish.bind(this))
    service.on('service-unpublish', this._onServiceUnpublish.bind(this))
    service.on('service-announce-request', this._onAnnounceRequest.bind(this))
    service.on('service-packet-change', this._onServiceChange.bind(this))
    service.start()
    return service
  },

  unpublishAll: function (cb) {
    this._tearDown(this._services, cb)
    this._services = []
  },

  destroy: function () {
    for (let i = 0; i < this._services.length; i++) { this._services[i].destroy() }
  },

  /**
     * Stop the given services
     *
     * Besides removing a service from the mDNS registry, a "goodbye"
     * message is sent for each service to let the network know about the
     * shutdown.
     */
  _tearDown: function (services, cb) {
    if (!Array.isArray(services)) { services = [services] }

    services = services.filter(function (service) {
      return service._activated // ignore services not currently starting or started
    })

    const records = flatten.depth(services.map(function (service) {
      service.deactivate()
      const records = service._records(true)
      records.forEach(function (record) {
        record.ttl = 0 // prepare goodbye message
      })
      return records
    }), 1)

    if (records.length === 0) { return cb && cb() }

    this._server.unregister(records)

    this._server.mdns.respond(records, this._onTearDownComplete.bind(this, services, cb))
  },

  _onTearDownComplete: function (services, cb) {
    for (let i = 0; i < services.length; i++) { services[i].published = false }

    if (cb) { cb.apply(null, Array.prototype.slice.call(arguments, 2)) }
  },

  _onServiceChange: function (oldPackets) {
    this._server.unregister(oldPackets)
  },

  /**
     * Initial service announcement
     *
     * Used to announce new services when they are first registered.
     *
     * Broadcasts right away, then after 3 seconds, 9 seconds, 27 seconds,
     * and so on, up to a maximum interval of one hour.
     */
  _onAnnounceRequest: function (packet, silent, cb) {
    this._server.register(packet)
    if (!silent) {
      this._server.mdns.respond(packet, cb)
    }
  },

  _onServiceUnpublish: function (service, cb) {
    const index = this._services.indexOf(service)

    this._tearDown(service, cb)

    if (index !== -1) { this._services.splice(index, 1) }
  },

  _onServicePublish: function (service) {
    this._services.push(service)

    if (service.probe) { (new Prober(this._server.mdns, service, this._onProbeComplete.bind(this, service))).start() } else { service.announce() }
  },

  _onProbeComplete: function (service, exists) {
    if (!exists) { return service.announce() }

    // Handle error
    service.stop()
    service.emit('error', new Error('Service name is already in use on the network'))
  }

}

module.exports = Registry


/***/ }),

/***/ 2240:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const multicastdns = __nccwpck_require__(2870)
const dnsEqual = __nccwpck_require__(6000)
const flatten = __nccwpck_require__(9945)
const helpers = __nccwpck_require__(8350)

const Server = function (opts) {
  this.mdns = multicastdns(opts)
  this.mdns.setMaxListeners(0)
  this.registry = {}
  this.mdns.on('query', this._respondToQuery.bind(this))
}

Server.prototype = {
  _respondToQuery: function (query) {
    for (let i = 0; i < query.questions.length; i++) {
      const question = query.questions[i]

      const type = question.type
      const name = question.name

      // generate the answers section
      const answers = type === 'ANY'
        ? flatten.depth(Object.keys(this.registry).map(this._recordsFor.bind(this, name)), 1)
        : this._recordsFor(name, type)

      if (answers.length === 0) return

      // generate the additionals section
      let additionals = []
      if (type !== 'ANY') {
        answers.forEach(answer => {
          if (answer.type !== 'PTR') return
          additionals = additionals
            .concat(this._recordsFor(answer.data, 'SRV'))
            .concat(this._recordsFor(answer.data, 'TXT'))
        })

        // to populate the A and AAAA records, we need to get a set of unique
        // targets from the SRV record
        additionals
          .filter(record => {
            return record.type === 'SRV'
          })
          .map(record => {
            return record.data.target
          })
          .filter(helpers.unique())
          .forEach(target => {
            additionals = additionals
              .concat(this._recordsFor(target, 'A'))
              .concat(this._recordsFor(target, 'AAAA'))
          })
      }

      this.mdns.respond({
        answers: answers,
        additionals: additionals
      }, err => {
        if (err) throw err // TODO: Handle this (if no callback is given, the error will be ignored)
      })
    }
  },

  register: function (records) {
    if (!Array.isArray(records)) { records = [records] }

    for (let i = 0; i < records.length; i++) {
      const record = records[i]
      let subRegistry = this.registry[record.type]

      if (!subRegistry) {
        subRegistry = this.registry[record.type] = []
      } else if (subRegistry.some(helpers.isDuplicateRecord(record))) {
        continue
      }

      subRegistry.push(record)
    }
  },

  unregister: function (records) {
    if (!Array.isArray(records)) { records = [records] }

    for (let i = 0; i < records.length; i++) {
      const record = records[i]
      const type = record.type

      if (!(type in this.registry)) { continue }

      this.registry[type] = this.registry[type].filter(r => {
        return r.name !== record.name
      })
    }
  },

  _recordsFor: function (name, type) {
    if (!(type in this.registry)) { return [] }

    return this.registry[type].filter(record => {
      const recordName = ~name.indexOf('.') ? record.name : record.name.split('.')[0]
      return dnsEqual(recordName, name)
    })
  }

}

module.exports = Server


/***/ }),

/***/ 6029:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const os = __nccwpck_require__(2087)
const util = __nccwpck_require__(1669)
const net = __nccwpck_require__(1631)
const assert = __nccwpck_require__(2357)
const EventEmitter = __nccwpck_require__(8614).EventEmitter
const serviceName = __nccwpck_require__(8634)
const network = __nccwpck_require__(3333)

const TLD = '.local'
const REANNOUNCE_MAX_MS = 60 * 60 * 1000
const REANNOUNCE_FACTOR = 3

const Service = function (opts) {
  if (!opts.name) throw new Error('Required name not given')
  if (!opts.type) throw new Error('Required type not given')
  if (!opts.port) throw new Error('Required port not given')

  this.name = opts.name
  this.protocol = opts.protocol || 'tcp'
  this.probe = opts.probe !== false
  this.type = serviceName.stringify(opts.type, this.protocol)
  this.host = opts.host || os.hostname()
  this.port = opts.port
  this.fqdn = this.name + '.' + this.type + TLD
  this.subtypes = opts.subtypes || null
  this.txt = opts.txt || null
  this.published = false

  // adds the meta query to the records array
  // this option can only be turned on if only one service is advertised on the responder
  // otherwise it will break when one service is removed from the network
  this.addUnsafeServiceEnumerationRecord = opts.addUnsafeServiceEnumerationRecord || false

  this.restrictedAddresses = undefined
  if (opts.restrictedAddresses) {
    assert(opts.restrictedAddresses.length, "The service property 'restrictedAddresses' cannot be an empty array!")
    this.restrictedAddresses = new Map()

    for (const entry of opts.restrictedAddresses) {
      if (net.isIP(entry)) {
        if (entry === '0.0.0.0' || entry === '::') {
          throw new Error(`[${this.fqdn}] Unspecified ip address (${entry}) cannot be used to restrict on to!`)
        }

        const interfaceName = network.resolveInterface(entry)
        if (!interfaceName) {
          throw new Error(`[${this.fqdn}] Could not restrict service to address ${entry} as we could not resolve it to an interface name!`)
        }

        const current = this.restrictedAddresses.get(interfaceName)
        if (current) {
          // empty interface signals "catch all" was already configured for this
          if (current.length && !current.includes(entry)) {
            current.push(entry)
          }
        } else {
          this.restrictedAddresses.set(interfaceName, [entry])
        }
      } else {
        this.restrictedAddresses.set(entry, []) // empty array signals "use all addresses for interface"
      }
    }
  }

  this.disabledIpv6 = opts.disabledIpv6 || false

  this._activated = false // indicates intent - true: starting/started, false: stopping/stopped
}

util.inherits(Service, EventEmitter)

const proto = {

  start: function () {
    if (this._activated) { return }

    this._activated = true

    this.emit('service-publish', this)
  },

  stop: function (cb) {
    if (!this._activated) {
      cb()
      return
    }

    this.emit('service-unpublish', this, cb)
  },

  updateTxt: function (txt, silent) {
    if (this.packet) { this.emit('service-packet-change', this.packet, this.onAnnounceComplete.bind(this)) }
    this.packet = null
    this.txt = txt

    if (!this.published) { return }

    this._unpublish()
    this.announce(silent)
  },

  announce: function (silent) {
    if (this._destroyed) { return }

    if (!this.packet) { this.packet = this._records() }

    if (this.timer) { clearTimeout(this.timer) }

    this.delay = 1000
    this.emit('service-announce-request', this.packet, silent || false, this.onAnnounceComplete.bind(this))
  },

  onAnnounceComplete: function () {
    if (!this.published) {
      this._activated = true // not sure if this is needed here
      this.published = true
      this.emit('up')
    }

    this.delay = this.delay * REANNOUNCE_FACTOR
    if (this.delay < REANNOUNCE_MAX_MS && !this._destroyed && this._activated) {
      this.timer = setTimeout(this.announce.bind(this), this.delay).unref()
    } else {
      this.timer = undefined
      this.delay = undefined
    }
  },

  deactivate: function () {
    this._unpublish()
    this._activated = false
  },

  destroy: function () {
    this._unpublish()
    this.removeAllListeners()
    this._destroyed = true
  },

  _unpublish: function () {
    if (this.timer) { clearTimeout(this.timer) }

    this.published = false
  },

  _records: function (teardown) {
    const records = [this._rrPtr(), this._rrSrv(), this._rrTxt()]

    records.push(...this._addressRecords())

    if (!teardown && this.addUnsafeServiceEnumerationRecord) {
      records.push(this._rrMetaPtr())
    }

    return records
  },

  _addressRecords: function () {
    const records = []
    const addresses = []

    Object.entries(os.networkInterfaces()).forEach(([name, interfaces]) => {
      let restrictedAddresses = this.restrictedAddresses ? this.restrictedAddresses.get(name) : undefined
      if (this.restrictedAddresses && !restrictedAddresses) {
        return
      }

      if (restrictedAddresses && restrictedAddresses.length === 0) {
        restrictedAddresses = undefined
      }

      interfaces.forEach(iface => {
        if (iface.internal || addresses.includes(iface.address)) {
          return
        }

        if (restrictedAddresses && restrictedAddresses.includes(iface.address)) {
          return
        }

        if (iface.family === 'IPv4') {
          records.push(this._rrA(iface.address))
          addresses.push(iface.address)
        } else if (!this.disabledIpv6) {
          records.push(this._rrAaaa(iface.address))
          addresses.push(iface.address)
        }
      })
    })

    return records
  },

  _rrMetaPtr: function () {
    return {
      name: '_services._dns-sd._udp.local',
      type: 'PTR',
      ttl: 4500,
      data: this.type + TLD
    }
  },

  _rrPtr: function () {
    return {
      name: this.type + TLD,
      type: 'PTR',
      ttl: 4500,
      data: this.fqdn
    }
  },

  _rrSrv: function () {
    return {
      name: this.fqdn,
      type: 'SRV',
      ttl: 120,
      flush: true,
      data: {
        port: this.port,
        target: this.host
      }
    }
  },

  _rrTxt: function () {
    const data = []
    if (this.txt) {
      const txtRecords = this.txt
      const keys = Object.keys(txtRecords)
      keys.forEach((key) => {
        const val = txtRecords[key]
        data.push(key + '=' + val)
      })
    }
    return {
      name: this.fqdn,
      type: 'TXT',
      ttl: 4500,
      flush: true,
      data: data
    }
  },

  _rrA: function (ip) {
    return {
      name: this.host,
      type: 'A',
      ttl: 120,
      flush: true,
      data: ip
    }
  },

  _rrAaaa: function (ip) {
    return {
      name: this.host,
      type: 'AAAA',
      ttl: 120,
      flush: true,
      data: ip
    }
  }

}

for (const x in proto) { Service.prototype[x] = proto[x] }

module.exports = Service


/***/ }),

/***/ 8350:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const deepEqual = __nccwpck_require__(2124)

module.exports = {

  isDuplicateRecord: function (a) {
    return function (b) {
      return a.type === b.type &&
                a.name === b.name &&
                deepEqual(a.data, b.data)
    }
  },

  unique: function () {
    const set = []
    return function (obj) {
      if (~set.indexOf(obj)) return false
      set.push(obj)
      return true
    }
  }

}


/***/ }),

/***/ 6000:
/***/ ((module) => {

"use strict";


const r = /[A-Z]/g

module.exports = function (a, b) {
  a = a.replace(r, replacer)
  b = b.replace(r, replacer)
  return a === b
}

function replacer (m) {
  return m.toLowerCase()
}


/***/ }),

/***/ 3333:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const os = __nccwpck_require__(2087)

function resolveInterface (address) {
  for (const [name, infoArray] of Object.entries(os.networkInterfaces())) {
    for (const info of infoArray) {
      if (info.address === address) {
        return name
      }
    }
  }

  return undefined
}

module.exports = {
  resolveInterface: resolveInterface
}


/***/ }),

/***/ 2860:
/***/ ((module) => {

"use strict";


const equalSign = Buffer.from('=')

module.exports = function (opts) {
  const binary = opts ? opts.binary : false
  const that = {}

  that.decodeBlocks = function (bufArray) {
    const data = {}

    bufArray.forEach(buf => {
      if (buf.length === 0) {
        return // ignore: most likely a single zero byte
      }

      const i = buf.indexOf(equalSign)

      if (i === -1) { // equal sign does not exist
        data[buf.toString().toLowerCase()] = true
      } else if (i > 0) { // we ignore zero key-length blocks
        const key = buf.slice(0, i).toString().toLowerCase()

        if (key in data) { // ignore: overwriting not allowed
          return
        }

        const valueBuf = buf.slice(i + 1)
        data[key] = binary ? valueBuf : valueBuf.toString()
      }
    })

    return data
  }

  return that
}


/***/ }),

/***/ 2420:
/***/ ((module) => {

var toString = Object.prototype.toString

var isModern = (
  typeof Buffer.alloc === 'function' &&
  typeof Buffer.allocUnsafe === 'function' &&
  typeof Buffer.from === 'function'
)

function isArrayBuffer (input) {
  return toString.call(input).slice(8, -1) === 'ArrayBuffer'
}

function fromArrayBuffer (obj, byteOffset, length) {
  byteOffset >>>= 0

  var maxLength = obj.byteLength - byteOffset

  if (maxLength < 0) {
    throw new RangeError("'offset' is out of bounds")
  }

  if (length === undefined) {
    length = maxLength
  } else {
    length >>>= 0

    if (length > maxLength) {
      throw new RangeError("'length' is out of bounds")
    }
  }

  return isModern
    ? Buffer.from(obj.slice(byteOffset, byteOffset + length))
    : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)))
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  return isModern
    ? Buffer.from(string, encoding)
    : new Buffer(string, encoding)
}

function bufferFrom (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value)) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return isModern
    ? Buffer.from(value)
    : new Buffer(value)
}

module.exports = bufferFrom


/***/ }),

/***/ 8749:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var GetIntrinsic = __nccwpck_require__(9879);

var callBind = __nccwpck_require__(3112);

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),

/***/ 3112:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var bind = __nccwpck_require__(4517);
var GetIntrinsic = __nccwpck_require__(9879);

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),

/***/ 3487:
/***/ ((__unused_webpack_module, exports) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


/***/ }),

/***/ 5535:
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ 9851:
/***/ ((module, exports, __nccwpck_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __nccwpck_require__(6033)(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ 6033:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __nccwpck_require__(5535);
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ 7984:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __nccwpck_require__(9851);
} else {
	module.exports = __nccwpck_require__(3860);
}


/***/ }),

/***/ 3860:
/***/ ((module, exports, __nccwpck_require__) => {

/**
 * Module dependencies.
 */

const tty = __nccwpck_require__(3867);
const util = __nccwpck_require__(1669);

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	() => {},
	'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
);

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __nccwpck_require__(395);

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.format(...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __nccwpck_require__(6033)(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.split('\n')
		.map(str => str.trim())
		.join(' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),

/***/ 2124:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var objectKeys = __nccwpck_require__(5283);
var isArguments = __nccwpck_require__(6312);
var is = __nccwpck_require__(5450);
var isRegex = __nccwpck_require__(7239);
var flags = __nccwpck_require__(8495);
var isArray = __nccwpck_require__(8147);
var isDate = __nccwpck_require__(4044);
var whichBoxedPrimitive = __nccwpck_require__(481);
var GetIntrinsic = __nccwpck_require__(9879);
var callBound = __nccwpck_require__(8749);
var whichCollection = __nccwpck_require__(2454);
var getIterator = __nccwpck_require__(9697);
var getSideChannel = __nccwpck_require__(3616);
var whichTypedArray = __nccwpck_require__(2715);
var assign = __nccwpck_require__(5599);

var $getTime = callBound('Date.prototype.getTime');
var gPO = Object.getPrototypeOf;
var $objToString = callBound('Object.prototype.toString');

var $Set = GetIntrinsic('%Set%', true);
var $mapHas = callBound('Map.prototype.has', true);
var $mapGet = callBound('Map.prototype.get', true);
var $mapSize = callBound('Map.prototype.size', true);
var $setAdd = callBound('Set.prototype.add', true);
var $setDelete = callBound('Set.prototype.delete', true);
var $setHas = callBound('Set.prototype.has', true);
var $setSize = callBound('Set.prototype.size', true);

// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L401-L414
function setHasEqualElement(set, val1, opts, channel) {
  var i = getIterator(set);
  var result;
  while ((result = i.next()) && !result.done) {
    if (internalDeepEqual(val1, result.value, opts, channel)) { // eslint-disable-line no-use-before-define
      // Remove the matching element to make sure we do not check that again.
      $setDelete(set, result.value);
      return true;
    }
  }

  return false;
}

// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L416-L439
function findLooseMatchingPrimitives(prim) {
  if (typeof prim === 'undefined') {
    return null;
  }
  if (typeof prim === 'object') { // Only pass in null as object!
    return void 0;
  }
  if (typeof prim === 'symbol') {
    return false;
  }
  if (typeof prim === 'string' || typeof prim === 'number') {
    // Loose equal entries exist only if the string is possible to convert to a regular number and not NaN.
    return +prim === +prim; // eslint-disable-line no-implicit-coercion
  }
  return true;
}

// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L449-L460
function mapMightHaveLoosePrim(a, b, prim, item, opts, channel) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) {
    return altValue;
  }
  var curB = $mapGet(b, altValue);
  var looseOpts = assign({}, opts, { strict: false });
  if (
    (typeof curB === 'undefined' && !$mapHas(b, altValue))
    // eslint-disable-next-line no-use-before-define
    || !internalDeepEqual(item, curB, looseOpts, channel)
  ) {
    return false;
  }
  // eslint-disable-next-line no-use-before-define
  return !$mapHas(a, altValue) && internalDeepEqual(item, curB, looseOpts, channel);
}

// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L441-L447
function setMightHaveLoosePrim(a, b, prim) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) {
    return altValue;
  }

  return $setHas(b, altValue) && !$setHas(a, altValue);
}

// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L518-L533
function mapHasEqualEntry(set, map, key1, item1, opts, channel) {
  var i = getIterator(set);
  var result;
  var key2;
  while ((result = i.next()) && !result.done) {
    key2 = result.value;
    if (
      // eslint-disable-next-line no-use-before-define
      internalDeepEqual(key1, key2, opts, channel)
      // eslint-disable-next-line no-use-before-define
      && internalDeepEqual(item1, $mapGet(map, key2), opts, channel)
    ) {
      $setDelete(set, key2);
      return true;
    }
  }

  return false;
}

function internalDeepEqual(actual, expected, options, channel) {
  var opts = options || {};

  // 7.1. All identical values are equivalent, as determined by ===.
  if (opts.strict ? is(actual, expected) : actual === expected) {
    return true;
  }

  var actualBoxed = whichBoxedPrimitive(actual);
  var expectedBoxed = whichBoxedPrimitive(expected);
  if (actualBoxed !== expectedBoxed) {
    return false;
  }

  // 7.3. Other pairs that do not both pass typeof value == 'object', equivalence is determined by ==.
  if (!actual || !expected || (typeof actual !== 'object' && typeof expected !== 'object')) {
    return opts.strict ? is(actual, expected) : actual == expected; // eslint-disable-line eqeqeq
  }

  /*
   * 7.4. For all other Object pairs, including Array objects, equivalence is
   * determined by having the same number of owned properties (as verified
   * with Object.prototype.hasOwnProperty.call), the same set of keys
   * (although not necessarily the same order), equivalent values for every
   * corresponding key, and an identical 'prototype' property. Note: this
   * accounts for both named and indexed properties on Arrays.
   */
  // see https://github.com/nodejs/node/commit/d3aafd02efd3a403d646a3044adcf14e63a88d32 for memos/channel inspiration

  var hasActual = channel.has(actual);
  var hasExpected = channel.has(expected);
  var sentinel;
  if (hasActual && hasExpected) {
    if (channel.get(actual) === channel.get(expected)) {
      return true;
    }
  } else {
    sentinel = {};
  }
  if (!hasActual) { channel.set(actual, sentinel); }
  if (!hasExpected) { channel.set(expected, sentinel); }

  // eslint-disable-next-line no-use-before-define
  return objEquiv(actual, expected, opts, channel);
}

function isBuffer(x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') {
    return false;
  }
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') {
    return false;
  }

  return !!(x.constructor && x.constructor.isBuffer && x.constructor.isBuffer(x));
}

function setEquiv(a, b, opts, channel) {
  if ($setSize(a) !== $setSize(b)) {
    return false;
  }
  var iA = getIterator(a);
  var iB = getIterator(b);
  var resultA;
  var resultB;
  var set;
  while ((resultA = iA.next()) && !resultA.done) {
    if (resultA.value && typeof resultA.value === 'object') {
      if (!set) { set = new $Set(); }
      $setAdd(set, resultA.value);
    } else if (!$setHas(b, resultA.value)) {
      if (opts.strict) { return false; }
      if (!setMightHaveLoosePrim(a, b, resultA.value)) {
        return false;
      }
      if (!set) { set = new $Set(); }
      $setAdd(set, resultA.value);
    }
  }
  if (set) {
    while ((resultB = iB.next()) && !resultB.done) {
      // We have to check if a primitive value is already matching and only if it's not, go hunting for it.
      if (resultB.value && typeof resultB.value === 'object') {
        if (!setHasEqualElement(set, resultB.value, opts.strict, channel)) {
          return false;
        }
      } else if (
        !opts.strict
        && !$setHas(a, resultB.value)
        && !setHasEqualElement(set, resultB.value, opts.strict, channel)
      ) {
        return false;
      }
    }
    return $setSize(set) === 0;
  }
  return true;
}

function mapEquiv(a, b, opts, channel) {
  if ($mapSize(a) !== $mapSize(b)) {
    return false;
  }
  var iA = getIterator(a);
  var iB = getIterator(b);
  var resultA;
  var resultB;
  var set;
  var key;
  var item1;
  var item2;
  while ((resultA = iA.next()) && !resultA.done) {
    key = resultA.value[0];
    item1 = resultA.value[1];
    if (key && typeof key === 'object') {
      if (!set) { set = new $Set(); }
      $setAdd(set, key);
    } else {
      item2 = $mapGet(b, key);
      if ((typeof item2 === 'undefined' && !$mapHas(b, key)) || !internalDeepEqual(item1, item2, opts, channel)) {
        if (opts.strict) {
          return false;
        }
        if (!mapMightHaveLoosePrim(a, b, key, item1, opts, channel)) {
          return false;
        }
        if (!set) { set = new $Set(); }
        $setAdd(set, key);
      }
    }
  }

  if (set) {
    while ((resultB = iB.next()) && !resultB.done) {
      key = resultB.value[0];
      item2 = resultB.value[1];
      if (key && typeof key === 'object') {
        if (!mapHasEqualEntry(set, a, key, item2, opts, channel)) {
          return false;
        }
      } else if (
        !opts.strict
        && (!a.has(key) || !internalDeepEqual($mapGet(a, key), item2, opts, channel))
        && !mapHasEqualEntry(set, a, key, item2, assign({}, opts, { strict: false }), channel)
      ) {
        return false;
      }
    }
    return $setSize(set) === 0;
  }
  return true;
}

function objEquiv(a, b, opts, channel) {
  /* eslint max-statements: [2, 100], max-lines-per-function: [2, 120], max-depth: [2, 5] */
  var i, key;

  if (typeof a !== typeof b) { return false; }
  if (a == null || b == null) { return false; }

  if ($objToString(a) !== $objToString(b)) { return false; }

  if (isArguments(a) !== isArguments(b)) { return false; }

  var aIsArray = isArray(a);
  var bIsArray = isArray(b);
  if (aIsArray !== bIsArray) { return false; }

  // TODO: replace when a cross-realm brand check is available
  var aIsError = a instanceof Error;
  var bIsError = b instanceof Error;
  if (aIsError !== bIsError) { return false; }
  if (aIsError || bIsError) {
    if (a.name !== b.name || a.message !== b.message) { return false; }
  }

  var aIsRegex = isRegex(a);
  var bIsRegex = isRegex(b);
  if (aIsRegex !== bIsRegex) { return false; }
  if ((aIsRegex || bIsRegex) && (a.source !== b.source || flags(a) !== flags(b))) {
    return false;
  }

  var aIsDate = isDate(a);
  var bIsDate = isDate(b);
  if (aIsDate !== bIsDate) { return false; }
  if (aIsDate || bIsDate) { // && would work too, because both are true or both false here
    if ($getTime(a) !== $getTime(b)) { return false; }
  }
  if (opts.strict && gPO && gPO(a) !== gPO(b)) { return false; }

  if (whichTypedArray(a) !== whichTypedArray(b)) {
    return false;
  }

  var aIsBuffer = isBuffer(a);
  var bIsBuffer = isBuffer(b);
  if (aIsBuffer !== bIsBuffer) { return false; }
  if (aIsBuffer || bIsBuffer) { // && would work too, because both are true or both false here
    if (a.length !== b.length) { return false; }
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) { return false; }
    }
    return true;
  }

  if (typeof a !== typeof b) { return false; }

  var ka = objectKeys(a);
  var kb = objectKeys(b);
  // having the same number of owned properties (keys incorporates hasOwnProperty)
  if (ka.length !== kb.length) { return false; }

  // the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  // ~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i]) { return false; } // eslint-disable-line eqeqeq
  }

  // equivalent values for every corresponding key, and ~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!internalDeepEqual(a[key], b[key], opts, channel)) { return false; }
  }

  var aCollection = whichCollection(a);
  var bCollection = whichCollection(b);
  if (aCollection !== bCollection) {
    return false;
  }
  if (aCollection === 'Set' || bCollection === 'Set') { // aCollection === bCollection
    return setEquiv(a, b, opts, channel);
  }
  if (aCollection === 'Map') { // aCollection === bCollection
    return mapEquiv(a, b, opts, channel);
  }

  return true;
}

module.exports = function deepEqual(a, b, opts) {
  return internalDeepEqual(a, b, opts, getSideChannel());
};


/***/ }),

/***/ 8147:
/***/ ((module) => {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ 8961:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var keys = __nccwpck_require__(5283);
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		origDefineProperty(obj, 'x', { enumerable: false, value: obj });
		// eslint-disable-next-line no-unused-vars, no-restricted-syntax
		for (var _ in obj) { // jscs:ignore disallowUnusedVariables
			return false;
		}
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		origDefineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;


/***/ }),

/***/ 4355:
/***/ ((module) => {

/**
 * Diff Match and Patch
 * Copyright 2018 The diff-match-patch Authors.
 * https://github.com/google/diff-match-patch
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Computes the difference between two texts to create a patch.
 * Applies the patch onto another text, allowing for errors.
 * @author fraser@google.com (Neil Fraser)
 */

/**
 * Class containing the diff, match and patch methods.
 * @constructor
 */
var diff_match_patch = function() {

  // Defaults.
  // Redefine these in your program to override the defaults.

  // Number of seconds to map a diff before giving up (0 for infinity).
  this.Diff_Timeout = 1.0;
  // Cost of an empty edit operation in terms of edit characters.
  this.Diff_EditCost = 4;
  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
  this.Match_Threshold = 0.5;
  // How far to search for a match (0 = exact location, 1000+ = broad match).
  // A match this many characters away from the expected location will add
  // 1.0 to the score (0.0 is a perfect match).
  this.Match_Distance = 1000;
  // When deleting a large block of text (over ~64 characters), how close do
  // the contents have to be to match the expected contents. (0.0 = perfection,
  // 1.0 = very loose).  Note that Match_Threshold controls how closely the
  // end points of a delete need to match.
  this.Patch_DeleteThreshold = 0.5;
  // Chunk size for context length.
  this.Patch_Margin = 4;

  // The number of bits in an int.
  this.Match_MaxBits = 32;
};


//  DIFF FUNCTIONS


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;

/**
 * Class representing one diff tuple.
 * ~Attempts to look like a two-element array (which is what this used to be).~
 * Constructor returns an actual two-element array, to allow destructing @JackuB
 * See https://github.com/JackuB/diff-match-patch/issues/14 for details
 * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.
 * @param {string} text Text to be deleted, inserted, or retained.
 * @constructor
 */
diff_match_patch.Diff = function(op, text) {
  return [op, text];
};

/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean=} opt_checklines Optional speedup flag. If present and false,
 *     then don't run a line-level diff first to identify the changed areas.
 *     Defaults to true, which does a faster, slightly less optimal diff.
 * @param {number=} opt_deadline Optional time when the diff should be complete
 *     by.  Used internally for recursive calls.  Users should set DiffTimeout
 *     instead.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 */
diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,
    opt_deadline) {
  // Set a deadline by which time the diff must be complete.
  if (typeof opt_deadline == 'undefined') {
    if (this.Diff_Timeout <= 0) {
      opt_deadline = Number.MAX_VALUE;
    } else {
      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;
    }
  }
  var deadline = opt_deadline;

  // Check for null inputs.
  if (text1 == null || text2 == null) {
    throw new Error('Null input. (diff_main)');
  }

  // Check for equality (speedup).
  if (text1 == text2) {
    if (text1) {
      return [new diff_match_patch.Diff(DIFF_EQUAL, text1)];
    }
    return [];
  }

  if (typeof opt_checklines == 'undefined') {
    opt_checklines = true;
  }
  var checklines = opt_checklines;

  // Trim off common prefix (speedup).
  var commonlength = this.diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);

  // Trim off common suffix (speedup).
  commonlength = this.diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);

  // Compute the diff on the middle block.
  var diffs = this.diff_compute_(text1, text2, checklines, deadline);

  // Restore the prefix and suffix.
  if (commonprefix) {
    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, commonprefix));
  }
  if (commonsuffix) {
    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, commonsuffix));
  }
  this.diff_cleanupMerge(diffs);
  return diffs;
};


/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean} checklines Speedup flag.  If false, then don't run a
 *     line-level diff first to identify the changed areas.
 *     If true, then run a faster, slightly less optimal diff.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,
    deadline) {
  var diffs;

  if (!text1) {
    // Just add some text (speedup).
    return [new diff_match_patch.Diff(DIFF_INSERT, text2)];
  }

  if (!text2) {
    // Just delete some text (speedup).
    return [new diff_match_patch.Diff(DIFF_DELETE, text1)];
  }

  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i != -1) {
    // Shorter text is inside the longer text (speedup).
    diffs = [new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(0, i)),
             new diff_match_patch.Diff(DIFF_EQUAL, shorttext),
             new diff_match_patch.Diff(DIFF_INSERT,
                 longtext.substring(i + shorttext.length))];
    // Swap insertions for deletions if diff is reversed.
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }

  if (shorttext.length == 1) {
    // Single character string.
    // After the previous speedup, the character can't be an equality.
    return [new diff_match_patch.Diff(DIFF_DELETE, text1),
            new diff_match_patch.Diff(DIFF_INSERT, text2)];
  }

  // Check to see if the problem can be split in two.
  var hm = this.diff_halfMatch_(text1, text2);
  if (hm) {
    // A half-match was found, sort out the return data.
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    // Send both pairs off for separate processing.
    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
    // Merge the results.
    return diffs_a.concat([new diff_match_patch.Diff(DIFF_EQUAL, mid_common)],
                          diffs_b);
  }

  if (checklines && text1.length > 100 && text2.length > 100) {
    return this.diff_lineMode_(text1, text2, deadline);
  }

  return this.diff_bisect_(text1, text2, deadline);
};


/**
 * Do a quick line-level diff on both strings, then rediff the parts for
 * greater accuracy.
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
  // Scan the text on a line-by-line basis first.
  var a = this.diff_linesToChars_(text1, text2);
  text1 = a.chars1;
  text2 = a.chars2;
  var linearray = a.lineArray;

  var diffs = this.diff_main(text1, text2, false, deadline);

  // Convert the diff back to original text.
  this.diff_charsToLines_(diffs, linearray);
  // Eliminate freak matches (e.g. blank lines)
  this.diff_cleanupSemantic(diffs);

  // Rediff any replacement blocks, this time character-by-character.
  // Add a dummy entry at the end.
  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete >= 1 && count_insert >= 1) {
          // Delete the offending records and add the merged ones.
          diffs.splice(pointer - count_delete - count_insert,
                       count_delete + count_insert);
          pointer = pointer - count_delete - count_insert;
          var subDiff =
              this.diff_main(text_delete, text_insert, false, deadline);
          for (var j = subDiff.length - 1; j >= 0; j--) {
            diffs.splice(pointer, 0, subDiff[j]);
          }
          pointer = pointer + subDiff.length;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
    pointer++;
  }
  diffs.pop();  // Remove the dummy entry at the end.

  return diffs;
};


/**
 * Find the 'middle snake' of a diff, split the problem in two
 * and return the recursively constructed diff.
 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = Math.ceil((text1_length + text2_length) / 2);
  var v_offset = max_d;
  var v_length = 2 * max_d;
  var v1 = new Array(v_length);
  var v2 = new Array(v_length);
  // Setting all elements to -1 is faster in Chrome & Firefox than mixing
  // integers and undefined.
  for (var x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  var delta = text1_length - text2_length;
  // If the total number of characters is odd, then the front path will collide
  // with the reverse path.
  var front = (delta % 2 != 0);
  // Offsets for start and end of k loop.
  // Prevents mapping of space beyond the grid.
  var k1start = 0;
  var k1end = 0;
  var k2start = 0;
  var k2end = 0;
  for (var d = 0; d < max_d; d++) {
    // Bail out if deadline is reached.
    if ((new Date()).getTime() > deadline) {
      break;
    }

    // Walk the front path one step.
    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      var k1_offset = v_offset + k1;
      var x1;
      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
        x1 = v1[k1_offset + 1];
      } else {
        x1 = v1[k1_offset - 1] + 1;
      }
      var y1 = x1 - k1;
      while (x1 < text1_length && y1 < text2_length &&
             text1.charAt(x1) == text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        // Ran off the right of the graph.
        k1end += 2;
      } else if (y1 > text2_length) {
        // Ran off the bottom of the graph.
        k1start += 2;
      } else if (front) {
        var k2_offset = v_offset + delta - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
          // Mirror x2 onto top-left coordinate system.
          var x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            // Overlap detected.
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }

    // Walk the reverse path one step.
    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      var k2_offset = v_offset + k2;
      var x2;
      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
        x2 = v2[k2_offset + 1];
      } else {
        x2 = v2[k2_offset - 1] + 1;
      }
      var y2 = x2 - k2;
      while (x2 < text1_length && y2 < text2_length &&
             text1.charAt(text1_length - x2 - 1) ==
             text2.charAt(text2_length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        // Ran off the left of the graph.
        k2end += 2;
      } else if (y2 > text2_length) {
        // Ran off the top of the graph.
        k2start += 2;
      } else if (!front) {
        var k1_offset = v_offset + delta - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
          var x1 = v1[k1_offset];
          var y1 = v_offset + x1 - k1_offset;
          // Mirror x2 onto top-left coordinate system.
          x2 = text1_length - x2;
          if (x1 >= x2) {
            // Overlap detected.
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }
  }
  // Diff took too long and hit the deadline or
  // number of diffs equals number of characters, no commonality at all.
  return [new diff_match_patch.Diff(DIFF_DELETE, text1),
          new diff_match_patch.Diff(DIFF_INSERT, text2)];
};


/**
 * Given the location of the 'middle snake', split the diff in two parts
 * and recurse.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} x Index of split point in text1.
 * @param {number} y Index of split point in text2.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,
    deadline) {
  var text1a = text1.substring(0, x);
  var text2a = text2.substring(0, y);
  var text1b = text1.substring(x);
  var text2b = text2.substring(y);

  // Compute both diffs serially.
  var diffs = this.diff_main(text1a, text2a, false, deadline);
  var diffsb = this.diff_main(text1b, text2b, false, deadline);

  return diffs.concat(diffsb);
};


/**
 * Split two texts into an array of strings.  Reduce the texts to a string of
 * hashes where each Unicode character represents one line.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}
 *     An object containing the encoded text1, the encoded text2 and
 *     the array of unique strings.
 *     The zeroth element of the array of unique strings is intentionally blank.
 * @private
 */
diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
  var lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
  var lineHash = {};   // e.g. lineHash['Hello\n'] == 4

  // '\x00' is a valid character, but various debuggers don't like it.
  // So we'll insert a junk entry to avoid generating a null character.
  lineArray[0] = '';

  /**
   * Split a text into an array of strings.  Reduce the texts to a string of
   * hashes where each Unicode character represents one line.
   * Modifies linearray and linehash through being a closure.
   * @param {string} text String to encode.
   * @return {string} Encoded string.
   * @private
   */
  function diff_linesToCharsMunge_(text) {
    var chars = '';
    // Walk the text, pulling out a substring for each line.
    // text.split('\n') would would temporarily double our memory footprint.
    // Modifying text would create many large strings to garbage collect.
    var lineStart = 0;
    var lineEnd = -1;
    // Keeping our own length variable is faster than looking it up.
    var lineArrayLength = lineArray.length;
    while (lineEnd < text.length - 1) {
      lineEnd = text.indexOf('\n', lineStart);
      if (lineEnd == -1) {
        lineEnd = text.length - 1;
      }
      var line = text.substring(lineStart, lineEnd + 1);

      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :
          (lineHash[line] !== undefined)) {
        chars += String.fromCharCode(lineHash[line]);
      } else {
        if (lineArrayLength == maxLines) {
          // Bail out at 65535 because
          // String.fromCharCode(65536) == String.fromCharCode(0)
          line = text.substring(lineStart);
          lineEnd = text.length;
        }
        chars += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
      lineStart = lineEnd + 1;
    }
    return chars;
  }
  // Allocate 2/3rds of the space for text1, the rest for text2.
  var maxLines = 40000;
  var chars1 = diff_linesToCharsMunge_(text1);
  maxLines = 65535;
  var chars2 = diff_linesToCharsMunge_(text2);
  return {chars1: chars1, chars2: chars2, lineArray: lineArray};
};


/**
 * Rehydrate the text in a diff from a string of line hashes to real lines of
 * text.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {!Array.<string>} lineArray Array of unique strings.
 * @private
 */
diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
  for (var i = 0; i < diffs.length; i++) {
    var chars = diffs[i][1];
    var text = [];
    for (var j = 0; j < chars.length; j++) {
      text[j] = lineArray[chars.charCodeAt(j)];
    }
    diffs[i][1] = text.join('');
  }
};


/**
 * Determine the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: https://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) ==
        text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 ||
      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: https://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
        text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine if the suffix of one string is the prefix of another.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of the first
 *     string and the start of the second string.
 * @private
 */
diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  // Eliminate the null case.
  if (text1_length == 0 || text2_length == 0) {
    return 0;
  }
  // Truncate the longer string.
  if (text1_length > text2_length) {
    text1 = text1.substring(text1_length - text2_length);
  } else if (text1_length < text2_length) {
    text2 = text2.substring(0, text1_length);
  }
  var text_length = Math.min(text1_length, text2_length);
  // Quick check for the worst case.
  if (text1 == text2) {
    return text_length;
  }

  // Start by looking for a single character match
  // and increase length until no match is found.
  // Performance analysis: https://neil.fraser.name/news/2010/11/04/
  var best = 0;
  var length = 1;
  while (true) {
    var pattern = text1.substring(text_length - length);
    var found = text2.indexOf(pattern);
    if (found == -1) {
      return best;
    }
    length += found;
    if (found == 0 || text1.substring(text_length - length) ==
        text2.substring(0, length)) {
      best = length;
      length++;
    }
  }
};


/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 * @private
 */
diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
  if (this.Diff_Timeout <= 0) {
    // Don't risk returning a non-optimal diff if we have unlimited time.
    return null;
  }
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
    return null;  // Pointless.
  }
  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string.
   * @param {string} shorttext Shorter string.
   * @param {number} i Start index of quarter length substring within longtext.
   * @return {Array.<string>} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */
  function diff_halfMatchI_(longtext, shorttext, i) {
    // Start with a 1/4 length substring at position i as a seed.
    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    var j = -1;
    var best_common = '';
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),
                                               shorttext.substring(j));
      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),
                                               shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext.substring(j - suffixLength, j) +
            shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext.length) {
      return [best_longtext_a, best_longtext_b,
              best_shorttext_a, best_shorttext_b, best_common];
    } else {
      return null;
    }
  }

  // First check if the second quarter is the seed for a half-match.
  var hm1 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 4));
  // Check again based on the third quarter.
  var hm2 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 2));
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    // Both matched.  Select the longest.
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }

  // A half-match was found, sort out the return data.
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
};


/**
 * Reduce the number of edits by eliminating semantically trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  /** @type {?string} */
  var lastEquality = null;
  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
  var pointer = 0;  // Index of current position.
  // Number of characters that changed prior to the equality.
  var length_insertions1 = 0;
  var length_deletions1 = 0;
  // Number of characters that changed after the equality.
  var length_insertions2 = 0;
  var length_deletions2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
      equalities[equalitiesLength++] = pointer;
      length_insertions1 = length_insertions2;
      length_deletions1 = length_deletions2;
      length_insertions2 = 0;
      length_deletions2 = 0;
      lastEquality = diffs[pointer][1];
    } else {  // An insertion or deletion.
      if (diffs[pointer][0] == DIFF_INSERT) {
        length_insertions2 += diffs[pointer][1].length;
      } else {
        length_deletions2 += diffs[pointer][1].length;
      }
      // Eliminate an equality that is smaller or equal to the edits on both
      // sides of it.
      if (lastEquality && (lastEquality.length <=
          Math.max(length_insertions1, length_deletions1)) &&
          (lastEquality.length <= Math.max(length_insertions2,
                                           length_deletions2))) {
        // Duplicate record.
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        // Throw away the equality we just deleted.
        equalitiesLength--;
        // Throw away the previous equality (it needs to be reevaluated).
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_insertions1 = 0;  // Reset the counters.
        length_deletions1 = 0;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastEquality = null;
        changes = true;
      }
    }
    pointer++;
  }

  // Normalize the diff.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
  this.diff_cleanupSemanticLossless(diffs);

  // Find any overlaps between deletions and insertions.
  // e.g: <del>abcxxx</del><ins>xxxdef</ins>
  //   -> <del>abc</del>xxx<ins>def</ins>
  // e.g: <del>xxxabc</del><ins>defxxx</ins>
  //   -> <ins>def</ins>xxx<del>abc</del>
  // Only extract an overlap if it is as big as the edit ahead or behind it.
  pointer = 1;
  while (pointer < diffs.length) {
    if (diffs[pointer - 1][0] == DIFF_DELETE &&
        diffs[pointer][0] == DIFF_INSERT) {
      var deletion = diffs[pointer - 1][1];
      var insertion = diffs[pointer][1];
      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
      if (overlap_length1 >= overlap_length2) {
        if (overlap_length1 >= deletion.length / 2 ||
            overlap_length1 >= insertion.length / 2) {
          // Overlap found.  Insert an equality and trim the surrounding edits.
          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,
              insertion.substring(0, overlap_length1)));
          diffs[pointer - 1][1] =
              deletion.substring(0, deletion.length - overlap_length1);
          diffs[pointer + 1][1] = insertion.substring(overlap_length1);
          pointer++;
        }
      } else {
        if (overlap_length2 >= deletion.length / 2 ||
            overlap_length2 >= insertion.length / 2) {
          // Reverse overlap found.
          // Insert an equality and swap and trim the surrounding edits.
          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,
              deletion.substring(0, overlap_length2)));
          diffs[pointer - 1][0] = DIFF_INSERT;
          diffs[pointer - 1][1] =
              insertion.substring(0, insertion.length - overlap_length2);
          diffs[pointer + 1][0] = DIFF_DELETE;
          diffs[pointer + 1][1] =
              deletion.substring(overlap_length2);
          pointer++;
        }
      }
      pointer++;
    }
    pointer++;
  }
};


/**
 * Look for single edits surrounded on both sides by equalities
 * which can be shifted sideways to align the edit to a word boundary.
 * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
  /**
   * Given two strings, compute a score representing whether the internal
   * boundary falls on logical boundaries.
   * Scores range from 6 (best) to 0 (worst).
   * Closure, but does not reference any external variables.
   * @param {string} one First string.
   * @param {string} two Second string.
   * @return {number} The score.
   * @private
   */
  function diff_cleanupSemanticScore_(one, two) {
    if (!one || !two) {
      // Edges are the best.
      return 6;
    }

    // Each port of this function behaves slightly differently due to
    // subtle differences in each language's definition of things like
    // 'whitespace'.  Since this function's purpose is largely cosmetic,
    // the choice has been made to use each language's native features
    // rather than force total conformity.
    var char1 = one.charAt(one.length - 1);
    var char2 = two.charAt(0);
    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
    var whitespace1 = nonAlphaNumeric1 &&
        char1.match(diff_match_patch.whitespaceRegex_);
    var whitespace2 = nonAlphaNumeric2 &&
        char2.match(diff_match_patch.whitespaceRegex_);
    var lineBreak1 = whitespace1 &&
        char1.match(diff_match_patch.linebreakRegex_);
    var lineBreak2 = whitespace2 &&
        char2.match(diff_match_patch.linebreakRegex_);
    var blankLine1 = lineBreak1 &&
        one.match(diff_match_patch.blanklineEndRegex_);
    var blankLine2 = lineBreak2 &&
        two.match(diff_match_patch.blanklineStartRegex_);

    if (blankLine1 || blankLine2) {
      // Five points for blank lines.
      return 5;
    } else if (lineBreak1 || lineBreak2) {
      // Four points for line breaks.
      return 4;
    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
      // Three points for end of sentences.
      return 3;
    } else if (whitespace1 || whitespace2) {
      // Two points for whitespace.
      return 2;
    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
      // One point for non-alphanumeric.
      return 1;
    }
    return 0;
  }

  var pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      var equality1 = diffs[pointer - 1][1];
      var edit = diffs[pointer][1];
      var equality2 = diffs[pointer + 1][1];

      // First, shift the edit as far left as possible.
      var commonOffset = this.diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        var commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }

      // Second, step character by character right, looking for the best fit.
      var bestEquality1 = equality1;
      var bestEdit = edit;
      var bestEquality2 = equality2;
      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +
          diff_cleanupSemanticScore_(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        var score = diff_cleanupSemanticScore_(equality1, edit) +
            diff_cleanupSemanticScore_(edit, equality2);
        // The >= encourages trailing rather than leading whitespace on edits.
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }

      if (diffs[pointer - 1][1] != bestEquality1) {
        // We have an improvement, save it back to the diff.
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
};

// Define some regex patterns for matching boundaries.
diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
diff_match_patch.whitespaceRegex_ = /\s/;
diff_match_patch.linebreakRegex_ = /[\r\n]/;
diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;

/**
 * Reduce the number of edits by eliminating operationally trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  /** @type {?string} */
  var lastEquality = null;
  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
  var pointer = 0;  // Index of current position.
  // Is there an insertion operation before the last equality.
  var pre_ins = false;
  // Is there a deletion operation before the last equality.
  var pre_del = false;
  // Is there an insertion operation after the last equality.
  var post_ins = false;
  // Is there a deletion operation after the last equality.
  var post_del = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
      if (diffs[pointer][1].length < this.Diff_EditCost &&
          (post_ins || post_del)) {
        // Candidate found.
        equalities[equalitiesLength++] = pointer;
        pre_ins = post_ins;
        pre_del = post_del;
        lastEquality = diffs[pointer][1];
      } else {
        // Not a candidate, and can never become one.
        equalitiesLength = 0;
        lastEquality = null;
      }
      post_ins = post_del = false;
    } else {  // An insertion or deletion.
      if (diffs[pointer][0] == DIFF_DELETE) {
        post_del = true;
      } else {
        post_ins = true;
      }
      /*
       * Five types to be split:
       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
       * <ins>A</ins>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<ins>C</ins>
       * <ins>A</del>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<del>C</del>
       */
      if (lastEquality && ((pre_ins && pre_del && post_ins && post_del) ||
                           ((lastEquality.length < this.Diff_EditCost / 2) &&
                            (pre_ins + pre_del + post_ins + post_del) == 3))) {
        // Duplicate record.
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;  // Throw away the equality we just deleted;
        lastEquality = null;
        if (pre_ins && pre_del) {
          // No changes made which could affect previous entry, keep going.
          post_ins = post_del = true;
          equalitiesLength = 0;
        } else {
          equalitiesLength--;  // Throw away the previous equality.
          pointer = equalitiesLength > 0 ?
              equalities[equalitiesLength - 1] : -1;
          post_ins = post_del = false;
        }
        changes = true;
      }
    }
    pointer++;
  }

  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
  // Add a dummy entry at the end.
  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            // Factor out any common prefixies.
            commonlength = this.diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if ((pointer - count_delete - count_insert) > 0 &&
                  diffs[pointer - count_delete - count_insert - 1][0] ==
                  DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] +=
                    text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, new diff_match_patch.Diff(DIFF_EQUAL,
                    text_insert.substring(0, commonlength)));
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixies.
            commonlength = this.diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length -
                  commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length -
                  commonlength);
              text_delete = text_delete.substring(0, text_delete.length -
                  commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          pointer -= count_delete + count_insert;
          diffs.splice(pointer, count_delete + count_insert);
          if (text_delete.length) {
            diffs.splice(pointer, 0,
                new diff_match_patch.Diff(DIFF_DELETE, text_delete));
            pointer++;
          }
          if (text_insert.length) {
            diffs.splice(pointer, 0,
                new diff_match_patch.Diff(DIFF_INSERT, text_insert));
            pointer++;
          }
          pointer++;
        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === '') {
    diffs.pop();  // Remove the dummy entry at the end.
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length -
          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] +
            diffs[pointer][1].substring(0, diffs[pointer][1].length -
                                        diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
          diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] =
            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
            diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another shift sweep.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * loc is a location in text1, compute and return the equivalent location in
 * text2.
 * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {number} loc Location within text1.
 * @return {number} Location within text2.
 */
diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
  var chars1 = 0;
  var chars2 = 0;
  var last_chars1 = 0;
  var last_chars2 = 0;
  var x;
  for (x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.
      chars1 += diffs[x][1].length;
    }
    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.
      chars2 += diffs[x][1].length;
    }
    if (chars1 > loc) {  // Overshot the location.
      break;
    }
    last_chars1 = chars1;
    last_chars2 = chars2;
  }
  // Was the location was deleted?
  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
    return last_chars2;
  }
  // Add the remaining character length.
  return last_chars2 + (loc - last_chars1);
};


/**
 * Convert a diff array into a pretty HTML report.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} HTML representation.
 */
diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
  var html = [];
  var pattern_amp = /&/g;
  var pattern_lt = /</g;
  var pattern_gt = />/g;
  var pattern_para = /\n/g;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];    // Operation (insert, delete, equal)
    var data = diffs[x][1];  // Text of change.
    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')
        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');
    switch (op) {
      case DIFF_INSERT:
        html[x] = '<ins style="background:#e6ffe6;">' + text + '</ins>';
        break;
      case DIFF_DELETE:
        html[x] = '<del style="background:#ffe6e6;">' + text + '</del>';
        break;
      case DIFF_EQUAL:
        html[x] = '<span>' + text + '</span>';
        break;
    }
  }
  return html.join('');
};


/**
 * Compute and return the source text (all equalities and deletions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Source text.
 */
diff_match_patch.prototype.diff_text1 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute and return the destination text (all equalities and insertions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Destination text.
 */
diff_match_patch.prototype.diff_text2 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_DELETE) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute the Levenshtein distance; the number of inserted, deleted or
 * substituted characters.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {number} Number of changes.
 */
diff_match_patch.prototype.diff_levenshtein = function(diffs) {
  var levenshtein = 0;
  var insertions = 0;
  var deletions = 0;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];
    var data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        // A deletion and an insertion is one substitution.
        levenshtein += Math.max(insertions, deletions);
        insertions = 0;
        deletions = 0;
        break;
    }
  }
  levenshtein += Math.max(insertions, deletions);
  return levenshtein;
};


/**
 * Crush the diff into an encoded string which describes the operations
 * required to transform text1 into text2.
 * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
 * Operations are tab-separated.  Inserted text is escaped using %xx notation.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Delta text.
 */
diff_match_patch.prototype.diff_toDelta = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    switch (diffs[x][0]) {
      case DIFF_INSERT:
        text[x] = '+' + encodeURI(diffs[x][1]);
        break;
      case DIFF_DELETE:
        text[x] = '-' + diffs[x][1].length;
        break;
      case DIFF_EQUAL:
        text[x] = '=' + diffs[x][1].length;
        break;
    }
  }
  return text.join('\t').replace(/%20/g, ' ');
};


/**
 * Given the original text1, and an encoded string which describes the
 * operations required to transform text1 into text2, compute the full diff.
 * @param {string} text1 Source string for the diff.
 * @param {string} delta Delta text.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
  var diffs = [];
  var diffsLength = 0;  // Keeping our own length var is faster in JS.
  var pointer = 0;  // Cursor in text1
  var tokens = delta.split(/\t/g);
  for (var x = 0; x < tokens.length; x++) {
    // Each token begins with a one character parameter which specifies the
    // operation of this token (delete, insert, equality).
    var param = tokens[x].substring(1);
    switch (tokens[x].charAt(0)) {
      case '+':
        try {
          diffs[diffsLength++] =
              new diff_match_patch.Diff(DIFF_INSERT, decodeURI(param));
        } catch (ex) {
          // Malformed URI sequence.
          throw new Error('Illegal escape in diff_fromDelta: ' + param);
        }
        break;
      case '-':
        // Fall through.
      case '=':
        var n = parseInt(param, 10);
        if (isNaN(n) || n < 0) {
          throw new Error('Invalid number in diff_fromDelta: ' + param);
        }
        var text = text1.substring(pointer, pointer += n);
        if (tokens[x].charAt(0) == '=') {
          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_EQUAL, text);
        } else {
          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_DELETE, text);
        }
        break;
      default:
        // Blank tokens are ok (from a trailing \t).
        // Anything else is an error.
        if (tokens[x]) {
          throw new Error('Invalid diff operation in diff_fromDelta: ' +
                          tokens[x]);
        }
    }
  }
  if (pointer != text1.length) {
    throw new Error('Delta length (' + pointer +
        ') does not equal source text length (' + text1.length + ').');
  }
  return diffs;
};


//  MATCH FUNCTIONS


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc'.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 */
diff_match_patch.prototype.match_main = function(text, pattern, loc) {
  // Check for null inputs.
  if (text == null || pattern == null || loc == null) {
    throw new Error('Null input. (match_main)');
  }

  loc = Math.max(0, Math.min(loc, text.length));
  if (text == pattern) {
    // Shortcut (potentially not guaranteed by the algorithm)
    return 0;
  } else if (!text.length) {
    // Nothing to match.
    return -1;
  } else if (text.substring(loc, loc + pattern.length) == pattern) {
    // Perfect match at the perfect spot!  (Includes case of null pattern)
    return loc;
  } else {
    // Do a fuzzy compare.
    return this.match_bitap_(text, pattern, loc);
  }
};


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc' using the
 * Bitap algorithm.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 * @private
 */
diff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {
  if (pattern.length > this.Match_MaxBits) {
    throw new Error('Pattern too long for this browser.');
  }

  // Initialise the alphabet.
  var s = this.match_alphabet_(pattern);

  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Compute and return the score for a match with e errors and x location.
   * Accesses loc and pattern through being a closure.
   * @param {number} e Number of errors in match.
   * @param {number} x Location of match.
   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
   * @private
   */
  function match_bitapScore_(e, x) {
    var accuracy = e / pattern.length;
    var proximity = Math.abs(loc - x);
    if (!dmp.Match_Distance) {
      // Dodge divide by zero error.
      return proximity ? 1.0 : accuracy;
    }
    return accuracy + (proximity / dmp.Match_Distance);
  }

  // Highest score beyond which we give up.
  var score_threshold = this.Match_Threshold;
  // Is there a nearby exact match? (speedup)
  var best_loc = text.indexOf(pattern, loc);
  if (best_loc != -1) {
    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
    // What about in the other direction? (speedup)
    best_loc = text.lastIndexOf(pattern, loc + pattern.length);
    if (best_loc != -1) {
      score_threshold =
          Math.min(match_bitapScore_(0, best_loc), score_threshold);
    }
  }

  // Initialise the bit arrays.
  var matchmask = 1 << (pattern.length - 1);
  best_loc = -1;

  var bin_min, bin_mid;
  var bin_max = pattern.length + text.length;
  var last_rd;
  for (var d = 0; d < pattern.length; d++) {
    // Scan for the best match; each iteration allows for one more error.
    // Run a binary search to determine how far from 'loc' we can stray at this
    // error level.
    bin_min = 0;
    bin_mid = bin_max;
    while (bin_min < bin_mid) {
      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
        bin_min = bin_mid;
      } else {
        bin_max = bin_mid;
      }
      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
    }
    // Use the result from this iteration as the maximum for the next.
    bin_max = bin_mid;
    var start = Math.max(1, loc - bin_mid + 1);
    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;

    var rd = Array(finish + 2);
    rd[finish + 1] = (1 << d) - 1;
    for (var j = finish; j >= start; j--) {
      // The alphabet (s) is a sparse hash, so the following line generates
      // warnings.
      var charMatch = s[text.charAt(j - 1)];
      if (d === 0) {  // First pass: exact match.
        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
      } else {  // Subsequent passes: fuzzy match.
        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |
                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |
                last_rd[j + 1];
      }
      if (rd[j] & matchmask) {
        var score = match_bitapScore_(d, j - 1);
        // This match will almost certainly be better than any existing match.
        // But check anyway.
        if (score <= score_threshold) {
          // Told you so.
          score_threshold = score;
          best_loc = j - 1;
          if (best_loc > loc) {
            // When passing loc, don't exceed our current distance from loc.
            start = Math.max(1, 2 * loc - best_loc);
          } else {
            // Already passed loc, downhill from here on in.
            break;
          }
        }
      }
    }
    // No hope for a (better) match at greater error levels.
    if (match_bitapScore_(d + 1, loc) > score_threshold) {
      break;
    }
    last_rd = rd;
  }
  return best_loc;
};


/**
 * Initialise the alphabet for the Bitap algorithm.
 * @param {string} pattern The text to encode.
 * @return {!Object} Hash of character locations.
 * @private
 */
diff_match_patch.prototype.match_alphabet_ = function(pattern) {
  var s = {};
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] = 0;
  }
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);
  }
  return s;
};


//  PATCH FUNCTIONS


/**
 * Increase the context until it is unique,
 * but don't let the pattern expand beyond Match_MaxBits.
 * @param {!diff_match_patch.patch_obj} patch The patch to grow.
 * @param {string} text Source text.
 * @private
 */
diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
  if (text.length == 0) {
    return;
  }
  if (patch.start2 === null) {
    throw Error('patch not initialized');
  }
  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
  var padding = 0;

  // Look for the first and last matches of pattern in text.  If two different
  // matches are found, increase the pattern length.
  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&
         pattern.length < this.Match_MaxBits - this.Patch_Margin -
         this.Patch_Margin) {
    padding += this.Patch_Margin;
    pattern = text.substring(patch.start2 - padding,
                             patch.start2 + patch.length1 + padding);
  }
  // Add one chunk for good luck.
  padding += this.Patch_Margin;

  // Add the prefix.
  var prefix = text.substring(patch.start2 - padding, patch.start2);
  if (prefix) {
    patch.diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, prefix));
  }
  // Add the suffix.
  var suffix = text.substring(patch.start2 + patch.length1,
                              patch.start2 + patch.length1 + padding);
  if (suffix) {
    patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, suffix));
  }

  // Roll back the start points.
  patch.start1 -= prefix.length;
  patch.start2 -= prefix.length;
  // Extend the lengths.
  patch.length1 += prefix.length + suffix.length;
  patch.length2 += prefix.length + suffix.length;
};


/**
 * Compute a list of patches to turn text1 into text2.
 * Use diffs if provided, otherwise compute it ourselves.
 * There are four ways to call this function, depending on what data is
 * available to the caller:
 * Method 1:
 * a = text1, b = text2
 * Method 2:
 * a = diffs
 * Method 3 (optimal):
 * a = text1, b = diffs
 * Method 4 (deprecated, use method 3):
 * a = text1, b = text2, c = diffs
 *
 * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or
 * Array of diff tuples for text1 to text2 (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>=} opt_b text2 (methods 1,4) or
 * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>=} opt_c Array of diff tuples
 * for text1 to text2 (method 4) or undefined (methods 1,2,3).
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
  var text1, diffs;
  if (typeof a == 'string' && typeof opt_b == 'string' &&
      typeof opt_c == 'undefined') {
    // Method 1: text1, text2
    // Compute diffs from text1 and text2.
    text1 = /** @type {string} */(a);
    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);
    if (diffs.length > 2) {
      this.diff_cleanupSemantic(diffs);
      this.diff_cleanupEfficiency(diffs);
    }
  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&
      typeof opt_c == 'undefined') {
    // Method 2: diffs
    // Compute text1 from diffs.
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);
    text1 = this.diff_text1(diffs);
  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&
      typeof opt_c == 'undefined') {
    // Method 3: text1, diffs
    text1 = /** @type {string} */(a);
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);
  } else if (typeof a == 'string' && typeof opt_b == 'string' &&
      opt_c && typeof opt_c == 'object') {
    // Method 4: text1, text2, diffs
    // text2 is not used.
    text1 = /** @type {string} */(a);
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);
  } else {
    throw new Error('Unknown call format to patch_make.');
  }

  if (diffs.length === 0) {
    return [];  // Get rid of the null case.
  }
  var patches = [];
  var patch = new diff_match_patch.patch_obj();
  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.
  var char_count1 = 0;  // Number of characters into the text1 string.
  var char_count2 = 0;  // Number of characters into the text2 string.
  // Start with text1 (prepatch_text) and apply the diffs until we arrive at
  // text2 (postpatch_text).  We recreate the patches one by one to determine
  // context info.
  var prepatch_text = text1;
  var postpatch_text = text1;
  for (var x = 0; x < diffs.length; x++) {
    var diff_type = diffs[x][0];
    var diff_text = diffs[x][1];

    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
      // A new patch starts here.
      patch.start1 = char_count1;
      patch.start2 = char_count2;
    }

    switch (diff_type) {
      case DIFF_INSERT:
        patch.diffs[patchDiffLength++] = diffs[x];
        patch.length2 += diff_text.length;
        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +
                         postpatch_text.substring(char_count2);
        break;
      case DIFF_DELETE:
        patch.length1 += diff_text.length;
        patch.diffs[patchDiffLength++] = diffs[x];
        postpatch_text = postpatch_text.substring(0, char_count2) +
                         postpatch_text.substring(char_count2 +
                             diff_text.length);
        break;
      case DIFF_EQUAL:
        if (diff_text.length <= 2 * this.Patch_Margin &&
            patchDiffLength && diffs.length != x + 1) {
          // Small equality inside a patch.
          patch.diffs[patchDiffLength++] = diffs[x];
          patch.length1 += diff_text.length;
          patch.length2 += diff_text.length;
        } else if (diff_text.length >= 2 * this.Patch_Margin) {
          // Time for a new patch.
          if (patchDiffLength) {
            this.patch_addContext_(patch, prepatch_text);
            patches.push(patch);
            patch = new diff_match_patch.patch_obj();
            patchDiffLength = 0;
            // Unlike Unidiff, our patch lists have a rolling context.
            // https://github.com/google/diff-match-patch/wiki/Unidiff
            // Update prepatch text & pos to reflect the application of the
            // just completed patch.
            prepatch_text = postpatch_text;
            char_count1 = char_count2;
          }
        }
        break;
    }

    // Update the current character count.
    if (diff_type !== DIFF_INSERT) {
      char_count1 += diff_text.length;
    }
    if (diff_type !== DIFF_DELETE) {
      char_count2 += diff_text.length;
    }
  }
  // Pick up the leftover patch if not empty.
  if (patchDiffLength) {
    this.patch_addContext_(patch, prepatch_text);
    patches.push(patch);
  }

  return patches;
};


/**
 * Given an array of patches, return another array that is identical.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_deepCopy = function(patches) {
  // Making deep copies is hard in JavaScript.
  var patchesCopy = [];
  for (var x = 0; x < patches.length; x++) {
    var patch = patches[x];
    var patchCopy = new diff_match_patch.patch_obj();
    patchCopy.diffs = [];
    for (var y = 0; y < patch.diffs.length; y++) {
      patchCopy.diffs[y] =
          new diff_match_patch.Diff(patch.diffs[y][0], patch.diffs[y][1]);
    }
    patchCopy.start1 = patch.start1;
    patchCopy.start2 = patch.start2;
    patchCopy.length1 = patch.length1;
    patchCopy.length2 = patch.length2;
    patchesCopy[x] = patchCopy;
  }
  return patchesCopy;
};


/**
 * Merge a set of patches onto the text.  Return a patched text, as well
 * as a list of true/false values indicating which patches were applied.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @param {string} text Old text.
 * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the
 *      new text and an array of boolean values.
 */
diff_match_patch.prototype.patch_apply = function(patches, text) {
  if (patches.length == 0) {
    return [text, []];
  }

  // Deep copy the patches so that no changes are made to originals.
  patches = this.patch_deepCopy(patches);

  var nullPadding = this.patch_addPadding(patches);
  text = nullPadding + text + nullPadding;

  this.patch_splitMax(patches);
  // delta keeps track of the offset between the expected and actual location
  // of the previous patch.  If there are patches expected at positions 10 and
  // 20, but the first patch was found at 12, delta is 2 and the second patch
  // has an effective expected position of 22.
  var delta = 0;
  var results = [];
  for (var x = 0; x < patches.length; x++) {
    var expected_loc = patches[x].start2 + delta;
    var text1 = this.diff_text1(patches[x].diffs);
    var start_loc;
    var end_loc = -1;
    if (text1.length > this.Match_MaxBits) {
      // patch_splitMax will only provide an oversized pattern in the case of
      // a monster delete.
      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),
                                  expected_loc);
      if (start_loc != -1) {
        end_loc = this.match_main(text,
            text1.substring(text1.length - this.Match_MaxBits),
            expected_loc + text1.length - this.Match_MaxBits);
        if (end_loc == -1 || start_loc >= end_loc) {
          // Can't find valid trailing context.  Drop this patch.
          start_loc = -1;
        }
      }
    } else {
      start_loc = this.match_main(text, text1, expected_loc);
    }
    if (start_loc == -1) {
      // No match found.  :(
      results[x] = false;
      // Subtract the delta for this failed patch from subsequent patches.
      delta -= patches[x].length2 - patches[x].length1;
    } else {
      // Found a match.  :)
      results[x] = true;
      delta = start_loc - expected_loc;
      var text2;
      if (end_loc == -1) {
        text2 = text.substring(start_loc, start_loc + text1.length);
      } else {
        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
      }
      if (text1 == text2) {
        // Perfect match, just shove the replacement text in.
        text = text.substring(0, start_loc) +
               this.diff_text2(patches[x].diffs) +
               text.substring(start_loc + text1.length);
      } else {
        // Imperfect match.  Run a diff to get a framework of equivalent
        // indices.
        var diffs = this.diff_main(text1, text2, false);
        if (text1.length > this.Match_MaxBits &&
            this.diff_levenshtein(diffs) / text1.length >
            this.Patch_DeleteThreshold) {
          // The end points match, but the content is unacceptably bad.
          results[x] = false;
        } else {
          this.diff_cleanupSemanticLossless(diffs);
          var index1 = 0;
          var index2;
          for (var y = 0; y < patches[x].diffs.length; y++) {
            var mod = patches[x].diffs[y];
            if (mod[0] !== DIFF_EQUAL) {
              index2 = this.diff_xIndex(diffs, index1);
            }
            if (mod[0] === DIFF_INSERT) {  // Insertion
              text = text.substring(0, start_loc + index2) + mod[1] +
                     text.substring(start_loc + index2);
            } else if (mod[0] === DIFF_DELETE) {  // Deletion
              text = text.substring(0, start_loc + index2) +
                     text.substring(start_loc + this.diff_xIndex(diffs,
                         index1 + mod[1].length));
            }
            if (mod[0] !== DIFF_DELETE) {
              index1 += mod[1].length;
            }
          }
        }
      }
    }
  }
  // Strip the padding off.
  text = text.substring(nullPadding.length, text.length - nullPadding.length);
  return [text, results];
};


/**
 * Add some padding on text start and end so that edges can match something.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} The padding string added to each side.
 */
diff_match_patch.prototype.patch_addPadding = function(patches) {
  var paddingLength = this.Patch_Margin;
  var nullPadding = '';
  for (var x = 1; x <= paddingLength; x++) {
    nullPadding += String.fromCharCode(x);
  }

  // Bump all the patches forward.
  for (var x = 0; x < patches.length; x++) {
    patches[x].start1 += paddingLength;
    patches[x].start2 += paddingLength;
  }

  // Add some padding on start of first diff.
  var patch = patches[0];
  var diffs = patch.diffs;
  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
    patch.start1 -= paddingLength;  // Should be 0.
    patch.start2 -= paddingLength;  // Should be 0.
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[0][1].length) {
    // Grow first equality.
    var extraLength = paddingLength - diffs[0][1].length;
    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
    patch.start1 -= extraLength;
    patch.start2 -= extraLength;
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  // Add some padding on end of last diff.
  patch = patches[patches.length - 1];
  diffs = patch.diffs;
  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[diffs.length - 1][1].length) {
    // Grow last equality.
    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  return nullPadding;
};


/**
 * Look through the patches and break up any which are longer than the maximum
 * limit of the match algorithm.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 */
diff_match_patch.prototype.patch_splitMax = function(patches) {
  var patch_size = this.Match_MaxBits;
  for (var x = 0; x < patches.length; x++) {
    if (patches[x].length1 <= patch_size) {
      continue;
    }
    var bigpatch = patches[x];
    // Remove the big old patch.
    patches.splice(x--, 1);
    var start1 = bigpatch.start1;
    var start2 = bigpatch.start2;
    var precontext = '';
    while (bigpatch.diffs.length !== 0) {
      // Create one of several smaller patches.
      var patch = new diff_match_patch.patch_obj();
      var empty = true;
      patch.start1 = start1 - precontext.length;
      patch.start2 = start2 - precontext.length;
      if (precontext !== '') {
        patch.length1 = patch.length2 = precontext.length;
        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, precontext));
      }
      while (bigpatch.diffs.length !== 0 &&
             patch.length1 < patch_size - this.Patch_Margin) {
        var diff_type = bigpatch.diffs[0][0];
        var diff_text = bigpatch.diffs[0][1];
        if (diff_type === DIFF_INSERT) {
          // Insertions are harmless.
          patch.length2 += diff_text.length;
          start2 += diff_text.length;
          patch.diffs.push(bigpatch.diffs.shift());
          empty = false;
        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&
                   patch.diffs[0][0] == DIFF_EQUAL &&
                   diff_text.length > 2 * patch_size) {
          // This is a large deletion.  Let it pass in one chunk.
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          empty = false;
          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
          bigpatch.diffs.shift();
        } else {
          // Deletion or equality.  Only take as much as we can stomach.
          diff_text = diff_text.substring(0,
              patch_size - patch.length1 - this.Patch_Margin);
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          if (diff_type === DIFF_EQUAL) {
            patch.length2 += diff_text.length;
            start2 += diff_text.length;
          } else {
            empty = false;
          }
          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
          if (diff_text == bigpatch.diffs[0][1]) {
            bigpatch.diffs.shift();
          } else {
            bigpatch.diffs[0][1] =
                bigpatch.diffs[0][1].substring(diff_text.length);
          }
        }
      }
      // Compute the head context for the next patch.
      precontext = this.diff_text2(patch.diffs);
      precontext =
          precontext.substring(precontext.length - this.Patch_Margin);
      // Append the end context for this patch.
      var postcontext = this.diff_text1(bigpatch.diffs)
                            .substring(0, this.Patch_Margin);
      if (postcontext !== '') {
        patch.length1 += postcontext.length;
        patch.length2 += postcontext.length;
        if (patch.diffs.length !== 0 &&
            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
          patch.diffs[patch.diffs.length - 1][1] += postcontext;
        } else {
          patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, postcontext));
        }
      }
      if (!empty) {
        patches.splice(++x, 0, patch);
      }
    }
  }
};


/**
 * Take a list of patches and return a textual representation.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} Text representation of patches.
 */
diff_match_patch.prototype.patch_toText = function(patches) {
  var text = [];
  for (var x = 0; x < patches.length; x++) {
    text[x] = patches[x];
  }
  return text.join('');
};


/**
 * Parse a textual representation of patches and return a list of Patch objects.
 * @param {string} textline Text representation of patches.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.patch_fromText = function(textline) {
  var patches = [];
  if (!textline) {
    return patches;
  }
  var text = textline.split('\n');
  var textPointer = 0;
  var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
  while (textPointer < text.length) {
    var m = text[textPointer].match(patchHeader);
    if (!m) {
      throw new Error('Invalid patch string: ' + text[textPointer]);
    }
    var patch = new diff_match_patch.patch_obj();
    patches.push(patch);
    patch.start1 = parseInt(m[1], 10);
    if (m[2] === '') {
      patch.start1--;
      patch.length1 = 1;
    } else if (m[2] == '0') {
      patch.length1 = 0;
    } else {
      patch.start1--;
      patch.length1 = parseInt(m[2], 10);
    }

    patch.start2 = parseInt(m[3], 10);
    if (m[4] === '') {
      patch.start2--;
      patch.length2 = 1;
    } else if (m[4] == '0') {
      patch.length2 = 0;
    } else {
      patch.start2--;
      patch.length2 = parseInt(m[4], 10);
    }
    textPointer++;

    while (textPointer < text.length) {
      var sign = text[textPointer].charAt(0);
      try {
        var line = decodeURI(text[textPointer].substring(1));
      } catch (ex) {
        // Malformed URI sequence.
        throw new Error('Illegal escape in patch_fromText: ' + line);
      }
      if (sign == '-') {
        // Deletion.
        patch.diffs.push(new diff_match_patch.Diff(DIFF_DELETE, line));
      } else if (sign == '+') {
        // Insertion.
        patch.diffs.push(new diff_match_patch.Diff(DIFF_INSERT, line));
      } else if (sign == ' ') {
        // Minor equality.
        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, line));
      } else if (sign == '@') {
        // Start of next patch.
        break;
      } else if (sign === '') {
        // Blank line?  Whatever.
      } else {
        // WTF?
        throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
      }
      textPointer++;
    }
  }
  return patches;
};


/**
 * Class representing one patch operation.
 * @constructor
 */
diff_match_patch.patch_obj = function() {
  /** @type {!Array.<!diff_match_patch.Diff>} */
  this.diffs = [];
  /** @type {?number} */
  this.start1 = null;
  /** @type {?number} */
  this.start2 = null;
  /** @type {number} */
  this.length1 = 0;
  /** @type {number} */
  this.length2 = 0;
};


/**
 * Emulate GNU diff's format.
 * Header: @@ -382,8 +481,9 @@
 * Indices are printed as 1-based, not 0-based.
 * @return {string} The GNU diff string.
 */
diff_match_patch.patch_obj.prototype.toString = function() {
  var coords1, coords2;
  if (this.length1 === 0) {
    coords1 = this.start1 + ',0';
  } else if (this.length1 == 1) {
    coords1 = this.start1 + 1;
  } else {
    coords1 = (this.start1 + 1) + ',' + this.length1;
  }
  if (this.length2 === 0) {
    coords2 = this.start2 + ',0';
  } else if (this.length2 == 1) {
    coords2 = this.start2 + 1;
  } else {
    coords2 = (this.start2 + 1) + ',' + this.length2;
  }
  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n'];
  var op;
  // Escape the body of the patch with %xx notation.
  for (var x = 0; x < this.diffs.length; x++) {
    switch (this.diffs[x][0]) {
      case DIFF_INSERT:
        op = '+';
        break;
      case DIFF_DELETE:
        op = '-';
        break;
      case DIFF_EQUAL:
        op = ' ';
        break;
    }
    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n';
  }
  return text.join('').replace(/%20/g, ' ');
};


// The following export code was added by @ForbesLindesay
module.exports = diff_match_patch;
module.exports.diff_match_patch = diff_match_patch;
module.exports.DIFF_DELETE = DIFF_DELETE;
module.exports.DIFF_INSERT = DIFF_INSERT;
module.exports.DIFF_EQUAL = DIFF_EQUAL;

/***/ }),

/***/ 9903:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.toString = function (klass) {
  switch (klass) {
    case 1: return 'IN'
    case 2: return 'CS'
    case 3: return 'CH'
    case 4: return 'HS'
    case 255: return 'ANY'
  }
  return 'UNKNOWN_' + klass
}

exports.toClass = function (name) {
  switch (name.toUpperCase()) {
    case 'IN': return 1
    case 'CS': return 2
    case 'CH': return 3
    case 'HS': return 4
    case 'ANY': return 255
  }
  return 0
}


/***/ }),

/***/ 8667:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const types = __nccwpck_require__(2342)
const rcodes = __nccwpck_require__(3523)
const opcodes = __nccwpck_require__(4882)
const classes = __nccwpck_require__(9903)
const ip = __nccwpck_require__(3434)
const Buffer = __nccwpck_require__(3118).Buffer

const QUERY_FLAG = 0
const RESPONSE_FLAG = 1 << 15
const FLUSH_MASK = 1 << 15
const NOT_FLUSH_MASK = ~FLUSH_MASK
const QU_MASK = 1 << 15
const NOT_QU_MASK = ~QU_MASK

const name = exports.txt = exports.name = {}

name.encode = function (str, buf, offset) {
  if (!buf) buf = Buffer.allocUnsafe(name.encodingLength(str))
  if (!offset) offset = 0
  const oldOffset = offset

  // strip leading and trailing .
  const n = str.replace(/^\.|\.$/gm, '')
  if (n.length) {
    const list = n.split('.')

    for (let i = 0; i < list.length; i++) {
      const len = buf.write(list[i], offset + 1)
      buf[offset] = len
      offset += len + 1
    }
  }

  buf[offset++] = 0

  name.encode.bytes = offset - oldOffset
  return buf
}

name.encode.bytes = 0

name.decode = function (buf, offset) {
  if (!offset) offset = 0

  const list = []
  const oldOffset = offset
  let len = buf[offset++]

  if (len === 0) {
    name.decode.bytes = 1
    return '.'
  }
  if (len >= 0xc0) {
    const res = name.decode(buf, buf.readUInt16BE(offset - 1) - 0xc000)
    name.decode.bytes = 2
    return res
  }

  while (len) {
    if (len >= 0xc0) {
      list.push(name.decode(buf, buf.readUInt16BE(offset - 1) - 0xc000))
      offset++
      break
    }

    list.push(buf.toString('utf-8', offset, offset + len))
    offset += len
    len = buf[offset++]
  }

  name.decode.bytes = offset - oldOffset
  return list.join('.')
}

name.decode.bytes = 0

name.encodingLength = function (n) {
  if (n === '.') return 1
  return Buffer.byteLength(n) + 2
}

const string = {}

string.encode = function (s, buf, offset) {
  if (!buf) buf = Buffer.allocUnsafe(string.encodingLength(s))
  if (!offset) offset = 0

  const len = buf.write(s, offset + 1)
  buf[offset] = len
  string.encode.bytes = len + 1
  return buf
}

string.encode.bytes = 0

string.decode = function (buf, offset) {
  if (!offset) offset = 0

  const len = buf[offset]
  const s = buf.toString('utf-8', offset + 1, offset + 1 + len)
  string.decode.bytes = len + 1
  return s
}

string.decode.bytes = 0

string.encodingLength = function (s) {
  return Buffer.byteLength(s) + 1
}

const header = {}

header.encode = function (h, buf, offset) {
  if (!buf) buf = header.encodingLength(h)
  if (!offset) offset = 0

  const flags = (h.flags || 0) & 32767
  const type = h.type === 'response' ? RESPONSE_FLAG : QUERY_FLAG

  buf.writeUInt16BE(h.id || 0, offset)
  buf.writeUInt16BE(flags | type, offset + 2)
  buf.writeUInt16BE(h.questions.length, offset + 4)
  buf.writeUInt16BE(h.answers.length, offset + 6)
  buf.writeUInt16BE(h.authorities.length, offset + 8)
  buf.writeUInt16BE(h.additionals.length, offset + 10)

  return buf
}

header.encode.bytes = 12

header.decode = function (buf, offset) {
  if (!offset) offset = 0
  if (buf.length < 12) throw new Error('Header must be 12 bytes')
  const flags = buf.readUInt16BE(offset + 2)

  return {
    id: buf.readUInt16BE(offset),
    type: flags & RESPONSE_FLAG ? 'response' : 'query',
    flags: flags & 32767,
    flag_qr: ((flags >> 15) & 0x1) === 1,
    opcode: opcodes.toString((flags >> 11) & 0xf),
    flag_aa: ((flags >> 10) & 0x1) === 1,
    flag_tc: ((flags >> 9) & 0x1) === 1,
    flag_rd: ((flags >> 8) & 0x1) === 1,
    flag_ra: ((flags >> 7) & 0x1) === 1,
    flag_z: ((flags >> 6) & 0x1) === 1,
    flag_ad: ((flags >> 5) & 0x1) === 1,
    flag_cd: ((flags >> 4) & 0x1) === 1,
    rcode: rcodes.toString(flags & 0xf),
    questions: new Array(buf.readUInt16BE(offset + 4)),
    answers: new Array(buf.readUInt16BE(offset + 6)),
    authorities: new Array(buf.readUInt16BE(offset + 8)),
    additionals: new Array(buf.readUInt16BE(offset + 10))
  }
}

header.decode.bytes = 12

header.encodingLength = function () {
  return 12
}

const runknown = exports.unknown = {}

runknown.encode = function (data, buf, offset) {
  if (!buf) buf = Buffer.allocUnsafe(runknown.encodingLength(data))
  if (!offset) offset = 0

  buf.writeUInt16BE(data.length, offset)
  data.copy(buf, offset + 2)

  runknown.encode.bytes = data.length + 2
  return buf
}

runknown.encode.bytes = 0

runknown.decode = function (buf, offset) {
  if (!offset) offset = 0

  const len = buf.readUInt16BE(offset)
  const data = buf.slice(offset + 2, offset + 2 + len)
  runknown.decode.bytes = len + 2
  return data
}

runknown.decode.bytes = 0

runknown.encodingLength = function (data) {
  return data.length + 2
}

const rns = exports.ns = {}

rns.encode = function (data, buf, offset) {
  if (!buf) buf = Buffer.allocUnsafe(rns.encodingLength(data))
  if (!offset) offset = 0

  name.encode(data, buf, offset + 2)
  buf.writeUInt16BE(name.encode.bytes, offset)
  rns.encode.bytes = name.encode.bytes + 2
  return buf
}

rns.encode.bytes = 0

rns.decode = function (buf, offset) {
  if (!offset) offset = 0

  const len = buf.readUInt16BE(offset)
  const dd = name.decode(buf, offset + 2)

  rns.decode.bytes = len + 2
  return dd
}

rns.decode.bytes = 0

rns.encodingLength = function (data) {
  return name.encodingLength(data) + 2
}

const rsoa = exports.soa = {}

rsoa.encode = function (data, buf, offset) {
  if (!buf) buf = Buffer.allocUnsafe(rsoa.encodingLength(data))
  if (!offset) offset = 0

  const oldOffset = offset
  offset += 2
  name.encode(data.mname, buf, offset)
  offset += name.encode.bytes
  name.encode(data.rname, buf, offset)
  offset += name.encode.bytes
  buf.writeUInt32BE(data.serial || 0, offset)
  offset += 4
  buf.writeUInt32BE(data.refresh || 0, offset)
  offset += 4
  buf.writeUInt32BE(data.retry || 0, offset)
  offset += 4
  buf.writeUInt32BE(data.expire || 0, offset)
  offset += 4
  buf.writeUInt32BE(data.minimum || 0, offset)
  offset += 4

  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)
  rsoa.encode.bytes = offset - oldOffset
  return buf
}

rsoa.encode.bytes = 0

rsoa.decode = function (buf, offset) {
  if (!offset) offset = 0

  const oldOffset = offset

  const data = {}
  offset += 2
  data.mname = name.decode(buf, offset)
  offset += name.decode.bytes
  data.rname = name.decode(buf, offset)
  offset += name.decode.bytes
  data.serial = buf.readUInt32BE(offset)
  offset += 4
  data.refresh = buf.readUInt32BE(offset)
  offset += 4
  data.retry = buf.readUInt32BE(offset)
  offset += 4
  data.expire = buf.readUInt32BE(offset)
  offset += 4
  data.minimum = buf.readUInt32BE(offset)
  offset += 4

  rsoa.decode.bytes = offset - oldOffset
  return data
}

rsoa.decode.bytes = 0

rsoa.encodingLength = function (data) {
  return 22 + name.encodingLength(data.mname) + name.encodingLength(data.rname)
}

const rtxt = exports.txt = {}

rtxt.encode = function (data, buf, offset) {
  if (!Array.isArray(data)) data = [data]
  for (let i = 0; i < data.length; i++) {
    if (typeof data[i] === 'string') {
      data[i] = Buffer.from(data[i])
    }
    if (!Buffer.isBuffer(data[i])) {
      throw new Error('Must be a Buffer')
    }
  }

  if (!buf) buf = Buffer.allocUnsafe(rtxt.encodingLength(data))
  if (!offset) offset = 0

  const oldOffset = offset
  offset += 2

  data.forEach(function (d) {
    buf[offset++] = d.length
    d.copy(buf, offset, 0, d.length)
    offset += d.length
  })

  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)
  rtxt.encode.bytes = offset - oldOffset
  return buf
}

rtxt.encode.bytes = 0

rtxt.decode = function (buf, offset) {
  if (!offset) offset = 0
  const oldOffset = offset
  let remaining = buf.readUInt16BE(offset)
  offset += 2

  let data = []
  while (remaining > 0) {
    const len = buf[offset++]
    --remaining
    if (remaining < len) {
      throw new Error('Buffer overflow')
    }
    data.push(buf.slice(offset, offset + len))
    offset += len
    remaining -= len
  }

  rtxt.decode.bytes = offset - oldOffset
  return data
}

rtxt.decode.bytes = 0

rtxt.encodingLength = function (data) {
  if (!Array.isArray(data)) data = [data]
  let length = 2
  data.forEach(function (buf) {
    if (typeof buf === 'string') {
      length += Buffer.byteLength(buf) + 1
    } else {
      length += buf.length + 1
    }
  })
  return length
}

const rnull = exports.null = {}

rnull.encode = function (data, buf, offset) {
  if (!buf) buf = Buffer.allocUnsafe(rnull.encodingLength(data))
  if (!offset) offset = 0

  if (typeof data === 'string') data = Buffer.from(data)
  if (!data) data = Buffer.allocUnsafe(0)

  const oldOffset = offset
  offset += 2

  const len = data.length
  data.copy(buf, offset, 0, len)
  offset += len

  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)
  rnull.encode.bytes = offset - oldOffset
  return buf
}

rnull.encode.bytes = 0

rnull.decode = function (buf, offset) {
  if (!offset) offset = 0
  const oldOffset = offset
  const len = buf.readUInt16BE(offset)

  offset += 2

  const data = buf.slice(offset, offset + len)
  offset += len

  rnull.decode.bytes = offset - oldOffset
  return data
}

rnull.decode.bytes = 0

rnull.encodingLength = function (data) {
  if (!data) return 2
  return (Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data)) + 2
}

const rhinfo = exports.hinfo = {}

rhinfo.encode = function (data, buf, offset) {
  if (!buf) buf = Buffer.allocUnsafe(rhinfo.encodingLength(data))
  if (!offset) offset = 0

  const oldOffset = offset
  offset += 2
  string.encode(data.cpu, buf, offset)
  offset += string.encode.bytes
  string.encode(data.os, buf, offset)
  offset += string.encode.bytes
  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)
  rhinfo.encode.bytes = offset - oldOffset
  return buf
}

rhinfo.encode.bytes = 0

rhinfo.decode = function (buf, offset) {
  if (!offset) offset = 0

  const oldOffset = offset

  const data = {}
  offset += 2
  data.cpu = string.decode(buf, offset)
  offset += string.decode.bytes
  data.os = string.decode(buf, offset)
  offset += string.decode.bytes
  rhinfo.decode.bytes = offset - oldOffset
  return data
}

rhinfo.decode.bytes = 0

rhinfo.encodingLength = function (data) {
  return string.encodingLength(data.cpu) + string.encodingLength(data.os) + 2
}

const rptr = exports.ptr = {}
const rcname = exports.cname = rptr
const rdname = exports.dname = rptr

rptr.encode = function (data, buf, offset) {
  if (!buf) buf = Buffer.allocUnsafe(rptr.encodingLength(data))
  if (!offset) offset = 0

  name.encode(data, buf, offset + 2)
  buf.writeUInt16BE(name.encode.bytes, offset)
  rptr.encode.bytes = name.encode.bytes + 2
  return buf
}

rptr.encode.bytes = 0

rptr.decode = function (buf, offset) {
  if (!offset) offset = 0

  const data = name.decode(buf, offset + 2)
  rptr.decode.bytes = name.decode.bytes + 2
  return data
}

rptr.decode.bytes = 0

rptr.encodingLength = function (data) {
  return name.encodingLength(data) + 2
}

const rsrv = exports.srv = {}

rsrv.encode = function (data, buf, offset) {
  if (!buf) buf = Buffer.allocUnsafe(rsrv.encodingLength(data))
  if (!offset) offset = 0

  buf.writeUInt16BE(data.priority || 0, offset + 2)
  buf.writeUInt16BE(data.weight || 0, offset + 4)
  buf.writeUInt16BE(data.port || 0, offset + 6)
  name.encode(data.target, buf, offset + 8)

  const len = name.encode.bytes + 6
  buf.writeUInt16BE(len, offset)

  rsrv.encode.bytes = len + 2
  return buf
}

rsrv.encode.bytes = 0

rsrv.decode = function (buf, offset) {
  if (!offset) offset = 0

  const len = buf.readUInt16BE(offset)

  const data = {}
  data.priority = buf.readUInt16BE(offset + 2)
  data.weight = buf.readUInt16BE(offset + 4)
  data.port = buf.readUInt16BE(offset + 6)
  data.target = name.decode(buf, offset + 8)

  rsrv.decode.bytes = len + 2
  return data
}

rsrv.decode.bytes = 0

rsrv.encodingLength = function (data) {
  return 8 + name.encodingLength(data.target)
}

const rcaa = exports.caa = {}

rcaa.ISSUER_CRITICAL = 1 << 7

rcaa.encode = function (data, buf, offset) {
  const len = rcaa.encodingLength(data)

  if (!buf) buf = Buffer.allocUnsafe(rcaa.encodingLength(data))
  if (!offset) offset = 0

  if (data.issuerCritical) {
    data.flags = rcaa.ISSUER_CRITICAL
  }

  buf.writeUInt16BE(len - 2, offset)
  offset += 2
  buf.writeUInt8(data.flags || 0, offset)
  offset += 1
  string.encode(data.tag, buf, offset)
  offset += string.encode.bytes
  buf.write(data.value, offset)
  offset += Buffer.byteLength(data.value)

  rcaa.encode.bytes = len
  return buf
}

rcaa.encode.bytes = 0

rcaa.decode = function (buf, offset) {
  if (!offset) offset = 0

  const len = buf.readUInt16BE(offset)
  offset += 2

  const oldOffset = offset
  const data = {}
  data.flags = buf.readUInt8(offset)
  offset += 1
  data.tag = string.decode(buf, offset)
  offset += string.decode.bytes
  data.value = buf.toString('utf-8', offset, oldOffset + len)

  data.issuerCritical = !!(data.flags & rcaa.ISSUER_CRITICAL)

  rcaa.decode.bytes = len + 2

  return data
}

rcaa.decode.bytes = 0

rcaa.encodingLength = function (data) {
  return string.encodingLength(data.tag) + string.encodingLength(data.value) + 2
}

const rmx = exports.mx = {}

rmx.encode = function (data, buf, offset) {
  if (!buf) buf = Buffer.allocUnsafe(rmx.encodingLength(data))
  if (!offset) offset = 0

  const oldOffset = offset
  offset += 2
  buf.writeUInt16BE(data.preference || 0, offset)
  offset += 2
  name.encode(data.exchange, buf, offset)
  offset += name.encode.bytes

  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)
  rmx.encode.bytes = offset - oldOffset
  return buf
}

rmx.encode.bytes = 0

rmx.decode = function (buf, offset) {
  if (!offset) offset = 0

  const oldOffset = offset

  const data = {}
  offset += 2
  data.preference = buf.readUInt16BE(offset)
  offset += 2
  data.exchange = name.decode(buf, offset)
  offset += name.decode.bytes

  rmx.decode.bytes = offset - oldOffset
  return data
}

rmx.encodingLength = function (data) {
  return 4 + name.encodingLength(data.exchange)
}

const ra = exports.a = {}

ra.encode = function (host, buf, offset) {
  if (!buf) buf = Buffer.allocUnsafe(ra.encodingLength(host))
  if (!offset) offset = 0

  buf.writeUInt16BE(4, offset)
  offset += 2
  ip.toBuffer(host, buf, offset)
  ra.encode.bytes = 6
  return buf
}

ra.encode.bytes = 0

ra.decode = function (buf, offset) {
  if (!offset) offset = 0

  offset += 2
  const host = ip.toString(buf, offset, 4)
  ra.decode.bytes = 6
  return host
}

ra.decode.bytes = 0

ra.encodingLength = function () {
  return 6
}

const raaaa = exports.aaaa = {}

raaaa.encode = function (host, buf, offset) {
  if (!buf) buf = Buffer.allocUnsafe(raaaa.encodingLength(host))
  if (!offset) offset = 0

  buf.writeUInt16BE(16, offset)
  offset += 2
  ip.toBuffer(host, buf, offset)
  raaaa.encode.bytes = 18
  return buf
}

raaaa.encode.bytes = 0

raaaa.decode = function (buf, offset) {
  if (!offset) offset = 0

  offset += 2
  const host = ip.toString(buf, offset, 16)
  raaaa.decode.bytes = 18
  return host
}

raaaa.decode.bytes = 0

raaaa.encodingLength = function () {
  return 18
}

const roption = exports.option = {}

roption.encode = function (option, buf, offset) {
  if (!buf) buf = Buffer.allocUnsafe(roption.encodingLength(option))
  if (!offset) offset = 0
  const oldOffset = offset

  buf.writeUInt16BE(option.code, offset)
  offset += 2
  buf.writeUInt16BE(option.data.length, offset)
  offset += 2
  option.data.copy(buf, offset)
  offset += option.data.length

  roption.encode.bytes = offset - oldOffset
  return buf
}

roption.encode.bytes = 0

roption.decode = function (buf, offset) {
  if (!offset) offset = 0
  const option = {}

  option.code = buf.readUInt16BE(offset)
  const len = buf.readUInt16BE(offset + 2)
  option.data = buf.slice(offset + 4, offset + 4 + len)

  roption.decode.bytes = len + 4
  return option
}

roption.decode.bytes = 0

roption.encodingLength = function (option) {
  return option.data.length + 4
}

const ropt = exports.opt = {}

ropt.encode = function (options, buf, offset) {
  if (!buf) buf = Buffer.allocUnsafe(ropt.encodingLength(options))
  if (!offset) offset = 0
  const oldOffset = offset

  const rdlen = encodingLengthList(options, roption)
  buf.writeUInt16BE(rdlen, offset)
  offset = encodeList(options, roption, buf, offset + 2)

  ropt.encode.bytes = offset - oldOffset
  return buf
}

ropt.encode.bytes = 0

ropt.decode = function (buf, offset) {
  if (!offset) offset = 0
  const oldOffset = offset

  const options = []
  let rdlen = buf.readUInt16BE(offset)
  offset += 2
  let o = 0
  while (rdlen > 0) {
    options[o++] = roption.decode(buf, offset)
    offset += roption.decode.bytes
    rdlen -= roption.decode.bytes
  }
  ropt.decode.bytes = offset - oldOffset
  return options
}

ropt.decode.bytes = 0

ropt.encodingLength = function (options) {
  return 2 + encodingLengthList(options || [], roption)
}

const renc = exports.record = function (type) {
  switch (type.toUpperCase()) {
    case 'A': return ra
    case 'PTR': return rptr
    case 'CNAME': return rcname
    case 'DNAME': return rdname
    case 'TXT': return rtxt
    case 'NULL': return rnull
    case 'AAAA': return raaaa
    case 'SRV': return rsrv
    case 'HINFO': return rhinfo
    case 'CAA': return rcaa
    case 'NS': return rns
    case 'SOA': return rsoa
    case 'MX': return rmx
    case 'OPT': return ropt
  }
  return runknown
}

const answer = exports.answer = {}

answer.encode = function (a, buf, offset) {
  if (!buf) buf = Buffer.allocUnsafe(answer.encodingLength(a))
  if (!offset) offset = 0

  const oldOffset = offset

  name.encode(a.name, buf, offset)
  offset += name.encode.bytes

  buf.writeUInt16BE(types.toType(a.type), offset)

  if (a.type.toUpperCase() === 'OPT') {
    if (a.name !== '.') {
      throw new Error('OPT name must be root.')
    }
    buf.writeUInt16BE(a.updPayloadSize || 4096, offset + 2)
    buf.writeUInt8(a.extendedRcode || 0, offset + 4)
    buf.writeUInt8(a.ednsVersion || 0, offset + 5)
    buf.writeUInt16BE(a.flags || 0, offset + 6)

    offset += 8
    ropt.encode(a.options || [], buf, offset)
    offset += ropt.encode.bytes
  } else {
    let klass = classes.toClass(a.class === undefined ? 'IN' : a.class)
    if (a.flush) klass |= FLUSH_MASK // the 1st bit of the class is the flush bit
    buf.writeUInt16BE(klass, offset + 2)
    buf.writeUInt32BE(a.ttl || 0, offset + 4)

    offset += 8
    const enc = renc(a.type)
    enc.encode(a.data, buf, offset)
    offset += enc.encode.bytes
  }

  answer.encode.bytes = offset - oldOffset
  return buf
}

answer.encode.bytes = 0

answer.decode = function (buf, offset) {
  if (!offset) offset = 0

  const a = {}
  const oldOffset = offset

  a.name = name.decode(buf, offset)
  offset += name.decode.bytes
  a.type = types.toString(buf.readUInt16BE(offset))
  if (a.type === 'OPT') {
    a.udpPayloadSize = buf.readUInt16BE(offset + 2)
    a.extendedRcode = buf.readUInt8(offset + 4)
    a.ednsVersion = buf.readUInt8(offset + 5)
    a.flags = buf.readUInt16BE(offset + 6)
    a.flag_do = ((a.flags >> 15) & 0x1) === 1
    a.options = ropt.decode(buf, offset + 8)
    offset += 8 + ropt.decode.bytes
  } else {
    const klass = buf.readUInt16BE(offset + 2)
    a.ttl = buf.readUInt32BE(offset + 4)

    a.class = classes.toString(klass & NOT_FLUSH_MASK)
    a.flush = !!(klass & FLUSH_MASK)

    const enc = renc(a.type)
    a.data = enc.decode(buf, offset + 8)
    offset += 8 + enc.decode.bytes
  }

  answer.decode.bytes = offset - oldOffset
  return a
}

answer.decode.bytes = 0

answer.encodingLength = function (a) {
  return name.encodingLength(a.name) + 8 + renc(a.type).encodingLength(a.data || a.options)
}

const question = exports.question = {}

question.encode = function (q, buf, offset) {
  if (!buf) buf = Buffer.allocUnsafe(question.encodingLength(q))
  if (!offset) offset = 0

  const oldOffset = offset

  name.encode(q.name, buf, offset)
  offset += name.encode.bytes

  buf.writeUInt16BE(types.toType(q.type), offset)
  offset += 2

  buf.writeUInt16BE(classes.toClass(q.class === undefined ? 'IN' : q.class), offset)
  offset += 2

  question.encode.bytes = offset - oldOffset
  return q
}

question.encode.bytes = 0

question.decode = function (buf, offset) {
  if (!offset) offset = 0

  const oldOffset = offset
  const q = {}

  q.name = name.decode(buf, offset)
  offset += name.decode.bytes

  q.type = types.toString(buf.readUInt16BE(offset))
  offset += 2

  q.class = classes.toString(buf.readUInt16BE(offset))
  offset += 2

  const qu = !!(q.class & QU_MASK)
  if (qu) q.class &= NOT_QU_MASK

  question.decode.bytes = offset - oldOffset
  return q
}

question.decode.bytes = 0

question.encodingLength = function (q) {
  return name.encodingLength(q.name) + 4
}

exports.AUTHORITATIVE_ANSWER = 1 << 10
exports.TRUNCATED_RESPONSE = 1 << 9
exports.RECURSION_DESIRED = 1 << 8
exports.RECURSION_AVAILABLE = 1 << 7
exports.AUTHENTIC_DATA = 1 << 5
exports.CHECKING_DISABLED = 1 << 4
exports.DNSSEC_OK = 1 << 15

exports.encode = function (result, buf, offset) {
  if (!buf) buf = Buffer.allocUnsafe(exports.encodingLength(result))
  if (!offset) offset = 0

  const oldOffset = offset

  if (!result.questions) result.questions = []
  if (!result.answers) result.answers = []
  if (!result.authorities) result.authorities = []
  if (!result.additionals) result.additionals = []

  header.encode(result, buf, offset)
  offset += header.encode.bytes

  offset = encodeList(result.questions, question, buf, offset)
  offset = encodeList(result.answers, answer, buf, offset)
  offset = encodeList(result.authorities, answer, buf, offset)
  offset = encodeList(result.additionals, answer, buf, offset)

  exports.encode.bytes = offset - oldOffset

  return buf
}

exports.encode.bytes = 0

exports.decode = function (buf, offset) {
  if (!offset) offset = 0

  const oldOffset = offset
  const result = header.decode(buf, offset)
  offset += header.decode.bytes

  offset = decodeList(result.questions, question, buf, offset)
  offset = decodeList(result.answers, answer, buf, offset)
  offset = decodeList(result.authorities, answer, buf, offset)
  offset = decodeList(result.additionals, answer, buf, offset)

  exports.decode.bytes = offset - oldOffset

  return result
}

exports.decode.bytes = 0

exports.encodingLength = function (result) {
  return header.encodingLength(result) +
    encodingLengthList(result.questions || [], question) +
    encodingLengthList(result.answers || [], answer) +
    encodingLengthList(result.authorities || [], answer) +
    encodingLengthList(result.additionals || [], answer)
}

exports.streamEncode = function (result) {
  const buf = exports.encode(result)
  const sbuf = Buffer.allocUnsafe(2)
  sbuf.writeUInt16BE(buf.byteLength)
  const combine = Buffer.concat([sbuf, buf])
  exports.streamEncode.bytes = combine.byteLength
  return combine
}

exports.streamEncode.bytes = 0

exports.streamDecode = function (sbuf) {
  const len = sbuf.readUInt16BE(0)
  if (sbuf.byteLength < len + 2) {
    // not enough data
    return null
  }
  const result = exports.decode(sbuf.slice(2))
  exports.streamDecode.bytes = exports.decode.bytes
  return result
}

exports.streamDecode.bytes = 0

function encodingLengthList (list, enc) {
  let len = 0
  for (let i = 0; i < list.length; i++) len += enc.encodingLength(list[i])
  return len
}

function encodeList (list, enc, buf, offset) {
  for (let i = 0; i < list.length; i++) {
    enc.encode(list[i], buf, offset)
    offset += enc.encode.bytes
  }
  return offset
}

function decodeList (list, enc, buf, offset) {
  for (let i = 0; i < list.length; i++) {
    list[i] = enc.decode(buf, offset)
    offset += enc.decode.bytes
  }
  return offset
}


/***/ }),

/***/ 4882:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/*
 * Traditional DNS header OPCODEs (4-bits) defined by IANA in
 * https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-5
 */

exports.toString = function (opcode) {
  switch (opcode) {
    case 0: return 'QUERY'
    case 1: return 'IQUERY'
    case 2: return 'STATUS'
    case 3: return 'OPCODE_3'
    case 4: return 'NOTIFY'
    case 5: return 'UPDATE'
    case 6: return 'OPCODE_6'
    case 7: return 'OPCODE_7'
    case 8: return 'OPCODE_8'
    case 9: return 'OPCODE_9'
    case 10: return 'OPCODE_10'
    case 11: return 'OPCODE_11'
    case 12: return 'OPCODE_12'
    case 13: return 'OPCODE_13'
    case 14: return 'OPCODE_14'
    case 15: return 'OPCODE_15'
  }
  return 'OPCODE_' + opcode
}

exports.toOpcode = function (code) {
  switch (code.toUpperCase()) {
    case 'QUERY': return 0
    case 'IQUERY': return 1
    case 'STATUS': return 2
    case 'OPCODE_3': return 3
    case 'NOTIFY': return 4
    case 'UPDATE': return 5
    case 'OPCODE_6': return 6
    case 'OPCODE_7': return 7
    case 'OPCODE_8': return 8
    case 'OPCODE_9': return 9
    case 'OPCODE_10': return 10
    case 'OPCODE_11': return 11
    case 'OPCODE_12': return 12
    case 'OPCODE_13': return 13
    case 'OPCODE_14': return 14
    case 'OPCODE_15': return 15
  }
  return 0
}


/***/ }),

/***/ 3523:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/*
 * Traditional DNS header RCODEs (4-bits) defined by IANA in
 * https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml
 */

exports.toString = function (rcode) {
  switch (rcode) {
    case 0: return 'NOERROR'
    case 1: return 'FORMERR'
    case 2: return 'SERVFAIL'
    case 3: return 'NXDOMAIN'
    case 4: return 'NOTIMP'
    case 5: return 'REFUSED'
    case 6: return 'YXDOMAIN'
    case 7: return 'YXRRSET'
    case 8: return 'NXRRSET'
    case 9: return 'NOTAUTH'
    case 10: return 'NOTZONE'
    case 11: return 'RCODE_11'
    case 12: return 'RCODE_12'
    case 13: return 'RCODE_13'
    case 14: return 'RCODE_14'
    case 15: return 'RCODE_15'
  }
  return 'RCODE_' + rcode
}

exports.toRcode = function (code) {
  switch (code.toUpperCase()) {
    case 'NOERROR': return 0
    case 'FORMERR': return 1
    case 'SERVFAIL': return 2
    case 'NXDOMAIN': return 3
    case 'NOTIMP': return 4
    case 'REFUSED': return 5
    case 'YXDOMAIN': return 6
    case 'YXRRSET': return 7
    case 'NXRRSET': return 8
    case 'NOTAUTH': return 9
    case 'NOTZONE': return 10
    case 'RCODE_11': return 11
    case 'RCODE_12': return 12
    case 'RCODE_13': return 13
    case 'RCODE_14': return 14
    case 'RCODE_15': return 15
  }
  return 0
}


/***/ }),

/***/ 2342:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.toString = function (type) {
  switch (type) {
    case 1: return 'A'
    case 10: return 'NULL'
    case 28: return 'AAAA'
    case 18: return 'AFSDB'
    case 42: return 'APL'
    case 257: return 'CAA'
    case 60: return 'CDNSKEY'
    case 59: return 'CDS'
    case 37: return 'CERT'
    case 5: return 'CNAME'
    case 49: return 'DHCID'
    case 32769: return 'DLV'
    case 39: return 'DNAME'
    case 48: return 'DNSKEY'
    case 43: return 'DS'
    case 55: return 'HIP'
    case 13: return 'HINFO'
    case 45: return 'IPSECKEY'
    case 25: return 'KEY'
    case 36: return 'KX'
    case 29: return 'LOC'
    case 15: return 'MX'
    case 35: return 'NAPTR'
    case 2: return 'NS'
    case 47: return 'NSEC'
    case 50: return 'NSEC3'
    case 51: return 'NSEC3PARAM'
    case 12: return 'PTR'
    case 46: return 'RRSIG'
    case 17: return 'RP'
    case 24: return 'SIG'
    case 6: return 'SOA'
    case 99: return 'SPF'
    case 33: return 'SRV'
    case 44: return 'SSHFP'
    case 32768: return 'TA'
    case 249: return 'TKEY'
    case 52: return 'TLSA'
    case 250: return 'TSIG'
    case 16: return 'TXT'
    case 252: return 'AXFR'
    case 251: return 'IXFR'
    case 41: return 'OPT'
    case 255: return 'ANY'
  }
  return 'UNKNOWN_' + type
}

exports.toType = function (name) {
  switch (name.toUpperCase()) {
    case 'A': return 1
    case 'NULL': return 10
    case 'AAAA': return 28
    case 'AFSDB': return 18
    case 'APL': return 42
    case 'CAA': return 257
    case 'CDNSKEY': return 60
    case 'CDS': return 59
    case 'CERT': return 37
    case 'CNAME': return 5
    case 'DHCID': return 49
    case 'DLV': return 32769
    case 'DNAME': return 39
    case 'DNSKEY': return 48
    case 'DS': return 43
    case 'HIP': return 55
    case 'HINFO': return 13
    case 'IPSECKEY': return 45
    case 'KEY': return 25
    case 'KX': return 36
    case 'LOC': return 29
    case 'MX': return 15
    case 'NAPTR': return 35
    case 'NS': return 2
    case 'NSEC': return 47
    case 'NSEC3': return 50
    case 'NSEC3PARAM': return 51
    case 'PTR': return 12
    case 'RRSIG': return 46
    case 'RP': return 17
    case 'SIG': return 24
    case 'SOA': return 6
    case 'SPF': return 99
    case 'SRV': return 33
    case 'SSHFP': return 44
    case 'TA': return 32768
    case 'TKEY': return 249
    case 'TLSA': return 52
    case 'TSIG': return 250
    case 'TXT': return 16
    case 'AXFR': return 252
    case 'IXFR': return 251
    case 'OPT': return 41
    case 'ANY': return 255
    case '*': return 255
  }
  return 0
}


/***/ }),

/***/ 3265:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var stream = __nccwpck_require__(675)
var eos = __nccwpck_require__(2498)
var inherits = __nccwpck_require__(6919)
var shift = __nccwpck_require__(662)

var SIGNAL_FLUSH = (Buffer.from && Buffer.from !== Uint8Array.from)
  ? Buffer.from([0])
  : new Buffer([0])

var onuncork = function(self, fn) {
  if (self._corked) self.once('uncork', fn)
  else fn()
}

var autoDestroy = function (self, err) {
  if (self._autoDestroy) self.destroy(err)
}

var destroyer = function(self, end) {
  return function(err) {
    if (err) autoDestroy(self, err.message === 'premature close' ? null : err)
    else if (end && !self._ended) self.end()
  }
}

var end = function(ws, fn) {
  if (!ws) return fn()
  if (ws._writableState && ws._writableState.finished) return fn()
  if (ws._writableState) return ws.end(fn)
  ws.end()
  fn()
}

var toStreams2 = function(rs) {
  return new (stream.Readable)({objectMode:true, highWaterMark:16}).wrap(rs)
}

var Duplexify = function(writable, readable, opts) {
  if (!(this instanceof Duplexify)) return new Duplexify(writable, readable, opts)
  stream.Duplex.call(this, opts)

  this._writable = null
  this._readable = null
  this._readable2 = null

  this._autoDestroy = !opts || opts.autoDestroy !== false
  this._forwardDestroy = !opts || opts.destroy !== false
  this._forwardEnd = !opts || opts.end !== false
  this._corked = 1 // start corked
  this._ondrain = null
  this._drained = false
  this._forwarding = false
  this._unwrite = null
  this._unread = null
  this._ended = false

  this.destroyed = false

  if (writable) this.setWritable(writable)
  if (readable) this.setReadable(readable)
}

inherits(Duplexify, stream.Duplex)

Duplexify.obj = function(writable, readable, opts) {
  if (!opts) opts = {}
  opts.objectMode = true
  opts.highWaterMark = 16
  return new Duplexify(writable, readable, opts)
}

Duplexify.prototype.cork = function() {
  if (++this._corked === 1) this.emit('cork')
}

Duplexify.prototype.uncork = function() {
  if (this._corked && --this._corked === 0) this.emit('uncork')
}

Duplexify.prototype.setWritable = function(writable) {
  if (this._unwrite) this._unwrite()

  if (this.destroyed) {
    if (writable && writable.destroy) writable.destroy()
    return
  }

  if (writable === null || writable === false) {
    this.end()
    return
  }

  var self = this
  var unend = eos(writable, {writable:true, readable:false}, destroyer(this, this._forwardEnd))

  var ondrain = function() {
    var ondrain = self._ondrain
    self._ondrain = null
    if (ondrain) ondrain()
  }

  var clear = function() {
    self._writable.removeListener('drain', ondrain)
    unend()
  }

  if (this._unwrite) process.nextTick(ondrain) // force a drain on stream reset to avoid livelocks

  this._writable = writable
  this._writable.on('drain', ondrain)
  this._unwrite = clear

  this.uncork() // always uncork setWritable
}

Duplexify.prototype.setReadable = function(readable) {
  if (this._unread) this._unread()

  if (this.destroyed) {
    if (readable && readable.destroy) readable.destroy()
    return
  }

  if (readable === null || readable === false) {
    this.push(null)
    this.resume()
    return
  }

  var self = this
  var unend = eos(readable, {writable:false, readable:true}, destroyer(this))

  var onreadable = function() {
    self._forward()
  }

  var onend = function() {
    self.push(null)
  }

  var clear = function() {
    self._readable2.removeListener('readable', onreadable)
    self._readable2.removeListener('end', onend)
    unend()
  }

  this._drained = true
  this._readable = readable
  this._readable2 = readable._readableState ? readable : toStreams2(readable)
  this._readable2.on('readable', onreadable)
  this._readable2.on('end', onend)
  this._unread = clear

  this._forward()
}

Duplexify.prototype._read = function() {
  this._drained = true
  this._forward()
}

Duplexify.prototype._forward = function() {
  if (this._forwarding || !this._readable2 || !this._drained) return
  this._forwarding = true

  var data

  while (this._drained && (data = shift(this._readable2)) !== null) {
    if (this.destroyed) continue
    this._drained = this.push(data)
  }

  this._forwarding = false
}

Duplexify.prototype.destroy = function(err) {
  if (this.destroyed) return
  this.destroyed = true

  var self = this
  process.nextTick(function() {
    self._destroy(err)
  })
}

Duplexify.prototype._destroy = function(err) {
  if (err) {
    var ondrain = this._ondrain
    this._ondrain = null
    if (ondrain) ondrain(err)
    else this.emit('error', err)
  }

  if (this._forwardDestroy) {
    if (this._readable && this._readable.destroy) this._readable.destroy()
    if (this._writable && this._writable.destroy) this._writable.destroy()
  }

  this.emit('close')
}

Duplexify.prototype._write = function(data, enc, cb) {
  if (this.destroyed) return cb()
  if (this._corked) return onuncork(this, this._write.bind(this, data, enc, cb))
  if (data === SIGNAL_FLUSH) return this._finish(cb)
  if (!this._writable) return cb()

  if (this._writable.write(data) === false) this._ondrain = cb
  else cb()
}

Duplexify.prototype._finish = function(cb) {
  var self = this
  this.emit('preend')
  onuncork(this, function() {
    end(self._forwardEnd && self._writable, function() {
      // haxx to not emit prefinish twice
      if (self._writableState.prefinished === false) self._writableState.prefinished = true
      self.emit('prefinish')
      onuncork(self, cb)
    })
  })
}

Duplexify.prototype.end = function(data, enc, cb) {
  if (typeof data === 'function') return this.end(null, null, data)
  if (typeof enc === 'function') return this.end(data, null, enc)
  this._ended = true
  if (data) this.write(data)
  if (!this._writableState.ending) this.write(SIGNAL_FLUSH)
  return stream.Writable.prototype.end.call(this, cb)
}

module.exports = Duplexify


/***/ }),

/***/ 2498:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var once = __nccwpck_require__(7197);

var noop = function() {};

var isRequest = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function(stream) {
	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos(stream, null, opts);
	if (!opts) opts = {};

	callback = once(callback || noop);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);
	var cancelled = false;

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback.call(stream);
	};

	var onend = function() {
		readable = false;
		if (!writable) callback.call(stream);
	};

	var onexit = function(exitCode) {
		callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
	};

	var onerror = function(err) {
		callback.call(stream, err);
	};

	var onclose = function() {
		process.nextTick(onclosenexttick);
	};

	var onclosenexttick = function() {
		if (cancelled) return;
		if (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));
		if (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	if (isChildProcess(stream)) stream.on('exit', onexit);

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', onerror);
	stream.on('close', onclose);

	return function() {
		cancelled = true;
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('exit', onexit);
		stream.removeListener('end', onend);
		stream.removeListener('error', onerror);
		stream.removeListener('close', onclose);
	};
};

module.exports = eos;


/***/ }),

/***/ 6649:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var GetIntrinsic = __nccwpck_require__(9879);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%');
if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ 9697:
/***/ ((module) => {

"use strict";


// this should only run in node >= 13.2, so it
// does not need any of the intense fallbacks that old node/browsers do

var $iterator = Symbol.iterator;
module.exports = function getIterator(iterable) {
	// alternatively, `iterable[$iterator]?.()`
	if (iterable != null && typeof iterable[$iterator] !== 'undefined') {
		return iterable[$iterator]();
	}
};


/***/ }),

/***/ 6003:
/***/ ((module) => {

"use strict";


var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

module.exports = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	return str.replace(matchOperatorsRe, '\\$&');
};


/***/ }),

/***/ 7689:
/***/ ((module) => {

"use strict";


// do not edit .js files directly - edit src/index.jst



module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};


/***/ }),

/***/ 6573:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*
 * Basic JavaScript BN library - subset useful for RSA encryption.
 *
 * Copyright (c) 2003-2005  Tom Wu
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY
 * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
 * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER
 * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF
 * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * In addition, the following condition applies:
 *
 * All redistributions must retain an intact copy of this copyright notice
 * and disclaimer.
 */

/*
 *
 * Copyright (c) 2015 Zarmack Tanen
 * Fixed .toString(16) to be compatible with node >0.12.7 because hexWrite()
 *       only accepts %2=0 strings
 *
 *
 * Added Node.js Buffers support
 * 2014 rzcoder
 */

var crypt = __nccwpck_require__(6417);

// Bits per digit
var dbits;

// JavaScript engine analysis
var canary = 0xdeadbeefcafe;
var j_lm = ((canary & 0xffffff) == 0xefcafe);

// (public) Constructor
function BigInteger(a, b) {
    if (a != null) {
        if ("number" == typeof a) {
            this.fromNumber(a, b);
        } else if (Buffer.isBuffer(a)) {
            this.fromBuffer(a);
        } else if (b == null && "string" != typeof a) {
            this.fromByteArray(a);
        } else {
            this.fromString(a, b);
        }
    }
}

// return new, unset BigInteger
function nbi() {
    return new BigInteger(null);
}

// am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.

// am1: use a single mult and divide to get the high bits,
// max digit bits should be 26 because
// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
function am1(i, x, w, j, c, n) {
    while (--n >= 0) {
        var v = x * this[i++] + w[j] + c;
        c = Math.floor(v / 0x4000000);
        w[j++] = v & 0x3ffffff;
    }
    return c;
}
// am2 avoids a big mult-and-extract completely.
// Max digit bits should be <= 30 because we do bitwise ops
// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
function am2(i, x, w, j, c, n) {
    var xl = x & 0x7fff, xh = x >> 15;
    while (--n >= 0) {
        var l = this[i] & 0x7fff;
        var h = this[i++] >> 15;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);
        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
        w[j++] = l & 0x3fffffff;
    }
    return c;
}
// Alternately, set max digit bits to 28 since some
// browsers slow down when dealing with 32-bit numbers.
function am3(i, x, w, j, c, n) {
    var xl = x & 0x3fff, xh = x >> 14;
    while (--n >= 0) {
        var l = this[i] & 0x3fff;
        var h = this[i++] >> 14;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;
        c = (l >> 28) + (m >> 14) + xh * h;
        w[j++] = l & 0xfffffff;
    }
    return c;
}

// We need to select the fastest one that works in this environment.
//if (j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
//	BigInteger.prototype.am = am2;
//	dbits = 30;
//} else if (j_lm && (navigator.appName != "Netscape")) {
//	BigInteger.prototype.am = am1;
//	dbits = 26;
//} else { // Mozilla/Netscape seems to prefer am3
//	BigInteger.prototype.am = am3;
//	dbits = 28;
//}

// For node.js, we pick am3 with max dbits to 28.
BigInteger.prototype.am = am3;
dbits = 28;

BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = ((1 << dbits) - 1);
BigInteger.prototype.DV = (1 << dbits);

var BI_FP = 52;
BigInteger.prototype.FV = Math.pow(2, BI_FP);
BigInteger.prototype.F1 = BI_FP - dbits;
BigInteger.prototype.F2 = 2 * dbits - BI_FP;

// Digit conversions
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
var BI_RC = new Array();
var rr, vv;
rr = "0".charCodeAt(0);
for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
rr = "a".charCodeAt(0);
for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
rr = "A".charCodeAt(0);
for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

function int2char(n) {
    return BI_RM.charAt(n);
}
function intAt(s, i) {
    var c = BI_RC[s.charCodeAt(i)];
    return (c == null) ? -1 : c;
}

// (protected) copy this to r
function bnpCopyTo(r) {
    for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];
    r.t = this.t;
    r.s = this.s;
}

// (protected) set from integer value x, -DV <= x < DV
function bnpFromInt(x) {
    this.t = 1;
    this.s = (x < 0) ? -1 : 0;
    if (x > 0) this[0] = x;
    else if (x < -1) this[0] = x + DV;
    else this.t = 0;
}

// return bigint initialized to value
function nbv(i) {
    var r = nbi();
    r.fromInt(i);
    return r;
}

// (protected) set from string and radix
function bnpFromString(data, radix, unsigned) {
    var k;
    switch (radix) {
        case 2:
            k = 1;
            break;
        case 4:
            k = 2;
            break;
        case 8:
            k = 3;
            break;
        case 16:
            k = 4;
            break;
        case 32:
            k = 5;
            break;
        case 256:
            k = 8;
            break;
        default:
            this.fromRadix(data, radix);
            return;
    }

    this.t = 0;
    this.s = 0;

    var i = data.length;
    var mi = false;
    var sh = 0;

    while (--i >= 0) {
        var x = (k == 8) ? data[i] & 0xff : intAt(data, i);
        if (x < 0) {
            if (data.charAt(i) == "-") mi = true;
            continue;
        }
        mi = false;
        if (sh === 0)
            this[this.t++] = x;
        else if (sh + k > this.DB) {
            this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
            this[this.t++] = (x >> (this.DB - sh));
        }
        else
            this[this.t - 1] |= x << sh;
        sh += k;
        if (sh >= this.DB) sh -= this.DB;
    }
    if ((!unsigned) && k == 8 && (data[0] & 0x80) != 0) {
        this.s = -1;
        if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
    }
    this.clamp();
    if (mi) BigInteger.ZERO.subTo(this, this);
}

function bnpFromByteArray(a, unsigned) {
    this.fromString(a, 256, unsigned)
}

function bnpFromBuffer(a) {
    this.fromString(a, 256, true)
}

// (protected) clamp off excess high words
function bnpClamp() {
    var c = this.s & this.DM;
    while (this.t > 0 && this[this.t - 1] == c) --this.t;
}

// (public) return string representation in given radix
function bnToString(b) {
    if (this.s < 0) return "-" + this.negate().toString(b);
    var k;
    if (b == 16) k = 4;
    else if (b == 8) k = 3;
    else if (b == 2) k = 1;
    else if (b == 32) k = 5;
    else if (b == 4) k = 2;
    else return this.toRadix(b);
    var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
    var p = this.DB - (i * this.DB) % k;
    if (i-- > 0) {
        if (p < this.DB && (d = this[i] >> p) > 0) {
            m = true;
            r = int2char(d);
        }
        while (i >= 0) {
            if (p < k) {
                d = (this[i] & ((1 << p) - 1)) << (k - p);
                d |= this[--i] >> (p += this.DB - k);
            }
            else {
                d = (this[i] >> (p -= k)) & km;
                if (p <= 0) {
                    p += this.DB;
                    --i;
                }
            }
            if (d > 0) m = true;
            if (m) r += int2char(d);
        }
    }
    //! Fix to be compatible with node >0.12.7 Buffer.js
    if(b == 16 && r.length % 2 != 0)
	     r = "0" + r;
    return m ? r : "0";
}

// (public) -this
function bnNegate() {
    var r = nbi();
    BigInteger.ZERO.subTo(this, r);
    return r;
}

// (public) |this|
function bnAbs() {
    return (this.s < 0) ? this.negate() : this;
}

// (public) return + if this > a, - if this < a, 0 if equal
function bnCompareTo(a) {
    var r = this.s - a.s;
    if (r != 0) return r;
    var i = this.t;
    r = i - a.t;
    if (r != 0) return (this.s < 0) ? -r : r;
    while (--i >= 0) if ((r = this[i] - a[i]) != 0) return r;
    return 0;
}

function bnEqual(a) {
  console.log(this.compareTo(a));
  return (this.compareTo(a) == 0) ? true: false;
}

function bnGreater(a) {
  return (this.compareTo(a) > 0) ? true : false;
}

function bnGreaterOrEqual(a) {
  return (this.compareTo(a) >= 0) ? true : false;
}

function bnLesser(a) {
  return (this.compareTo(a) < 0) ? true : false;
}

function bnLesserOrEqual(a) {
  return (this.compareTo(a) <= 0) ? true : false;
}

// returns bit length of the integer x
function nbits(x) {
    var r = 1, t;
    if ((t = x >>> 16) != 0) {
        x = t;
        r += 16;
    }
    if ((t = x >> 8) != 0) {
        x = t;
        r += 8;
    }
    if ((t = x >> 4) != 0) {
        x = t;
        r += 4;
    }
    if ((t = x >> 2) != 0) {
        x = t;
        r += 2;
    }
    if ((t = x >> 1) != 0) {
        x = t;
        r += 1;
    }
    return r;
}

// (public) return the number of bits in "this"
function bnBitLength() {
    if (this.t <= 0) return 0;
    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));
}

// (protected) r = this << n*DB
function bnpDLShiftTo(n, r) {
    var i;
    for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];
    for (i = n - 1; i >= 0; --i) r[i] = 0;
    r.t = this.t + n;
    r.s = this.s;
}

// (protected) r = this >> n*DB
function bnpDRShiftTo(n, r) {
    for (var i = n; i < this.t; ++i) r[i - n] = this[i];
    r.t = Math.max(this.t - n, 0);
    r.s = this.s;
}

// (protected) r = this << n
function bnpLShiftTo(n, r) {
    var bs = n % this.DB;
    var cbs = this.DB - bs;
    var bm = (1 << cbs) - 1;
    var ds = Math.floor(n / this.DB), c = (this.s << bs) & this.DM, i;
    for (i = this.t - 1; i >= 0; --i) {
        r[i + ds + 1] = (this[i] >> cbs) | c;
        c = (this[i] & bm) << bs;
    }
    for (i = ds - 1; i >= 0; --i) r[i] = 0;
    r[ds] = c;
    r.t = this.t + ds + 1;
    r.s = this.s;
    r.clamp();
}

// (protected) r = this >> n
function bnpRShiftTo(n, r) {
    r.s = this.s;
    var ds = Math.floor(n / this.DB);
    if (ds >= this.t) {
        r.t = 0;
        return;
    }
    var bs = n % this.DB;
    var cbs = this.DB - bs;
    var bm = (1 << bs) - 1;
    r[0] = this[ds] >> bs;
    for (var i = ds + 1; i < this.t; ++i) {
        r[i - ds - 1] |= (this[i] & bm) << cbs;
        r[i - ds] = this[i] >> bs;
    }
    if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;
    r.t = this.t - ds;
    r.clamp();
}

// (protected) r = this - a
function bnpSubTo(a, r) {
    var i = 0, c = 0, m = Math.min(a.t, this.t);
    while (i < m) {
        c += this[i] - a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
    }
    if (a.t < this.t) {
        c -= a.s;
        while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
        }
        c += this.s;
    }
    else {
        c += this.s;
        while (i < a.t) {
            c -= a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
        }
        c -= a.s;
    }
    r.s = (c < 0) ? -1 : 0;
    if (c < -1) r[i++] = this.DV + c;
    else if (c > 0) r[i++] = c;
    r.t = i;
    r.clamp();
}

// (protected) r = this * a, r != this,a (HAC 14.12)
// "this" should be the larger one if appropriate.
function bnpMultiplyTo(a, r) {
    var x = this.abs(), y = a.abs();
    var i = x.t;
    r.t = i + y.t;
    while (--i >= 0) r[i] = 0;
    for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
    r.s = 0;
    r.clamp();
    if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
}

// (protected) r = this^2, r != this (HAC 14.16)
function bnpSquareTo(r) {
    var x = this.abs();
    var i = r.t = 2 * x.t;
    while (--i >= 0) r[i] = 0;
    for (i = 0; i < x.t - 1; ++i) {
        var c = x.am(i, x[i], r, 2 * i, 0, 1);
        if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
            r[i + x.t] -= x.DV;
            r[i + x.t + 1] = 1;
        }
    }
    if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
    r.s = 0;
    r.clamp();
}

// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
// r != q, this != m.  q or r may be null.
function bnpDivRemTo(m, q, r) {
    var pm = m.abs();
    if (pm.t <= 0) return;
    var pt = this.abs();
    if (pt.t < pm.t) {
        if (q != null) q.fromInt(0);
        if (r != null) this.copyTo(r);
        return;
    }
    if (r == null) r = nbi();
    var y = nbi(), ts = this.s, ms = m.s;
    var nsh = this.DB - nbits(pm[pm.t - 1]);	// normalize modulus
    if (nsh > 0) {
        pm.lShiftTo(nsh, y);
        pt.lShiftTo(nsh, r);
    }
    else {
        pm.copyTo(y);
        pt.copyTo(r);
    }
    var ys = y.t;
    var y0 = y[ys - 1];
    if (y0 === 0) return;
    var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);
    var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
    var i = r.t, j = i - ys, t = (q == null) ? nbi() : q;
    y.dlShiftTo(j, t);
    if (r.compareTo(t) >= 0) {
        r[r.t++] = 1;
        r.subTo(t, r);
    }
    BigInteger.ONE.dlShiftTo(ys, t);
    t.subTo(y, y);	// "negative" y so we can replace sub with am later
    while (y.t < ys) y[y.t++] = 0;
    while (--j >= 0) {
        // Estimate quotient digit
        var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
        if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {	// Try it out
            y.dlShiftTo(j, t);
            r.subTo(t, r);
            while (r[i] < --qd) r.subTo(t, r);
        }
    }
    if (q != null) {
        r.drShiftTo(ys, q);
        if (ts != ms) BigInteger.ZERO.subTo(q, q);
    }
    r.t = ys;
    r.clamp();
    if (nsh > 0) r.rShiftTo(nsh, r);	// Denormalize remainder
    if (ts < 0) BigInteger.ZERO.subTo(r, r);
}

// (public) this mod a
function bnMod(a) {
    var r = nbi();
    this.abs().divRemTo(a, null, r);
    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
    return r;
}

// Modular reduction using "classic" algorithm
function Classic(m) {
    this.m = m;
}
function cConvert(x) {
    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
    else return x;
}
function cRevert(x) {
    return x;
}
function cReduce(x) {
    x.divRemTo(this.m, null, x);
}
function cMulTo(x, y, r) {
    x.multiplyTo(y, r);
    this.reduce(r);
}
function cSqrTo(x, r) {
    x.squareTo(r);
    this.reduce(r);
}

Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;

// (protected) return "-1/this % 2^DB"; useful for Mont. reduction
// justification:
//         xy == 1 (mod m)
//         xy =  1+km
//   xy(2-xy) = (1+km)(1-km)
// x[y(2-xy)] = 1-k^2m^2
// x[y(2-xy)] == 1 (mod m^2)
// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
// JS multiply "overflows" differently from C/C++, so care is needed here.
function bnpInvDigit() {
    if (this.t < 1) return 0;
    var x = this[0];
    if ((x & 1) === 0) return 0;
    var y = x & 3;		// y == 1/x mod 2^2
    y = (y * (2 - (x & 0xf) * y)) & 0xf;	// y == 1/x mod 2^4
    y = (y * (2 - (x & 0xff) * y)) & 0xff;	// y == 1/x mod 2^8
    y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff;	// y == 1/x mod 2^16
    // last step - calculate inverse mod DV directly;
    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
    y = (y * (2 - x * y % this.DV)) % this.DV;		// y == 1/x mod 2^dbits
    // we really want the negative inverse, and -DV < y < DV
    return (y > 0) ? this.DV - y : -y;
}

// Montgomery reduction
function Montgomery(m) {
    this.m = m;
    this.mp = m.invDigit();
    this.mpl = this.mp & 0x7fff;
    this.mph = this.mp >> 15;
    this.um = (1 << (m.DB - 15)) - 1;
    this.mt2 = 2 * m.t;
}

// xR mod m
function montConvert(x) {
    var r = nbi();
    x.abs().dlShiftTo(this.m.t, r);
    r.divRemTo(this.m, null, r);
    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
    return r;
}

// x/R mod m
function montRevert(x) {
    var r = nbi();
    x.copyTo(r);
    this.reduce(r);
    return r;
}

// x = x/R mod m (HAC 14.32)
function montReduce(x) {
    while (x.t <= this.mt2)	// pad x so am has enough room later
        x[x.t++] = 0;
    for (var i = 0; i < this.m.t; ++i) {
        // faster way of calculating u0 = x[i]*mp mod DV
        var j = x[i] & 0x7fff;
        var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;
        // use am to combine the multiply-shift-add into one call
        j = i + this.m.t;
        x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
        // propagate carry
        while (x[j] >= x.DV) {
            x[j] -= x.DV;
            x[++j]++;
        }
    }
    x.clamp();
    x.drShiftTo(this.m.t, x);
    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
}

// r = "x^2/R mod m"; x != r
function montSqrTo(x, r) {
    x.squareTo(r);
    this.reduce(r);
}

// r = "xy/R mod m"; x,y != r
function montMulTo(x, y, r) {
    x.multiplyTo(y, r);
    this.reduce(r);
}

Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo;

// (protected) true iff this is even
function bnpIsEven() {
    return ((this.t > 0) ? (this[0] & 1) : this.s) === 0;
}

// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
function bnpExp(e, z) {
    if (e > 0xffffffff || e < 1) return BigInteger.ONE;
    var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
    g.copyTo(r);
    while (--i >= 0) {
        z.sqrTo(r, r2);
        if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);
        else {
            var t = r;
            r = r2;
            r2 = t;
        }
    }
    return z.revert(r);
}

// (public) this^e % m, 0 <= e < 2^32
function bnModPowInt(e, m) {
    var z;
    if (e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
    return this.exp(e, z);
}

// Copyright (c) 2005-2009  Tom Wu
// All Rights Reserved.
// See "LICENSE" for details.

// Extended JavaScript BN functions, required for RSA private ops.

// Version 1.1: new BigInteger("0", 10) returns "proper" zero
// Version 1.2: square() API, isProbablePrime fix

//(public)
function bnClone() {
    var r = nbi();
    this.copyTo(r);
    return r;
}

//(public) return value as integer
function bnIntValue() {
    if (this.s < 0) {
        if (this.t == 1) return this[0] - this.DV;
        else if (this.t === 0) return -1;
    }
    else if (this.t == 1) return this[0];
    else if (this.t === 0) return 0;
// assumes 16 < DB < 32
    return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];
}

//(public) return value as byte
function bnByteValue() {
    return (this.t == 0) ? this.s : (this[0] << 24) >> 24;
}

//(public) return value as short (assumes DB>=16)
function bnShortValue() {
    return (this.t == 0) ? this.s : (this[0] << 16) >> 16;
}

//(protected) return x s.t. r^x < DV
function bnpChunkSize(r) {
    return Math.floor(Math.LN2 * this.DB / Math.log(r));
}

//(public) 0 if this === 0, 1 if this > 0
function bnSigNum() {
    if (this.s < 0) return -1;
    else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
    else return 1;
}

//(protected) convert to radix string
function bnpToRadix(b) {
    if (b == null) b = 10;
    if (this.signum() === 0 || b < 2 || b > 36) return "0";
    var cs = this.chunkSize(b);
    var a = Math.pow(b, cs);
    var d = nbv(a), y = nbi(), z = nbi(), r = "";
    this.divRemTo(d, y, z);
    while (y.signum() > 0) {
        r = (a + z.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d, y, z);
    }
    return z.intValue().toString(b) + r;
}

//(protected) convert from radix string
function bnpFromRadix(s, b) {
    this.fromInt(0);
    if (b == null) b = 10;
    var cs = this.chunkSize(b);
    var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
    for (var i = 0; i < s.length; ++i) {
        var x = intAt(s, i);
        if (x < 0) {
            if (s.charAt(i) == "-" && this.signum() === 0) mi = true;
            continue;
        }
        w = b * w + x;
        if (++j >= cs) {
            this.dMultiply(d);
            this.dAddOffset(w, 0);
            j = 0;
            w = 0;
        }
    }
    if (j > 0) {
        this.dMultiply(Math.pow(b, j));
        this.dAddOffset(w, 0);
    }
    if (mi) BigInteger.ZERO.subTo(this, this);
}

//(protected) alternate constructor
function bnpFromNumber(a, b) {
    if ("number" == typeof b) {
        // new BigInteger(int,int,RNG)
        if (a < 2) this.fromInt(1);
        else {
            this.fromNumber(a);
            if (!this.testBit(a - 1))	// force MSB set
                this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
            if (this.isEven()) this.dAddOffset(1, 0); // force odd
            while (!this.isProbablePrime(b)) {
                this.dAddOffset(2, 0);
                if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
            }
        }
    } else {
        // new BigInteger(int,RNG)
        var x = crypt.randomBytes((a >> 3) + 1)
        var t = a & 7;

        if (t > 0)
            x[0] &= ((1 << t) - 1);
        else
            x[0] = 0;

        this.fromByteArray(x);
    }
}

//(public) convert to bigendian byte array
function bnToByteArray() {
    var i = this.t, r = new Array();
    r[0] = this.s;
    var p = this.DB - (i * this.DB) % 8, d, k = 0;
    if (i-- > 0) {
        if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
            r[k++] = d | (this.s << (this.DB - p));
        while (i >= 0) {
            if (p < 8) {
                d = (this[i] & ((1 << p) - 1)) << (8 - p);
                d |= this[--i] >> (p += this.DB - 8);
            }
            else {
                d = (this[i] >> (p -= 8)) & 0xff;
                if (p <= 0) {
                    p += this.DB;
                    --i;
                }
            }
            if ((d & 0x80) != 0) d |= -256;
            if (k === 0 && (this.s & 0x80) != (d & 0x80)) ++k;
            if (k > 0 || d != this.s) r[k++] = d;
        }
    }
    return r;
}

/**
 * return Buffer object
 * @param trim {boolean} slice buffer if first element == 0
 * @returns {Buffer}
 */
function bnToBuffer(trimOrSize) {
    var res = Buffer.from(this.toByteArray());
    if (trimOrSize === true && res[0] === 0) {
        res = res.slice(1);
    } else if (typeof trimOrSize == 'number') {
        if (res.length > trimOrSize) {
            for (var i = 0; i < res.length - trimOrSize; i++) {
                if (res[i] !== 0) {
                    return null;
                }
            }
            return res.slice(res.length - trimOrSize);
        } else if (res.length < trimOrSize) {
            var padded = Buffer.alloc(trimOrSize);
            padded.fill(0, 0, trimOrSize - res.length);
            res.copy(padded, trimOrSize - res.length);
            return padded;
        }
    }
    return res;
}

function bnEquals(a) {
    return (this.compareTo(a) == 0);
}
function bnMin(a) {
    return (this.compareTo(a) < 0) ? this : a;
}
function bnMax(a) {
    return (this.compareTo(a) > 0) ? this : a;
}

//(protected) r = this op a (bitwise)
function bnpBitwiseTo(a, op, r) {
    var i, f, m = Math.min(a.t, this.t);
    for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);
    if (a.t < this.t) {
        f = a.s & this.DM;
        for (i = m; i < this.t; ++i) r[i] = op(this[i], f);
        r.t = this.t;
    }
    else {
        f = this.s & this.DM;
        for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);
        r.t = a.t;
    }
    r.s = op(this.s, a.s);
    r.clamp();
}

//(public) this & a
function op_and(x, y) {
    return x & y;
}
function bnAnd(a) {
    var r = nbi();
    this.bitwiseTo(a, op_and, r);
    return r;
}

//(public) this | a
function op_or(x, y) {
    return x | y;
}
function bnOr(a) {
    var r = nbi();
    this.bitwiseTo(a, op_or, r);
    return r;
}

//(public) this ^ a
function op_xor(x, y) {
    return x ^ y;
}
function bnXor(a) {
    var r = nbi();
    this.bitwiseTo(a, op_xor, r);
    return r;
}

//(public) this & ~a
function op_andnot(x, y) {
    return x & ~y;
}
function bnAndNot(a) {
    var r = nbi();
    this.bitwiseTo(a, op_andnot, r);
    return r;
}

//(public) ~this
function bnNot() {
    var r = nbi();
    for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];
    r.t = this.t;
    r.s = ~this.s;
    return r;
}

//(public) this << n
function bnShiftLeft(n) {
    var r = nbi();
    if (n < 0) this.rShiftTo(-n, r); else this.lShiftTo(n, r);
    return r;
}

//(public) this >> n
function bnShiftRight(n) {
    var r = nbi();
    if (n < 0) this.lShiftTo(-n, r); else this.rShiftTo(n, r);
    return r;
}

//return index of lowest 1-bit in x, x < 2^31
function lbit(x) {
    if (x === 0) return -1;
    var r = 0;
    if ((x & 0xffff) === 0) {
        x >>= 16;
        r += 16;
    }
    if ((x & 0xff) === 0) {
        x >>= 8;
        r += 8;
    }
    if ((x & 0xf) === 0) {
        x >>= 4;
        r += 4;
    }
    if ((x & 3) === 0) {
        x >>= 2;
        r += 2;
    }
    if ((x & 1) === 0) ++r;
    return r;
}

//(public) returns index of lowest 1-bit (or -1 if none)
function bnGetLowestSetBit() {
    for (var i = 0; i < this.t; ++i)
        if (this[i] != 0) return i * this.DB + lbit(this[i]);
    if (this.s < 0) return this.t * this.DB;
    return -1;
}

//return number of 1 bits in x
function cbit(x) {
    var r = 0;
    while (x != 0) {
        x &= x - 1;
        ++r;
    }
    return r;
}

//(public) return number of set bits
function bnBitCount() {
    var r = 0, x = this.s & this.DM;
    for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);
    return r;
}

//(public) true iff nth bit is set
function bnTestBit(n) {
    var j = Math.floor(n / this.DB);
    if (j >= this.t) return (this.s != 0);
    return ((this[j] & (1 << (n % this.DB))) != 0);
}

//(protected) this op (1<<n)
function bnpChangeBit(n, op) {
    var r = BigInteger.ONE.shiftLeft(n);
    this.bitwiseTo(r, op, r);
    return r;
}

//(public) this | (1<<n)
function bnSetBit(n) {
    return this.changeBit(n, op_or);
}

//(public) this & ~(1<<n)
function bnClearBit(n) {
    return this.changeBit(n, op_andnot);
}

//(public) this ^ (1<<n)
function bnFlipBit(n) {
    return this.changeBit(n, op_xor);
}

//(protected) r = this + a
function bnpAddTo(a, r) {
    var i = 0, c = 0, m = Math.min(a.t, this.t);
    while (i < m) {
        c += this[i] + a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
    }
    if (a.t < this.t) {
        c += a.s;
        while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
        }
        c += this.s;
    }
    else {
        c += this.s;
        while (i < a.t) {
            c += a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
        }
        c += a.s;
    }
    r.s = (c < 0) ? -1 : 0;
    if (c > 0) r[i++] = c;
    else if (c < -1) r[i++] = this.DV + c;
    r.t = i;
    r.clamp();
}

//(public) this + a
function bnAdd(a) {
    var r = nbi();
    this.addTo(a, r);
    return r;
}

//(public) this - a
function bnSubtract(a) {
    var r = nbi();
    this.subTo(a, r);
    return r;
}

//(public) this * a
function bnMultiply(a) {
    var r = nbi();
    this.multiplyTo(a, r);
    return r;
}

// (public) this^2
function bnSquare() {
    var r = nbi();
    this.squareTo(r);
    return r;
}

//(public) this / a
function bnDivide(a) {
    var r = nbi();
    this.divRemTo(a, r, null);
    return r;
}

//(public) this % a
function bnRemainder(a) {
    var r = nbi();
    this.divRemTo(a, null, r);
    return r;
}

//(public) [this/a,this%a]
function bnDivideAndRemainder(a) {
    var q = nbi(), r = nbi();
    this.divRemTo(a, q, r);
    return new Array(q, r);
}

//(protected) this *= n, this >= 0, 1 < n < DV
function bnpDMultiply(n) {
    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
    ++this.t;
    this.clamp();
}

//(protected) this += n << w words, this >= 0
function bnpDAddOffset(n, w) {
    if (n === 0) return;
    while (this.t <= w) this[this.t++] = 0;
    this[w] += n;
    while (this[w] >= this.DV) {
        this[w] -= this.DV;
        if (++w >= this.t) this[this.t++] = 0;
        ++this[w];
    }
}

//A "null" reducer
function NullExp() {
}
function nNop(x) {
    return x;
}
function nMulTo(x, y, r) {
    x.multiplyTo(y, r);
}
function nSqrTo(x, r) {
    x.squareTo(r);
}

NullExp.prototype.convert = nNop;
NullExp.prototype.revert = nNop;
NullExp.prototype.mulTo = nMulTo;
NullExp.prototype.sqrTo = nSqrTo;

//(public) this^e
function bnPow(e) {
    return this.exp(e, new NullExp());
}

//(protected) r = lower n words of "this * a", a.t <= n
//"this" should be the larger one if appropriate.
function bnpMultiplyLowerTo(a, n, r) {
    var i = Math.min(this.t + a.t, n);
    r.s = 0; // assumes a,this >= 0
    r.t = i;
    while (i > 0) r[--i] = 0;
    var j;
    for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
    for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);
    r.clamp();
}

//(protected) r = "this * a" without lower n words, n > 0
//"this" should be the larger one if appropriate.
function bnpMultiplyUpperTo(a, n, r) {
    --n;
    var i = r.t = this.t + a.t - n;
    r.s = 0; // assumes a,this >= 0
    while (--i >= 0) r[i] = 0;
    for (i = Math.max(n - this.t, 0); i < a.t; ++i)
        r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
    r.clamp();
    r.drShiftTo(1, r);
}

//Barrett modular reduction
function Barrett(m) {
// setup Barrett
    this.r2 = nbi();
    this.q3 = nbi();
    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
    this.mu = this.r2.divide(m);
    this.m = m;
}

function barrettConvert(x) {
    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
    else if (x.compareTo(this.m) < 0) return x;
    else {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
    }
}

function barrettRevert(x) {
    return x;
}

//x = x mod m (HAC 14.42)
function barrettReduce(x) {
    x.drShiftTo(this.m.t - 1, this.r2);
    if (x.t > this.m.t + 1) {
        x.t = this.m.t + 1;
        x.clamp();
    }
    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
    while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
    x.subTo(this.r2, x);
    while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
}

//r = x^2 mod m; x != r
function barrettSqrTo(x, r) {
    x.squareTo(r);
    this.reduce(r);
}

//r = x*y mod m; x,y != r
function barrettMulTo(x, y, r) {
    x.multiplyTo(y, r);
    this.reduce(r);
}

Barrett.prototype.convert = barrettConvert;
Barrett.prototype.revert = barrettRevert;
Barrett.prototype.reduce = barrettReduce;
Barrett.prototype.mulTo = barrettMulTo;
Barrett.prototype.sqrTo = barrettSqrTo;

//(public) this^e % m (HAC 14.85)
function bnModPow(e, m) {
    var i = e.bitLength(), k, r = nbv(1), z;
    if (i <= 0) return r;
    else if (i < 18) k = 1;
    else if (i < 48) k = 3;
    else if (i < 144) k = 4;
    else if (i < 768) k = 5;
    else k = 6;
    if (i < 8)
        z = new Classic(m);
    else if (m.isEven())
        z = new Barrett(m);
    else
        z = new Montgomery(m);

// precomputation
    var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
    g[1] = z.convert(this);
    if (k > 1) {
        var g2 = nbi();
        z.sqrTo(g[1], g2);
        while (n <= km) {
            g[n] = nbi();
            z.mulTo(g2, g[n - 2], g[n]);
            n += 2;
        }
    }

    var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
    i = nbits(e[j]) - 1;
    while (j >= 0) {
        if (i >= k1) w = (e[j] >> (i - k1)) & km;
        else {
            w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
            if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);
        }

        n = k;
        while ((w & 1) === 0) {
            w >>= 1;
            --n;
        }
        if ((i -= n) < 0) {
            i += this.DB;
            --j;
        }
        if (is1) {	// ret == 1, don't bother squaring or multiplying it
            g[w].copyTo(r);
            is1 = false;
        }
        else {
            while (n > 1) {
                z.sqrTo(r, r2);
                z.sqrTo(r2, r);
                n -= 2;
            }
            if (n > 0) z.sqrTo(r, r2); else {
                t = r;
                r = r2;
                r2 = t;
            }
            z.mulTo(r2, g[w], r);
        }

        while (j >= 0 && (e[j] & (1 << i)) === 0) {
            z.sqrTo(r, r2);
            t = r;
            r = r2;
            r2 = t;
            if (--i < 0) {
                i = this.DB - 1;
                --j;
            }
        }
    }
    return z.revert(r);
}

//(public) gcd(this,a) (HAC 14.54)
function bnGCD(a) {
    var x = (this.s < 0) ? this.negate() : this.clone();
    var y = (a.s < 0) ? a.negate() : a.clone();
    if (x.compareTo(y) < 0) {
        var t = x;
        x = y;
        y = t;
    }
    var i = x.getLowestSetBit(), g = y.getLowestSetBit();
    if (g < 0) return x;
    if (i < g) g = i;
    if (g > 0) {
        x.rShiftTo(g, x);
        y.rShiftTo(g, y);
    }
    while (x.signum() > 0) {
        if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
        if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
        if (x.compareTo(y) >= 0) {
            x.subTo(y, x);
            x.rShiftTo(1, x);
        }
        else {
            y.subTo(x, y);
            y.rShiftTo(1, y);
        }
    }
    if (g > 0) y.lShiftTo(g, y);
    return y;
}

//(protected) this % n, n < 2^26
function bnpModInt(n) {
    if (n <= 0) return 0;
    var d = this.DV % n, r = (this.s < 0) ? n - 1 : 0;
    if (this.t > 0)
        if (d === 0) r = this[0] % n;
        else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;
    return r;
}

//(public) 1/this % m (HAC 14.61)
function bnModInverse(m) {
    var ac = m.isEven();
    if ((this.isEven() && ac) || m.signum() === 0) return BigInteger.ZERO;
    var u = m.clone(), v = this.clone();
    var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
    while (u.signum() != 0) {
        while (u.isEven()) {
            u.rShiftTo(1, u);
            if (ac) {
                if (!a.isEven() || !b.isEven()) {
                    a.addTo(this, a);
                    b.subTo(m, b);
                }
                a.rShiftTo(1, a);
            }
            else if (!b.isEven()) b.subTo(m, b);
            b.rShiftTo(1, b);
        }
        while (v.isEven()) {
            v.rShiftTo(1, v);
            if (ac) {
                if (!c.isEven() || !d.isEven()) {
                    c.addTo(this, c);
                    d.subTo(m, d);
                }
                c.rShiftTo(1, c);
            }
            else if (!d.isEven()) d.subTo(m, d);
            d.rShiftTo(1, d);
        }
        if (u.compareTo(v) >= 0) {
            u.subTo(v, u);
            if (ac) a.subTo(c, a);
            b.subTo(d, b);
        }
        else {
            v.subTo(u, v);
            if (ac) c.subTo(a, c);
            d.subTo(b, d);
        }
    }
    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
    if (d.compareTo(m) >= 0) return d.subtract(m);
    if (d.signum() < 0) d.addTo(m, d); else return d;
    if (d.signum() < 0) return d.add(m); else return d;
}

var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];

//(public) test primality with certainty >= 1-.5^t
function bnIsProbablePrime(t) {
    var i, x = this.abs();
    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
        for (i = 0; i < lowprimes.length; ++i)
            if (x[0] == lowprimes[i]) return true;
        return false;
    }
    if (x.isEven()) return false;
    i = 1;
    while (i < lowprimes.length) {
        var m = lowprimes[i], j = i + 1;
        while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
        m = x.modInt(m);
        while (i < j) if (m % lowprimes[i++] === 0) return false;
    }
    return x.millerRabin(t);
}

//(protected) true if probably prime (HAC 4.24, Miller-Rabin)
function bnpMillerRabin(t) {
    var n1 = this.subtract(BigInteger.ONE);
    var k = n1.getLowestSetBit();
    if (k <= 0) return false;
    var r = n1.shiftRight(k);
    t = (t + 1) >> 1;
    if (t > lowprimes.length) t = lowprimes.length;
    var a = nbi();
    for (var i = 0; i < t; ++i) {
        //Pick bases at random, instead of starting at 2
        a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
        var y = a.modPow(r, this);
        if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
            var j = 1;
            while (j++ < k && y.compareTo(n1) != 0) {
                y = y.modPowInt(2, this);
                if (y.compareTo(BigInteger.ONE) === 0) return false;
            }
            if (y.compareTo(n1) != 0) return false;
        }
    }
    return true;
}

// protected
BigInteger.prototype.copyTo = bnpCopyTo;
BigInteger.prototype.fromInt = bnpFromInt;
BigInteger.prototype.fromString = bnpFromString;
BigInteger.prototype.fromByteArray = bnpFromByteArray;
BigInteger.prototype.fromBuffer = bnpFromBuffer;
BigInteger.prototype.clamp = bnpClamp;
BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
BigInteger.prototype.drShiftTo = bnpDRShiftTo;
BigInteger.prototype.lShiftTo = bnpLShiftTo;
BigInteger.prototype.rShiftTo = bnpRShiftTo;
BigInteger.prototype.subTo = bnpSubTo;
BigInteger.prototype.multiplyTo = bnpMultiplyTo;
BigInteger.prototype.squareTo = bnpSquareTo;
BigInteger.prototype.divRemTo = bnpDivRemTo;
BigInteger.prototype.invDigit = bnpInvDigit;
BigInteger.prototype.isEven = bnpIsEven;
BigInteger.prototype.exp = bnpExp;

BigInteger.prototype.chunkSize = bnpChunkSize;
BigInteger.prototype.toRadix = bnpToRadix;
BigInteger.prototype.fromRadix = bnpFromRadix;
BigInteger.prototype.fromNumber = bnpFromNumber;
BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
BigInteger.prototype.changeBit = bnpChangeBit;
BigInteger.prototype.addTo = bnpAddTo;
BigInteger.prototype.dMultiply = bnpDMultiply;
BigInteger.prototype.dAddOffset = bnpDAddOffset;
BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
BigInteger.prototype.modInt = bnpModInt;
BigInteger.prototype.millerRabin = bnpMillerRabin;


// public
BigInteger.prototype.toString = bnToString;
BigInteger.prototype.negate = bnNegate;
BigInteger.prototype.abs = bnAbs;
BigInteger.prototype.compareTo = bnCompareTo;
BigInteger.prototype.bitLength = bnBitLength;
BigInteger.prototype.mod = bnMod;
BigInteger.prototype.modPowInt = bnModPowInt;

BigInteger.prototype.clone = bnClone;
BigInteger.prototype.intValue = bnIntValue;
BigInteger.prototype.byteValue = bnByteValue;
BigInteger.prototype.shortValue = bnShortValue;
BigInteger.prototype.signum = bnSigNum;
BigInteger.prototype.toByteArray = bnToByteArray;
BigInteger.prototype.toBuffer = bnToBuffer;
BigInteger.prototype.equals = bnEquals;
BigInteger.prototype.eq = bnEqual;
BigInteger.prototype.gt = bnGreater;
BigInteger.prototype.gte = bnGreaterOrEqual;
BigInteger.prototype.lt = bnLesser;
BigInteger.prototype.lte = bnLesserOrEqual;
BigInteger.prototype.min = bnMin;
BigInteger.prototype.max = bnMax;
BigInteger.prototype.and = bnAnd;
BigInteger.prototype.or = bnOr;
BigInteger.prototype.xor = bnXor;
BigInteger.prototype.andNot = bnAndNot;
BigInteger.prototype.not = bnNot;
BigInteger.prototype.shiftLeft = bnShiftLeft;
BigInteger.prototype.shiftRight = bnShiftRight;
BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
BigInteger.prototype.bitCount = bnBitCount;
BigInteger.prototype.testBit = bnTestBit;
BigInteger.prototype.setBit = bnSetBit;
BigInteger.prototype.clearBit = bnClearBit;
BigInteger.prototype.flipBit = bnFlipBit;
BigInteger.prototype.add = bnAdd;
BigInteger.prototype.subtract = bnSubtract;
BigInteger.prototype.multiply = bnMultiply;
BigInteger.prototype.divide = bnDivide;
BigInteger.prototype.remainder = bnRemainder;
BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
BigInteger.prototype.modPow = bnModPow;
BigInteger.prototype.modInverse = bnModInverse;
BigInteger.prototype.pow = bnPow;
BigInteger.prototype.gcd = bnGCD;
BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
BigInteger.int2char = int2char;

// "constants"
BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1);

// JSBN-specific extension
BigInteger.prototype.square = bnSquare;

//BigInteger interfaces not implemented in jsbn:

//BigInteger(int signum, byte[] magnitude)
//double doubleValue()
//float floatValue()
//int hashCode()
//long longValue()
//static BigInteger valueOf(long val)

module.exports = BigInteger;


/***/ }),

/***/ 5309:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * SRP Group Parameters
 * http://tools.ietf.org/html/rfc5054#appendix-A
 *
 * The 1024-, 1536-, and 2048-bit groups are taken from software
 * developed by Tom Wu and Eugene Jhong for the Stanford SRP
 * distribution, and subsequently proven to be prime.  The larger primes
 * are taken from [MODP], but generators have been calculated that are
 * primitive roots of N, unlike the generators in [MODP].
 *
 * The 1024-bit and 1536-bit groups MUST be supported.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.params = exports.hex = void 0;
// since these are meant to be used internally, all values are numbers. If
// you want to add parameter sets, you'll need to convert them to bignums.
const BigInteger = __nccwpck_require__(6573);
function hex(s) {
    return new BigInteger(s.split(/\s|\n/).join(""), 16);
}
exports.hex = hex;
exports.params = {
    1024: {
        N_length_bits: 1024,
        N: hex(`
      EEAF0AB9 ADB38DD6 9C33F80A FA8FC5E8 60726187 75FF3C0B 9EA2314C
      9C256576 D674DF74 96EA81D3 383B4813 D692C6E0 E0D5D8E2 50B98BE4
      8E495C1D 6089DAD1 5DC7D7B4 6154D6B6 CE8EF4AD 69B15D49 82559B29
      7BCF1885 C529F566 660E57EC 68EDBC3C 05726CC0 2FD4CBF4 976EAA9A
      FD5138FE 8376435B 9FC61D2F C0EB06E3
    `),
        g: hex("02"),
        hash: "sha1",
    },
    1536: {
        N_length_bits: 1536,
        N: hex(`
      9DEF3CAF B939277A B1F12A86 17A47BBB DBA51DF4 99AC4C80 BEEEA961
      4B19CC4D 5F4F5F55 6E27CBDE 51C6A94B E4607A29 1558903B A0D0F843
      80B655BB 9A22E8DC DF028A7C EC67F0D0 8134B1C8 B9798914 9B609E0B
      E3BAB63D 47548381 DBC5B1FC 764E3F4B 53DD9DA1 158BFD3E 2B9C8CF5
      6EDF0195 39349627 DB2FD53D 24B7C486 65772E43 7D6C7F8C E442734A
      F7CCB7AE 837C264A E3A9BEB8 7F8A2FE9 B8B5292E 5A021FFF 5E91479E
      8CE7A28C 2442C6F3 15180F93 499A234D CF76E3FE D135F9BB
    `),
        g: hex("02"),
        hash: "sha1",
    },
    2048: {
        N_length_bits: 2048,
        N: hex(`
      AC6BDB41 324A9A9B F166DE5E 1389582F AF72B665 1987EE07 FC319294
      3DB56050 A37329CB B4A099ED 8193E075 7767A13D D52312AB 4B03310D
      CD7F48A9 DA04FD50 E8083969 EDB767B0 CF609517 9A163AB3 661A05FB
      D5FAAAE8 2918A996 2F0B93B8 55F97993 EC975EEA A80D740A DBF4FF74
      7359D041 D5C33EA7 1D281E44 6B14773B CA97B43A 23FB8016 76BD207A
      436C6481 F1D2B907 8717461A 5B9D32E6 88F87748 544523B5 24B0D57D
      5EA77A27 75D2ECFA 032CFBDB F52FB378 61602790 04E57AE6 AF874E73
      03CE5329 9CCC041C 7BC308D8 2A5698F3 A8D0C382 71AE35F8 E9DBFBB6
      94B5C803 D89F7AE4 35DE236D 525F5475 9B65E372 FCD68EF2 0FA7111F
      9E4AFF73
    `),
        g: hex("02"),
        hash: "sha256",
    },
    3072: {
        N_length_bits: 3072,
        N: hex(`
      FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 29024E08
      8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD EF9519B3 CD3A431B
      302B0A6D F25F1437 4FE1356D 6D51C245 E485B576 625E7EC6 F44C42E9
      A637ED6B 0BFF5CB6 F406B7ED EE386BFB 5A899FA5 AE9F2411 7C4B1FE6
      49286651 ECE45B3D C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8
      FD24CF5F 83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D
      670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B E39E772C
      180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9 DE2BCBF6 95581718
      3995497C EA956AE5 15D22618 98FA0510 15728E5A 8AAAC42D AD33170D
      04507A33 A85521AB DF1CBA64 ECFB8504 58DBEF0A 8AEA7157 5D060C7D
      B3970F85 A6E1E4C7 ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226
      1AD2EE6B F12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200C
      BBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB31 43DB5BFC
      E0FD108E 4B82D120 A93AD2CA FFFFFFFF FFFFFFFF
    `),
        g: hex("05"),
        hash: "sha256",
    },
    hap: {
        N_length_bits: 3072,
        N: hex(`
      FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 29024E08
      8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD EF9519B3 CD3A431B
      302B0A6D F25F1437 4FE1356D 6D51C245 E485B576 625E7EC6 F44C42E9
      A637ED6B 0BFF5CB6 F406B7ED EE386BFB 5A899FA5 AE9F2411 7C4B1FE6
      49286651 ECE45B3D C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8
      FD24CF5F 83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D
      670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B E39E772C
      180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9 DE2BCBF6 95581718
      3995497C EA956AE5 15D22618 98FA0510 15728E5A 8AAAC42D AD33170D
      04507A33 A85521AB DF1CBA64 ECFB8504 58DBEF0A 8AEA7157 5D060C7D
      B3970F85 A6E1E4C7 ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226
      1AD2EE6B F12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200C
      BBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB31 43DB5BFC
      E0FD108E 4B82D120 A93AD2CA FFFFFFFF FFFFFFFF
    `),
        g: hex("05"),
        hash: "sha512",
    },
    4096: {
        N_length_bits: 4096,
        N: hex(`
      FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 29024E08
      8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD EF9519B3 CD3A431B
      302B0A6D F25F1437 4FE1356D 6D51C245 E485B576 625E7EC6 F44C42E9
      A637ED6B 0BFF5CB6 F406B7ED EE386BFB 5A899FA5 AE9F2411 7C4B1FE6
      49286651 ECE45B3D C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8
      FD24CF5F 83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D
      670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B E39E772C
      180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9 DE2BCBF6 95581718
      3995497C EA956AE5 15D22618 98FA0510 15728E5A 8AAAC42D AD33170D
      04507A33 A85521AB DF1CBA64 ECFB8504 58DBEF0A 8AEA7157 5D060C7D
      B3970F85 A6E1E4C7 ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226
      1AD2EE6B F12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200C
      BBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB31 43DB5BFC
      E0FD108E 4B82D120 A9210801 1A723C12 A787E6D7 88719A10 BDBA5B26
      99C32718 6AF4E23C 1A946834 B6150BDA 2583E9CA 2AD44CE8 DBBBC2DB
      04DE8EF9 2E8EFC14 1FBECAA6 287C5947 4E6BC05D 99B2964F A090C3A2
      233BA186 515BE7ED 1F612970 CEE2D7AF B81BDD76 2170481C D0069127
      D5B05AA9 93B4EA98 8D8FDDC1 86FFB7DC 90A6C08F 4DF435C9 34063199
      FFFFFFFF FFFFFFFF
    `),
        g: hex("05"),
        hash: "sha256",
    },
    6244: {
        N_length_bits: 6244,
        N: hex(`
      FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 29024E08
      8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD EF9519B3 CD3A431B
      302B0A6D F25F1437 4FE1356D 6D51C245 E485B576 625E7EC6 F44C42E9
      A637ED6B 0BFF5CB6 F406B7ED EE386BFB 5A899FA5 AE9F2411 7C4B1FE6
      49286651 ECE45B3D C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8
      FD24CF5F 83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D
      670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B E39E772C
      180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9 DE2BCBF6 95581718
      3995497C EA956AE5 15D22618 98FA0510 15728E5A 8AAAC42D AD33170D
      04507A33 A85521AB DF1CBA64 ECFB8504 58DBEF0A 8AEA7157 5D060C7D
      B3970F85 A6E1E4C7 ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226
      1AD2EE6B F12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200C
      BBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB31 43DB5BFC
      E0FD108E 4B82D120 A9210801 1A723C12 A787E6D7 88719A10 BDBA5B26
      99C32718 6AF4E23C 1A946834 B6150BDA 2583E9CA 2AD44CE8 DBBBC2DB
      04DE8EF9 2E8EFC14 1FBECAA6 287C5947 4E6BC05D 99B2964F A090C3A2
      233BA186 515BE7ED 1F612970 CEE2D7AF B81BDD76 2170481C D0069127
      D5B05AA9 93B4EA98 8D8FDDC1 86FFB7DC 90A6C08F 4DF435C9 34028492
      36C3FAB4 D27C7026 C1D4DCB2 602646DE C9751E76 3DBA37BD F8FF9406
      AD9E530E E5DB382F 413001AE B06A53ED 9027D831 179727B0 865A8918
      DA3EDBEB CF9B14ED 44CE6CBA CED4BB1B DB7F1447 E6CC254B 33205151
      2BD7AF42 6FB8F401 378CD2BF 5983CA01 C64B92EC F032EA15 D1721D03
      F482D7CE 6E74FEF6 D55E702F 46980C82 B5A84031 900B1C9E 59E7C97F
      BEC7E8F3 23A97A7E 36CC88BE 0F1D45B7 FF585AC5 4BD407B2 2B4154AA
      CC8F6D7E BF48E1D8 14CC5ED2 0F8037E0 A79715EE F29BE328 06A1D58B
      B7C5DA76 F550AA3D 8A1FBFF0 EB19CCB1 A313D55C DA56C9EC 2EF29632
      387FE8D7 6E3C0468 043E8F66 3F4860EE 12BF2D5B 0B7474D6 E694F91E
      6DCC4024 FFFFFFFF FFFFFFFF
    `),
        g: hex("05"),
        hash: "sha256",
    },
    8192: {
        N_length_bits: 8192,
        N: hex(`
      FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 29024E08
      8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD EF9519B3 CD3A431B
      302B0A6D F25F1437 4FE1356D 6D51C245 E485B576 625E7EC6 F44C42E9
      A637ED6B 0BFF5CB6 F406B7ED EE386BFB 5A899FA5 AE9F2411 7C4B1FE6
      49286651 ECE45B3D C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8
      FD24CF5F 83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D
      670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B E39E772C
      180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9 DE2BCBF6 95581718
      3995497C EA956AE5 15D22618 98FA0510 15728E5A 8AAAC42D AD33170D
      04507A33 A85521AB DF1CBA64 ECFB8504 58DBEF0A 8AEA7157 5D060C7D
      B3970F85 A6E1E4C7 ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226
      1AD2EE6B F12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200C
      BBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB31 43DB5BFC
      E0FD108E 4B82D120 A9210801 1A723C12 A787E6D7 88719A10 BDBA5B26
      99C32718 6AF4E23C 1A946834 B6150BDA 2583E9CA 2AD44CE8 DBBBC2DB
      04DE8EF9 2E8EFC14 1FBECAA6 287C5947 4E6BC05D 99B2964F A090C3A2
      233BA186 515BE7ED 1F612970 CEE2D7AF B81BDD76 2170481C D0069127
      D5B05AA9 93B4EA98 8D8FDDC1 86FFB7DC 90A6C08F 4DF435C9 34028492
      36C3FAB4 D27C7026 C1D4DCB2 602646DE C9751E76 3DBA37BD F8FF9406
      AD9E530E E5DB382F 413001AE B06A53ED 9027D831 179727B0 865A8918
      DA3EDBEB CF9B14ED 44CE6CBA CED4BB1B DB7F1447 E6CC254B 33205151
      2BD7AF42 6FB8F401 378CD2BF 5983CA01 C64B92EC F032EA15 D1721D03
      F482D7CE 6E74FEF6 D55E702F 46980C82 B5A84031 900B1C9E 59E7C97F
      BEC7E8F3 23A97A7E 36CC88BE 0F1D45B7 FF585AC5 4BD407B2 2B4154AA
      CC8F6D7E BF48E1D8 14CC5ED2 0F8037E0 A79715EE F29BE328 06A1D58B
      B7C5DA76 F550AA3D 8A1FBFF0 EB19CCB1 A313D55C DA56C9EC 2EF29632
      387FE8D7 6E3C0468 043E8F66 3F4860EE 12BF2D5B 0B7474D6 E694F91E
      6DBE1159 74A3926F 12FEE5E4 38777CB6 A932DF8C D8BEC4D0 73B931BA
      3BC832B6 8D9DD300 741FA7BF 8AFC47ED 2576F693 6BA42466 3AAB639C
      5AE4F568 3423B474 2BF1C978 238F16CB E39D652D E3FDB8BE FC848AD9
      22222E04 A4037C07 13EB57A8 1A23F0C7 3473FC64 6CEA306B 4BCBC886
      2F8385DD FA9D4B7F A2C087E8 79683303 ED5BDD3A 062B3CF5 B3A278A6
      6D2A13F8 3F44F82D DF310EE0 74AB6A36 4597E899 A0255DC1 64F31CC5
      0846851D F9AB4819 5DED7EA1 B1D510BD 7EE74D73 FAF36BC3 1ECFA268
      359046F4 EB879F92 4009438B 481C6CD7 889A002E D5EE382B C9190DA6
      FC026E47 9558E447 5677E9AA 9E3050E2 765694DF C81F56E8 80B96E71
      60C980DD 98EDD3DF FFFFFFFF FFFFFFFF
    `),
        g: hex("13"),
        hash: "sha256",
    },
};
exports.default = exports.params;
//# sourceMappingURL=params.js.map

/***/ }),

/***/ 2796:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SrpServer = exports.SrpClient = exports.SRP = void 0;
const crypto_1 = __importDefault(__nccwpck_require__(6417));
const assert_1 = __importDefault(__nccwpck_require__(2357));
const BigInteger = __nccwpck_require__(6573);
const params_1 = __nccwpck_require__(5309);
const zero = new BigInteger(0, 10);
function assert_(val, msg) {
    if (!val) {
        throw new Error(msg || "assertion");
    }
}
function assertIsBuffer(arg, argname = "arg") {
    assert_(Buffer.isBuffer(arg), `Type error: ${argname} must be a buffer`);
}
function assertIsBigInteger(arg, argname = "arg") {
    assert_(arg instanceof BigInteger, `Type error: ${argname} must be a BigInteger`);
}
/**
 * If a conversion is explicitly specified with the operator PAD(),
 * the integer will first be implicitly converted, then the resultant
 * byte-string will be left-padded with zeros (if necessary) until its
 * length equals the implicitly-converted length of N.
 *
 * @param {Buffer} n Number to pad
 * @param {number} len Length of the resulting Buffer
 * @return {Buffer}
 */
function padTo(n, len) {
    assertIsBuffer(n, "n");
    const padding = len - n.length;
    assert_(padding > -1, "Negative padding.  Very uncomfortable.");
    const result = Buffer.alloc(len);
    result.fill(0, 0, padding);
    n.copy(result, padding);
    assert_1.default.strictEqual(result.length, len);
    return result;
}
function padToN(number, params) {
    assertIsBigInteger(number);
    const n = number.toString(16).length % 2 !== 0 ? "0" + number.toString(16) : number.toString(16);
    return padTo(Buffer.from(n, "hex"), params.N_length_bits / 8);
}
/**
 * Compute the intermediate value x as a hash of three buffers:
 * salt, identity, and password.  And a colon.  FOUR buffers.
 *
 *      x = H(s | H(I | ":" | P))
 *
 * @param {object} params
 * @param {Buffer} salt
 * @param {Buffer} I User identity
 * @param {Buffer} P User password
 * @return {BigInteger} User secret
 */
function getx(params, salt, I, P) {
    assertIsBuffer(salt, "salt (salt)");
    assertIsBuffer(I, "identity (I)");
    assertIsBuffer(P, "password (P)");
    const hashIP = crypto_1.default.createHash(params.hash)
        .update(Buffer.concat([I, Buffer.from(":"), P]))
        .digest();
    const hashX = crypto_1.default.createHash(params.hash)
        .update(salt)
        .update(hashIP)
        .digest();
    return new BigInteger(hashX);
}
class SRP {
    /**
     * The verifier is calculated as described in Section 3 of [SRP-RFC].
     * We give the algorithm here for convenience.
     *
     * The verifier (v) is computed based on the salt (s), user name (I),
     * password (P), and group parameters (N, g).
     *
     *         x = H(s | H(I | ":" | P))
     *         v = g^x % N
     *
     * @param {object} params Group parameters, with .N, .g, .hash
     * @param {Buffer} salt
     * @param {Buffer} I User identity
     * @param {Buffer} P User password
     * @return {Buffer}
     */
    static computeVerifier(params, salt, I, P) {
        assertIsBuffer(salt, "salt (salt)");
        assertIsBuffer(I, "identity (I)");
        assertIsBuffer(P, "password (P)");
        const v_num = params.g.modPow(getx(params, salt, I, P), params.N);
        return v_num.toBuffer(params.N_length_bits / 8);
    }
    static genKey(bytes = 32, callback) {
        // bytes is optional
        if (typeof bytes !== "number") {
            callback = bytes;
            bytes = 32;
        }
        if (!callback) {
            return new Promise((rs, rj) => SRP.genKey(bytes, (err, data) => err ? rj(err) : rs(data)));
        }
        crypto_1.default.randomBytes(bytes, (err, buf) => {
            if (err) {
                return callback(err, null);
            }
            return callback(null, buf);
        });
    }
}
exports.SRP = SRP;
SRP.params = params_1.params;
/**
 * Calculate the SRP-6 multiplier.
 *
 * @param {object} params Group parameters, with .N, .g, .hash
 * @return {BigInteger}
 */
function getk(params) {
    const k_buf = crypto_1.default
        .createHash(params.hash)
        .update(padToN(params.N, params))
        .update(padToN(params.g, params))
        .digest();
    return new BigInteger(k_buf);
}
/**
 * The server key exchange message also contains the server's public
 * value (B).  The server calculates this value as B = k*v + g^b % N,
 * where b is a random number that SHOULD be at least 256 bits in length
 * and k = H(N | PAD(g)).
 *
 * Note: as the tests imply, the entire expression is mod N.
 *
 * @param {SrpParams} params Group parameters, with .N, .g, .hash
 * @param {BigInteger} k
 * @param {BigInteger} v Verifier (stored)
 * @param {BigInteger} b Server secret exponent
 * @return {Buffer} B - The server public message
 */
function getB(params, k, v, b) {
    assertIsBigInteger(v);
    assertIsBigInteger(k);
    assertIsBigInteger(b);
    const r = k.multiply(v).add(params.g.modPow(b, params.N)).mod(params.N);
    return r.toBuffer(params.N_length_bits / 8);
}
/**
 * The client key exchange message carries the client's public value
 * (A).  The client calculates this value as A = g^a % N, where a is a
 * random number that SHOULD be at least 256 bits in length.
 *
 * Note: for this implementation, we take that to mean 256/8 bytes.
 *
 * @param {object} params Group parameters, with .N, .g, .hash
 * @param {BigInteger} a_num Client secret exponent
 * @return {Buffer} A - The client public message
 */
function getA(params, a_num) {
    assertIsBigInteger(a_num);
    if (Math.ceil(a_num.toString(16).length / 2) < 32) {
        console.warn("getA: client key length %d is less than the recommended 256 bits", a_num.bitLength());
    }
    return params.g.modPow(a_num, params.N).toBuffer(params.N_length_bits / 8);
}
/**
 * getu() hashes the two public messages together, to obtain a scrambling
 * parameter "u" which cannot be predicted by either party ahead of time.
 * This makes it safe to use the message ordering defined in the SRP-6a
 * paper, in which the server reveals their "B" value before the client
 * commits to their "A" value.
 *
 * @param {object} params Group parameters, with .N, .g, .hash
 * @param {Buffer} A Client ephemeral public key
 * @param {Buffer} B Server ephemeral public key
 * @return {BigInteger} u - Shared scrambling parameter
 */
function getu(params, A, B) {
    assertIsBuffer(A, "A");
    assertIsBuffer(B, "B");
    const u_buf = crypto_1.default.createHash(params.hash)
        .update(padTo(A, params.N_length_bits / 8))
        .update(padTo(B, params.N_length_bits / 8))
        .digest();
    return new BigInteger(u_buf);
}
/**
 * The TLS premaster secret as calculated by the client
 *
 * @param {SrpParams} params Group parameters, with .N, .g, .hash
 * @param {BigInteger} k_num
 * @param {BigInteger} x_num
 * @param {BigInteger} a_num
 * @param {BigInteger} B_num
 * @param {BigInteger} u_num
 * @return {Buffer}
 */
function client_getS(params, k_num, x_num, a_num, B_num, u_num) {
    assertIsBigInteger(k_num);
    assertIsBigInteger(x_num);
    assertIsBigInteger(a_num);
    assertIsBigInteger(B_num);
    assertIsBigInteger(u_num);
    if ((zero.compareTo(B_num) >= 0) || (params.N.compareTo(B_num) <= 0)) {
        throw new Error("invalid server-supplied \"B\", must be 1..N-1");
    }
    const S_num = B_num.subtract(k_num.multiply(params.g.modPow(x_num, params.N)))
        .modPow(a_num.add(u_num.multiply(x_num)), params.N)
        .mod(params.N);
    return S_num.toBuffer(params.N_length_bits / 8);
}
/**
 * The TLS premastersecret as calculated by the server
 *
 * @param {BigInteger} params Group parameters, with .N, .g, .hash
 * @param {BigInteger} v_num Verifier (stored on server)
 * @param {BigInteger} A_num Ephemeral client public key (read from client)
 * @param {BigInteger} b_num Server ephemeral private key (generated for session)
 * @param {BigInteger} u_num {@see getu}
 * @return {Buffer}
 */
function server_getS(params, v_num, A_num, b_num, u_num) {
    assertIsBigInteger(v_num);
    assertIsBigInteger(A_num);
    assertIsBigInteger(b_num);
    assertIsBigInteger(u_num);
    if ((zero.compareTo(A_num) >= 0) || (params.N.compareTo(A_num) <= 0)) {
        throw new Error("invalid client-supplied \"A\", must be 1..N-1");
    }
    const S_num = A_num.multiply(v_num.modPow(u_num, params.N))
        .modPow(b_num, params.N)
        .mod(params.N);
    return S_num.toBuffer(params.N_length_bits / 8);
}
/**
 * Compute the shared session key K from S
 *
 * @param {object} params Group parameters, with .N, .g, .hash
 * @param {Buffer} S_buf Session key
 * @return {Buffer}
 */
function getK(params, S_buf) {
    assertIsBuffer(S_buf, "S");
    if (params.hash === "sha1") {
        // use t_mgf1 interleave for short sha1 hashes
        return Buffer.concat([
            crypto_1.default.createHash(params.hash).update(S_buf).update(Buffer.from([0, 0, 0, 0])).digest(),
            crypto_1.default.createHash(params.hash).update(S_buf).update(Buffer.from([0, 0, 0, 1])).digest(),
        ]);
    }
    else {
        // use hash as-is otherwise
        return crypto_1.default.createHash(params.hash).update(S_buf).digest();
    }
}
function getM1(params, u_buf, s_buf, A_buf, B_buf, K_buf) {
    if (arguments.length > 4) {
        assertIsBuffer(u_buf, "identity (I)");
        assertIsBuffer(s_buf, "salt (s)");
        assertIsBuffer(A_buf, "client public key (A)");
        assertIsBuffer(B_buf, "server public key (B)");
        assertIsBuffer(K_buf, "session key (K)");
        const hN = crypto_1.default.createHash(params.hash).update(params.N.toBuffer(true)).digest();
        const hG = crypto_1.default.createHash(params.hash).update(params.g.toBuffer(true)).digest();
        for (let i = 0; i < hN.length; i++) {
            hN[i] ^= hG[i];
        }
        const hU = crypto_1.default.createHash(params.hash).update(u_buf).digest();
        return crypto_1.default.createHash(params.hash)
            .update(hN).update(hU).update(s_buf)
            .update(A_buf).update(B_buf).update(K_buf)
            .digest();
    }
    else {
        [A_buf, B_buf, s_buf] = [u_buf, s_buf, A_buf];
        assertIsBuffer(A_buf, "A");
        assertIsBuffer(B_buf, "B");
        assertIsBuffer(s_buf, "S");
        return crypto_1.default.createHash(params.hash)
            .update(A_buf).update(B_buf).update(s_buf)
            .digest();
    }
}
function getM2(params, A_buf, M1_buf, K_buf) {
    assertIsBuffer(A_buf, "A");
    assertIsBuffer(M1_buf, "M1");
    assertIsBuffer(K_buf, "K");
    return crypto_1.default.createHash(params.hash)
        .update(A_buf).update(M1_buf).update(K_buf)
        .digest();
}
function equal(buf1, buf2) {
    // constant-time comparison. A drop in the ocean compared to our
    // non-constant-time modexp operations, but still good practice.
    return buf1.toString("hex") === buf2.toString("hex");
}
class SrpClient {
    /**
     * Create an SRP client.
     *
     * @param {object} params Group parameters, with .N, .g, .hash
     * @param {Buffer} salt_buf User salt (from server)
     * @param {Buffer} identity_buf Identity/username
     * @param {Buffer} password_buf Password
     * @param {Buffer} secret1_buf Client private key {@see genKey}
     * @param {boolean} hap
     */
    constructor(params, salt_buf, identity_buf, password_buf, secret1_buf, hap = true) {
        assertIsBuffer(salt_buf, "salt (s)");
        assertIsBuffer(identity_buf, "identity (I)");
        assertIsBuffer(password_buf, "password (P)");
        assertIsBuffer(secret1_buf, "secret1");
        this._params = params;
        this._k = getk(params);
        this._x = getx(params, salt_buf, identity_buf, password_buf);
        this._a = new BigInteger(secret1_buf);
        if (hap) {
            this._I = identity_buf;
            this._s = salt_buf;
        }
        this._A = getA(params, this._a);
    }
    /**
     * Returns the client's public key (A).
     *
     * @return {Buffer}
     */
    computeA() {
        return this._A;
    }
    /**
     * Sets the server's public key (B).
     *
     * @param {Buffer} B_buf The server's public key
     */
    setB(B_buf) {
        const u_num = getu(this._params, this._A, B_buf);
        const S_buf_x = client_getS(this._params, this._k, this._x, this._a, new BigInteger(B_buf), u_num);
        this._K = getK(this._params, S_buf_x);
        this._u = u_num; // only for tests
        this._S = S_buf_x; // only for tests
        this._B = B_buf;
        if (this._I && this._s) {
            this._M1 = getM1(this._params, this._I, this._s, this._A, this._B, this._K);
        }
        else {
            this._M1 = getM1(this._params, this._A, this._B, this._S);
        }
        this._M2 = getM2(this._params, this._A, this._M1, this._K);
    }
    /**
     * Gets the M1 value.
     * This requires setting the server's public key {@see Client.setB}.
     *
     * @return {Buffer}
     */
    computeM1() {
        if (this._M1 === undefined) {
            throw new Error("incomplete protocol");
        }
        return this._M1;
    }
    /**
     * Checks the server was able to calculate M2.
     * This requires setting the server's public key {@see Client.setB}.
     *
     * @param M2 The server's M2 value
     */
    checkM2(M2) {
        if (!equal(this._M2, M2)) {
            throw new Error("server is not authentic");
        }
    }
    /**
     * Returns the shared session key.
     *
     * @return {Buffer}
     */
    computeK() {
        if (this._K === undefined) {
            throw new Error("incomplete protocol");
        }
        return this._K;
    }
}
exports.SrpClient = SrpClient;
class SrpServer {
    constructor(params, salt_buf, identity_buf, password_buf, secret2_buf) {
        this._params = params;
        this._k = getk(params);
        if (arguments.length > 3) {
            assertIsBuffer(salt_buf, "salt (salt)");
            assertIsBuffer(identity_buf, "identity (I)");
            assertIsBuffer(password_buf, "password (P)");
            assertIsBuffer(secret2_buf, "secret2");
            this._b = new BigInteger(secret2_buf);
            this._v = new BigInteger(SRP.computeVerifier(params, salt_buf, identity_buf, password_buf));
            this._I = identity_buf;
            this._s = salt_buf;
        }
        else if (salt_buf instanceof Buffer) {
            const verifier_buf = salt_buf;
            // noinspection JSUnusedAssignment
            [secret2_buf, salt_buf, identity_buf, password_buf] = [identity_buf, undefined, undefined, undefined];
            assertIsBuffer(verifier_buf, "verifier (v)");
            assertIsBuffer(secret2_buf, "secret2");
            this._b = new BigInteger(secret2_buf);
            this._v = new BigInteger(verifier_buf);
        }
        else {
            const identity = salt_buf;
            // noinspection JSUnusedAssignment
            [secret2_buf, salt_buf, identity_buf, password_buf] = [identity_buf, undefined, undefined, undefined];
            // noinspection SuspiciousTypeOfGuard
            assert_1.default(identity.username instanceof Buffer || typeof identity.username === "string", "identity.username (I) must be a string or Buffer");
            assertIsBuffer(identity.salt, "identity.salt (s)");
            assert_1.default("password" in identity || "verifier" in identity, "identity requires a password or verifier");
            if ("verifier" in identity) {
                assertIsBuffer(identity.verifier, "identity.verifier (v)");
            }
            else {
                // noinspection SuspiciousTypeOfGuard
                assert_1.default(identity.password instanceof Buffer || typeof identity.password === "string", "identity.password (p) must be a string or Buffer");
            }
            assertIsBuffer(secret2_buf, "secret2");
            const username = typeof identity.username === "string" ? Buffer.from(identity.username) : identity.username;
            this._b = new BigInteger(secret2_buf);
            if ("verifier" in identity) {
                this._v = new BigInteger(identity.verifier);
            }
            else {
                this._v = new BigInteger(SRP.computeVerifier(params, identity.salt, username, typeof identity.password === "string" ? Buffer.from(identity.password) : identity.password));
            }
            this._I = username;
            this._s = identity.salt;
        }
        this._B = getB(params, this._k, this._v, this._b);
    }
    /**
     * Returns the server's public key (B).
     *
     * @return {Buffer}
     */
    computeB() {
        return this._B;
    }
    /**
     * Sets the client's public key (A).
     *
     * @param {Buffer} A The client's public key
     */
    setA(A) {
        const u_num = getu(this._params, A, this._B);
        const S_buf = server_getS(this._params, this._v, new BigInteger(A), this._b, u_num);
        this._K = getK(this._params, S_buf);
        this._u = u_num; // only for tests
        this._S = S_buf; // only for tests
        if (this._I && this._s) {
            this._M1 = getM1(this._params, this._I, this._s, A, this._B, this._K);
        }
        else {
            this._M1 = getM1(this._params, A, this._B, this._S);
        }
        this._M2 = getM2(this._params, A, this._M1, this._K);
    }
    /**
     * Checks the client was able to calculate M1.
     *
     * @param {Buffer} M1 The client's M1 value
     */
    checkM1(M1) {
        if (this._M1 === undefined) {
            throw new Error("incomplete protocol");
        }
        if (!equal(this._M1, M1)) {
            throw new Error("client did not use the same password");
        }
    }
    /**
     * Returns the shared session key.
     *
     * @return {Buffer}
     */
    computeK() {
        if (this._K === undefined) {
            throw new Error("incomplete protocol");
        }
        return this._K;
    }
    /**
     * Gets the M2 value.
     * This requires setting the client's public key {@see Server.setA}.
     *
     * @return {Buffer}
     */
    computeM2() {
        if (this._M2 === undefined) {
            throw new Error("incomplete protocol");
        }
        return this._M2;
    }
}
exports.SrpServer = SrpServer;
//# sourceMappingURL=srp.js.map

/***/ }),

/***/ 3219:
/***/ ((module) => {


var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};



/***/ }),

/***/ 9733:
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ 4517:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var implementation = __nccwpck_require__(9733);

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ 247:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


/**
 * @file
 *
 * Copyright 2018 FutoIn Project (https://futoin.org)
 * Copyright 2018 Andrey Galkin <andrey@futoin.org>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const { createHash, createHmac } = __nccwpck_require__( 6417 );

const g_digestLenCache = {};

/**
 * Get expected hash length.
 *
 * @func
 * @alias hkdf.hash_length
 * @param {string} hash - Hash algorithm (as in underlying Node.js crypto library)
 * @returns {integer} hash digest byte length
 *
 * @note Values are hardcoded with fallback for unknown algorithms.
 */
const hash_length = ( hash ) => {
    switch ( hash ) {
    case 'sha256': return 32;
    case 'sha512': return 64;
    case 'sha224': return 28;
    case 'sha384': return 48;
    case 'sha3-256': return 32;
    case 'sha3-512': return 64;
    case 'sha3-224': return 28;
    case 'sha3-384': return 48;
    case 'blake2s256': return 32;
    case 'blake2b512': return 64;
    case 'sha1': return 20;
    case 'md5': return 16;
    default: {
        let len = g_digestLenCache[hash];

        if ( len === undefined ) {
            len = createHash( hash ).digest().length;
            g_digestLenCache[hash] = len;
        }

        return len;
    }
    }
};

/**
 * HKDF extract action.
 *
 * @func
 * @alias hkdf.extract
 * @param {string} hash - Hash algorithm (as in underlying Node.js crypto library)
 * @param {integer} hash_len - Hash digest length
 * @param {Buffer|string} ikm - Initial Keying Material
 * @param {Buffer|string} salt - Optional salt (recommended)
 * @returns {Buffer} A buffer with pseudorandom key
 *
 * @note Values are hardcoded with fallback for unknown algorithms.
 */
const hkdf_extract = ( hash, hash_len, ikm, salt ) => {
    const b_ikm = Buffer.isBuffer( ikm ) ? ikm : Buffer.from( ikm );
    const b_salt = ( salt && salt.length ) ? Buffer.from( salt ) : Buffer.alloc( hash_len, 0 );

    return createHmac( hash, b_salt ).update( b_ikm ).digest();
};

/**
 * HKDF expand action.
 *
 * @func
 * @alias hkdf.expand
 * @param {string} hash - Hash algorithm (as in underlying Node.js crypto library)
 * @param {integer} hash_len - Hash digest length
 * @param {Buffer|string} prk - A buffer with pseudorandom key
 * @param {integer} length - length of output keying material in octets
 * @param {Buffer|string} info - Optional context (safe to skip)
 * @returns {Buffer} A buffer with output keying material
 *
 * @note Values are hardcoded with fallback for unknown algorithms.
 */
const hkdf_expand = ( hash, hash_len, prk, length, info ) => {
    const b_info = Buffer.from( info || '' );
    const info_len = b_info.length;

    const steps = Math.ceil( length / hash_len );

    if ( steps > 0xFF ) {
        throw new Error( `OKM length ${length} is too long for ${hash} hash` );
    }

    // use single buffer with unnecessary create/copy/move operations
    const t = Buffer.alloc( hash_len * steps + info_len + 1 );

    for ( let c = 1, start = 0, end = 0; c <= steps; ++c ) {
        // add info
        b_info.copy( t, end );
        // add counter
        t[ end + info_len ] = c;

        createHmac( hash, prk )
            // use view: T(C) = T(C-1) | info | C
            .update( t.slice( start, end + info_len + 1 ) )
            .digest()
            // put back to the same buffer
            .copy( t, end );

        start = end; // used for T(C-1) start
        end += hash_len; // used for T(C-1) end & overall end
    }

    return t.slice( 0, length );
};

/**
 * HMAC-based Extract-and-Expand Key Derivation Function (HKDF)
 *
 * @param {Buffer|string} ikm - Initial Keying Material
 * @param {integer} length - Required byte length of output
 * @param {Buffer|string} salt='' - Optional salt (recommended)
 * @param {Buffer|string} info='' - Optional context (safe to skip)
 * @param {string} hash='SHA-256' - HMAC hash function to use
 * @returns {Buffer} Raw buffer with derived key of @p length bytes
 */
function hkdf( ikm, length, { salt='', info='', hash='SHA-256' } = {} ) {
    hash = hash.toLowerCase().replace( '-', '' );

    // 0. Hash length
    const hash_len = hash_length( hash );

    // 1. extract
    const prk = hkdf_extract( hash, hash_len, ikm, salt );

    // 2. expand
    return hkdf_expand( hash, hash_len, prk, length, info );
}

Object.defineProperties( hkdf, {
    hash_length : {
        configurable: false,
        enumerable: false,
        writable: false,
        value: hash_length,
    },
    extract : {
        configurable: false,
        enumerable: false,
        writable: false,
        value: hkdf_extract,
    },
    expand : {
        configurable: false,
        enumerable: false,
        writable: false,
        value: hkdf_expand,
    },
} );

module.exports = hkdf;


/***/ }),

/***/ 9879:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __nccwpck_require__(3805)();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __nccwpck_require__(4517);
var hasOwn = __nccwpck_require__(9930);
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ 9852:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

//HomeKit Types UUID's
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MANUFACTURER_CTYPE = exports.LOGS_CTYPE = exports.LOCK_MECHANISM_LAST_KNOWN_ACTION_CTYPE = exports.LOCK_MANAGEMENT_CONTROL_POINT_CTYPE = exports.LOCK_MANAGEMENT_AUTO_SECURE_TIMEOUT_CTYPE = exports.IDENTIFY_CTYPE = exports.HUE_CTYPE = exports.HEATING_THRESHOLD_CTYPE = exports.CURRENT_TEMPERATURE_CTYPE = exports.CURRENT_RELATIVE_HUMIDITY_CTYPE = exports.CURRENT_LOCK_MECHANISM_STATE_CTYPE = exports.CURRENT_DOOR_STATE_CTYPE = exports.CONTACT_SENSOR_STATE_CTYPE = exports.COOLING_THRESHOLD_CTYPE = exports.BATTERY_LEVEL_CTYPE = exports.BRIGHTNESS_CTYPE = exports.AUDIO_FEEDBACK_CTYPE = exports.ADMIN_ONLY_ACCESS_CTYPE = exports.ALARM_TARGET_STATE_CTYPE = exports.ALARM_CURRENT_STATE_CTYPE = exports.TEMPERATURE_SENSOR_STYPE = exports.HUMIDITY_SENSOR_STYPE = exports.MOTION_SENSOR_STYPE = exports.CONTACT_SENSOR_STYPE = exports.OCCUPANCY_SENSOR_STYPE = exports.WINDOW_COVERING_STYPE = exports.ALARM_STYPE = exports.LOCK_MANAGEMENT_STYPE = exports.LOCK_MECHANISM_STYPE = exports.OUTLET_STYPE = exports.FAN_STYPE = exports.ACCESSORY_INFORMATION_STYPE = exports.GARAGE_DOOR_OPENER_STYPE = exports.THERMOSTAT_STYPE = exports.SWITCH_STYPE = exports.LIGHTBULB_STYPE = exports.PROGRAMMABLE_SWITCH_TCTYPE = exports.WINDOW_COVERING_TCTYPE = exports.WINDOW_TCTYPE = exports.DOOR_TCTYPE = exports.ALARM_SYSTEM_TCTYPE = exports.SENSOR_TCTYPE = exports.THERMOSTAT_TCTYPE = exports.SWITCH_TCTYPE = exports.OUTLET_TCTYPE = exports.DOOR_LOCK_TCTYPE = exports.LIGHTBULB_TCTYPE = exports.GARAGE_DOOR_OPENER_TCTYPE = exports.FAN_TCTYPE = exports.OTHER_TCTYPE = void 0;
exports.TARGETHEATINGCOOLING_CTYPE = exports.CURRENTHEATINGCOOLING_CTYPE = exports.WINDOW_COVERING_OPERATION_STATE_CTYPE = exports.WINDOW_COVERING_CURRENT_POSITION_CTYPE = exports.WINDOW_COVERING_TARGET_POSITION_CTYPE = exports.VERSION_CTYPE = exports.TEMPERATURE_UNITS_CTYPE = exports.TARGET_TEMPERATURE_CTYPE = exports.TARGET_RELATIVE_HUMIDITY_CTYPE = exports.TARGET_LOCK_MECHANISM_STATE_CTYPE = exports.TARGET_DOORSTATE_CTYPE = exports.STATUS_FAULT_CTYPE = exports.STATUS_LOW_BATTERY_CTYPE = exports.FIRMWARE_REVISION_CTYPE = exports.SERIAL_NUMBER_CTYPE = exports.SATURATION_CTYPE = exports.ROTATION_SPEED_CTYPE = exports.ROTATION_DIRECTION_CTYPE = exports.PROGRAMMABLE_SWITCH_OUTPUT_STATE_CTYPE = exports.PROGRAMMABLE_SWITCH_SWITCH_EVENT_CTYPE = exports.POWER_STATE_CTYPE = exports.OCCUPANCY_DETECTED_CTYPE = exports.OUTLET_IN_USE_CTYPE = exports.OBSTRUCTION_DETECTED_CTYPE = exports.NAME_CTYPE = exports.MOTION_DETECTED_CTYPE = exports.MODEL_CTYPE = void 0;
var stPre = "000000";
var stPost = "-0000-1000-8000-0026BB765291";
//HomeKitTransportCategoryTypes
exports.OTHER_TCTYPE = 1;
exports.FAN_TCTYPE = 3;
exports.GARAGE_DOOR_OPENER_TCTYPE = 4;
exports.LIGHTBULB_TCTYPE = 5;
exports.DOOR_LOCK_TCTYPE = 6;
exports.OUTLET_TCTYPE = 7;
exports.SWITCH_TCTYPE = 8;
exports.THERMOSTAT_TCTYPE = 9;
exports.SENSOR_TCTYPE = 10;
exports.ALARM_SYSTEM_TCTYPE = 11;
exports.DOOR_TCTYPE = 12;
exports.WINDOW_TCTYPE = 13;
exports.WINDOW_COVERING_TCTYPE = 14;
exports.PROGRAMMABLE_SWITCH_TCTYPE = 15;
//HomeKitServiceTypes
exports.LIGHTBULB_STYPE = stPre + "43" + stPost;
exports.SWITCH_STYPE = stPre + "49" + stPost;
exports.THERMOSTAT_STYPE = stPre + "4A" + stPost;
exports.GARAGE_DOOR_OPENER_STYPE = stPre + "41" + stPost;
exports.ACCESSORY_INFORMATION_STYPE = stPre + "3E" + stPost;
exports.FAN_STYPE = stPre + "40" + stPost;
exports.OUTLET_STYPE = stPre + "47" + stPost;
exports.LOCK_MECHANISM_STYPE = stPre + "45" + stPost;
exports.LOCK_MANAGEMENT_STYPE = stPre + "44" + stPost;
exports.ALARM_STYPE = stPre + "7E" + stPost;
exports.WINDOW_COVERING_STYPE = stPre + "8C" + stPost;
exports.OCCUPANCY_SENSOR_STYPE = stPre + "86" + stPost;
exports.CONTACT_SENSOR_STYPE = stPre + "80" + stPost;
exports.MOTION_SENSOR_STYPE = stPre + "85" + stPost;
exports.HUMIDITY_SENSOR_STYPE = stPre + "82" + stPost;
exports.TEMPERATURE_SENSOR_STYPE = stPre + "8A" + stPost;
//HomeKitCharacteristicsTypes
exports.ALARM_CURRENT_STATE_CTYPE = stPre + "66" + stPost;
exports.ALARM_TARGET_STATE_CTYPE = stPre + "67" + stPost;
exports.ADMIN_ONLY_ACCESS_CTYPE = stPre + "01" + stPost;
exports.AUDIO_FEEDBACK_CTYPE = stPre + "05" + stPost;
exports.BRIGHTNESS_CTYPE = stPre + "08" + stPost;
exports.BATTERY_LEVEL_CTYPE = stPre + "68" + stPost;
exports.COOLING_THRESHOLD_CTYPE = stPre + "0D" + stPost;
exports.CONTACT_SENSOR_STATE_CTYPE = stPre + "6A" + stPost;
exports.CURRENT_DOOR_STATE_CTYPE = stPre + "0E" + stPost;
exports.CURRENT_LOCK_MECHANISM_STATE_CTYPE = stPre + "1D" + stPost;
exports.CURRENT_RELATIVE_HUMIDITY_CTYPE = stPre + "10" + stPost;
exports.CURRENT_TEMPERATURE_CTYPE = stPre + "11" + stPost;
exports.HEATING_THRESHOLD_CTYPE = stPre + "12" + stPost;
exports.HUE_CTYPE = stPre + "13" + stPost;
exports.IDENTIFY_CTYPE = stPre + "14" + stPost;
exports.LOCK_MANAGEMENT_AUTO_SECURE_TIMEOUT_CTYPE = stPre + "1A" + stPost;
exports.LOCK_MANAGEMENT_CONTROL_POINT_CTYPE = stPre + "19" + stPost;
exports.LOCK_MECHANISM_LAST_KNOWN_ACTION_CTYPE = stPre + "1C" + stPost;
exports.LOGS_CTYPE = stPre + "1F" + stPost;
exports.MANUFACTURER_CTYPE = stPre + "20" + stPost;
exports.MODEL_CTYPE = stPre + "21" + stPost;
exports.MOTION_DETECTED_CTYPE = stPre + "22" + stPost;
exports.NAME_CTYPE = stPre + "23" + stPost;
exports.OBSTRUCTION_DETECTED_CTYPE = stPre + "24" + stPost;
exports.OUTLET_IN_USE_CTYPE = stPre + "26" + stPost;
exports.OCCUPANCY_DETECTED_CTYPE = stPre + "71" + stPost;
exports.POWER_STATE_CTYPE = stPre + "25" + stPost;
exports.PROGRAMMABLE_SWITCH_SWITCH_EVENT_CTYPE = stPre + "73" + stPost;
exports.PROGRAMMABLE_SWITCH_OUTPUT_STATE_CTYPE = stPre + "74" + stPost;
exports.ROTATION_DIRECTION_CTYPE = stPre + "28" + stPost;
exports.ROTATION_SPEED_CTYPE = stPre + "29" + stPost;
exports.SATURATION_CTYPE = stPre + "2F" + stPost;
exports.SERIAL_NUMBER_CTYPE = stPre + "30" + stPost;
exports.FIRMWARE_REVISION_CTYPE = stPre + "52" + stPost;
exports.STATUS_LOW_BATTERY_CTYPE = stPre + "79" + stPost;
exports.STATUS_FAULT_CTYPE = stPre + "77" + stPost;
exports.TARGET_DOORSTATE_CTYPE = stPre + "32" + stPost;
exports.TARGET_LOCK_MECHANISM_STATE_CTYPE = stPre + "1E" + stPost;
exports.TARGET_RELATIVE_HUMIDITY_CTYPE = stPre + "34" + stPost;
exports.TARGET_TEMPERATURE_CTYPE = stPre + "35" + stPost;
exports.TEMPERATURE_UNITS_CTYPE = stPre + "36" + stPost;
exports.VERSION_CTYPE = stPre + "37" + stPost;
exports.WINDOW_COVERING_TARGET_POSITION_CTYPE = stPre + "7C" + stPost;
exports.WINDOW_COVERING_CURRENT_POSITION_CTYPE = stPre + "6D" + stPost;
exports.WINDOW_COVERING_OPERATION_STATE_CTYPE = stPre + "72" + stPost;
exports.CURRENTHEATINGCOOLING_CTYPE = stPre + "0F" + stPost;
exports.TARGETHEATINGCOOLING_CTYPE = stPre + "33" + stPost;
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 7585:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.init = exports.LegacyTypes = exports.uuid = exports.AccessoryLoader = void 0;
var tslib_1 = __nccwpck_require__(4290);
__nccwpck_require__(3418); // registering node-source-map-support for typescript stack traces
__nccwpck_require__(3476); // must be loaded before Characteristic and Service class
var accessoryLoader = tslib_1.__importStar(__nccwpck_require__(1004));
var uuidFunctions = tslib_1.__importStar(__nccwpck_require__(6814));
var legacyTypes = tslib_1.__importStar(__nccwpck_require__(9852));
var HAPStorage_1 = __nccwpck_require__(7617);
exports.AccessoryLoader = accessoryLoader;
exports.uuid = uuidFunctions;
tslib_1.__exportStar(__nccwpck_require__(7617), exports);
tslib_1.__exportStar(__nccwpck_require__(7430), exports);
tslib_1.__exportStar(__nccwpck_require__(4931), exports);
tslib_1.__exportStar(__nccwpck_require__(7383), exports);
tslib_1.__exportStar(__nccwpck_require__(3859), exports);
tslib_1.__exportStar(__nccwpck_require__(1004), exports);
tslib_1.__exportStar(__nccwpck_require__(4992), exports);
tslib_1.__exportStar(__nccwpck_require__(8545), exports);
tslib_1.__exportStar(__nccwpck_require__(7551), exports);
tslib_1.__exportStar(__nccwpck_require__(7580), exports);
tslib_1.__exportStar(__nccwpck_require__(9237), exports);
tslib_1.__exportStar(__nccwpck_require__(9885), exports);
tslib_1.__exportStar(__nccwpck_require__(8597), exports);
tslib_1.__exportStar(__nccwpck_require__(4041), exports);
tslib_1.__exportStar(__nccwpck_require__(9495), exports);
tslib_1.__exportStar(__nccwpck_require__(1814), exports);
tslib_1.__exportStar(__nccwpck_require__(1637), exports);
tslib_1.__exportStar(__nccwpck_require__(4128), exports);
exports.LegacyTypes = legacyTypes;
function printInit() {
    var packageJson = __nccwpck_require__(7308);
    console.log("Initializing HAP-NodeJS v" + packageJson.version + "...");
}
printInit();
/**
 *
 * @param {string} storagePath
 * @deprecated the need to manually initialize the internal storage was removed. If you want to set a custom
 *  storage path location, please use {@link HAPStorage.setCustomStoragePath} directly.
 */
function init(storagePath) {
    console.log("DEPRECATED: The need to manually initialize HAP (by calling the init method) was removed. " +
        "If you want to set a custom storage path location, please ust HAPStorage.setCustomStoragePath directly. " +
        "This method will be removed in the next major update!");
    if (storagePath) {
        HAPStorage_1.HAPStorage.setCustomStoragePath(storagePath);
    }
}
exports.init = init;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 4824:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.consideredTrue = exports.ResourceRequestType = void 0;
var ResourceRequestType;
(function (ResourceRequestType) {
    ResourceRequestType["IMAGE"] = "image";
})(ResourceRequestType = exports.ResourceRequestType || (exports.ResourceRequestType = {}));
function consideredTrue(input) {
    if (!input) {
        return false;
    }
    return input === "true" || input === "1";
}
exports.consideredTrue = consideredTrue;
//# sourceMappingURL=internal-types.js.map

/***/ }),

/***/ 7430:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Accessory = exports.AccessoryEventTypes = exports.MDNSAdvertiser = exports.CharacteristicWarningType = exports.Categories = void 0;
var tslib_1 = __nccwpck_require__(4290);
var assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
var crypto_1 = tslib_1.__importDefault(__nccwpck_require__(6417));
var debug_1 = tslib_1.__importDefault(__nccwpck_require__(7984));
var events_1 = __nccwpck_require__(8614);
var net_1 = tslib_1.__importDefault(__nccwpck_require__(1631));
var Advertiser_1 = __nccwpck_require__(6779);
// noinspection JSDeprecatedSymbols
var camera_1 = __nccwpck_require__(4992);
var Characteristic_1 = __nccwpck_require__(3859);
var controller_1 = __nccwpck_require__(9237);
var HAPServer_1 = __nccwpck_require__(7551);
var AccessoryInfo_1 = __nccwpck_require__(3623);
var ControllerStorage_1 = __nccwpck_require__(548);
var IdentifierCache_1 = __nccwpck_require__(996);
var Service_1 = __nccwpck_require__(7383);
var clone_1 = __nccwpck_require__(9885);
var request_util_1 = __nccwpck_require__(8131);
var uuid = tslib_1.__importStar(__nccwpck_require__(6814));
var uuid_1 = __nccwpck_require__(6814);
var debug = debug_1.default('HAP-NodeJS:Accessory');
var MAX_ACCESSORIES = 149; // Maximum number of bridged accessories per bridge.
var MAX_SERVICES = 100;
// Known category values. Category is a hint to iOS clients about what "type" of Accessory this represents, for UI only.
var Categories;
(function (Categories) {
    // noinspection JSUnusedGlobalSymbols
    Categories[Categories["OTHER"] = 1] = "OTHER";
    Categories[Categories["BRIDGE"] = 2] = "BRIDGE";
    Categories[Categories["FAN"] = 3] = "FAN";
    Categories[Categories["GARAGE_DOOR_OPENER"] = 4] = "GARAGE_DOOR_OPENER";
    Categories[Categories["LIGHTBULB"] = 5] = "LIGHTBULB";
    Categories[Categories["DOOR_LOCK"] = 6] = "DOOR_LOCK";
    Categories[Categories["OUTLET"] = 7] = "OUTLET";
    Categories[Categories["SWITCH"] = 8] = "SWITCH";
    Categories[Categories["THERMOSTAT"] = 9] = "THERMOSTAT";
    Categories[Categories["SENSOR"] = 10] = "SENSOR";
    Categories[Categories["ALARM_SYSTEM"] = 11] = "ALARM_SYSTEM";
    Categories[Categories["SECURITY_SYSTEM"] = 11] = "SECURITY_SYSTEM";
    Categories[Categories["DOOR"] = 12] = "DOOR";
    Categories[Categories["WINDOW"] = 13] = "WINDOW";
    Categories[Categories["WINDOW_COVERING"] = 14] = "WINDOW_COVERING";
    Categories[Categories["PROGRAMMABLE_SWITCH"] = 15] = "PROGRAMMABLE_SWITCH";
    Categories[Categories["RANGE_EXTENDER"] = 16] = "RANGE_EXTENDER";
    Categories[Categories["CAMERA"] = 17] = "CAMERA";
    Categories[Categories["IP_CAMERA"] = 17] = "IP_CAMERA";
    Categories[Categories["VIDEO_DOORBELL"] = 18] = "VIDEO_DOORBELL";
    Categories[Categories["AIR_PURIFIER"] = 19] = "AIR_PURIFIER";
    Categories[Categories["AIR_HEATER"] = 20] = "AIR_HEATER";
    Categories[Categories["AIR_CONDITIONER"] = 21] = "AIR_CONDITIONER";
    Categories[Categories["AIR_HUMIDIFIER"] = 22] = "AIR_HUMIDIFIER";
    Categories[Categories["AIR_DEHUMIDIFIER"] = 23] = "AIR_DEHUMIDIFIER";
    Categories[Categories["APPLE_TV"] = 24] = "APPLE_TV";
    Categories[Categories["HOMEPOD"] = 25] = "HOMEPOD";
    Categories[Categories["SPEAKER"] = 26] = "SPEAKER";
    Categories[Categories["AIRPORT"] = 27] = "AIRPORT";
    Categories[Categories["SPRINKLER"] = 28] = "SPRINKLER";
    Categories[Categories["FAUCET"] = 29] = "FAUCET";
    Categories[Categories["SHOWER_HEAD"] = 30] = "SHOWER_HEAD";
    Categories[Categories["TELEVISION"] = 31] = "TELEVISION";
    Categories[Categories["TARGET_CONTROLLER"] = 32] = "TARGET_CONTROLLER";
    Categories[Categories["ROUTER"] = 33] = "ROUTER";
    Categories[Categories["AUDIO_RECEIVER"] = 34] = "AUDIO_RECEIVER";
    Categories[Categories["TV_SET_TOP_BOX"] = 35] = "TV_SET_TOP_BOX";
    Categories[Categories["TV_STREAMING_STICK"] = 36] = "TV_STREAMING_STICK";
})(Categories = exports.Categories || (exports.Categories = {}));
var CharacteristicWarningType;
(function (CharacteristicWarningType) {
    CharacteristicWarningType["SLOW_WRITE"] = "slow-write";
    CharacteristicWarningType["TIMEOUT_WRITE"] = "timeout-write";
    CharacteristicWarningType["SLOW_READ"] = "slow-read";
    CharacteristicWarningType["TIMEOUT_READ"] = "timeout-read";
    CharacteristicWarningType["WARN_MESSAGE"] = "warn-message";
    CharacteristicWarningType["ERROR_MESSAGE"] = "error-message";
})(CharacteristicWarningType = exports.CharacteristicWarningType || (exports.CharacteristicWarningType = {}));
var MDNSAdvertiser;
(function (MDNSAdvertiser) {
    /**
     * Use the `@homebridge/ciao` module as advertiser.
     */
    MDNSAdvertiser["CIAO"] = "ciao";
    /**
     * Use the `bonjour-hap` module as advertiser.
     */
    MDNSAdvertiser["BONJOUR"] = "bonjour-hap";
})(MDNSAdvertiser = exports.MDNSAdvertiser || (exports.MDNSAdvertiser = {}));
var WriteRequestState;
(function (WriteRequestState) {
    WriteRequestState[WriteRequestState["REGULAR_REQUEST"] = 0] = "REGULAR_REQUEST";
    WriteRequestState[WriteRequestState["TIMED_WRITE_AUTHENTICATED"] = 1] = "TIMED_WRITE_AUTHENTICATED";
    WriteRequestState[WriteRequestState["TIMED_WRITE_REJECTED"] = 2] = "TIMED_WRITE_REJECTED";
})(WriteRequestState || (WriteRequestState = {}));
var AccessoryEventTypes;
(function (AccessoryEventTypes) {
    /**
     * Emitted when an iOS device wishes for this Accessory to identify itself. If `paired` is false, then
     * this device is currently browsing for Accessories in the system-provided "Add Accessory" screen. If
     * `paired` is true, then this is a device that has already paired with us. Note that if `paired` is true,
     * listening for this event is a shortcut for the underlying mechanism of setting the `Identify` Characteristic:
     * `getService(Service.AccessoryInformation).getCharacteristic(Characteristic.Identify).on('set', ...)`
     * You must call the callback for identification to be successful.
     */
    AccessoryEventTypes["IDENTIFY"] = "identify";
    AccessoryEventTypes["LISTENING"] = "listening";
    AccessoryEventTypes["SERVICE_CONFIGURATION_CHANGE"] = "service-configurationChange";
    /**
     * Emitted after a change in the value of one of the provided Service's Characteristics.
     */
    AccessoryEventTypes["SERVICE_CHARACTERISTIC_CHANGE"] = "service-characteristic-change";
    AccessoryEventTypes["PAIRED"] = "paired";
    AccessoryEventTypes["UNPAIRED"] = "unpaired";
    AccessoryEventTypes["CHARACTERISTIC_WARNING"] = "characteristic-warning";
})(AccessoryEventTypes = exports.AccessoryEventTypes || (exports.AccessoryEventTypes = {}));
/**
 * Accessory is a virtual HomeKit device. It can publish an associated HAP server for iOS devices to communicate
 * with - or it can run behind another "Bridge" Accessory server.
 *
 * Bridged Accessories in this implementation must have a UUID that is unique among all other Accessories that
 * are hosted by the Bridge. This UUID must be "stable" and unchanging, even when the server is restarted. This
 * is required so that the Bridge can provide consistent "Accessory IDs" (aid) and "Instance IDs" (iid) for all
 * Accessories, Services, and Characteristics for iOS clients to reference later.
 */
var Accessory = /** @class */ (function (_super) {
    tslib_1.__extends(Accessory, _super);
    function Accessory(displayName, UUID) {
        var _this = _super.call(this) || this;
        _this.displayName = displayName;
        _this.UUID = UUID;
        // NOTICE: when adding/changing properties, remember to possibly adjust the serialize/deserialize functions
        _this.aid = null; // assigned by us in assignIDs() or by a Bridge
        _this._isBridge = false; // true if we are a Bridge (creating a new instance of the Bridge subclass sets this to true)
        _this.bridged = false; // true if we are hosted "behind" a Bridge Accessory
        _this.bridgedAccessories = []; // If we are a Bridge, these are the Accessories we are bridging
        _this.reachable = true;
        _this.category = 1 /* OTHER */;
        _this.services = [];
        _this.shouldPurgeUnusedIDs = true; // Purge unused ids by default
        _this.controllers = {};
        _this._setupID = null;
        _this.controllerStorage = new ControllerStorage_1.ControllerStorage(_this);
        /**
         * This property captures the time when we last server a /accessories request.
         * For multiple bursts of /accessories request we don't want to always contact GET handlers
         */
        _this.lastAccessoriesRequest = 0;
        /**
         * Returns the bridging accessory if this accessory is bridged.
         * Otherwise returns itself.
         *
         * @returns the primary accessory
         */
        _this.getPrimaryAccessory = function () {
            return _this.bridged ? _this.bridge : _this;
        };
        _this.disableUnusedIDPurge = function () {
            _this.shouldPurgeUnusedIDs = false;
        };
        _this.enableUnusedIDPurge = function () {
            _this.shouldPurgeUnusedIDs = true;
        };
        /**
         * Manually purge the unused ids if you like, comes handy
         * when you have disabled auto purge so you can do it manually
         */
        _this.purgeUnusedIDs = function () {
            //Cache the state of the purge mechanism and set it to true
            var oldValue = _this.shouldPurgeUnusedIDs;
            _this.shouldPurgeUnusedIDs = true;
            //Reassign all ids
            _this._assignIDs(_this._identifierCache);
            //Revert back the purge mechanism state
            _this.shouldPurgeUnusedIDs = oldValue;
        };
        assert_1.default(displayName, "Accessories must be created with a non-empty displayName.");
        assert_1.default(UUID, "Accessories must be created with a valid UUID.");
        assert_1.default(uuid.isValid(UUID), "UUID '" + UUID + "' is not a valid UUID. Try using the provided 'generateUUID' function to create a valid UUID from any arbitrary string, like a serial number.");
        // create our initial "Accessory Information" Service that all Accessories are expected to have
        _this.addService(Service_1.Service.AccessoryInformation)
            .setCharacteristic(Characteristic_1.Characteristic.Name, displayName);
        // sign up for when iOS attempts to "set" the Identify characteristic - this means a paired device wishes
        // for us to identify ourselves (as opposed to an unpaired device - that case is handled by HAPServer 'identify' event)
        _this.getService(Service_1.Service.AccessoryInformation)
            .getCharacteristic(Characteristic_1.Characteristic.Identify)
            .on("set" /* SET */, function (value, callback) {
            if (value) {
                var paired = true;
                _this.identificationRequest(paired, callback);
            }
        });
        return _this;
    }
    Accessory.prototype.identificationRequest = function (paired, callback) {
        debug("[%s] Identification request", this.displayName);
        if (this.listeners("identify" /* IDENTIFY */).length > 0) {
            // allow implementors to identify this Accessory in whatever way is appropriate, and pass along
            // the standard callback for completion.
            this.emit("identify" /* IDENTIFY */, paired, callback);
        }
        else {
            debug("[%s] Identification request ignored; no listeners to 'identify' event", this.displayName);
            callback();
        }
    };
    Accessory.prototype.addService = function (serviceParam) {
        var e_1, _a;
        var constructorArgs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            constructorArgs[_i - 1] = arguments[_i];
        }
        // service might be a constructor like `Service.AccessoryInformation` instead of an instance
        // of Service. Coerce if necessary.
        var service = typeof serviceParam === 'function'
            ? new serviceParam(constructorArgs[0], constructorArgs[1], constructorArgs[2])
            : serviceParam;
        try {
            // check for UUID+subtype conflict
            for (var _b = tslib_1.__values(this.services), _c = _b.next(); !_c.done; _c = _b.next()) {
                var existing = _c.value;
                if (existing.UUID === service.UUID) {
                    // OK we have two Services with the same UUID. Check that each defines a `subtype` property and that each is unique.
                    if (!service.subtype)
                        throw new Error("Cannot add a Service with the same UUID '" + existing.UUID + "' as another Service in this Accessory without also defining a unique 'subtype' property.");
                    if (service.subtype === existing.subtype)
                        throw new Error("Cannot add a Service with the same UUID '" + existing.UUID + "' and subtype '" + existing.subtype + "' as another Service in this Accessory.");
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (this.services.length >= MAX_SERVICES) {
            throw new Error("Cannot add more than " + MAX_SERVICES + " services to a single accessory!");
        }
        this.services.push(service);
        if (service.isPrimaryService) { // check if a primary service was added
            if (this.primaryService !== undefined) {
                this.primaryService.isPrimaryService = false;
            }
            this.primaryService = service;
        }
        if (!this.bridged) {
            this.enqueueConfigurationUpdate();
        }
        else {
            this.emit("service-configurationChange" /* SERVICE_CONFIGURATION_CHANGE */, { service: service });
        }
        this.setupServiceEventHandlers(service);
        return service;
    };
    /**
     * @deprecated use {@link Service.setPrimaryService} directly
     */
    Accessory.prototype.setPrimaryService = function (service) {
        service.setPrimaryService();
    };
    Accessory.prototype.removeService = function (service) {
        var index = this.services.indexOf(service);
        if (index >= 0) {
            this.services.splice(index, 1);
            if (this.primaryService === service) { // check if we are removing out primary service
                this.primaryService = undefined;
            }
            this.removeLinkedService(service); // remove it from linked service entries on the local accessory
            if (!this.bridged) {
                this.enqueueConfigurationUpdate();
            }
            else {
                this.emit("service-configurationChange" /* SERVICE_CONFIGURATION_CHANGE */, { service: service });
            }
            service.removeAllListeners();
        }
    };
    Accessory.prototype.removeLinkedService = function (removed) {
        var e_2, _a;
        try {
            for (var _b = tslib_1.__values(this.services), _c = _b.next(); !_c.done; _c = _b.next()) {
                var service = _c.value;
                service.removeLinkedService(removed);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    Accessory.prototype.getService = function (name) {
        var e_3, _a;
        try {
            for (var _b = tslib_1.__values(this.services), _c = _b.next(); !_c.done; _c = _b.next()) {
                var service = _c.value;
                if (typeof name === 'string' && (service.displayName === name || service.name === name || service.subtype === name)) {
                    return service;
                }
                else if (typeof name === 'function' && ((service instanceof name) || (name.UUID === service.UUID))) {
                    return service;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return undefined;
    };
    Accessory.prototype.getServiceById = function (uuid, subType) {
        var e_4, _a;
        try {
            for (var _b = tslib_1.__values(this.services), _c = _b.next(); !_c.done; _c = _b.next()) {
                var service = _c.value;
                if (typeof uuid === "string" && (service.displayName === uuid || service.name === uuid) && service.subtype === subType) {
                    return service;
                }
                else if (typeof uuid === "function" && ((service instanceof uuid) || (uuid.UUID === service.UUID)) && service.subtype === subType) {
                    return service;
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return undefined;
    };
    /**
     * @deprecated Not supported anymore
     */
    Accessory.prototype.updateReachability = function (reachable) {
        if (!this.bridged)
            throw new Error("Cannot update reachability on non-bridged accessory!");
        this.reachable = reachable;
        debug('Reachability update is no longer being supported.');
    };
    Accessory.prototype.addBridgedAccessory = function (accessory, deferUpdate) {
        var e_5, _a;
        var _this = this;
        if (deferUpdate === void 0) { deferUpdate = false; }
        if (accessory._isBridge) {
            throw new Error("Cannot Bridge another Bridge!");
        }
        try {
            // check for UUID conflict
            for (var _b = tslib_1.__values(this.bridgedAccessories), _c = _b.next(); !_c.done; _c = _b.next()) {
                var existing = _c.value;
                if (existing.UUID === accessory.UUID) {
                    throw new Error("Cannot add a bridged Accessory with the same UUID as another bridged Accessory: " + existing.UUID);
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
        if (this.bridgedAccessories.length >= MAX_ACCESSORIES) {
            throw new Error("Cannot Bridge more than " + MAX_ACCESSORIES + " Accessories");
        }
        // listen for changes in ANY characteristics of ANY services on this Accessory
        accessory.on("service-characteristic-change" /* SERVICE_CHARACTERISTIC_CHANGE */, function (change) { return _this.handleCharacteristicChangeEvent(accessory, change.service, change); });
        accessory.on("service-configurationChange" /* SERVICE_CONFIGURATION_CHANGE */, this.enqueueConfigurationUpdate.bind(this));
        accessory.on("characteristic-warning" /* CHARACTERISTIC_WARNING */, this.handleCharacteristicWarning.bind(this));
        accessory.bridged = true;
        accessory.bridge = this;
        this.bridgedAccessories.push(accessory);
        this.controllerStorage.linkAccessory(accessory); // init controllers of bridged accessory
        if (!deferUpdate) {
            this.enqueueConfigurationUpdate();
        }
        return accessory;
    };
    Accessory.prototype.addBridgedAccessories = function (accessories) {
        var e_6, _a;
        try {
            for (var accessories_1 = tslib_1.__values(accessories), accessories_1_1 = accessories_1.next(); !accessories_1_1.done; accessories_1_1 = accessories_1.next()) {
                var accessory = accessories_1_1.value;
                this.addBridgedAccessory(accessory, true);
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (accessories_1_1 && !accessories_1_1.done && (_a = accessories_1.return)) _a.call(accessories_1);
            }
            finally { if (e_6) throw e_6.error; }
        }
        this.enqueueConfigurationUpdate();
    };
    Accessory.prototype.removeBridgedAccessory = function (accessory, deferUpdate) {
        if (accessory._isBridge)
            throw new Error("Cannot Bridge another Bridge!");
        // check for UUID conflict
        var foundMatchAccessory = this.bridgedAccessories.findIndex(function (existing) {
            return existing.UUID === accessory.UUID;
        });
        if (foundMatchAccessory === -1)
            throw new Error("Cannot find the bridged Accessory to remove.");
        this.bridgedAccessories.splice(foundMatchAccessory, 1);
        accessory.removeAllListeners();
        if (!deferUpdate) {
            this.enqueueConfigurationUpdate();
        }
    };
    Accessory.prototype.removeBridgedAccessories = function (accessories) {
        var e_7, _a;
        try {
            for (var accessories_2 = tslib_1.__values(accessories), accessories_2_1 = accessories_2.next(); !accessories_2_1.done; accessories_2_1 = accessories_2.next()) {
                var accessory = accessories_2_1.value;
                this.removeBridgedAccessory(accessory, true);
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (accessories_2_1 && !accessories_2_1.done && (_a = accessories_2.return)) _a.call(accessories_2);
            }
            finally { if (e_7) throw e_7.error; }
        }
        this.enqueueConfigurationUpdate();
    };
    Accessory.prototype.removeAllBridgedAccessories = function () {
        for (var i = this.bridgedAccessories.length - 1; i >= 0; i--) {
            this.removeBridgedAccessory(this.bridgedAccessories[i], true);
        }
        this.enqueueConfigurationUpdate();
    };
    Accessory.prototype.getCharacteristicByIID = function (iid) {
        var e_8, _a;
        try {
            for (var _b = tslib_1.__values(this.services), _c = _b.next(); !_c.done; _c = _b.next()) {
                var service = _c.value;
                var characteristic = service.getCharacteristicByIID(iid);
                if (characteristic) {
                    return characteristic;
                }
            }
        }
        catch (e_8_1) { e_8 = { error: e_8_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_8) throw e_8.error; }
        }
    };
    Accessory.prototype.getAccessoryByAID = function (aid) {
        var e_9, _a;
        if (aid === 1) {
            return this;
        }
        try {
            for (var _b = tslib_1.__values(this.bridgedAccessories), _c = _b.next(); !_c.done; _c = _b.next()) {
                var accessory = _c.value;
                if (accessory.aid === aid) {
                    return accessory;
                }
            }
        }
        catch (e_9_1) { e_9 = { error: e_9_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_9) throw e_9.error; }
        }
        return undefined;
    };
    Accessory.prototype.findCharacteristic = function (aid, iid) {
        var accessory = this.getAccessoryByAID(aid);
        return accessory && accessory.getCharacteristicByIID(iid);
    };
    // noinspection JSDeprecatedSymbols
    /**
     * Method is used to configure an old style CameraSource.
     * The CameraSource API was fully replaced by the new Controller API used by {@link CameraController}.
     * The {@link CameraStreamingDelegate} used by the CameraController is the equivalent to the old CameraSource.
     *
     * The new Controller API is much more refined and robust way of "grouping" services together.
     * It especially is intended to fully support serialization/deserialization to/from persistent storage.
     * This feature is also gained when using the old style CameraSource API.
     * The {@link CameraStreamingDelegate} improves on the overall camera API though and provides some reworked
     * type definitions and a refined callback interface to better signal errors to the requesting HomeKit device.
     * It is advised to update to it.
     *
     * Full backwards compatibility is currently maintained. A legacy CameraSource will be wrapped into an Adapter.
     * All legacy StreamControllers in the "streamControllers" property will be replaced by CameraRTPManagement instances.
     * Any services in the "services" property which are one of the following are ignored:
     *     - CameraRTPStreamManagement
     *     - CameraOperatingMode
     *     - CameraEventRecordingManagement
     *
     * @param cameraSource {LegacyCameraSource}
     * @deprecated please refer to the new {@see CameraController} API and {@link configureController}
     */
    Accessory.prototype.configureCameraSource = function (cameraSource) {
        var _this = this;
        if (cameraSource.streamControllers.length === 0) {
            throw new Error("Malformed legacy CameraSource. Did not expose any StreamControllers!");
        }
        var options = cameraSource.streamControllers[0].options; // grab options from one of the StreamControllers
        var cameraControllerOptions = {
            cameraStreamCount: cameraSource.streamControllers.length,
            streamingOptions: options,
            delegate: new camera_1.LegacyCameraSourceAdapter(cameraSource),
        };
        var cameraController = new controller_1.CameraController(cameraControllerOptions, true); // create CameraController in legacy mode
        this.configureController(cameraController);
        // we try here to be as good as possibly of keeping current behaviour
        cameraSource.services.forEach(function (service) {
            if (service.UUID === Service_1.Service.CameraRTPStreamManagement.UUID || service.UUID === Service_1.Service.CameraOperatingMode.UUID
                || service.UUID === Service_1.Service.CameraRecordingManagement.UUID) {
                return; // ignore those services, as they get replaced by the RTPStreamManagement
            }
            // all other services get added. We can't really control possibly linking to any of those ignored services
            // so this is really only half baked stuff.
            _this.addService(service);
        });
        // replace stream controllers; basically only to still support the "forceStop" call
        // noinspection JSDeprecatedSymbols
        cameraSource.streamControllers = cameraController.streamManagements;
        return cameraController; // return the reference for the controller (maybe this could be useful?)
    };
    /**
     * This method is used to setup a new Controller for this accessory. See {@see Controller} for a more detailed
     * explanation what a Controller is and what it is capable of.
     *
     * The controller can be passed as an instance of the class or as a constructor (without any necessary parameters)
     * for a new Controller.
     * Only one Controller of a given {@link ControllerIdentifier} can be configured for a given Accessory.
     *
     * When called, it will be checked if there are any services and persistent data the Controller (for the given
     * {@link ControllerIdentifier}) can be restored from. Otherwise the Controller will be created with new services.
     *
     *
     * @param controllerConstructor {Controller | ControllerConstructor}
     */
    Accessory.prototype.configureController = function (controllerConstructor) {
        var _this = this;
        var controller = typeof controllerConstructor === "function"
            ? new controllerConstructor() // any custom constructor arguments should be passed before using .bind(...)
            : controllerConstructor;
        var id = controller.controllerId();
        if (this.controllers[id]) {
            throw new Error("A Controller with the type/id '" + id + "' was already added to the accessory " + this.displayName);
        }
        var savedServiceMap = this.serializedControllers && this.serializedControllers[id];
        var serviceMap;
        if (savedServiceMap) { // we found data to restore from
            var clonedServiceMap = clone_1.clone(savedServiceMap);
            var updatedServiceMap = controller.initWithServices(savedServiceMap); // init controller with existing services
            serviceMap = updatedServiceMap || savedServiceMap; // initWithServices could return a updated serviceMap, otherwise just use the existing one
            if (updatedServiceMap) { // controller returned a ServiceMap and thus signaled a updated set of services
                // clonedServiceMap is altered by this method, should not be touched again after this call (for the future people)
                this.handleUpdatedControllerServiceMap(clonedServiceMap, updatedServiceMap);
            }
            controller.configureServices(); // let the controller setup all its handlers
            // remove serialized data from our dictionary:
            delete this.serializedControllers[id];
            if (Object.entries(this.serializedControllers).length === 0) {
                this.serializedControllers = undefined;
            }
        }
        else {
            serviceMap = controller.constructServices(); // let the controller create his services
            controller.configureServices(); // let the controller setup all its handlers
            Object.values(serviceMap).forEach(function (service) {
                if (service && !_this.services.includes(service)) {
                    _this.addService(service);
                }
            });
        }
        // --- init handlers and setup context ---
        var context = {
            controller: controller,
            serviceMap: serviceMap,
        };
        if (controller_1.isSerializableController(controller)) {
            this.controllerStorage.trackController(controller);
        }
        this.controllers[id] = context;
        if (controller instanceof controller_1.CameraController) { // save CameraController for Snapshot handling
            this.activeCameraController = controller;
        }
    };
    /**
     * This method will remove a given Controller from this accessory.
     * The controller object will be restored to its initial state.
     * This also means that any event handlers setup for the controller will be removed.
     *
     * @param controller - The controller which should be removed from the accessory.
     */
    Accessory.prototype.removeController = function (controller) {
        var _this = this;
        var id = controller.controllerId();
        var storedController = this.controllers[id];
        if (storedController) {
            if (storedController.controller !== controller) {
                throw new Error("[" + this.displayName + "] tried removing a controller with the id/type '" + id + "' though provided controller isn't the same which is registered!");
            }
            if (controller_1.isSerializableController(controller)) {
                // this will reset the state change delegate before we call handleControllerRemoved()
                this.controllerStorage.untrackController(controller);
            }
            if (controller.handleFactoryReset) {
                controller.handleFactoryReset();
            }
            controller.handleControllerRemoved();
            delete this.controllers[id];
            if (this.activeCameraController === controller) {
                this.activeCameraController = undefined;
            }
            Object.values(storedController.serviceMap).forEach(function (service) {
                if (service) {
                    _this.removeService(service);
                }
            });
        }
        if (this.serializedControllers) {
            delete this.serializedControllers[id];
        }
    };
    Accessory.prototype.handleAccessoryUnpairedForControllers = function () {
        var e_10, _a;
        try {
            for (var _b = tslib_1.__values(Object.values(this.controllers)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var context = _c.value;
                var controller = context.controller;
                if (controller.handleFactoryReset) { // if the controller implements handleFactoryReset, setup event handlers for this controller
                    controller.handleFactoryReset();
                }
                if (controller_1.isSerializableController(controller)) {
                    this.controllerStorage.purgeControllerData(controller);
                }
            }
        }
        catch (e_10_1) { e_10 = { error: e_10_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_10) throw e_10.error; }
        }
    };
    Accessory.prototype.handleUpdatedControllerServiceMap = function (originalServiceMap, updatedServiceMap) {
        var _this = this;
        updatedServiceMap = clone_1.clone(updatedServiceMap); // clone it so we can alter it
        Object.keys(originalServiceMap).forEach(function (name) {
            var service = originalServiceMap[name];
            var updatedService = updatedServiceMap[name];
            if (service && updatedService) { // we check all names contained in both ServiceMaps for changes
                delete originalServiceMap[name]; // delete from original ServiceMap so it will only contain deleted services at the end
                delete updatedServiceMap[name]; // delete from updated ServiceMap so it will only contain added services at the end
                if (service !== updatedService) {
                    _this.removeService(service);
                    _this.addService(updatedService);
                }
            }
        });
        // now originalServiceMap contains only deleted services and updateServiceMap only added services
        Object.values(originalServiceMap).forEach(function (service) {
            if (service) {
                _this.removeService(service);
            }
        });
        Object.values(updatedServiceMap).forEach(function (service) {
            if (service) {
                _this.addService(service);
            }
        });
    };
    Accessory.prototype.setupURI = function () {
        if (this._setupURI) {
            return this._setupURI;
        }
        var buffer = Buffer.alloc(8);
        var setupCode = this._accessoryInfo && parseInt(this._accessoryInfo.pincode.replace(/-/g, ''), 10);
        var value_low = setupCode;
        var value_high = this._accessoryInfo && this._accessoryInfo.category >> 1;
        value_low |= 1 << 28; // Supports IP;
        buffer.writeUInt32BE(value_low, 4);
        if (this._accessoryInfo && this._accessoryInfo.category & 1) {
            buffer[4] = buffer[4] | 1 << 7;
        }
        buffer.writeUInt32BE(value_high, 0);
        var encodedPayload = (buffer.readUInt32BE(4) + (buffer.readUInt32BE(0) * Math.pow(2, 32))).toString(36).toUpperCase();
        if (encodedPayload.length != 9) {
            for (var i = 0; i <= 9 - encodedPayload.length; i++) {
                encodedPayload = "0" + encodedPayload;
            }
        }
        this._setupURI = "X-HM://" + encodedPayload + this._setupID;
        return this._setupURI;
    };
    /**
     * This method is called right before the accessory is published. It should be used to check for common
     * mistakes in Accessory structured, which may lead to HomeKit rejecting the accessory when pairing.
     * If it is called on a bridge it will call this method for all bridged accessories.
     */
    Accessory.prototype.validateAccessory = function (mainAccessory) {
        var _this = this;
        var service = this.getService(Service_1.Service.AccessoryInformation);
        if (!service) {
            console.log("HAP-NodeJS WARNING: The accessory '" + this.displayName + "' is getting published without a AccessoryInformation service. " +
                "This might prevent the accessory from being added to the Home app or leading to the accessory being unresponsive!");
        }
        else {
            var checkValue = function (name, value) {
                if (!value) {
                    console.log("HAP-NodeJS WARNING: The accessory '" + _this.displayName + "' is getting published with the characteristic '" + name + "'" +
                        " (of the AccessoryInformation service) not having a value set. " +
                        "This might prevent the accessory from being added to the Home App or leading to the accessory being unresponsive!");
                }
            };
            var model = service.getCharacteristic(Characteristic_1.Characteristic.Model).value;
            var serialNumber = service.getCharacteristic(Characteristic_1.Characteristic.SerialNumber).value;
            var firmwareRevision = service.getCharacteristic(Characteristic_1.Characteristic.FirmwareRevision).value;
            var name = service.getCharacteristic(Characteristic_1.Characteristic.Name).value;
            checkValue("Model", model);
            checkValue("SerialNumber", serialNumber);
            checkValue("FirmwareRevision", firmwareRevision);
            checkValue("Name", name);
        }
        if (mainAccessory) {
            // the main accessory which is advertised via bonjour must have a name with length <= 63 (limitation of DNS FQDN names)
            assert_1.default(Buffer.from(this.displayName, "utf8").length <= 63, "Accessory displayName cannot be longer than 63 bytes!");
        }
        if (this.bridged) {
            this.bridgedAccessories.forEach(function (accessory) { return accessory.validateAccessory(); });
        }
    };
    /**
     * Assigns aid/iid to ourselves, any Accessories we are bridging, and all associated Services+Characteristics. Uses
     * the provided identifierCache to keep IDs stable.
     */
    Accessory.prototype._assignIDs = function (identifierCache) {
        var e_11, _a, e_12, _b;
        // if we are responsible for our own identifierCache, start the expiration process
        // also check weather we want to have an expiration process
        if (this._identifierCache && this.shouldPurgeUnusedIDs) {
            this._identifierCache.startTrackingUsage();
        }
        if (this.bridged) {
            // This Accessory is bridged, so it must have an aid > 1. Use the provided identifierCache to
            // fetch or assign one based on our UUID.
            this.aid = identifierCache.getAID(this.UUID);
        }
        else {
            // Since this Accessory is the server (as opposed to any Accessories that may be bridged behind us),
            // we must have aid = 1
            this.aid = 1;
        }
        try {
            for (var _c = tslib_1.__values(this.services), _d = _c.next(); !_d.done; _d = _c.next()) {
                var service = _d.value;
                if (this._isBridge) {
                    service._assignIDs(identifierCache, this.UUID, 2000000000);
                }
                else {
                    service._assignIDs(identifierCache, this.UUID);
                }
            }
        }
        catch (e_11_1) { e_11 = { error: e_11_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_11) throw e_11.error; }
        }
        try {
            // now assign IDs for any Accessories we are bridging
            for (var _e = tslib_1.__values(this.bridgedAccessories), _f = _e.next(); !_f.done; _f = _e.next()) {
                var accessory = _f.value;
                accessory._assignIDs(identifierCache);
            }
        }
        catch (e_12_1) { e_12 = { error: e_12_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_12) throw e_12.error; }
        }
        // expire any now-unused cache keys (for Accessories, Services, or Characteristics
        // that have been removed since the last call to assignIDs())
        if (this._identifierCache) {
            //Check weather we want to purge the unused ids
            if (this.shouldPurgeUnusedIDs)
                this._identifierCache.stopTrackingUsageAndExpireUnused();
            //Save in case we have new ones
            this._identifierCache.save();
        }
    };
    /**
     * Returns a JSON representation of this accessory suitable for delivering to HAP clients.
     */
    Accessory.prototype.toHAP = function (connection, contactGetHandlers) {
        if (contactGetHandlers === void 0) { contactGetHandlers = true; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var accessory, accessories, _a, _b, _c;
            var _d;
            return tslib_1.__generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        assert_1.default(this.aid, "aid cannot be undefined for accessory '" + this.displayName + "'");
                        assert_1.default(this.services.length, "accessory '" + this.displayName + "' does not have any services!");
                        _d = {
                            aid: this.aid
                        };
                        return [4 /*yield*/, Promise.all(this.services.map(function (service) { return service.toHAP(connection, contactGetHandlers); }))];
                    case 1:
                        accessory = (_d.services = _e.sent(),
                            _d);
                        accessories = [accessory];
                        if (!!this.bridged) return [3 /*break*/, 3];
                        _b = (_a = accessories.push).apply;
                        _c = [accessories];
                        return [4 /*yield*/, Promise.all(this.bridgedAccessories
                                .map(function (accessory) { return accessory.toHAP(connection, contactGetHandlers).then(function (value) { return value[0]; }); }))];
                    case 2:
                        _b.apply(_a, _c.concat([tslib_1.__spread.apply(void 0, [_e.sent()])]));
                        _e.label = 3;
                    case 3: return [2 /*return*/, accessories];
                }
            });
        });
    };
    /**
     * Returns a JSON representation of this accessory without characteristic values.
     */
    Accessory.prototype.internalHAPRepresentation = function (assignIds) {
        var e_13, _a;
        if (assignIds === void 0) { assignIds = true; }
        if (assignIds) {
            this._assignIDs(this._identifierCache); // make sure our aid/iid's are all assigned
        }
        assert_1.default(this.aid, "aid cannot be undefined for accessory '" + this.displayName + "'");
        assert_1.default(this.services.length, "accessory '" + this.displayName + "' does not have any services!");
        var accessory = {
            aid: this.aid,
            services: this.services.map(function (service) { return service.internalHAPRepresentation(); }),
        };
        var accessories = [accessory];
        if (!this.bridged) {
            try {
                for (var _b = tslib_1.__values(this.bridgedAccessories), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var accessory_1 = _c.value;
                    accessories.push(accessory_1.internalHAPRepresentation(false)[0]);
                }
            }
            catch (e_13_1) { e_13 = { error: e_13_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_13) throw e_13.error; }
            }
        }
        return accessories;
    };
    /**
     * Publishes this Accessory on the local network for iOS clients to communicate with.
     *
     * @param {Object} info - Required info for publishing.
     * @param allowInsecureRequest - Will allow unencrypted and unauthenticated access to the http server
     * @param {string} info.username - The "username" (formatted as a MAC address - like "CC:22:3D:E3:CE:F6") of
     *                                this Accessory. Must be globally unique from all Accessories on your local network.
     * @param {string} info.pincode - The 8-digit pincode for clients to use when pairing this Accessory. Must be formatted
     *                               as a string like "031-45-154".
     * @param {string} info.category - One of the values of the Accessory.Category enum, like Accessory.Category.SWITCH.
     *                                This is a hint to iOS clients about what "type" of Accessory this represents, so
     *                                that for instance an appropriate icon can be drawn for the user while adding a
     *                                new Accessory.
     */
    Accessory.prototype.publish = function (info, allowInsecureRequest) {
        var _this = this;
        var _a, _b;
        // noinspection JSDeprecatedSymbols
        if (!info.advertiser && info.useLegacyAdvertiser != null) {
            // noinspection JSDeprecatedSymbols
            info.advertiser = info.useLegacyAdvertiser ? "bonjour-hap" /* BONJOUR */ : "ciao" /* CIAO */;
            console.warn('DEPRECATED The PublishInfo.useLegacyAdvertiser option has been removed. Please use the PublishInfo.advertiser property to enable "ciao" (useLegacyAdvertiser=false) ' +
                'or "bonjour-hap" (useLegacyAdvertiser=true) mdns advertiser libraries!');
        }
        // noinspection JSDeprecatedSymbols
        if (info.mdns && info.advertiser !== "bonjour-hap" /* BONJOUR */) {
            console.log("DEPRECATED user supplied a custom 'mdns' option. This option is deprecated and ignored. " +
                "Please move to the new 'bind' option.");
        }
        var service = this.getService(Service_1.Service.ProtocolInformation);
        if (!service) {
            service = this.addService(Service_1.Service.ProtocolInformation); // add the protocol information service to the primary accessory
        }
        service.setCharacteristic(Characteristic_1.Characteristic.Version, Advertiser_1.CiaoAdvertiser.protocolVersionService);
        if (this.lastKnownUsername && this.lastKnownUsername !== info.username) { // username changed since last publish
            Accessory.cleanupAccessoryData(this.lastKnownUsername); // delete old Accessory data
        }
        if ((_a = info.addIdentifyingMaterial) !== null && _a !== void 0 ? _a : true) {
            // adding some identifying material to our displayName
            this.displayName = this.displayName + " " + crypto_1.default.createHash('sha512')
                .update(info.username, 'utf8')
                .digest('hex').slice(0, 4).toUpperCase();
            this.getService(Service_1.Service.AccessoryInformation).updateCharacteristic(Characteristic_1.Characteristic.Name, this.displayName);
        }
        // attempt to load existing AccessoryInfo from disk
        this._accessoryInfo = AccessoryInfo_1.AccessoryInfo.load(info.username);
        // if we don't have one, create a new one.
        if (!this._accessoryInfo) {
            debug("[%s] Creating new AccessoryInfo for our HAP server", this.displayName);
            this._accessoryInfo = AccessoryInfo_1.AccessoryInfo.create(info.username);
        }
        if (info.setupID) {
            this._setupID = info.setupID;
        }
        else if (this._accessoryInfo.setupID === undefined || this._accessoryInfo.setupID === "") {
            this._setupID = Accessory._generateSetupID();
        }
        else {
            this._setupID = this._accessoryInfo.setupID;
        }
        this._accessoryInfo.setupID = this._setupID;
        // make sure we have up-to-date values in AccessoryInfo, then save it in case they changed (or if we just created it)
        this._accessoryInfo.displayName = this.displayName;
        this._accessoryInfo.model = this.getService(Service_1.Service.AccessoryInformation).getCharacteristic(Characteristic_1.Characteristic.Model).value;
        this._accessoryInfo.category = info.category || 1 /* OTHER */;
        this._accessoryInfo.pincode = info.pincode;
        this._accessoryInfo.save();
        // create our IdentifierCache so we can provide clients with stable aid/iid's
        this._identifierCache = IdentifierCache_1.IdentifierCache.load(info.username);
        // if we don't have one, create a new one.
        if (!this._identifierCache) {
            debug("[%s] Creating new IdentifierCache", this.displayName);
            this._identifierCache = new IdentifierCache_1.IdentifierCache(info.username);
        }
        //If it's bridge and there are not accessories already assigned to the bridge
        //probably purge is not needed since it's going to delete all the ids
        //of accessories that might be added later. Useful when dynamically adding
        //accessories.
        if (this._isBridge && this.bridgedAccessories.length == 0) {
            this.disableUnusedIDPurge();
            this.controllerStorage.purgeUnidentifiedAccessoryData = false;
        }
        this.controllerStorage.load(info.username); // initializing controller data
        // assign aid/iid
        this._assignIDs(this._identifierCache);
        // get our accessory information in HAP format and determine if our configuration (that is, our
        // Accessories/Services/Characteristics) has changed since the last time we were published. make
        // sure to omit actual values since these are not part of the "configuration".
        var config = this.internalHAPRepresentation(false); // TODO ensure this stuff is ordered
        // TODO queue this check until about 5 seconds after startup, allowing some last changes after the publish call
        //   without constantly incrementing the current config number
        this._accessoryInfo.checkForCurrentConfigurationNumberIncrement(config, true);
        this.validateAccessory(true);
        // create our Advertiser which broadcasts our presence over mdns
        var parsed = Accessory.parseBindOption(info);
        switch ((_b = info.advertiser) !== null && _b !== void 0 ? _b : "bonjour-hap" /* BONJOUR */) {
            case "ciao" /* CIAO */:
                this._advertiser = new Advertiser_1.CiaoAdvertiser(this._accessoryInfo, {
                    interface: parsed.advertiserAddress
                }, {
                    restrictedAddresses: parsed.serviceRestrictedAddress,
                    disabledIpv6: parsed.serviceDisableIpv6,
                });
                break;
            case "bonjour-hap" /* BONJOUR */:
                // noinspection JSDeprecatedSymbols
                this._advertiser = new Advertiser_1.BonjourHAPAdvertiser(this._accessoryInfo, info.mdns, {
                    restrictedAddresses: parsed.serviceRestrictedAddress,
                    disabledIpv6: parsed.serviceDisableIpv6,
                });
                break;
            default:
                throw new Error("Unsupported advertiser setting: '" + info.advertiser + "'");
        }
        this._advertiser.on("updated-name" /* UPDATED_NAME */, function (name) {
            _this.displayName = name;
            if (_this._accessoryInfo) {
                _this._accessoryInfo.displayName = name;
                _this._accessoryInfo.save();
            }
            // bonjour service name MUST match the name in the accessory information service
            _this.getService(Service_1.Service.AccessoryInformation)
                .updateCharacteristic(Characteristic_1.Characteristic.Name, name);
        });
        // create our HAP server which handles all communication between iOS devices and us
        this._server = new HAPServer_1.HAPServer(this._accessoryInfo);
        this._server.allowInsecureRequest = !!allowInsecureRequest;
        this._server.on("listening" /* LISTENING */, this.onListening.bind(this));
        this._server.on("identify" /* IDENTIFY */, this.identificationRequest.bind(this, false));
        this._server.on("pair" /* PAIR */, this.handleInitialPairSetupFinished.bind(this));
        this._server.on("add-pairing" /* ADD_PAIRING */, this.handleAddPairing.bind(this));
        this._server.on("remove-pairing" /* REMOVE_PAIRING */, this.handleRemovePairing.bind(this));
        this._server.on("list-pairings" /* LIST_PAIRINGS */, this.handleListPairings.bind(this));
        this._server.on("accessories" /* ACCESSORIES */, this.handleAccessories.bind(this));
        this._server.on("get-characteristics" /* GET_CHARACTERISTICS */, this.handleGetCharacteristics.bind(this));
        this._server.on("set-characteristics" /* SET_CHARACTERISTICS */, this.handleSetCharacteristics.bind(this));
        this._server.on("connection-closed" /* CONNECTION_CLOSED */, this.handleHAPConnectionClosed.bind(this));
        this._server.on("request-resource" /* REQUEST_RESOURCE */, this.handleResource.bind(this));
        this._server.listen(info.port, parsed.serverAddress);
    };
    /**
     * Removes this Accessory from the local network
     * Accessory object will no longer valid after invoking this method
     * Trying to invoke publish() on the object will result undefined behavior
     */
    Accessory.prototype.destroy = function () {
        this.unpublish();
        if (this._accessoryInfo) {
            Accessory.cleanupAccessoryData(this._accessoryInfo.username);
            this._accessoryInfo = undefined;
            this._identifierCache = undefined;
            this.controllerStorage = new ControllerStorage_1.ControllerStorage(this);
        }
        this.removeAllListeners();
    };
    Accessory.prototype.unpublish = function () {
        if (this._server) {
            this._server.destroy();
            this._server = undefined;
        }
        if (this._advertiser) {
            // noinspection JSIgnoredPromiseFromCall
            this._advertiser.destroy();
            this._advertiser = undefined;
        }
    };
    Accessory.prototype.enqueueConfigurationUpdate = function () {
        var _this = this;
        if (this.configurationChangeDebounceTimeout) {
            return; // already enqueued
        }
        this.configurationChangeDebounceTimeout = setTimeout(function () {
            var _a;
            _this.configurationChangeDebounceTimeout = undefined;
            if (_this._advertiser && _this._advertiser) {
                // get our accessory information in HAP format and determine if our configuration (that is, our
                // Accessories/Services/Characteristics) has changed since the last time we were published. make
                // sure to omit actual values since these are not part of the "configuration".
                var config = _this.internalHAPRepresentation(); // TODO ensure this stuff is ordered
                if ((_a = _this._accessoryInfo) === null || _a === void 0 ? void 0 : _a.checkForCurrentConfigurationNumberIncrement(config)) {
                    _this._advertiser.updateAdvertisement();
                }
            }
        }, 1000);
        this.configurationChangeDebounceTimeout.unref();
        // 1d is fine, HomeKit is built that with configuration updates no iid or aid conflicts occur.
        // Thus the only thing happening when the txt update arrives late is already removed accessories/services
        // not responding or new accessories/services not yet shown
    };
    Accessory.prototype.onListening = function (port, hostname) {
        assert_1.default(this._advertiser, "Advertiser wasn't created at onListening!");
        // the HAP server is listening, so we can now start advertising our presence.
        this._advertiser.initPort(port);
        // noinspection JSIgnoredPromiseFromCall
        this._advertiser.startAdvertising();
        this.emit("listening" /* LISTENING */, port, hostname);
    };
    Accessory.prototype.handleInitialPairSetupFinished = function (username, publicKey, callback) {
        debug("[%s] Paired with client %s", this.displayName, username);
        this._accessoryInfo && this._accessoryInfo.addPairedClient(username, publicKey, 1 /* ADMIN */);
        this._accessoryInfo && this._accessoryInfo.save();
        // update our advertisement so it can pick up on the paired status of AccessoryInfo
        this._advertiser && this._advertiser.updateAdvertisement();
        callback();
        this.emit("paired" /* PAIRED */);
    };
    Accessory.prototype.handleAddPairing = function (connection, username, publicKey, permission, callback) {
        if (!this._accessoryInfo) {
            callback(6 /* UNAVAILABLE */);
            return;
        }
        if (!this._accessoryInfo.hasAdminPermissions(connection.username)) {
            callback(2 /* AUTHENTICATION */);
            return;
        }
        var existingKey = this._accessoryInfo.getClientPublicKey(username);
        if (existingKey) {
            if (existingKey.toString() !== publicKey.toString()) {
                callback(1 /* UNKNOWN */);
                return;
            }
            this._accessoryInfo.updatePermission(username, permission);
        }
        else {
            this._accessoryInfo.addPairedClient(username, publicKey, permission);
        }
        this._accessoryInfo.save();
        // there should be no need to update advertisement
        callback(0);
    };
    Accessory.prototype.handleRemovePairing = function (connection, username, callback) {
        var e_14, _a;
        if (!this._accessoryInfo) {
            callback(6 /* UNAVAILABLE */);
            return;
        }
        if (!this._accessoryInfo.hasAdminPermissions(connection.username)) {
            callback(2 /* AUTHENTICATION */);
            return;
        }
        this._accessoryInfo.removePairedClient(connection, username);
        this._accessoryInfo.save();
        callback(0); // first of all ensure the pairing is removed before we advertise availability again
        if (!this._accessoryInfo.paired()) {
            this._advertiser && this._advertiser.updateAdvertisement();
            this.emit("unpaired" /* UNPAIRED */);
            this.handleAccessoryUnpairedForControllers();
            try {
                for (var _b = tslib_1.__values(this.bridgedAccessories), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var accessory = _c.value;
                    accessory.handleAccessoryUnpairedForControllers();
                }
            }
            catch (e_14_1) { e_14 = { error: e_14_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_14) throw e_14.error; }
            }
        }
    };
    Accessory.prototype.handleListPairings = function (connection, callback) {
        if (!this._accessoryInfo) {
            callback(6 /* UNAVAILABLE */);
            return;
        }
        if (!this._accessoryInfo.hasAdminPermissions(connection.username)) {
            callback(2 /* AUTHENTICATION */);
            return;
        }
        callback(0, this._accessoryInfo.listPairings());
    };
    Accessory.prototype.handleAccessories = function (connection, callback) {
        var _this = this;
        this._assignIDs(this._identifierCache); // make sure our aid/iid's are all assigned
        var now = Date.now();
        var contactGetHandlers = now - this.lastAccessoriesRequest > 5000; // we query latest value if last /accessories was more than 5s ago
        this.lastAccessoriesRequest = now;
        this.toHAP(connection, contactGetHandlers).then(function (value) {
            callback(undefined, {
                accessories: value,
            });
        }, function (reason) {
            console.error("[" + _this.displayName + "] /accessories request error with: " + reason.stack);
            callback({ httpCode: 500 /* INTERNAL_SERVER_ERROR */, status: -70402 /* SERVICE_COMMUNICATION_FAILURE */ });
        });
    };
    Accessory.prototype.handleGetCharacteristics = function (connection, request, callback) {
        var e_15, _a;
        var _this = this;
        var characteristics = [];
        var response = { characteristics: characteristics };
        var missingCharacteristics = new Set(request.ids.map(function (id) { return id.aid + "." + id.iid; }));
        if (missingCharacteristics.size !== request.ids.length) {
            // if those sizes differ, we have duplicates and can't properly handle that
            callback({ httpCode: 422 /* UNPROCESSABLE_ENTITY */, status: -70410 /* INVALID_VALUE_IN_REQUEST */ });
            return;
        }
        var timeout = setTimeout(function () {
            var e_16, _a;
            try {
                for (var missingCharacteristics_1 = tslib_1.__values(missingCharacteristics), missingCharacteristics_1_1 = missingCharacteristics_1.next(); !missingCharacteristics_1_1.done; missingCharacteristics_1_1 = missingCharacteristics_1.next()) {
                    var id = missingCharacteristics_1_1.value;
                    var split = id.split(".");
                    var aid = parseInt(split[0], 10);
                    var iid = parseInt(split[1], 10);
                    var accessory = _this.getAccessoryByAID(aid);
                    var characteristic = accessory.getCharacteristicByIID(iid);
                    _this.sendCharacteristicWarning(characteristic, "slow-read" /* SLOW_READ */, "The read handler for the characteristic '" +
                        characteristic.displayName + "' on the accessory '" + accessory.displayName + "' was slow to respond!");
                }
            }
            catch (e_16_1) { e_16 = { error: e_16_1 }; }
            finally {
                try {
                    if (missingCharacteristics_1_1 && !missingCharacteristics_1_1.done && (_a = missingCharacteristics_1.return)) _a.call(missingCharacteristics_1);
                }
                finally { if (e_16) throw e_16.error; }
            }
            // after a total of 10s we do not longer wait for a request to appear and just return status code timeout
            timeout = setTimeout(function () {
                var e_17, _a;
                timeout = undefined;
                try {
                    for (var missingCharacteristics_2 = tslib_1.__values(missingCharacteristics), missingCharacteristics_2_1 = missingCharacteristics_2.next(); !missingCharacteristics_2_1.done; missingCharacteristics_2_1 = missingCharacteristics_2.next()) {
                        var id = missingCharacteristics_2_1.value;
                        var split = id.split(".");
                        var aid = parseInt(split[0], 10);
                        var iid = parseInt(split[1], 10);
                        var accessory = _this.getAccessoryByAID(aid);
                        var characteristic = accessory.getCharacteristicByIID(iid);
                        _this.sendCharacteristicWarning(characteristic, "timeout-read" /* TIMEOUT_READ */, "The read handler for the characteristic '" +
                            characteristic.displayName + "' on the accessory '" + accessory.displayName + "' didn't respond at all!. Please check that you properly call the callback!");
                        characteristics.push({
                            aid: aid,
                            iid: iid,
                            status: -70408 /* OPERATION_TIMED_OUT */,
                        });
                    }
                }
                catch (e_17_1) { e_17 = { error: e_17_1 }; }
                finally {
                    try {
                        if (missingCharacteristics_2_1 && !missingCharacteristics_2_1.done && (_a = missingCharacteristics_2.return)) _a.call(missingCharacteristics_2);
                    }
                    finally { if (e_17) throw e_17.error; }
                }
                missingCharacteristics.clear();
                callback(undefined, response);
            }, 6000);
            timeout.unref();
        }, 3000);
        timeout.unref();
        var _loop_1 = function (id) {
            var name = id.aid + "." + id.iid;
            this_1.handleCharacteristicRead(connection, id, request).then(function (value) {
                return tslib_1.__assign({ aid: id.aid, iid: id.iid }, value);
            }, function (reason) {
                console.error("[" + _this.displayName + "] Read request for characteristic " + name + " encountered an error: " + reason.stack);
                return {
                    aid: id.aid,
                    iid: id.iid,
                    status: -70402 /* SERVICE_COMMUNICATION_FAILURE */,
                };
            }).then(function (value) {
                if (!timeout) {
                    return; // if timeout is undefined, response was already sent out
                }
                missingCharacteristics.delete(name);
                characteristics.push(value);
                if (missingCharacteristics.size === 0) {
                    if (timeout) {
                        clearTimeout(timeout);
                        timeout = undefined;
                    }
                    callback(undefined, response);
                }
            });
        };
        var this_1 = this;
        try {
            for (var _b = tslib_1.__values(request.ids), _c = _b.next(); !_c.done; _c = _b.next()) {
                var id = _c.value;
                _loop_1(id);
            }
        }
        catch (e_15_1) { e_15 = { error: e_15_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_15) throw e_15.error; }
        }
    };
    Accessory.prototype.handleCharacteristicRead = function (connection, id, request) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var characteristic, verifiable;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                characteristic = this.findCharacteristic(id.aid, id.iid);
                if (!characteristic) {
                    debug('[%s] Could not find a Characteristic with aid of %s and iid of %s', this.displayName, id.aid, id.iid);
                    return [2 /*return*/, { status: -70410 /* INVALID_VALUE_IN_REQUEST */ }];
                }
                if (!characteristic.props.perms.includes("pr" /* PAIRED_READ */)) { // check if read is allowed for this characteristic
                    debug('[%s] Tried reading from characteristic which does not allow reading (aid of %s and iid of %s)', this.displayName, id.aid, id.iid);
                    return [2 /*return*/, { status: -70405 /* WRITE_ONLY_CHARACTERISTIC */ }];
                }
                if (characteristic.props.adminOnlyAccess && characteristic.props.adminOnlyAccess.includes(0 /* READ */)) {
                    verifiable = true;
                    if (!connection.username || !this._accessoryInfo) {
                        verifiable = false;
                        debug('[%s] Could not verify admin permissions for Characteristic which requires admin permissions for reading (aid of %s and iid of %s)', this.displayName, id.aid, id.iid);
                    }
                    if (!verifiable || !this._accessoryInfo.hasAdminPermissions(connection.username)) {
                        return [2 /*return*/, { status: -70401 /* INSUFFICIENT_PRIVILEGES */ }];
                    }
                }
                return [2 /*return*/, characteristic.handleGetRequest(connection).then(function (value) {
                        value = request_util_1.formatOutgoingCharacteristicValue(value, characteristic.props);
                        debug('[%s] Got Characteristic "%s" value: "%s"', _this.displayName, characteristic.displayName, value);
                        var data = {
                            value: value == undefined ? null : value,
                        };
                        if (request.includeMeta) {
                            data.format = characteristic.props.format;
                            data.unit = characteristic.props.unit;
                            data.minValue = characteristic.props.minValue;
                            data.maxValue = characteristic.props.maxValue;
                            data.minStep = characteristic.props.minStep;
                            data.maxLen = characteristic.props.maxLen || characteristic.props.maxDataLen;
                        }
                        if (request.includePerms) {
                            data.perms = characteristic.props.perms;
                        }
                        if (request.includeType) {
                            data.type = uuid_1.toShortForm(_this.UUID);
                        }
                        if (request.includeEvent) {
                            data.ev = connection.hasEventNotifications(id.aid, id.iid);
                        }
                        return data;
                    }, function (reason) {
                        // @ts-expect-error
                        debug('[%s] Error getting value for characteristic "%s": %s', _this.displayName, characteristic.displayName, HAPServer_1.HAPStatus[reason]);
                        return { status: reason };
                    })];
            });
        });
    };
    Accessory.prototype.handleSetCharacteristics = function (connection, writeRequest, callback) {
        var e_18, _a;
        var _this = this;
        debug("[%s] Processing characteristic set: %s", this.displayName, JSON.stringify(writeRequest));
        var writeState = 0 /* REGULAR_REQUEST */;
        if (writeRequest.pid !== undefined) { // check for timed writes
            if (connection.timedWritePid === writeRequest.pid) {
                writeState = 1 /* TIMED_WRITE_AUTHENTICATED */;
                clearTimeout(connection.timedWriteTimeout);
                connection.timedWritePid = undefined;
                connection.timedWriteTimeout = undefined;
                debug("[%s] Timed write request got acknowledged for pid %d", this.displayName, writeRequest.pid);
            }
            else {
                writeState = 2 /* TIMED_WRITE_REJECTED */;
                debug("[%s] TTL for timed write request has probably expired for pid %d", this.displayName, writeRequest.pid);
            }
        }
        var characteristics = [];
        var response = { characteristics: characteristics };
        var missingCharacteristics = new Set(writeRequest.characteristics
            .map(function (characteristic) { return characteristic.aid + "." + characteristic.iid; }));
        if (missingCharacteristics.size !== writeRequest.characteristics.length) {
            // if those sizes differ, we have duplicates and can't properly handle that
            callback({ httpCode: 422 /* UNPROCESSABLE_ENTITY */, status: -70410 /* INVALID_VALUE_IN_REQUEST */ });
            return;
        }
        var timeout = setTimeout(function () {
            var e_19, _a;
            try {
                for (var missingCharacteristics_3 = tslib_1.__values(missingCharacteristics), missingCharacteristics_3_1 = missingCharacteristics_3.next(); !missingCharacteristics_3_1.done; missingCharacteristics_3_1 = missingCharacteristics_3.next()) {
                    var id = missingCharacteristics_3_1.value;
                    var split = id.split(".");
                    var aid = parseInt(split[0], 10);
                    var iid = parseInt(split[1], 10);
                    var accessory = _this.getAccessoryByAID(aid);
                    var characteristic = accessory.getCharacteristicByIID(iid);
                    _this.sendCharacteristicWarning(characteristic, "slow-write" /* SLOW_WRITE */, "The write handler for the characteristic '" +
                        characteristic.displayName + "' on the accessory '" + accessory.displayName + "' was slow to respond!");
                }
            }
            catch (e_19_1) { e_19 = { error: e_19_1 }; }
            finally {
                try {
                    if (missingCharacteristics_3_1 && !missingCharacteristics_3_1.done && (_a = missingCharacteristics_3.return)) _a.call(missingCharacteristics_3);
                }
                finally { if (e_19) throw e_19.error; }
            }
            // after a total of 10s we do not longer wait for a request to appear and just return status code timeout
            timeout = setTimeout(function () {
                var e_20, _a;
                timeout = undefined;
                try {
                    for (var missingCharacteristics_4 = tslib_1.__values(missingCharacteristics), missingCharacteristics_4_1 = missingCharacteristics_4.next(); !missingCharacteristics_4_1.done; missingCharacteristics_4_1 = missingCharacteristics_4.next()) {
                        var id = missingCharacteristics_4_1.value;
                        var split = id.split(".");
                        var aid = parseInt(split[0], 10);
                        var iid = parseInt(split[1], 10);
                        var accessory = _this.getAccessoryByAID(aid);
                        var characteristic = accessory.getCharacteristicByIID(iid);
                        _this.sendCharacteristicWarning(characteristic, "timeout-write" /* TIMEOUT_WRITE */, "The write handler for the characteristic '" +
                            characteristic.displayName + "' on the accessory '" + accessory.displayName + "' didn't respond at all!. Please check that you properly call the callback!");
                        characteristics.push({
                            aid: aid,
                            iid: iid,
                            status: -70408 /* OPERATION_TIMED_OUT */,
                        });
                    }
                }
                catch (e_20_1) { e_20 = { error: e_20_1 }; }
                finally {
                    try {
                        if (missingCharacteristics_4_1 && !missingCharacteristics_4_1.done && (_a = missingCharacteristics_4.return)) _a.call(missingCharacteristics_4);
                    }
                    finally { if (e_20) throw e_20.error; }
                }
                missingCharacteristics.clear();
                callback(undefined, response);
            }, 6000);
            timeout.unref();
        }, 3000);
        timeout.unref();
        var _loop_2 = function (data) {
            var name = data.aid + "." + data.iid;
            this_2.handleCharacteristicWrite(connection, data, writeState).then(function (value) {
                return tslib_1.__assign({ aid: data.aid, iid: data.iid }, value);
            }, function (reason) {
                console.error("[" + _this.displayName + "] Write request for characteristic " + name + " encountered an error: " + reason.stack);
                return {
                    aid: data.aid,
                    iid: data.iid,
                    status: -70402 /* SERVICE_COMMUNICATION_FAILURE */,
                };
            }).then(function (value) {
                if (!timeout) {
                    return; // if timeout is undefined, response was already sent out
                }
                missingCharacteristics.delete(name);
                characteristics.push(value);
                if (missingCharacteristics.size === 0) { // if everything returned send the response
                    if (timeout) {
                        clearTimeout(timeout);
                        timeout = undefined;
                    }
                    callback(undefined, response);
                }
            });
        };
        var this_2 = this;
        try {
            for (var _b = tslib_1.__values(writeRequest.characteristics), _c = _b.next(); !_c.done; _c = _b.next()) {
                var data = _c.value;
                _loop_2(data);
            }
        }
        catch (e_18_1) { e_18 = { error: e_18_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_18) throw e_18.error; }
        }
    };
    Accessory.prototype.handleCharacteristicWrite = function (connection, data, writeState) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var characteristic, evResponse, notificationsEnabled, verifiable, verifiable, allowWrite;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                characteristic = this.findCharacteristic(data.aid, data.iid);
                evResponse = undefined;
                if (!characteristic) {
                    debug('[%s] Could not find a Characteristic with aid of %s and iid of %s', this.displayName, data.aid, data.iid);
                    return [2 /*return*/, { status: -70410 /* INVALID_VALUE_IN_REQUEST */ }];
                }
                if (writeState === 2 /* TIMED_WRITE_REJECTED */) {
                    return [2 /*return*/, { status: -70410 /* INVALID_VALUE_IN_REQUEST */ }];
                }
                if (data.ev != undefined) { // register/unregister event notifications
                    notificationsEnabled = connection.hasEventNotifications(data.aid, data.iid);
                    // it seems like the Home App sends unregister requests for characteristics which don't have notify permissions
                    // see https://github.com/homebridge/HAP-NodeJS/issues/868
                    if (notificationsEnabled != data.ev) {
                        if (!characteristic.props.perms.includes("ev" /* NOTIFY */)) { // check if notify is allowed for this characteristic
                            debug('[%s] Tried %s notifications for Characteristic which does not allow notify (aid of %s and iid of %s)', this.displayName, data.ev ? "enabling" : "disabling", data.aid, data.iid);
                            return [2 /*return*/, { status: -70406 /* NOTIFICATION_NOT_SUPPORTED */ }];
                        }
                        if (characteristic.props.adminOnlyAccess && characteristic.props.adminOnlyAccess.includes(2 /* NOTIFY */)) {
                            verifiable = true;
                            if (!connection.username || !this._accessoryInfo) {
                                verifiable = false;
                                debug('[%s] Could not verify admin permissions for Characteristic which requires admin permissions for notify (aid of %s and iid of %s)', this.displayName, data.aid, data.iid);
                            }
                            if (!verifiable || !this._accessoryInfo.hasAdminPermissions(connection.username)) {
                                return [2 /*return*/, { status: -70401 /* INSUFFICIENT_PRIVILEGES */ }];
                            }
                        }
                        // we already checked that data.ev != notificationsEnabled, thus just do whatever the connection asks for
                        if (data.ev) {
                            connection.enableEventNotifications(data.aid, data.iid);
                            characteristic.subscribe();
                            evResponse = true;
                            debug('[%s] Registered Characteristic "%s" on "%s" for events', connection.remoteAddress, characteristic.displayName, this.displayName);
                        }
                        else {
                            characteristic.unsubscribe();
                            connection.disableEventNotifications(data.aid, data.iid);
                            evResponse = false;
                            debug('[%s] Unregistered Characteristic "%s" on "%s" for events', connection.remoteAddress, characteristic.displayName, this.displayName);
                        }
                    }
                    // response is returned below in the else block
                }
                if (data.value != undefined) {
                    if (!characteristic.props.perms.includes("pw" /* PAIRED_WRITE */)) { // check if write is allowed for this characteristic
                        debug('[%s] Tried writing to Characteristic which does not allow writing (aid of %s and iid of %s)', this.displayName, data.aid, data.iid);
                        return [2 /*return*/, { status: -70404 /* READ_ONLY_CHARACTERISTIC */ }];
                    }
                    if (characteristic.props.adminOnlyAccess && characteristic.props.adminOnlyAccess.includes(1 /* WRITE */)) {
                        verifiable = true;
                        if (!connection.username || !this._accessoryInfo) {
                            verifiable = false;
                            debug('[%s] Could not verify admin permissions for Characteristic which requires admin permissions for write (aid of %s and iid of %s)', this.displayName, data.aid, data.iid);
                        }
                        if (!verifiable || !this._accessoryInfo.hasAdminPermissions(connection.username)) {
                            return [2 /*return*/, { status: -70401 /* INSUFFICIENT_PRIVILEGES */ }];
                        }
                    }
                    if (characteristic.props.perms.includes("aa" /* ADDITIONAL_AUTHORIZATION */) && characteristic.additionalAuthorizationHandler) {
                        allowWrite = void 0;
                        try {
                            allowWrite = characteristic.additionalAuthorizationHandler(data.authData);
                        }
                        catch (error) {
                            console.log("[" + this.displayName + "] Additional authorization handler has thrown an error when checking authData: " + error.stack);
                            allowWrite = false;
                        }
                        if (!allowWrite) {
                            return [2 /*return*/, { status: -70411 /* INSUFFICIENT_AUTHORIZATION */ }];
                        }
                    }
                    if (characteristic.props.perms.includes("tw" /* TIMED_WRITE */) && writeState !== 1 /* TIMED_WRITE_AUTHENTICATED */) {
                        debug('[%s] Tried writing to a timed write only Characteristic without properly preparing (iid of %s and aid of %s)', this.displayName, data.aid, data.iid);
                        return [2 /*return*/, { status: -70410 /* INVALID_VALUE_IN_REQUEST */ }];
                    }
                    return [2 /*return*/, characteristic.handleSetRequest(data.value, connection).then(function (value) {
                            debug('[%s] Setting Characteristic "%s" to value %s', _this.displayName, characteristic.displayName, data.value);
                            return {
                                value: data.r && value ? request_util_1.formatOutgoingCharacteristicValue(value, characteristic.props) : undefined,
                                ev: evResponse,
                            };
                        }, function (status) {
                            // @ts-expect-error
                            debug('[%s] Error setting Characteristic "%s" to value %s: ', _this.displayName, characteristic.displayName, data.value, HAPServer_1.HAPStatus[status]);
                            return { status: status };
                        })];
                }
                else {
                    return [2 /*return*/, { ev: evResponse }];
                }
                return [2 /*return*/];
            });
        });
    };
    Accessory.prototype.handleResource = function (data, callback) {
        var _a;
        if (data["resource-type"] === "image" /* IMAGE */) {
            var aid = data.aid; // aid is optionally supplied by HomeKit (for example when camera is bridged, multiple cams, etc)
            var accessory = undefined;
            var controller = undefined;
            if (aid) {
                accessory = this.getAccessoryByAID(aid);
                if (accessory && accessory.activeCameraController) {
                    controller = accessory.activeCameraController;
                }
            }
            else if (this.activeCameraController) { // aid was not supplied, check if this accessory is a camera
                accessory = this;
                controller = this.activeCameraController;
            }
            if (!controller) {
                debug("[%s] received snapshot request though no camera controller was associated!");
                callback({ httpCode: 404 /* NOT_FOUND */, status: -70409 /* RESOURCE_DOES_NOT_EXIST */ });
                return;
            }
            controller.handleSnapshotRequest(data["image-height"], data["image-width"], accessory === null || accessory === void 0 ? void 0 : accessory.displayName).then(function (buffer) {
                callback(undefined, buffer);
            }, function (status) {
                callback({ httpCode: 200 /* OK */, status: status });
            });
            return;
        }
        debug("[%s] received request for unsupported image type: " + data["resource-type"], (_a = this._accessoryInfo) === null || _a === void 0 ? void 0 : _a.username);
        callback({ httpCode: 404 /* NOT_FOUND */, status: -70409 /* RESOURCE_DOES_NOT_EXIST */ });
    };
    Accessory.prototype.handleHAPConnectionClosed = function (connection) {
        var e_21, _a;
        if (this.activeCameraController) {
            this.activeCameraController.handleCloseConnection(connection.sessionID);
        }
        try {
            for (var _b = tslib_1.__values(connection.getRegisteredEvents()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var event = _c.value;
                var ids = event.split(".");
                var aid = parseInt(ids[0], 10);
                var iid = parseInt(ids[1], 10);
                var characteristic = this.findCharacteristic(aid, iid);
                if (characteristic) {
                    characteristic.unsubscribe();
                }
            }
        }
        catch (e_21_1) { e_21 = { error: e_21_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_21) throw e_21.error; }
        }
        connection.clearRegisteredEvents();
    };
    Accessory.prototype.handleServiceConfigurationChangeEvent = function (service) {
        if (!service.isPrimaryService && service === this.primaryService) {
            // service changed form primary to non primary service
            this.primaryService = undefined;
        }
        else if (service.isPrimaryService && service !== this.primaryService) {
            // service changed from non primary to primary service
            if (this.primaryService !== undefined) {
                this.primaryService.isPrimaryService = false;
            }
            this.primaryService = service;
        }
        if (this.bridged) {
            this.emit("service-configurationChange" /* SERVICE_CONFIGURATION_CHANGE */, { service: service });
        }
        else {
            this.enqueueConfigurationUpdate();
        }
    };
    Accessory.prototype.handleCharacteristicChangeEvent = function (accessory, service, change) {
        if (this.bridged) { // forward this to our main accessory
            this.emit("service-characteristic-change" /* SERVICE_CHARACTERISTIC_CHANGE */, tslib_1.__assign(tslib_1.__assign({}, change), { service: service }));
        }
        else {
            if (!this._server) {
                return; // we're not running a HAPServer, so there's no one to notify about this event
            }
            if (accessory.aid == undefined || change.characteristic.iid == undefined) {
                debug("[%s] Muting event notification for %s as ids aren't yet assigned!", accessory.displayName, change.characteristic.displayName);
                return;
            }
            if (change.context != undefined && typeof change.context === "object" && change.context.omitEventUpdate) {
                debug("[%s] Omitting event updates for %s as specified in the context object!", accessory.displayName, change.characteristic.displayName);
                return;
            }
            if (!(change.reason === "event" /* EVENT */ || change.oldValue !== change.newValue
                || change.characteristic.UUID === Characteristic_1.Characteristic.ProgrammableSwitchEvent.UUID // those specific checks are out of backwards compatibility
                || change.characteristic.UUID === Characteristic_1.Characteristic.ButtonEvent.UUID // new characteristics should use sendEventNotification call
            )) {
                // we only emit a change event if the reason was a call to sendEventNotification, if the value changed
                // as of a write request or a read request or if the change happened on dedicated event characteristics
                // otherwise we ignore this change event (with the return below)
                return;
            }
            var uuid_2 = change.characteristic.UUID;
            var immediateDelivery = uuid_2 === Characteristic_1.Characteristic.ButtonEvent.UUID || uuid_2 === Characteristic_1.Characteristic.ProgrammableSwitchEvent.UUID
                || uuid_2 === Characteristic_1.Characteristic.MotionDetected.UUID || uuid_2 === Characteristic_1.Characteristic.ContactSensorState.UUID;
            var value = request_util_1.formatOutgoingCharacteristicValue(change.newValue, change.characteristic.props);
            this._server.sendEventNotifications(accessory.aid, change.characteristic.iid, value, change.originator, immediateDelivery);
        }
    };
    Accessory.prototype.sendCharacteristicWarning = function (characteristic, type, message) {
        this.handleCharacteristicWarning({
            characteristic: characteristic,
            type: type,
            message: message,
            originatorChain: [characteristic.displayName],
            stack: new Error().stack,
        });
    };
    Accessory.prototype.handleCharacteristicWarning = function (warning) {
        var _a;
        warning.originatorChain = tslib_1.__spread([this.displayName], warning.originatorChain);
        var emitted = this.emit("characteristic-warning" /* CHARACTERISTIC_WARNING */, warning);
        if (!emitted) {
            var message = "[" + warning.originatorChain.join("@") + "] " + warning.message;
            if (warning.type === "error-message" /* ERROR_MESSAGE */
                || warning.type === "timeout-read" /* TIMEOUT_READ */ || warning.type === "timeout-write" /* TIMEOUT_WRITE */) {
                console.error(message);
            }
            else {
                console.warn(message);
            }
            debug("[%s] Above characteristic warning was thrown at: %s", this.displayName, (_a = warning.stack) !== null && _a !== void 0 ? _a : "unknown");
        }
    };
    Accessory.prototype.setupServiceEventHandlers = function (service) {
        service.on("service-configurationChange" /* SERVICE_CONFIGURATION_CHANGE */, this.handleServiceConfigurationChangeEvent.bind(this, service));
        service.on("characteristic-change" /* CHARACTERISTIC_CHANGE */, this.handleCharacteristicChangeEvent.bind(this, this, service));
        service.on("characteristic-warning" /* CHARACTERISTIC_WARNING */, this.handleCharacteristicWarning.bind(this));
    };
    Accessory.prototype._sideloadServices = function (targetServices) {
        var e_22, _a;
        var _this = this;
        try {
            for (var targetServices_1 = tslib_1.__values(targetServices), targetServices_1_1 = targetServices_1.next(); !targetServices_1_1.done; targetServices_1_1 = targetServices_1.next()) {
                var service = targetServices_1_1.value;
                this.setupServiceEventHandlers(service);
            }
        }
        catch (e_22_1) { e_22 = { error: e_22_1 }; }
        finally {
            try {
                if (targetServices_1_1 && !targetServices_1_1.done && (_a = targetServices_1.return)) _a.call(targetServices_1);
            }
            finally { if (e_22) throw e_22.error; }
        }
        this.services = targetServices.slice();
        // Fix Identify
        this
            .getService(Service_1.Service.AccessoryInformation)
            .getCharacteristic(Characteristic_1.Characteristic.Identify)
            .on("set" /* SET */, function (value, callback) {
            if (value) {
                var paired = true;
                _this.identificationRequest(paired, callback);
            }
        });
    };
    Accessory._generateSetupID = function () {
        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        var max = chars.length;
        var setupID = '';
        for (var i = 0; i < 4; i++) {
            var index = Math.floor(Math.random() * max);
            setupID += chars.charAt(index);
        }
        return setupID;
    };
    // serialization and deserialization functions, mainly designed for homebridge to create a json copy to store on disk
    Accessory.serialize = function (accessory) {
        var json = {
            displayName: accessory.displayName,
            UUID: accessory.UUID,
            lastKnownUsername: accessory._accessoryInfo ? accessory._accessoryInfo.username : undefined,
            category: accessory.category,
            services: [],
        };
        var linkedServices = {};
        var hasLinkedServices = false;
        accessory.services.forEach(function (service) {
            json.services.push(Service_1.Service.serialize(service));
            var linkedServicesPresentation = [];
            service.linkedServices.forEach(function (linkedService) {
                linkedServicesPresentation.push(linkedService.getServiceId());
            });
            if (linkedServicesPresentation.length > 0) {
                linkedServices[service.getServiceId()] = linkedServicesPresentation;
                hasLinkedServices = true;
            }
        });
        if (hasLinkedServices) {
            json.linkedServices = linkedServices;
        }
        var controllers = [];
        // save controllers
        Object.values(accessory.controllers).forEach(function (context) {
            controllers.push({
                type: context.controller.controllerId(),
                services: Accessory.serializeServiceMap(context.serviceMap),
            });
        });
        // also save controller which didn't get initialized (could lead to service duplication if we throw that data away)
        accessory.serializedControllers && Object.entries(accessory.serializedControllers).forEach(function (_a) {
            var _b = tslib_1.__read(_a, 2), id = _b[0], serviceMap = _b[1];
            controllers.push({
                type: id,
                services: Accessory.serializeServiceMap(serviceMap),
            });
        });
        if (controllers.length > 0) {
            json.controllers = controllers;
        }
        return json;
    };
    Accessory.deserialize = function (json) {
        var e_23, _a;
        var accessory = new Accessory(json.displayName, json.UUID);
        accessory.lastKnownUsername = json.lastKnownUsername;
        accessory.category = json.category;
        var services = [];
        var servicesMap = {};
        json.services.forEach(function (serialized) {
            var service = Service_1.Service.deserialize(serialized);
            services.push(service);
            servicesMap[service.getServiceId()] = service;
        });
        if (json.linkedServices) {
            var _loop_3 = function (serviceId, linkedServicesKeys) {
                var primaryService = servicesMap[serviceId];
                if (!primaryService) {
                    return "continue";
                }
                linkedServicesKeys.forEach(function (linkedServiceKey) {
                    var linkedService = servicesMap[linkedServiceKey];
                    if (linkedService) {
                        primaryService.addLinkedService(linkedService);
                    }
                });
            };
            try {
                for (var _b = tslib_1.__values(Object.entries(json.linkedServices)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = tslib_1.__read(_c.value, 2), serviceId = _d[0], linkedServicesKeys = _d[1];
                    _loop_3(serviceId, linkedServicesKeys);
                }
            }
            catch (e_23_1) { e_23 = { error: e_23_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_23) throw e_23.error; }
            }
        }
        if (json.controllers) { // just save it for later if it exists {@see configureController}
            accessory.serializedControllers = {};
            json.controllers.forEach(function (serializedController) {
                accessory.serializedControllers[serializedController.type] = Accessory.deserializeServiceMap(serializedController.services, servicesMap);
            });
        }
        accessory._sideloadServices(services);
        return accessory;
    };
    Accessory.cleanupAccessoryData = function (username) {
        IdentifierCache_1.IdentifierCache.remove(username);
        AccessoryInfo_1.AccessoryInfo.remove(username);
        ControllerStorage_1.ControllerStorage.remove(username);
    };
    Accessory.serializeServiceMap = function (serviceMap) {
        var serialized = {};
        Object.entries(serviceMap).forEach(function (_a) {
            var _b = tslib_1.__read(_a, 2), name = _b[0], service = _b[1];
            if (!service) {
                return;
            }
            serialized[name] = service.getServiceId();
        });
        return serialized;
    };
    Accessory.deserializeServiceMap = function (serializedServiceMap, servicesMap) {
        var controllerServiceMap = {};
        Object.entries(serializedServiceMap).forEach(function (_a) {
            var _b = tslib_1.__read(_a, 2), name = _b[0], serviceId = _b[1];
            var service = servicesMap[serviceId];
            if (service) {
                controllerServiceMap[name] = service;
            }
        });
        return controllerServiceMap;
    };
    Accessory.parseBindOption = function (info) {
        var e_24, _a;
        var advertiserAddress = undefined;
        var disableIpv6 = false;
        var serverAddress = undefined;
        if (info.bind) {
            var entries = new Set(Array.isArray(info.bind) ? info.bind : [info.bind]);
            if (entries.has("::")) {
                serverAddress = "::";
                entries.delete("::");
                if (entries.size) {
                    advertiserAddress = Array.from(entries);
                }
            }
            else if (entries.has("0.0.0.0")) {
                disableIpv6 = true;
                serverAddress = "0.0.0.0";
                entries.delete("0.0.0.0");
                if (entries.size) {
                    advertiserAddress = Array.from(entries);
                }
            }
            else if (entries.size === 1) {
                advertiserAddress = Array.from(entries);
                var entry = entries.values().next().value; // grab the first one
                var version = net_1.default.isIP(entry); // check if ip address was specified or a interface name
                if (version) {
                    serverAddress = version === 4 ? "0.0.0.0" : "::"; // we currently bind to unspecified addresses so config-ui always has a connection via loopback
                }
                else {
                    serverAddress = "::"; // the interface could have both ipv4 and ipv6 addresses
                }
            }
            else if (entries.size > 1) {
                advertiserAddress = Array.from(entries);
                var bindUnspecifiedIpv6 = false; // we bind on "::" if there are interface names, or we detect ipv6 addresses
                try {
                    for (var entries_1 = tslib_1.__values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
                        var entry = entries_1_1.value;
                        var version = net_1.default.isIP(entry);
                        if (version === 0 || version === 6) {
                            bindUnspecifiedIpv6 = true;
                            break;
                        }
                    }
                }
                catch (e_24_1) { e_24 = { error: e_24_1 }; }
                finally {
                    try {
                        if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return)) _a.call(entries_1);
                    }
                    finally { if (e_24) throw e_24.error; }
                }
                if (bindUnspecifiedIpv6) {
                    serverAddress = "::";
                }
                else {
                    serverAddress = "0.0.0.0";
                }
            }
        }
        return {
            advertiserAddress: advertiserAddress,
            serviceRestrictedAddress: advertiserAddress,
            serviceDisableIpv6: disableIpv6,
            serverAddress: serverAddress,
        };
    };
    /**
     * @deprecated Please use the Categories const enum above. Scheduled to be removed in 2021-06.
     */
    // @ts-ignore
    Accessory.Categories = Categories;
    return Accessory;
}(events_1.EventEmitter));
exports.Accessory = Accessory;
//# sourceMappingURL=Accessory.js.map

/***/ }),

/***/ 1004:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseCharacteristicJSON = exports.parseServiceJSON = exports.parseAccessoryJSON = exports.loadDirectory = void 0;
var tslib_1 = __nccwpck_require__(4290);
var debug_1 = tslib_1.__importDefault(__nccwpck_require__(7984));
var fs_1 = tslib_1.__importDefault(__nccwpck_require__(5747));
var path_1 = tslib_1.__importDefault(__nccwpck_require__(5622));
var Accessory_1 = __nccwpck_require__(7430);
var Characteristic_1 = __nccwpck_require__(3859);
var Service_1 = __nccwpck_require__(7383);
var uuid = tslib_1.__importStar(__nccwpck_require__(6814));
var debug = debug_1.default('HAP-NodeJS:AccessoryLoader');
/**
 * Loads all accessories from the given folder. Handles object-literal-style accessories, "accessory factories",
 * and new-API style modules.
 */
function loadDirectory(dir) {
    // exported accessory objects loaded from this dir
    var accessories = [];
    fs_1.default.readdirSync(dir).forEach(function (file) {
        var suffix = file.split('_').pop();
        // "Accessories" are modules that export a single accessory.
        if (suffix === 'accessory.js' || suffix === 'accessory.ts') {
            debug('Parsing accessory: %s', file);
            var loadedAccessory = require(path_1.default.join(dir, file)).accessory;
            accessories.push(loadedAccessory);
        }
        // "Accessory Factories" are modules that export an array of accessories.
        else if (suffix === 'accfactory.js' || suffix === 'accfactory.ts') {
            debug('Parsing accessory factory: %s', file);
            // should return an array of objects { accessory: accessory-json }
            var loadedAccessories = require(path_1.default.join(dir, file));
            accessories = accessories.concat(loadedAccessories);
        }
    });
    // now we need to coerce all accessory objects into instances of Accessory (some or all of them may
    // be object-literal JSON-style accessories)
    return accessories.map(function (accessory) {
        if (accessory === null || accessory === undefined) { //check if accessory is not empty
            console.log("Invalid accessory!");
            return false;
        }
        else {
            return (accessory instanceof Accessory_1.Accessory) ? accessory : parseAccessoryJSON(accessory);
        }
    }).filter(function (accessory) { return !!accessory; });
}
exports.loadDirectory = loadDirectory;
/**
 * Accepts object-literal JSON structures from previous versions of HAP-NodeJS and parses them into
 * newer-style structures of Accessory/Service/Characteristic objects.
 */
function parseAccessoryJSON(json) {
    // parse services first so we can extract the accessory name
    var services = [];
    json.services.forEach(function (serviceJSON) {
        var service = parseServiceJSON(serviceJSON);
        services.push(service);
    });
    var displayName = json.displayName;
    services.forEach(function (service) {
        if (service.UUID === '0000003E-0000-1000-8000-0026BB765291') { // Service.AccessoryInformation.UUID
            service.characteristics.forEach(function (characteristic) {
                if (characteristic.UUID === '00000023-0000-1000-8000-0026BB765291') { // Characteristic.Name.UUID
                    displayName = characteristic.value;
                }
            });
        }
    });
    var accessory = new Accessory_1.Accessory(displayName, uuid.generate(displayName));
    // create custom properties for "username" and "pincode" for Core.js to find later (if using Core.js)
    // @ts-ignore
    accessory.username = json.username;
    // @ts-ignore
    accessory.pincode = json.pincode;
    // clear out the default services
    accessory.services.length = 0;
    // add services
    services.forEach(function (service) {
        accessory.addService(service);
    });
    return accessory;
}
exports.parseAccessoryJSON = parseAccessoryJSON;
function parseServiceJSON(json) {
    var serviceUUID = json.sType;
    // build characteristics first so we can extract the Name (if present)
    var characteristics = [];
    json.characteristics.forEach(function (characteristicJSON) {
        var characteristic = parseCharacteristicJSON(characteristicJSON);
        characteristics.push(characteristic);
    });
    var displayName = null;
    // extract the "Name" characteristic to use for 'type' discrimination if necessary
    characteristics.forEach(function (characteristic) {
        if (characteristic.UUID == '00000023-0000-1000-8000-0026BB765291') // Characteristic.Name.UUID
            displayName = characteristic.value;
    });
    // Use UUID for "displayName" if necessary, as the JSON structures don't have a value for this
    var service = new Service_1.Service(displayName || serviceUUID, serviceUUID, "" + displayName);
    characteristics.forEach(function (characteristic) {
        if (characteristic.UUID != '00000023-0000-1000-8000-0026BB765291') // Characteristic.Name.UUID, already present in all Services
            service.addCharacteristic(characteristic);
    });
    return service;
}
exports.parseServiceJSON = parseServiceJSON;
function parseCharacteristicJSON(json) {
    var characteristicUUID = json.cType;
    var characteristic = new Characteristic_1.Characteristic(json.manfDescription || characteristicUUID, characteristicUUID, {
        format: json.format,
        minValue: json.designedMinValue,
        maxValue: json.designedMaxValue,
        minStep: json.designedMinStep,
        unit: json.unit,
        perms: json.perms // example: ["pw","pr","ev"]
    });
    // copy simple properties
    characteristic.value = json.initialValue;
    // monkey-patch legacy "locals" property which used to exist.
    // @ts-ignore
    characteristic.locals = json.locals;
    var updateFunc = json.onUpdate; // optional function(value)
    var readFunc = json.onRead; // optional function(callback(value))
    var registerFunc = json.onRegister; // optional function
    if (updateFunc) {
        characteristic.on("set" /* SET */, function (value, callback) {
            updateFunc(value);
            callback && callback();
        });
    }
    if (readFunc) {
        characteristic.on("get" /* GET */, function (callback) {
            readFunc(function (value) {
                callback(null, value); // old onRead callbacks don't use Error as first param
            });
        });
    }
    if (registerFunc) {
        registerFunc(characteristic);
    }
    return characteristic;
}
exports.parseCharacteristicJSON = parseCharacteristicJSON;
//# sourceMappingURL=AccessoryLoader.js.map

/***/ }),

/***/ 6779:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BonjourHAPAdvertiser = exports.CiaoAdvertiser = exports.AdvertiserEvent = exports.PairingFeatureFlag = exports.StatusFlag = void 0;
var tslib_1 = __nccwpck_require__(4290);
/// <reference path="../../@types/bonjour-hap.d.ts" />
var ciao_1 = tslib_1.__importDefault(__nccwpck_require__(8381));
var assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
var bonjour_hap_1 = tslib_1.__importDefault(__nccwpck_require__(8227));
var crypto_1 = tslib_1.__importDefault(__nccwpck_require__(6417));
var events_1 = __nccwpck_require__(8614);
/**
 * This enum lists all bitmasks for all known status flags.
 * When the bit for the given bitmask is set, it represents the state described by the name.
 */
var StatusFlag;
(function (StatusFlag) {
    StatusFlag[StatusFlag["NOT_PAIRED"] = 1] = "NOT_PAIRED";
    StatusFlag[StatusFlag["NOT_JOINED_WIFI"] = 2] = "NOT_JOINED_WIFI";
    StatusFlag[StatusFlag["PROBLEM_DETECTED"] = 4] = "PROBLEM_DETECTED";
})(StatusFlag = exports.StatusFlag || (exports.StatusFlag = {}));
/**
 * This enum lists all bitmasks for all known pairing feature flags.
 * When the bit for the given bitmask is set, it represents the state described by the name.
 */
var PairingFeatureFlag;
(function (PairingFeatureFlag) {
    PairingFeatureFlag[PairingFeatureFlag["SUPPORTS_HARDWARE_AUTHENTICATION"] = 1] = "SUPPORTS_HARDWARE_AUTHENTICATION";
    PairingFeatureFlag[PairingFeatureFlag["SUPPORTS_SOFTWARE_AUTHENTICATION"] = 2] = "SUPPORTS_SOFTWARE_AUTHENTICATION";
})(PairingFeatureFlag = exports.PairingFeatureFlag || (exports.PairingFeatureFlag = {}));
var AdvertiserEvent;
(function (AdvertiserEvent) {
    AdvertiserEvent["UPDATED_NAME"] = "updated-name";
})(AdvertiserEvent = exports.AdvertiserEvent || (exports.AdvertiserEvent = {}));
/**
 * Advertiser uses mdns to broadcast the presence of an Accessory to the local network.
 *
 * Note that as of iOS 9, an accessory can only pair with a single client. Instead of pairing your
 * accessories with multiple iOS devices in your home, Apple intends for you to use Home Sharing.
 * To support this requirement, we provide the ability to be "discoverable" or not (via a "service flag" on the
 * mdns payload).
 */
var CiaoAdvertiser = /** @class */ (function (_super) {
    tslib_1.__extends(CiaoAdvertiser, _super);
    function CiaoAdvertiser(accessoryInfo, responderOptions, serviceOptions) {
        var _this = _super.call(this) || this;
        _this.accessoryInfo = accessoryInfo;
        _this.setupHash = CiaoAdvertiser.computeSetupHash(accessoryInfo);
        _this.responder = ciao_1.default.getResponder(tslib_1.__assign({}, responderOptions));
        _this.advertisedService = _this.responder.createService(tslib_1.__assign({ name: _this.accessoryInfo.displayName, type: "hap" /* HAP */, txt: CiaoAdvertiser.createTxt(accessoryInfo, _this.setupHash) }, serviceOptions));
        _this.advertisedService.on("name-change" /* NAME_CHANGED */, _this.emit.bind(_this, "updated-name" /* UPDATED_NAME */));
        console.log("Preparing Advertiser for '" + _this.accessoryInfo.displayName + "' using ciao backend!");
        return _this;
    }
    CiaoAdvertiser.prototype.initPort = function (port) {
        this.advertisedService.updatePort(port);
    };
    CiaoAdvertiser.prototype.startAdvertising = function () {
        console.log("Starting to advertise '" + this.accessoryInfo.displayName + "' using ciao backend!");
        return this.advertisedService.advertise();
    };
    CiaoAdvertiser.prototype.updateAdvertisement = function (silent) {
        this.advertisedService.updateTxt(CiaoAdvertiser.createTxt(this.accessoryInfo, this.setupHash), silent);
    };
    CiaoAdvertiser.prototype.destroy = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.advertisedService.destroy()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.responder.shutdown()];
                    case 2:
                        _a.sent();
                        this.removeAllListeners();
                        return [2 /*return*/];
                }
            });
        });
    };
    CiaoAdvertiser.createTxt = function (accessoryInfo, setupHash) {
        var statusFlags = [];
        if (!accessoryInfo.paired()) {
            statusFlags.push(1 /* NOT_PAIRED */);
        }
        return {
            "c#": accessoryInfo.getConfigVersion(),
            ff: CiaoAdvertiser.ff(),
            id: accessoryInfo.username,
            md: accessoryInfo.model,
            pv: CiaoAdvertiser.protocolVersion,
            "s#": 1,
            sf: CiaoAdvertiser.sf.apply(CiaoAdvertiser, tslib_1.__spread(statusFlags)),
            ci: accessoryInfo.category,
            sh: setupHash,
        };
    };
    CiaoAdvertiser.computeSetupHash = function (accessoryInfo) {
        var hash = crypto_1.default.createHash('sha512');
        hash.update(accessoryInfo.setupID + accessoryInfo.username.toUpperCase());
        return hash.digest().slice(0, 4).toString('base64');
    };
    CiaoAdvertiser.ff = function () {
        var flags = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            flags[_i] = arguments[_i];
        }
        var value = 0;
        flags.forEach(function (flag) { return value |= flag; });
        return value;
    };
    CiaoAdvertiser.sf = function () {
        var flags = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            flags[_i] = arguments[_i];
        }
        var value = 0;
        flags.forEach(function (flag) { return value |= flag; });
        return value;
    };
    CiaoAdvertiser.protocolVersion = "1.1";
    CiaoAdvertiser.protocolVersionService = "1.1.0";
    return CiaoAdvertiser;
}(events_1.EventEmitter));
exports.CiaoAdvertiser = CiaoAdvertiser;
/**
 * Advertiser base on the legacy "bonjour-hap" library.
 */
var BonjourHAPAdvertiser = /** @class */ (function (_super) {
    tslib_1.__extends(BonjourHAPAdvertiser, _super);
    function BonjourHAPAdvertiser(accessoryInfo, responderOptions, serviceOptions) {
        var _this = _super.call(this) || this;
        _this.destroyed = false;
        _this.accessoryInfo = accessoryInfo;
        _this.setupHash = CiaoAdvertiser.computeSetupHash(accessoryInfo);
        _this.serviceOptions = serviceOptions;
        _this.bonjour = bonjour_hap_1.default(responderOptions);
        console.log("Preparing Advertiser for '" + _this.accessoryInfo.displayName + "' using bonjour-hap backend!");
        return _this;
    }
    BonjourHAPAdvertiser.prototype.initPort = function (port) {
        this.port = port;
    };
    BonjourHAPAdvertiser.prototype.startAdvertising = function () {
        assert_1.default(!this.destroyed, "Can't advertise on a destroyed bonjour instance!");
        if (this.port == undefined) {
            throw new Error("Tried starting bonjour-hap advertisement without initializing port!");
        }
        console.log("Starting to advertise '" + this.accessoryInfo.displayName + "' using bonjour-hap backend!");
        if (this.advertisement) {
            this.destroy();
        }
        var hostname = this.accessoryInfo.username.replace(/:/ig, "_") + '.local';
        this.advertisement = this.bonjour.publish(tslib_1.__assign({ name: this.accessoryInfo.displayName, type: "hap", port: this.port, txt: CiaoAdvertiser.createTxt(this.accessoryInfo, this.setupHash), host: hostname, addUnsafeServiceEnumerationRecord: true }, this.serviceOptions));
    };
    BonjourHAPAdvertiser.prototype.updateAdvertisement = function (silent) {
        if (this.advertisement) {
            this.advertisement.updateTxt(CiaoAdvertiser.createTxt(this.accessoryInfo, this.setupHash), silent);
        }
    };
    BonjourHAPAdvertiser.prototype.destroy = function () {
        var _this = this;
        if (this.advertisement) {
            this.advertisement.stop(function () {
                _this.advertisement.destroy();
                _this.advertisement = undefined;
                _this.bonjour.destroy();
            });
        }
        else {
            this.bonjour.destroy();
        }
    };
    return BonjourHAPAdvertiser;
}(events_1.EventEmitter));
exports.BonjourHAPAdvertiser = BonjourHAPAdvertiser;
//# sourceMappingURL=Advertiser.js.map

/***/ }),

/***/ 4931:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Bridge = void 0;
var tslib_1 = __nccwpck_require__(4290);
var Accessory_1 = __nccwpck_require__(7430);
/**
 * Bridge is a special type of HomeKit Accessory that hosts other Accessories "behind" it. This way you
 * can simply publish() the Bridge (with a single HAPServer on a single port) and all bridged Accessories
 * will be hosted automatically, instead of needed to publish() every single Accessory as a separate server.
 */
var Bridge = /** @class */ (function (_super) {
    tslib_1.__extends(Bridge, _super);
    function Bridge(displayName, UUID) {
        var _this = _super.call(this, displayName, UUID) || this;
        _this._isBridge = true;
        return _this;
    }
    return Bridge;
}(Accessory_1.Accessory));
exports.Bridge = Bridge;
//# sourceMappingURL=Bridge.js.map

/***/ }),

/***/ 3859:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Characteristic = exports.CharacteristicEventTypes = exports.ChangeReason = exports.Access = exports.Perms = exports.Units = exports.Formats = void 0;
var tslib_1 = __nccwpck_require__(4290);
var assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
var debug_1 = tslib_1.__importDefault(__nccwpck_require__(7984));
var events_1 = __nccwpck_require__(8614);
var definitions_1 = __nccwpck_require__(3476);
var HAPServer_1 = __nccwpck_require__(7551);
var clone_1 = __nccwpck_require__(9885);
var hapStatusError_1 = __nccwpck_require__(9495);
var once_1 = __nccwpck_require__(8597);
var request_util_1 = __nccwpck_require__(8131);
var uuid_1 = __nccwpck_require__(6814);
var debug = debug_1.default("HAP-NodeJS:Characteristic");
var Formats;
(function (Formats) {
    Formats["BOOL"] = "bool";
    /**
     * Signed 32-bit integer
     */
    Formats["INT"] = "int";
    /**
     * Signed 64-bit floating point
     */
    Formats["FLOAT"] = "float";
    /**
     * String encoded in utf8
     */
    Formats["STRING"] = "string";
    /**
     * Unsigned 8-bit integer.
     */
    Formats["UINT8"] = "uint8";
    /**
     * Unsigned 16-bit integer.
     */
    Formats["UINT16"] = "uint16";
    /**
     * Unsigned 32-bit integer.
     */
    Formats["UINT32"] = "uint32";
    /**
     * Unsigned 64-bit integer.
     */
    Formats["UINT64"] = "uint64";
    /**
     * Data is base64 encoded string.
     */
    Formats["DATA"] = "data";
    /**
     * Base64 encoded tlv8 string.
     */
    Formats["TLV8"] = "tlv8";
    /**
     * @deprecated Not contained in the HAP spec
     */
    Formats["ARRAY"] = "array";
    /**
     * @deprecated Not contained in the HAP spec
     */
    Formats["DICTIONARY"] = "dict";
})(Formats = exports.Formats || (exports.Formats = {}));
var Units;
(function (Units) {
    /**
     * Celsius is the only temperature unit in the HomeKit Accessory Protocol.
     * Unit conversion is always done on the client side e.g. on the iPhone in the Home App depending on
     * the configured unit on the device itself.
     */
    Units["CELSIUS"] = "celsius";
    Units["PERCENTAGE"] = "percentage";
    Units["ARC_DEGREE"] = "arcdegrees";
    Units["LUX"] = "lux";
    Units["SECONDS"] = "seconds";
})(Units = exports.Units || (exports.Units = {}));
var Perms;
(function (Perms) {
    // noinspection JSUnusedGlobalSymbols
    /**
     * @deprecated replaced by {@link PAIRED_READ}. Kept for backwards compatibility.
     */
    Perms["READ"] = "pr";
    /**
     * @deprecated replaced by {@link PAIRED_WRITE}. Kept for backwards compatibility.
     */
    Perms["WRITE"] = "pw";
    Perms["PAIRED_READ"] = "pr";
    Perms["PAIRED_WRITE"] = "pw";
    Perms["NOTIFY"] = "ev";
    Perms["EVENTS"] = "ev";
    Perms["ADDITIONAL_AUTHORIZATION"] = "aa";
    Perms["TIMED_WRITE"] = "tw";
    Perms["HIDDEN"] = "hd";
    Perms["WRITE_RESPONSE"] = "wr";
})(Perms = exports.Perms || (exports.Perms = {}));
var Access;
(function (Access) {
    Access[Access["READ"] = 0] = "READ";
    Access[Access["WRITE"] = 1] = "WRITE";
    Access[Access["NOTIFY"] = 2] = "NOTIFY";
})(Access = exports.Access || (exports.Access = {}));
var ChangeReason;
(function (ChangeReason) {
    /**
     * Reason used when HomeKit writes a value or the API user calls {@link Characteristic.setValue}.
     */
    ChangeReason["WRITE"] = "write";
    /**
     * Reason used when the API user calls the method {@link Characteristic.updateValue}.
     */
    ChangeReason["UPDATE"] = "update";
    /**
     * Used when when HomeKit reads a value or the API user calls the deprecated method {@link Characteristic.getValue}.
     */
    ChangeReason["READ"] = "read";
    /**
     * Used when call to {@link Characteristic.sendEventNotification} was made.
     */
    ChangeReason["EVENT"] = "event";
})(ChangeReason = exports.ChangeReason || (exports.ChangeReason = {}));
var CharacteristicEventTypes;
(function (CharacteristicEventTypes) {
    /**
     * This event is thrown when a HomeKit controller wants to read the current value of the characteristic.
     * The event handler should call the supplied callback as fast as possible.
     *
     * HAP-NodeJS will complain about slow running get handlers after 3 seconds and terminate the request after 10 seconds.
     */
    CharacteristicEventTypes["GET"] = "get";
    /**
     * This event is thrown when a HomeKit controller wants to write a new value to the characteristic.
     * The event handler should call the supplied callback as fast as possible.
     *
     * HAP-NodeJS will complain about slow running set handlers after 3 seconds and terminate the request after 10 seconds.
     */
    CharacteristicEventTypes["SET"] = "set";
    /**
     * Emitted after a new value is set for the characteristic.
     * The new value can be set via a request by a HomeKit controller or via an API call.
     */
    CharacteristicEventTypes["CHANGE"] = "change";
    /**
     * @private
     */
    CharacteristicEventTypes["SUBSCRIBE"] = "subscribe";
    /**
     * @private
     */
    CharacteristicEventTypes["UNSUBSCRIBE"] = "unsubscribe";
    /**
     * @private
     */
    CharacteristicEventTypes["CHARACTERISTIC_WARNING"] = "characteristic-warning";
})(CharacteristicEventTypes = exports.CharacteristicEventTypes || (exports.CharacteristicEventTypes = {}));
var ValidValuesIterable = /** @class */ (function () {
    function ValidValuesIterable(props) {
        assert_1.default(request_util_1.isNumericFormat(props.format), "Cannot instantiate valid values iterable when format is not numeric. Found " + props.format);
        this.props = props;
    }
    ValidValuesIterable.prototype[Symbol.iterator] = function () {
        var _a, _b, value, e_1_1, min, max, stepValue, i;
        var e_1, _c;
        return tslib_1.__generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    if (!this.props.validValues) return [3 /*break*/, 9];
                    _d.label = 1;
                case 1:
                    _d.trys.push([1, 6, 7, 8]);
                    _a = tslib_1.__values(this.props.validValues), _b = _a.next();
                    _d.label = 2;
                case 2:
                    if (!!_b.done) return [3 /*break*/, 5];
                    value = _b.value;
                    return [4 /*yield*/, value];
                case 3:
                    _d.sent();
                    _d.label = 4;
                case 4:
                    _b = _a.next();
                    return [3 /*break*/, 2];
                case 5: return [3 /*break*/, 8];
                case 6:
                    e_1_1 = _d.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 8];
                case 7:
                    try {
                        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 8: return [3 /*break*/, 13];
                case 9:
                    min = 0;
                    max = void 0;
                    stepValue = 1;
                    if (this.props.validValueRanges) {
                        min = this.props.validValueRanges[0];
                        max = this.props.validValueRanges[1];
                    }
                    else if (this.props.minValue != null && this.props.maxValue != null) {
                        min = this.props.minValue;
                        max = this.props.maxValue;
                        if (this.props.minStep != null) {
                            stepValue = this.props.minStep;
                        }
                    }
                    else if (request_util_1.isUnsignedNumericFormat(this.props.format)) {
                        max = request_util_1.numericUpperBound(this.props.format);
                    }
                    else {
                        throw new Error("Could not find valid iterator strategy for props: " + JSON.stringify(this.props));
                    }
                    i = min;
                    _d.label = 10;
                case 10:
                    if (!(i <= max)) return [3 /*break*/, 13];
                    return [4 /*yield*/, i];
                case 11:
                    _d.sent();
                    _d.label = 12;
                case 12:
                    i += stepValue;
                    return [3 /*break*/, 10];
                case 13: return [2 /*return*/];
            }
        });
    };
    return ValidValuesIterable;
}());
/**
 * Characteristic represents a particular typed variable that can be assigned to a Service. For instance, a
 * "Hue" Characteristic might store a 'float' value of type 'arcdegrees'. You could add the Hue Characteristic
 * to a {@link Service} in order to store that value. A particular Characteristic is distinguished from others by its
 * UUID. HomeKit provides a set of known Characteristic UUIDs defined in HomeKit.ts along with a
 * corresponding concrete subclass.
 *
 * You can also define custom Characteristics by providing your own UUID. Custom Characteristics can be added
 * to any native or custom Services, but Siri will likely not be able to work with these.
 */
var Characteristic = /** @class */ (function (_super) {
    tslib_1.__extends(Characteristic, _super);
    function Characteristic(displayName, UUID, props) {
        var _this = _super.call(this) || this;
        _this.iid = null;
        _this.value = null;
        /**
         * @deprecated replaced by {@link statusCode}
         * @private
         */
        _this.status = null;
        /**
         * @private
         */
        _this.statusCode = 0 /* SUCCESS */;
        _this.subscriptions = 0;
        _this.displayName = displayName;
        _this.UUID = UUID;
        _this.props = {
            format: "int" /* INT */,
            perms: ["ev" /* NOTIFY */],
        };
        _this.setProps(props || {}); // ensure sanity checks are called
        return _this;
    }
    /**
     * Accepts a function that will be called to retrieve the current value of a Characteristic.
     * The function must return a valid Characteristic value for the Characteristic type.
     * May optionally return a promise.
     *
     * @example
     * ```ts
     * Characteristic.onGet(async () => {
     *   return true;
     * });
     * ```
     * @param handler
     */
    Characteristic.prototype.onGet = function (handler) {
        if (typeof handler !== 'function') {
            this.characteristicWarning(".onGet handler must be a function");
            return this;
        }
        this.getHandler = handler;
        return this;
    };
    /**
     * Removes the {@link CharacteristicGetHandler} handler which was configured using {@link onGet}.
     */
    Characteristic.prototype.removeOnGet = function () {
        this.getHandler = undefined;
        return this;
    };
    /**
     * Accepts a function that will be called when setting the value of a Characteristic.
     * If the characteristic supports {@link Perms.WRITE_RESPONSE} and the request requests a write response value,
     * the returned value will be used.
     * May optionally return a promise.
     *
     * @example
     * ```ts
     * Characteristic.onSet(async (value: CharacteristicValue) => {
     *   console.log(value);
     * });
     * ```
     * @param handler
     */
    Characteristic.prototype.onSet = function (handler) {
        if (typeof handler !== 'function') {
            this.characteristicWarning(".onSet handler must be a function");
            return this;
        }
        this.setHandler = handler;
        return this;
    };
    /**
     * Removes the {@link CharacteristicSetHandler} which was configured using {@link onSet}.
     */
    Characteristic.prototype.removeOnSet = function () {
        this.setHandler = undefined;
        return this;
    };
    /**
     * Updates the properties of this characteristic.
     * Properties passed via the parameter will be set. Any parameter set to null will be deleted.
     * See {@link CharacteristicProps}.
     *
     * @param props - Partial properties object with the desired updates.
     */
    Characteristic.prototype.setProps = function (props) {
        assert_1.default(props, "props cannot be undefined when setting props");
        // TODO calling setProps after publish doesn't lead to a increment in the current configuration number
        // for every value "null" can be used to reset props, except for required props
        if (props.format) {
            this.props.format = props.format;
        }
        if (props.perms) {
            assert_1.default(props.perms.length > 0, "characteristic prop perms cannot be empty array");
            this.props.perms = props.perms;
        }
        if (props.unit !== undefined) {
            this.props.unit = props.unit != null ? props.unit : undefined;
        }
        if (props.description !== undefined) {
            this.props.description = props.description != null ? props.description : undefined;
        }
        // check minValue is valid for the format type
        if (props.minValue !== undefined) {
            if (props.minValue === null) {
                props.minValue = undefined;
            }
            else if (!request_util_1.isNumericFormat(this.props.format)) {
                this.characteristicWarning("Characteristic Property `minValue` can only be set for characteristics with numeric format, but not for " + this.props.format, "error-message" /* ERROR_MESSAGE */);
                props.minValue = undefined;
            }
            else if (request_util_1.isUnsignedNumericFormat(this.props.format)) {
                if (props.minValue < request_util_1.numericLowerBound(this.props.format)) {
                    this.characteristicWarning("Characteristic Property `minValue` was set to " + props.minValue + ", but for numeric format " +
                        this.props.format + " minimum possible is " + request_util_1.numericLowerBound(this.props.format), "error-message" /* ERROR_MESSAGE */);
                    props.minValue = request_util_1.numericLowerBound(this.props.format);
                }
                else if (props.minValue > request_util_1.numericUpperBound(this.props.format)) {
                    this.characteristicWarning("Characteristic Property `minValue` was set to " + props.minValue + ", but for numeric format " +
                        this.props.format + " maximum possible is " + request_util_1.numericUpperBound(this.props.format), "error-message" /* ERROR_MESSAGE */);
                    props.minValue = request_util_1.numericLowerBound(this.props.format);
                }
            }
            this.props.minValue = props.minValue;
        }
        // check maxValue is valid for the format type
        if (props.maxValue !== undefined) {
            if (props.maxValue === null) {
                props.maxValue = undefined;
            }
            else if (!request_util_1.isNumericFormat(this.props.format)) {
                this.characteristicWarning("Characteristic Property `maxValue` can only be set for characteristics with numeric format, but not for " + this.props.format, "error-message" /* ERROR_MESSAGE */);
                props.maxValue = undefined;
            }
            else if (request_util_1.isUnsignedNumericFormat(this.props.format)) {
                if (props.maxValue > request_util_1.numericUpperBound(this.props.format)) {
                    this.characteristicWarning("Characteristic Property `maxValue` was set to " + props.maxValue + ", but for numeric format " +
                        this.props.format + " maximum possible is " + request_util_1.numericUpperBound(this.props.format), "error-message" /* ERROR_MESSAGE */);
                    props.maxValue = request_util_1.numericUpperBound(this.props.format);
                }
                else if (props.maxValue < request_util_1.numericLowerBound(this.props.format)) {
                    this.characteristicWarning("Characteristic Property `maxValue` was set to " + props.maxValue + ", but for numeric format " +
                        this.props.format + " minimum possible is " + request_util_1.numericUpperBound(this.props.format), "error-message" /* ERROR_MESSAGE */);
                    props.maxValue = request_util_1.numericUpperBound(this.props.format);
                }
            }
            this.props.maxValue = props.maxValue;
        }
        if (props.minStep !== undefined) {
            if (props.minStep === null) {
                this.props.minStep = undefined;
            }
            else if (!request_util_1.isNumericFormat(this.props.format)) {
                this.characteristicWarning("Characteristic Property `minStep` can only be set for characteristics with numeric format, but not for " + this.props.format, "error-message" /* ERROR_MESSAGE */);
            }
            else {
                if (props.minStep < 1 && request_util_1.isIntegerNumericFormat(this.props.format)) {
                    this.characteristicWarning("Characteristic Property `minStep` was set to a value lower than 1, " +
                        "this will have no effect on format `" + this.props.format);
                }
                this.props.minStep = props.minStep;
            }
        }
        if (props.maxLen !== undefined) {
            if (props.maxLen === null) {
                this.props.maxLen = undefined;
            }
            else if (this.props.format !== "string" /* STRING */) {
                this.characteristicWarning("Characteristic Property `maxLen` can only be set for characteristics with format `STRING`, but not for " + this.props.format, "error-message" /* ERROR_MESSAGE */);
            }
            else {
                if (props.maxLen > 256) {
                    this.characteristicWarning("Characteristic Property string `maxLen` cannot be bigger than 256");
                    props.maxLen = 256;
                }
                this.props.maxLen = props.maxLen;
            }
        }
        if (props.maxDataLen !== undefined) {
            if (props.maxDataLen === null) {
                this.props.maxDataLen = undefined;
            }
            else if (this.props.format !== "data" /* DATA */) {
                this.characteristicWarning("Characteristic Property `maxDataLen` can only be set for characteristics with format `DATA`, but not for " + this.props.format, "error-message" /* ERROR_MESSAGE */);
            }
            else {
                this.props.maxDataLen = props.maxDataLen;
            }
        }
        if (props.validValues !== undefined) {
            if (props.validValues === null) {
                this.props.validValues = undefined;
            }
            else if (!request_util_1.isNumericFormat(this.props.format)) {
                this.characteristicWarning("Characteristic Property `validValues` was supplied for non numeric format " + this.props.format);
            }
            else {
                assert_1.default(props.validValues.length, "characteristic prop validValues cannot be empty array");
                this.props.validValues = props.validValues;
            }
        }
        if (props.validValueRanges !== undefined) {
            if (props.validValueRanges === null) {
                this.props.validValueRanges = undefined;
            }
            else if (!request_util_1.isNumericFormat(this.props.format)) {
                this.characteristicWarning("Characteristic Property `validValueRanges` was supplied for non numeric format " + this.props.format);
            }
            else {
                assert_1.default(props.validValueRanges.length === 2, "characteristic prop validValueRanges must have a length of 2");
                this.props.validValueRanges = props.validValueRanges;
            }
        }
        if (props.adminOnlyAccess !== undefined) {
            this.props.adminOnlyAccess = props.adminOnlyAccess != null ? props.adminOnlyAccess : undefined;
        }
        if (this.props.minValue != null && this.props.maxValue != null) { // the eqeq instead of eqeqeq is important here
            if (this.props.minValue > this.props.maxValue) { // see https://github.com/homebridge/HAP-NodeJS/issues/690
                this.props.minValue = undefined;
                this.props.maxValue = undefined;
                throw new Error("Error setting CharacteristicsProps for '" + this.displayName + "': 'minValue' cannot be greater or equal the 'maxValue'!");
            }
        }
        return this;
    };
    /**
     * This method can be used to gain a Iterator to loop over all valid values defined for this characteristic.
     *
     * The range of valid values can be defined using three different ways via the {@link CharacteristicProps} object
     * (set via the {@link setProps} method):
     *  * First method is to specifically list every valid value inside {@link CharacteristicProps.validValues}
     *  * Second you can specify a range via {@link CharacteristicProps.minValue} and {@link CharacteristicProps.maxValue} (with optionally defining
     *    {@link CharacteristicProps.minStep})
     *  * And lastly you can specify a range via {@link CharacteristicProps.validValueRanges}
     *  * Implicitly a valid value range is predefined for characteristics with Format {@link Formats.UINT8}, {@link Formats.UINT16},
     *    {@link Formats.UINT32} and {@link Formats.UINT64}: starting by zero to their respective maximum number
     *
     * The method will automatically detect which type of valid values definition is used and provide
     * the correct Iterator for that case.
     *
     * Note: This method is (obviously) only valid for numeric characteristics.
     *
     * @example
     * ```ts
     * // use the iterator to loop over every valid value...
     * for (const value of characteristic.validValuesIterator()) {
     *   // Insert logic to run for every
     * }
     *
     * // ... or collect them in an array for storage or manipulation
     * const validValues = Array.from(characteristic.validValuesIterator());
     * ```
     */
    Characteristic.prototype.validValuesIterator = function () {
        return new ValidValuesIterable(this.props);
    };
    // noinspection JSUnusedGlobalSymbols
    /**
     * This method can be used to setup additional authorization for a characteristic.
     * For one it adds the {@link Perms.ADDITIONAL_AUTHORIZATION} permission to the characteristic
     * (if it wasn't already) to signal support for additional authorization to HomeKit.
     * Additionally an {@link AdditionalAuthorizationHandler} is setup up which is called
     * before a write request is performed.
     *
     * Additional Authorization Data can be added to SET request via a custom iOS App.
     * Before hap-nodejs executes a write request it will call the {@link AdditionalAuthorizationHandler}
     * with 'authData' supplied in the write request. The 'authData' is a base64 encoded string
     * (or undefined if no authData was supplied).
     * The {@link AdditionalAuthorizationHandler} must then return true or false to indicate if the write request
     * is authorized and should be accepted.
     *
     * @param handler - Handler called to check additional authorization data.
     */
    Characteristic.prototype.setupAdditionalAuthorization = function (handler) {
        if (!this.props.perms.includes("aa" /* ADDITIONAL_AUTHORIZATION */)) {
            this.props.perms.push("aa" /* ADDITIONAL_AUTHORIZATION */);
        }
        this.additionalAuthorizationHandler = handler;
    };
    /**
     * Updates the current value of the characteristic.
     *
     * @param callback
     * @param context
     * @private use to return the current value on HAP requests
     *
     * @deprecated
     */
    Characteristic.prototype.getValue = function (callback, context) {
        this.handleGetRequest(undefined, context).then(function (value) {
            if (callback) {
                callback(null, value);
            }
        }, function (reason) {
            if (callback) {
                callback(reason);
            }
        });
    };
    Characteristic.prototype.setValue = function (value, callback, context) {
        if (value instanceof Error) {
            this.statusCode = value instanceof hapStatusError_1.HapStatusError ? value.hapStatus : extractHAPStatusFromError(value);
            // noinspection JSDeprecatedSymbols
            this.status = value;
            if (callback) {
                callback();
            }
            return this;
        }
        if (callback && !context && typeof callback !== "function") {
            context = callback;
            callback = undefined;
        }
        try {
            value = this.validateUserInput(value);
        }
        catch (error) {
            this.characteristicWarning((error === null || error === void 0 ? void 0 : error.message) + "", "error-message" /* ERROR_MESSAGE */, error === null || error === void 0 ? void 0 : error.stack);
            if (callback) {
                callback(error);
            }
            return this;
        }
        this.handleSetRequest(value, undefined, context).then(function (value) {
            if (callback) {
                if (value) { // possible write response
                    callback(null, value);
                }
                else {
                    callback(null);
                }
            }
        }, function (reason) {
            if (callback) {
                callback(reason);
            }
        });
        return this;
    };
    Characteristic.prototype.updateValue = function (value, callback, context) {
        if (value instanceof Error) {
            this.statusCode = value instanceof hapStatusError_1.HapStatusError ? value.hapStatus : extractHAPStatusFromError(value);
            // noinspection JSDeprecatedSymbols
            this.status = value;
            if (callback) {
                callback();
            }
            return this;
        }
        if (callback && !context && typeof callback !== "function") {
            context = callback;
            callback = undefined;
        }
        try {
            value = this.validateUserInput(value);
        }
        catch (error) {
            this.characteristicWarning((error === null || error === void 0 ? void 0 : error.message) + "", "error-message" /* ERROR_MESSAGE */, error === null || error === void 0 ? void 0 : error.stack);
            if (callback) {
                callback();
            }
            return this;
        }
        this.statusCode = 0 /* SUCCESS */;
        // noinspection JSDeprecatedSymbols
        this.status = null;
        var oldValue = this.value;
        this.value = value;
        if (callback) {
            callback();
        }
        this.emit("change" /* CHANGE */, { originator: undefined, oldValue: oldValue, newValue: value, reason: "update" /* UPDATE */, context: context });
        return this; // for chaining
    };
    /**
     * This method acts similarly to {@link updateValue} by setting the current value of the characteristic
     * without calling any {@link CharacteristicEventTypes.SET} or {@link onSet} handlers.
     * The difference is that this method forces a event notification sent (updateValue only sends one if the value changed).
     * This is especially useful for characteristics like {@link Characteristic.ButtonEvent} or {@link Characteristic.ProgrammableSwitchEvent}.
     *
     * @param value - The new value.
     * @param context - Passed to the {@link CharacteristicEventTypes.CHANGE} event handler.
     */
    Characteristic.prototype.sendEventNotification = function (value, context) {
        this.statusCode = 0 /* SUCCESS */;
        // noinspection JSDeprecatedSymbols
        this.status = null;
        value = this.validateUserInput(value);
        var oldValue = this.value;
        this.value = value;
        this.emit("change" /* CHANGE */, { originator: undefined, oldValue: oldValue, newValue: value, reason: "event" /* EVENT */, context: context });
        return this; // for chaining
    };
    /**
     * Called when a HAP requests wants to know the current value of the characteristic.
     *
     * @param connection - The HAP connection from which the request originated from.
     * @param context - Deprecated parameter. There for backwards compatibility.
     * @private Used by the Accessory to load the characteristic value
     */
    Characteristic.prototype.handleGetRequest = function (connection, context) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var value, oldValue, error_1;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.props.perms.includes("pr" /* PAIRED_READ */)) { // check if we are allowed to read from this characteristic
                            throw -70405 /* WRITE_ONLY_CHARACTERISTIC */;
                        }
                        if (this.UUID === Characteristic.ProgrammableSwitchEvent.UUID) {
                            // special workaround for event only programmable switch event, which must always return null
                            return [2 /*return*/, null];
                        }
                        if (!this.getHandler) return [3 /*break*/, 4];
                        if (this.listeners("get" /* GET */).length > 0) {
                            this.characteristicWarning("Ignoring on('get') handler as onGet handler was defined instead");
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.getHandler(context, connection)];
                    case 2:
                        value = _a.sent();
                        this.statusCode = 0 /* SUCCESS */;
                        // noinspection JSDeprecatedSymbols
                        this.status = null;
                        try {
                            value = this.validateUserInput(value);
                        }
                        catch (error) {
                            this.characteristicWarning("An illegal value was supplied by the read handler for characteristic: " + (error === null || error === void 0 ? void 0 : error.message), "warn-message" /* WARN_MESSAGE */, error === null || error === void 0 ? void 0 : error.stack);
                            this.statusCode = -70402 /* SERVICE_COMMUNICATION_FAILURE */;
                            // noinspection JSDeprecatedSymbols
                            this.status = error;
                            return [2 /*return*/, Promise.reject(-70402 /* SERVICE_COMMUNICATION_FAILURE */)];
                        }
                        oldValue = this.value;
                        this.value = value;
                        if (oldValue !== value) { // emit a change event if necessary
                            this.emit("change" /* CHANGE */, { originator: connection, oldValue: oldValue, newValue: value, reason: "read" /* READ */, context: context });
                        }
                        return [2 /*return*/, value];
                    case 3:
                        error_1 = _a.sent();
                        if (typeof error_1 === "number") {
                            this.statusCode = error_1;
                            // noinspection JSDeprecatedSymbols
                            this.status = new hapStatusError_1.HapStatusError(error_1);
                        }
                        else if (error_1 instanceof hapStatusError_1.HapStatusError) {
                            this.statusCode = error_1.hapStatus;
                            // noinspection JSDeprecatedSymbols
                            this.status = error_1;
                        }
                        else {
                            this.characteristicWarning("Unhandled error thrown inside read handler for characteristic: " + (error_1 === null || error_1 === void 0 ? void 0 : error_1.message), "error-message" /* ERROR_MESSAGE */, error_1 === null || error_1 === void 0 ? void 0 : error_1.stack);
                            this.statusCode = -70402 /* SERVICE_COMMUNICATION_FAILURE */;
                            // noinspection JSDeprecatedSymbols
                            this.status = error_1;
                        }
                        throw this.statusCode;
                    case 4:
                        if (this.listeners("get" /* GET */).length === 0) {
                            if (this.statusCode) {
                                throw this.statusCode;
                            }
                            try {
                                return [2 /*return*/, this.validateUserInput(this.value)];
                            }
                            catch (error) {
                                this.characteristicWarning("An illegal value was supplied by setting `value` for characteristic: " + (error === null || error === void 0 ? void 0 : error.message), "warn-message" /* WARN_MESSAGE */, error === null || error === void 0 ? void 0 : error.stack);
                                return [2 /*return*/, Promise.reject(-70402 /* SERVICE_COMMUNICATION_FAILURE */)];
                            }
                        }
                        return [2 /*return*/, new Promise(function (resolve, reject) {
                                try {
                                    _this.emit("get" /* GET */, once_1.once(function (status, value) {
                                        if (status) {
                                            if (typeof status === "number") {
                                                _this.statusCode = status;
                                                // noinspection JSDeprecatedSymbols
                                                _this.status = new hapStatusError_1.HapStatusError(status);
                                            }
                                            else if (status instanceof hapStatusError_1.HapStatusError) {
                                                _this.statusCode = status.hapStatus;
                                                // noinspection JSDeprecatedSymbols
                                                _this.status = status;
                                            }
                                            else {
                                                debug("[%s] Received error from get handler %s", _this.displayName, status.stack);
                                                _this.statusCode = extractHAPStatusFromError(status);
                                                // noinspection JSDeprecatedSymbols
                                                _this.status = status;
                                            }
                                            reject(_this.statusCode);
                                            return;
                                        }
                                        _this.statusCode = 0 /* SUCCESS */;
                                        // noinspection JSDeprecatedSymbols
                                        _this.status = null;
                                        value = _this.validateUserInput(value);
                                        var oldValue = _this.value;
                                        _this.value = value;
                                        resolve(value);
                                        if (oldValue !== value) { // emit a change event if necessary
                                            _this.emit("change" /* CHANGE */, { originator: connection, oldValue: oldValue, newValue: value, reason: "read" /* READ */, context: context });
                                        }
                                    }), context, connection);
                                }
                                catch (error) {
                                    _this.characteristicWarning("Unhandled error thrown inside read handler for characteristic: " + (error === null || error === void 0 ? void 0 : error.message), "error-message" /* ERROR_MESSAGE */, error === null || error === void 0 ? void 0 : error.stack);
                                    _this.statusCode = -70402 /* SERVICE_COMMUNICATION_FAILURE */;
                                    // noinspection JSDeprecatedSymbols
                                    _this.status = error;
                                    reject(-70402 /* SERVICE_COMMUNICATION_FAILURE */);
                                }
                            })];
                }
            });
        });
    };
    /**
     * Called when a HAP requests update the current value of the characteristic.
     *
     * @param value - The updated value
     * @param connection - The connection from which the request originated from
     * @param context - Deprecated parameter. There for backwards compatibility.
     * @returns Promise resolve to void in normal operation. When characteristic supports write response, the
     *  HAP request requests write response and the set handler returns a write response value, the respective
     *  write response value is resolved.
     * @private
     */
    Characteristic.prototype.handleSetRequest = function (value, connection, context) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var oldValue, writeResponse, error_2;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.statusCode = 0 /* SUCCESS */;
                        // noinspection JSDeprecatedSymbols
                        this.status = null;
                        if (connection !== undefined && !this.validClientSuppliedValue(value)) {
                            // if connection is undefined, the set "request" comes from the setValue method.
                            // for setValue a value of "null" is allowed and checked via validateUserInput.
                            return [2 /*return*/, Promise.reject(-70410 /* INVALID_VALUE_IN_REQUEST */)];
                        }
                        if (this.props.format === "bool" /* BOOL */ && typeof value === "number") {
                            // we already validate in validClientSuppliedValue that a number value can only be 0 or 1.
                            value = value === 1;
                        }
                        oldValue = this.value;
                        if (!this.setHandler) return [3 /*break*/, 4];
                        if (this.listeners("set" /* SET */).length > 0) {
                            this.characteristicWarning("Ignoring on('set') handler as onSet handler was defined instead");
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.setHandler(value, context, connection)];
                    case 2:
                        writeResponse = _a.sent();
                        this.statusCode = 0 /* SUCCESS */;
                        // noinspection JSDeprecatedSymbols
                        this.status = null;
                        if (writeResponse != null && this.props.perms.includes("wr" /* WRITE_RESPONSE */)) {
                            this.value = this.validateUserInput(writeResponse);
                            return [2 /*return*/, this.value];
                        }
                        else {
                            if (writeResponse != null) {
                                this.characteristicWarning("SET handler returned write response value, though the characteristic doesn't support write response");
                            }
                            this.value = value;
                            this.emit("change" /* CHANGE */, { originator: connection, oldValue: oldValue, newValue: value, reason: "write" /* WRITE */, context: context });
                            return [2 /*return*/];
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        error_2 = _a.sent();
                        if (typeof error_2 === "number") {
                            this.statusCode = error_2;
                            // noinspection JSDeprecatedSymbols
                            this.status = new hapStatusError_1.HapStatusError(error_2);
                        }
                        else if (error_2 instanceof hapStatusError_1.HapStatusError) {
                            this.statusCode = error_2.hapStatus;
                            // noinspection JSDeprecatedSymbols
                            this.status = error_2;
                        }
                        else {
                            this.characteristicWarning("Unhandled error thrown inside write handler for characteristic: " + (error_2 === null || error_2 === void 0 ? void 0 : error_2.message), "error-message" /* ERROR_MESSAGE */, error_2 === null || error_2 === void 0 ? void 0 : error_2.stack);
                            this.statusCode = -70402 /* SERVICE_COMMUNICATION_FAILURE */;
                            // noinspection JSDeprecatedSymbols
                            this.status = error_2;
                        }
                        throw this.statusCode;
                    case 4:
                        if (this.listeners("set" /* SET */).length === 0) {
                            this.value = value;
                            this.emit("change" /* CHANGE */, { originator: connection, oldValue: oldValue, newValue: value, reason: "write" /* WRITE */, context: context });
                            return [2 /*return*/, Promise.resolve()];
                        }
                        else {
                            return [2 /*return*/, new Promise(function (resolve, reject) {
                                    try {
                                        _this.emit("set" /* SET */, value, once_1.once(function (status, writeResponse) {
                                            if (status) {
                                                if (typeof status === "number") {
                                                    _this.statusCode = status;
                                                    // noinspection JSDeprecatedSymbols
                                                    _this.status = new hapStatusError_1.HapStatusError(status);
                                                }
                                                else if (status instanceof hapStatusError_1.HapStatusError) {
                                                    _this.statusCode = status.hapStatus;
                                                    // noinspection JSDeprecatedSymbols
                                                    _this.status = status;
                                                }
                                                else {
                                                    debug("[%s] Received error from set handler %s", _this.displayName, status.stack);
                                                    _this.statusCode = extractHAPStatusFromError(status);
                                                    // noinspection JSDeprecatedSymbols
                                                    _this.status = status;
                                                }
                                                reject(_this.statusCode);
                                                return;
                                            }
                                            _this.statusCode = 0 /* SUCCESS */;
                                            // noinspection JSDeprecatedSymbols
                                            _this.status = null;
                                            if (writeResponse != null && _this.props.perms.includes("wr" /* WRITE_RESPONSE */)) {
                                                // support write response simply by letting the implementor pass the response as second argument to the callback
                                                _this.value = _this.validateUserInput(writeResponse);
                                                resolve(_this.value);
                                            }
                                            else {
                                                if (writeResponse != null) {
                                                    _this.characteristicWarning("SET handler returned write response value, though the characteristic doesn't support write response");
                                                }
                                                _this.value = value;
                                                resolve();
                                                _this.emit("change" /* CHANGE */, { originator: connection, oldValue: oldValue, newValue: value, reason: "write" /* WRITE */, context: context });
                                            }
                                        }), context, connection);
                                    }
                                    catch (error) {
                                        _this.characteristicWarning("Unhandled error thrown inside write handler for characteristic: " + (error === null || error === void 0 ? void 0 : error.message), "error-message" /* ERROR_MESSAGE */, error === null || error === void 0 ? void 0 : error.stack);
                                        _this.statusCode = -70402 /* SERVICE_COMMUNICATION_FAILURE */;
                                        // noinspection JSDeprecatedSymbols
                                        _this.status = error;
                                        reject(-70402 /* SERVICE_COMMUNICATION_FAILURE */);
                                    }
                                })];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Called once a HomeKit controller subscribes to events of this characteristics.
     * @private
     */
    Characteristic.prototype.subscribe = function () {
        if (this.subscriptions === 0) {
            this.emit("subscribe" /* SUBSCRIBE */);
        }
        this.subscriptions++;
    };
    /**
     * Called once a HomeKit controller unsubscribe to events of this characteristics or a HomeKit controller
     * which was subscribed to this characteristic disconnects.
     * @private
     */
    Characteristic.prototype.unsubscribe = function () {
        var wasOne = this.subscriptions === 1;
        this.subscriptions--;
        this.subscriptions = Math.max(this.subscriptions, 0);
        if (wasOne) {
            this.emit("unsubscribe" /* UNSUBSCRIBE */);
        }
    };
    Characteristic.prototype.getDefaultValue = function () {
        var _a;
        // noinspection JSDeprecatedSymbols
        switch (this.props.format) {
            case "bool" /* BOOL */:
                return false;
            case "string" /* STRING */:
                switch (this.UUID) {
                    case Characteristic.Manufacturer.UUID:
                        return "Default-Manufacturer";
                    case Characteristic.Model.UUID:
                        return "Default-Model";
                    case Characteristic.SerialNumber.UUID:
                        return "Default-SerialNumber";
                    case Characteristic.FirmwareRevision.UUID:
                        return "0.0.0";
                    default:
                        return "";
                }
            case "data" /* DATA */:
                return null; // who knows!
            case "tlv8" /* TLV8 */:
                return null; // who knows!
            case "dict" /* DICTIONARY */:
                return {};
            case "array" /* ARRAY */:
                return [];
            case "int" /* INT */:
            case "float" /* FLOAT */:
            case "uint8" /* UINT8 */:
            case "uint16" /* UINT16 */:
            case "uint32" /* UINT32 */:
            case "uint64" /* UINT64 */:
                switch (this.UUID) {
                    case Characteristic.CurrentTemperature.UUID:
                        return 0; // some existing integrations expect this to be 0 by default
                    default: {
                        if (((_a = this.props.validValues) === null || _a === void 0 ? void 0 : _a.length) && typeof this.props.validValues[0] === 'number') {
                            return this.props.validValues[0];
                        }
                        if (typeof this.props.minValue === 'number') {
                            return this.props.minValue;
                        }
                        return 0;
                    }
                }
            default:
                return 0;
        }
    };
    /**
     * Checks if the value received from the HAP request is valid.
     * If returned false the received value is not valid and {@link HAPStatus.INVALID_VALUE_IN_REQUEST}
     * must be returned.
     * @param value - Value supplied by the HomeKit controller
     */
    Characteristic.prototype.validClientSuppliedValue = function (value) {
        if (value == undefined) {
            return false;
        }
        var numericMin = undefined;
        var numericMax = undefined;
        switch (this.props.format) {
            case "bool" /* BOOL */:
                if (!(typeof value === "boolean" || value == 0 || value == 1)) {
                    return false;
                }
                break;
            case "int" /* INT */: // 32-bit signed int
                if (typeof value === "boolean") {
                    value = value ? 1 : 0;
                }
                if (typeof value !== "number") {
                    return false;
                }
                numericMin = maxWithUndefined(this.props.minValue, request_util_1.numericLowerBound("int" /* INT */));
                numericMax = minWithUndefined(this.props.maxValue, request_util_1.numericUpperBound("int" /* INT */));
                break;
            case "float" /* FLOAT */:
                if (typeof value === "boolean") {
                    value = value ? 1 : 0;
                }
                if (typeof value !== "number") {
                    return false;
                }
                if (this.props.minValue != null) {
                    numericMin = this.props.minValue;
                }
                if (this.props.maxValue != null) {
                    numericMax = this.props.maxValue;
                }
                break;
            case "uint8" /* UINT8 */:
                if (typeof value === "boolean") {
                    value = value ? 1 : 0;
                }
                if (typeof value !== "number") {
                    return false;
                }
                numericMin = maxWithUndefined(this.props.minValue, request_util_1.numericLowerBound("uint8" /* UINT8 */));
                numericMax = minWithUndefined(this.props.maxValue, request_util_1.numericUpperBound("uint8" /* UINT8 */));
                break;
            case "uint16" /* UINT16 */:
                if (typeof value === "boolean") {
                    value = value ? 1 : 0;
                }
                if (typeof value !== "number") {
                    return false;
                }
                numericMin = maxWithUndefined(this.props.minValue, request_util_1.numericLowerBound("uint16" /* UINT16 */));
                numericMax = minWithUndefined(this.props.maxValue, request_util_1.numericUpperBound("uint16" /* UINT16 */));
                break;
            case "uint32" /* UINT32 */:
                if (typeof value === "boolean") {
                    value = value ? 1 : 0;
                }
                if (typeof value !== "number") {
                    return false;
                }
                numericMin = maxWithUndefined(this.props.minValue, request_util_1.numericLowerBound("uint32" /* UINT32 */));
                numericMax = minWithUndefined(this.props.maxValue, request_util_1.numericUpperBound("uint32" /* UINT32 */));
                break;
            case "uint64" /* UINT64 */:
                if (typeof value === "boolean") {
                    value = value ? 1 : 0;
                }
                if (typeof value !== "number") {
                    return false;
                }
                numericMin = maxWithUndefined(this.props.minValue, request_util_1.numericLowerBound("uint64" /* UINT64 */));
                numericMax = minWithUndefined(this.props.maxValue, request_util_1.numericUpperBound("uint64" /* UINT64 */));
                break;
            case "string" /* STRING */: {
                if (typeof value !== "string") {
                    return false;
                }
                var maxLength = this.props.maxLen != null ? this.props.maxLen : 64; // default is 64; max is 256 which is set in setProps
                if (value.length > maxLength) {
                    return false;
                }
                break;
            }
            case "data" /* DATA */: {
                if (typeof value !== "string") {
                    return false;
                }
                // we don't validate base64 here
                var maxLength = this.props.maxDataLen != null ? this.props.maxDataLen : 0x200000; // default is 0x200000
                if (value.length > maxLength) {
                    return false;
                }
                break;
            }
            case "tlv8" /* TLV8 */:
                if (typeof value !== "string") {
                    return false;
                }
                break;
        }
        if (typeof value === "number") {
            if (numericMin != null && value < numericMin) {
                return false;
            }
            if (numericMax != null && value > numericMax) {
                return false;
            }
            if (this.props.validValues && !this.props.validValues.includes(value)) {
                return false;
            }
            if (this.props.validValueRanges && this.props.validValueRanges.length === 2) {
                if (value < this.props.validValueRanges[0]) {
                    return false;
                }
                else if (value > this.props.validValueRanges[1]) {
                    return false;
                }
            }
        }
        return true;
    };
    /**
     * Checks if the value received from the API call is valid.
     * It adjust the value where it makes sense, prints a warning where values may be rejected with an error
     * in the future and throws an error which can't be converted to a valid value.
     *
     * @param value - The value received from the API call
     */
    Characteristic.prototype.validateUserInput = function (value) {
        var _a;
        if (value === null) {
            if (this.UUID === Characteristic.Model.UUID || this.UUID === Characteristic.SerialNumber.UUID) { // mirrors the statement in case: Formats.STRING
                this.characteristicWarning("characteristic must have a non null value otherwise HomeKit will reject this accessory, ignoring new value", "error-message" /* ERROR_MESSAGE */);
                return this.value; // don't change the value
            }
            /**
             * A short disclaimer here.
             * null is actually a perfectly valid value for characteristics to have.
             * The Home app will show "no response" for some characteristics for which it can't handle null
             * but ultimately its valid and the developers decision what the return.
             * BUT: out of history hap-nodejs did replaced null with the last known value and thus
             * homebridge devs started to adopting this method as a way of not changing the value in a GET handler.
             * As an intermediate step we kept the behavior but added a warning printed to the console.
             * In a future update we will do the breaking change of return null below!
             */
            if (this.UUID.endsWith(uuid_1.BASE_UUID)) { // we have a apple defined characteristic (at least assuming nobody else uses the UUID namespace)
                if (this.UUID === definitions_1.ProgrammableSwitchEvent.UUID) {
                    return value; // null is allowed as a value for ProgrammableSwitchEvent
                }
                this.characteristicWarning("characteristic was supplied illegal value: null! Home App will reject null for Apple defined characteristics");
                // if the value has been set previously, return it now, otherwise continue with validation to have a default value set.
                if (this.value !== null) {
                    return this.value;
                }
            }
            else {
                // we currently allow null for any non custom defined characteristics
                return value;
            }
        }
        var numericMin = undefined;
        var numericMax = undefined;
        var stepValue = undefined;
        switch (this.props.format) {
            case "bool" /* BOOL */: {
                if (typeof value === "boolean") {
                    return value;
                }
                else if (typeof value === "number") {
                    return value === 1;
                }
                else if (typeof value === "string") {
                    return value === "1" || value === "true";
                }
                else {
                    this.characteristicWarning("characteristic value expected boolean and received " + typeof value);
                    return false;
                }
            }
            case "int" /* INT */: {
                if (typeof value === "boolean") {
                    value = value ? 1 : 0;
                }
                if (typeof value === "string") {
                    // this.characteristicWarning(`characteristic was supplied illegal value: string instead of number. Supplying illegal values will throw errors in the future!`);
                    value = parseInt(value, 10);
                }
                if (typeof value === 'number' && isNaN(value)) {
                    this.characteristicWarning("characteristic was expected valid number and received NaN");
                    value = typeof this.value === 'number' ? this.value : this.props.minValue || 0;
                }
                if (typeof value !== "number") {
                    this.characteristicWarning("characteristic value expected number and received " + typeof value);
                    value = typeof this.value === 'number' ? this.value : this.props.minValue || 0;
                }
                numericMin = maxWithUndefined(this.props.minValue, request_util_1.numericLowerBound("int" /* INT */));
                numericMax = minWithUndefined(this.props.maxValue, request_util_1.numericUpperBound("int" /* INT */));
                stepValue = maxWithUndefined(this.props.minStep, 1);
                break;
            }
            case "float" /* FLOAT */: {
                if (typeof value === "boolean") {
                    value = value ? 1 : 0;
                }
                if (typeof value === "string") {
                    // this.characteristicWarning(`characteristic was supplied illegal value: string instead of float. Supplying illegal values will throw errors in the future!`);
                    value = parseFloat(value);
                }
                if (typeof value === 'number' && isNaN(value)) {
                    this.characteristicWarning("characteristic was expected valid number and received NaN");
                    value = typeof this.value === 'number' ? this.value : this.props.minValue || 0;
                }
                if (typeof value !== "number") {
                    this.characteristicWarning("characteristic value expected float and received " + typeof value);
                    value = typeof this.value === 'number' ? this.value : this.props.minValue || 0;
                }
                if (this.props.minValue != null) {
                    numericMin = this.props.minValue;
                }
                if (this.props.maxValue != null) {
                    numericMax = this.props.maxValue;
                }
                stepValue = this.props.minStep;
                break;
            }
            case "uint8" /* UINT8 */: {
                if (typeof value === "boolean") {
                    value = value ? 1 : 0;
                }
                if (typeof value === "string") {
                    // this.characteristicWarning(`characteristic was supplied illegal value: string instead of number. Supplying illegal values will throw errors in the future!`);
                    value = parseInt(value, 10);
                }
                if (typeof value === 'number' && isNaN(value)) {
                    this.characteristicWarning("characteristic was expected valid number and received NaN");
                    value = typeof this.value === 'number' ? this.value : this.props.minValue || 0;
                }
                if (typeof value !== "number") {
                    this.characteristicWarning("characteristic value expected number and received " + typeof value);
                    value = typeof this.value === 'number' ? this.value : this.props.minValue || 0;
                }
                numericMin = maxWithUndefined(this.props.minValue, request_util_1.numericLowerBound("uint8" /* UINT8 */));
                numericMax = minWithUndefined(this.props.maxValue, request_util_1.numericUpperBound("uint8" /* UINT8 */));
                stepValue = maxWithUndefined(this.props.minStep, 1);
                break;
            }
            case "uint16" /* UINT16 */: {
                if (typeof value === "boolean") {
                    value = value ? 1 : 0;
                }
                if (typeof value === "string") {
                    // this.characteristicWarning(`characteristic was supplied illegal value: string instead of number. Supplying illegal values will throw errors in the future!`);
                    value = parseInt(value, 10);
                }
                if (typeof value === 'number' && isNaN(value)) {
                    this.characteristicWarning("characteristic was expected valid number and received NaN");
                    value = typeof this.value === 'number' ? this.value : this.props.minValue || 0;
                }
                if (typeof value !== "number") {
                    this.characteristicWarning("characteristic value expected number and received " + typeof value);
                    value = typeof this.value === 'number' ? this.value : this.props.minValue || 0;
                }
                numericMin = maxWithUndefined(this.props.minValue, request_util_1.numericLowerBound("uint16" /* UINT16 */));
                numericMax = minWithUndefined(this.props.maxValue, request_util_1.numericUpperBound("uint16" /* UINT16 */));
                stepValue = maxWithUndefined(this.props.minStep, 1);
                break;
            }
            case "uint32" /* UINT32 */: {
                if (typeof value === "boolean") {
                    value = value ? 1 : 0;
                }
                if (typeof value === "string") {
                    // this.characteristicWarning(`characteristic was supplied illegal value: string instead of number. Supplying illegal values will throw errors in the future!`);
                    value = parseInt(value, 10);
                }
                if (typeof value === 'number' && isNaN(value)) {
                    this.characteristicWarning("characteristic was expected valid number and received NaN");
                    value = typeof this.value === 'number' ? this.value : this.props.minValue || 0;
                }
                if (typeof value !== "number") {
                    this.characteristicWarning("characteristic value expected number and received " + typeof value);
                    value = typeof this.value === 'number' ? this.value : this.props.minValue || 0;
                }
                numericMin = maxWithUndefined(this.props.minValue, request_util_1.numericLowerBound("uint32" /* UINT32 */));
                numericMax = minWithUndefined(this.props.maxValue, request_util_1.numericUpperBound("uint32" /* UINT32 */));
                stepValue = maxWithUndefined(this.props.minStep, 1);
                break;
            }
            case "uint64" /* UINT64 */: {
                if (typeof value === "boolean") {
                    value = value ? 1 : 0;
                }
                if (typeof value === "string") {
                    // this.characteristicWarning(`characteristic was supplied illegal value: string instead of number. Supplying illegal values will throw errors in the future!`);
                    value = parseInt(value, 10);
                }
                if (typeof value === 'number' && isNaN(value)) {
                    this.characteristicWarning("characteristic was expected valid number and received NaN");
                    value = typeof this.value === 'number' ? this.value : this.props.minValue || 0;
                }
                if (typeof value !== "number") {
                    this.characteristicWarning("characteristic value expected number and received " + typeof value);
                    value = typeof this.value === 'number' ? this.value : this.props.minValue || 0;
                }
                numericMin = maxWithUndefined(this.props.minValue, request_util_1.numericLowerBound("uint64" /* UINT64 */));
                numericMax = minWithUndefined(this.props.maxValue, request_util_1.numericUpperBound("uint64" /* UINT64 */));
                stepValue = maxWithUndefined(this.props.minStep, 1);
                break;
            }
            case "string" /* STRING */: {
                if (typeof value === "number") {
                    this.characteristicWarning("characteristic was supplied illegal value: number instead of string, supplying illegal values will throw errors in the future");
                    value = String(value);
                }
                if (typeof value !== "string") {
                    this.characteristicWarning("characteristic value expected string and received " + (typeof value));
                    value = typeof this.value === 'string' ? this.value : value + '';
                }
                if (value.length <= 1 && (this.UUID === Characteristic.Model.UUID || this.UUID === Characteristic.SerialNumber.UUID)) { // mirrors the case value = null at the beginning
                    this.characteristicWarning("[" + this.displayName + "] characteristic must have a length of more than 1 character otherwise HomeKit will reject this accessory, ignoring new value");
                    return this.value; // just return the current value
                }
                var maxLength = (_a = this.props.maxLen) !== null && _a !== void 0 ? _a : 64; // default is 64 (max is 256 which is set in setProps)
                if (value.length > maxLength) {
                    this.characteristicWarning("characteristic was supplied illegal value: string '" + value + "' exceeded max length of " + maxLength);
                    value = value.substring(0, maxLength);
                }
                return value;
            }
            case "data" /* DATA */:
                if (typeof value !== "string") {
                    throw new Error("characteristic with DATA format must have string value");
                }
                if (this.props.maxDataLen != null && value.length > this.props.maxDataLen) {
                    // can't cut it as we would basically yet binary rubbish afterwards
                    throw new Error("characteristic with DATA format exceeds specified maxDataLen");
                }
                return value;
            case "tlv8" /* TLV8 */:
                if (value === undefined) {
                    this.characteristicWarning("characteristic was supplied illegal value: undefined");
                    return this.value;
                }
                return value; // we trust that this is valid tlv8
        }
        if (typeof value === "number") {
            if (numericMin != null && value < numericMin) {
                this.characteristicWarning("characteristic was supplied illegal value: number " + value + " exceeded minimum of " + numericMin);
                value = numericMin;
            }
            if (numericMax != null && value > numericMax) {
                this.characteristicWarning("characteristic was supplied illegal value: number " + value + " exceeded maximum of " + numericMax);
                value = numericMax;
            }
            if (this.props.validValues && !this.props.validValues.includes(value)) {
                this.characteristicWarning("characteristic value " + value + " is not contained in valid values array");
                return this.props.validValues.includes(this.value) ? this.value : (this.props.validValues[0] || 0);
            }
            if (this.props.validValueRanges && this.props.validValueRanges.length === 2) {
                if (value < this.props.validValueRanges[0]) {
                    this.characteristicWarning("characteristic was supplied illegal value: number " + value + " not contained in valid value range of " + this.props.validValueRanges + ", supplying illegal values will throw errors in the future");
                    value = this.props.validValueRanges[0];
                }
                else if (value > this.props.validValueRanges[1]) {
                    this.characteristicWarning("characteristic was supplied illegal value: number " + value + " not contained in valid value range of " + this.props.validValueRanges + ", supplying illegal values will throw errors in the future");
                    value = this.props.validValueRanges[1];
                }
            }
            if (stepValue != undefined) {
                if (stepValue === 1) {
                    value = Math.round(value);
                }
                else if (stepValue > 1) {
                    value = Math.round(value);
                    value = value - (value % stepValue);
                } // for stepValue < 1 rounding is done only when formatting the response. We can't store the "perfect" .step anyways
            }
        }
        // hopefully it shouldn't get to this point
        if (value === undefined) {
            this.characteristicWarning("characteristic was supplied illegal value: undefined", "error-message" /* ERROR_MESSAGE */);
            return this.value;
        }
        return value;
    };
    /**
     * @private used to assign iid to characteristic
     */
    Characteristic.prototype._assignID = function (identifierCache, accessoryName, serviceUUID, serviceSubtype) {
        // generate our IID based on our UUID
        this.iid = identifierCache.getIID(accessoryName, serviceUUID, serviceSubtype, this.UUID);
    };
    Characteristic.prototype.characteristicWarning = function (message, type, stack) {
        if (type === void 0) { type = "warn-message" /* WARN_MESSAGE */; }
        if (stack === void 0) { stack = new Error().stack; }
        this.emit("characteristic-warning" /* CHARACTERISTIC_WARNING */, type, message, stack);
    };
    /**
     * @param event
     * @private
     */
    Characteristic.prototype.removeAllListeners = function (event) {
        if (!event) {
            this.removeOnGet();
            this.removeOnSet();
        }
        return _super.prototype.removeAllListeners.call(this, event);
    };
    /**
     * @param characteristic
     * @private
     */
    Characteristic.prototype.replaceBy = function (characteristic) {
        var _this = this;
        this.props = characteristic.props;
        this.updateValue(characteristic.value);
        var getListeners = characteristic.listeners("get" /* GET */);
        if (getListeners.length) {
            // the callback can only be called once so we remove all old listeners
            this.removeAllListeners("get" /* GET */);
            // @ts-expect-error
            getListeners.forEach(function (listener) { return _this.addListener("get" /* GET */, listener); });
        }
        this.removeOnGet();
        if (characteristic.getHandler) {
            this.onGet(characteristic.getHandler);
        }
        var setListeners = characteristic.listeners("set" /* SET */);
        if (setListeners.length) {
            // the callback can only be called once so we remove all old listeners
            this.removeAllListeners("set" /* SET */);
            // @ts-expect-error
            setListeners.forEach(function (listener) { return _this.addListener("set" /* SET */, listener); });
        }
        this.removeOnSet();
        if (characteristic.setHandler) {
            this.onSet(characteristic.setHandler);
        }
    };
    /**
     * Returns a JSON representation of this characteristic suitable for delivering to HAP clients.
     * @private used to generate response to /accessories query
     */
    Characteristic.prototype.toHAP = function (connection, contactGetHandlers) {
        if (contactGetHandlers === void 0) { contactGetHandlers = true; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var object, value, _a;
            var _this = this;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        object = this.internalHAPRepresentation();
                        if (!!this.props.perms.includes("pr" /* PAIRED_READ */)) return [3 /*break*/, 1];
                        object.value = undefined;
                        return [3 /*break*/, 6];
                    case 1:
                        if (!(this.UUID === Characteristic.ProgrammableSwitchEvent.UUID)) return [3 /*break*/, 2];
                        // special workaround for event only programmable switch event, which must always return null
                        object.value = null;
                        return [3 /*break*/, 6];
                    case 2:
                        if (!contactGetHandlers) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.handleGetRequest(connection).catch(function () {
                                debug('[%s] Error getting value for characteristic on /accessories request. Returning cached value instead: %s', _this.displayName, "" + _this.value);
                                return _this.value; // use cached value
                            })];
                    case 3:
                        _a = _b.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        _a = this.value;
                        _b.label = 5;
                    case 5:
                        value = _a;
                        object.value = request_util_1.formatOutgoingCharacteristicValue(value, this.props);
                        _b.label = 6;
                    case 6: return [2 /*return*/, object];
                }
            });
        });
    };
    /**
     * Returns a JSON representation of this characteristic without the value.
     * @private used to generate the config hash
     */
    Characteristic.prototype.internalHAPRepresentation = function () {
        assert_1.default(this.iid, "iid cannot be undefined for characteristic '" + this.displayName + "'");
        // TODO include the value for characteristics of the AccessoryInformation service
        return {
            type: uuid_1.toShortForm(this.UUID),
            iid: this.iid,
            value: null,
            perms: this.props.perms,
            description: this.props.description || this.displayName,
            format: this.props.format,
            unit: this.props.unit,
            minValue: this.props.minValue,
            maxValue: this.props.maxValue,
            minStep: this.props.minStep,
            maxLen: this.props.maxLen,
            maxDataLen: this.props.maxDataLen,
            "valid-values": this.props.validValues,
            "valid-values-range": this.props.validValueRanges,
        };
    };
    /**
     * Serialize characteristic into json string.
     *
     * @param characteristic - Characteristic object.
     * @private used to store characteristic on disk
     */
    Characteristic.serialize = function (characteristic) {
        var constructorName;
        if (characteristic.constructor.name !== "Characteristic") {
            constructorName = characteristic.constructor.name;
        }
        return {
            displayName: characteristic.displayName,
            UUID: characteristic.UUID,
            eventOnlyCharacteristic: characteristic.UUID === Characteristic.ProgrammableSwitchEvent.UUID,
            constructorName: constructorName,
            value: characteristic.value,
            props: clone_1.clone({}, characteristic.props),
        };
    };
    /**
     * Deserialize characteristic from json string.
     *
     * @param json - Json string representing a characteristic.
     * @private used to recreate characteristic from disk
     */
    Characteristic.deserialize = function (json) {
        var characteristic;
        if (json.constructorName && json.constructorName.charAt(0).toUpperCase() === json.constructorName.charAt(0)
            && Characteristic[json.constructorName]) { // MUST start with uppercase character and must exist on Characteristic object
            var constructor = Characteristic[json.constructorName];
            characteristic = new constructor();
            characteristic.displayName = json.displayName;
            characteristic.setProps(json.props);
        }
        else {
            characteristic = new Characteristic(json.displayName, json.UUID, json.props);
        }
        characteristic.value = json.value;
        return characteristic;
    };
    /**
     * @deprecated Please use the Formats const enum above. Scheduled to be removed in 2021-06.
     */
    // @ts-expect-error
    Characteristic.Formats = Formats;
    /**
     * @deprecated Please use the Units const enum above. Scheduled to be removed in 2021-06.
     */
    // @ts-expect-error
    Characteristic.Units = Units;
    /**
     * @deprecated Please use the Perms const enum above. Scheduled to be removed in 2021-06.
     */
    // @ts-expect-error
    Characteristic.Perms = Perms;
    return Characteristic;
}(events_1.EventEmitter));
exports.Characteristic = Characteristic;
var numberPattern = /^-?\d+$/;
function extractHAPStatusFromError(error) {
    var errorValue = -70402 /* SERVICE_COMMUNICATION_FAILURE */;
    if (numberPattern.test(error.message)) {
        var value = parseInt(error.message, 10);
        if (HAPServer_1.IsKnownHAPStatusError(value)) {
            errorValue = value;
        }
    }
    return errorValue;
}
function maxWithUndefined(a, b) {
    if (a === undefined) {
        return b;
    }
    else if (b === undefined) {
        return a;
    }
    else {
        return Math.max(a, b);
    }
}
function minWithUndefined(a, b) {
    if (a === undefined) {
        return b;
    }
    else if (b === undefined) {
        return a;
    }
    else {
        return Math.min(a, b);
    }
}
//# sourceMappingURL=Characteristic.js.map

/***/ }),

/***/ 7551:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HAPServer = exports.HAPServerEventTypes = exports.HAPPairingHTTPCode = exports.HAPHTTPCode = exports.Status = exports.Codes = exports.IsKnownHAPStatusError = exports.HAPStatus = exports.TLVErrorCode = void 0;
var tslib_1 = __nccwpck_require__(4290);
var crypto_1 = tslib_1.__importDefault(__nccwpck_require__(6417));
var debug_1 = tslib_1.__importDefault(__nccwpck_require__(7984));
var events_1 = __nccwpck_require__(8614);
var fast_srp_hap_1 = __nccwpck_require__(2796);
var tweetnacl_1 = tslib_1.__importDefault(__nccwpck_require__(9920));
var url_1 = __nccwpck_require__(8835);
var internal_types_1 = __nccwpck_require__(4824);
var eventedhttp_1 = __nccwpck_require__(1561);
var hapCrypto = tslib_1.__importStar(__nccwpck_require__(6272));
var once_1 = __nccwpck_require__(8597);
var tlv = tslib_1.__importStar(__nccwpck_require__(4041));
var debug = debug_1.default('HAP-NodeJS:HAPServer');
var TLVValues;
(function (TLVValues) {
    // noinspection JSUnusedGlobalSymbols
    TLVValues[TLVValues["REQUEST_TYPE"] = 0] = "REQUEST_TYPE";
    TLVValues[TLVValues["METHOD"] = 0] = "METHOD";
    TLVValues[TLVValues["USERNAME"] = 1] = "USERNAME";
    TLVValues[TLVValues["IDENTIFIER"] = 1] = "IDENTIFIER";
    TLVValues[TLVValues["SALT"] = 2] = "SALT";
    TLVValues[TLVValues["PUBLIC_KEY"] = 3] = "PUBLIC_KEY";
    TLVValues[TLVValues["PASSWORD_PROOF"] = 4] = "PASSWORD_PROOF";
    TLVValues[TLVValues["ENCRYPTED_DATA"] = 5] = "ENCRYPTED_DATA";
    TLVValues[TLVValues["SEQUENCE_NUM"] = 6] = "SEQUENCE_NUM";
    TLVValues[TLVValues["STATE"] = 6] = "STATE";
    TLVValues[TLVValues["ERROR_CODE"] = 7] = "ERROR_CODE";
    TLVValues[TLVValues["RETRY_DELAY"] = 8] = "RETRY_DELAY";
    TLVValues[TLVValues["CERTIFICATE"] = 9] = "CERTIFICATE";
    TLVValues[TLVValues["PROOF"] = 10] = "PROOF";
    TLVValues[TLVValues["SIGNATURE"] = 10] = "SIGNATURE";
    TLVValues[TLVValues["PERMISSIONS"] = 11] = "PERMISSIONS";
    TLVValues[TLVValues["FRAGMENT_DATA"] = 12] = "FRAGMENT_DATA";
    TLVValues[TLVValues["FRAGMENT_LAST"] = 13] = "FRAGMENT_LAST";
    TLVValues[TLVValues["SEPARATOR"] = 255] = "SEPARATOR"; // Zero-length TLV that separates different TLVs in a list.
})(TLVValues || (TLVValues = {}));
var PairMethods;
(function (PairMethods) {
    // noinspection JSUnusedGlobalSymbols
    PairMethods[PairMethods["PAIR_SETUP"] = 0] = "PAIR_SETUP";
    PairMethods[PairMethods["PAIR_SETUP_WITH_AUTH"] = 1] = "PAIR_SETUP_WITH_AUTH";
    PairMethods[PairMethods["PAIR_VERIFY"] = 2] = "PAIR_VERIFY";
    PairMethods[PairMethods["ADD_PAIRING"] = 3] = "ADD_PAIRING";
    PairMethods[PairMethods["REMOVE_PAIRING"] = 4] = "REMOVE_PAIRING";
    PairMethods[PairMethods["LIST_PAIRINGS"] = 5] = "LIST_PAIRINGS";
})(PairMethods || (PairMethods = {}));
/**
 * Pairing states (pair-setup or pair-verify). Encoded in {@link TLVValues.SEQUENCE_NUM}.
 */
var PairingStates;
(function (PairingStates) {
    PairingStates[PairingStates["M1"] = 1] = "M1";
    PairingStates[PairingStates["M2"] = 2] = "M2";
    PairingStates[PairingStates["M3"] = 3] = "M3";
    PairingStates[PairingStates["M4"] = 4] = "M4";
    PairingStates[PairingStates["M5"] = 5] = "M5";
    PairingStates[PairingStates["M6"] = 6] = "M6";
})(PairingStates || (PairingStates = {}));
/**
 * TLV error codes for the {@link TLVValues.ERROR_CODE} field.
 */
var TLVErrorCode;
(function (TLVErrorCode) {
    // noinspection JSUnusedGlobalSymbols
    TLVErrorCode[TLVErrorCode["UNKNOWN"] = 1] = "UNKNOWN";
    TLVErrorCode[TLVErrorCode["INVALID_REQUEST"] = 2] = "INVALID_REQUEST";
    TLVErrorCode[TLVErrorCode["AUTHENTICATION"] = 2] = "AUTHENTICATION";
    TLVErrorCode[TLVErrorCode["BACKOFF"] = 3] = "BACKOFF";
    TLVErrorCode[TLVErrorCode["MAX_PEERS"] = 4] = "MAX_PEERS";
    TLVErrorCode[TLVErrorCode["MAX_TRIES"] = 5] = "MAX_TRIES";
    TLVErrorCode[TLVErrorCode["UNAVAILABLE"] = 6] = "UNAVAILABLE";
    TLVErrorCode[TLVErrorCode["BUSY"] = 7] = "BUSY"; // cannot accept pairing request at this time
})(TLVErrorCode = exports.TLVErrorCode || (exports.TLVErrorCode = {}));
var HAPStatus;
(function (HAPStatus) {
    // noinspection JSUnusedGlobalSymbols
    HAPStatus[HAPStatus["SUCCESS"] = 0] = "SUCCESS";
    HAPStatus[HAPStatus["INSUFFICIENT_PRIVILEGES"] = -70401] = "INSUFFICIENT_PRIVILEGES";
    HAPStatus[HAPStatus["SERVICE_COMMUNICATION_FAILURE"] = -70402] = "SERVICE_COMMUNICATION_FAILURE";
    HAPStatus[HAPStatus["RESOURCE_BUSY"] = -70403] = "RESOURCE_BUSY";
    HAPStatus[HAPStatus["READ_ONLY_CHARACTERISTIC"] = -70404] = "READ_ONLY_CHARACTERISTIC";
    HAPStatus[HAPStatus["WRITE_ONLY_CHARACTERISTIC"] = -70405] = "WRITE_ONLY_CHARACTERISTIC";
    HAPStatus[HAPStatus["NOTIFICATION_NOT_SUPPORTED"] = -70406] = "NOTIFICATION_NOT_SUPPORTED";
    HAPStatus[HAPStatus["OUT_OF_RESOURCE"] = -70407] = "OUT_OF_RESOURCE";
    HAPStatus[HAPStatus["OPERATION_TIMED_OUT"] = -70408] = "OPERATION_TIMED_OUT";
    HAPStatus[HAPStatus["RESOURCE_DOES_NOT_EXIST"] = -70409] = "RESOURCE_DOES_NOT_EXIST";
    HAPStatus[HAPStatus["INVALID_VALUE_IN_REQUEST"] = -70410] = "INVALID_VALUE_IN_REQUEST";
    HAPStatus[HAPStatus["INSUFFICIENT_AUTHORIZATION"] = -70411] = "INSUFFICIENT_AUTHORIZATION";
    HAPStatus[HAPStatus["NOT_ALLOWED_IN_CURRENT_STATE"] = -70412] = "NOT_ALLOWED_IN_CURRENT_STATE";
    // when adding new status codes, remember to update bounds in IsKnownHAPStatusError below
})(HAPStatus = exports.HAPStatus || (exports.HAPStatus = {}));
/**
 * Determines if the given status code is a known {@link HAPStatus} error code.
 */
function IsKnownHAPStatusError(status) {
    return (
    // Lower bound (most negative error code)
    status >= -70412 /* NOT_ALLOWED_IN_CURRENT_STATE */ &&
        // Upper bound (negative error code closest to zero)
        status <= -70401 /* INSUFFICIENT_PRIVILEGES */);
}
exports.IsKnownHAPStatusError = IsKnownHAPStatusError;
// noinspection JSUnusedGlobalSymbols
/**
 * @deprecated please use {@link TLVErrorCode} as naming is more precise
 */
// @ts-expect-error (as we use const enums with --preserveConstEnums)
exports.Codes = TLVErrorCode;
// noinspection JSUnusedGlobalSymbols
/**
 * @deprecated please use {@link HAPStatus} as naming is more precise
 */
// @ts-expect-error (as we use const enums with --preserveConstEnums)
exports.Status = HAPStatus;
/**
 * Those status codes are the one listed as appropriate for the HAP spec!
 *
 * When the response is a client error 4xx or server error 5xx, the response
 * must include a status {@link HAPStatus} property.
 *
 * When the response is a MULTI_STATUS EVERY entry in the characteristics property MUST include a status property (even success).
 */
var HAPHTTPCode;
(function (HAPHTTPCode) {
    // noinspection JSUnusedGlobalSymbols
    HAPHTTPCode[HAPHTTPCode["OK"] = 200] = "OK";
    HAPHTTPCode[HAPHTTPCode["NO_CONTENT"] = 204] = "NO_CONTENT";
    HAPHTTPCode[HAPHTTPCode["MULTI_STATUS"] = 207] = "MULTI_STATUS";
    // client error
    HAPHTTPCode[HAPHTTPCode["BAD_REQUEST"] = 400] = "BAD_REQUEST";
    HAPHTTPCode[HAPHTTPCode["NOT_FOUND"] = 404] = "NOT_FOUND";
    HAPHTTPCode[HAPHTTPCode["UNPROCESSABLE_ENTITY"] = 422] = "UNPROCESSABLE_ENTITY";
    // server error
    HAPHTTPCode[HAPHTTPCode["INTERNAL_SERVER_ERROR"] = 500] = "INTERNAL_SERVER_ERROR";
    HAPHTTPCode[HAPHTTPCode["SERVICE_UNAVAILABLE"] = 503] = "SERVICE_UNAVAILABLE";
})(HAPHTTPCode = exports.HAPHTTPCode || (exports.HAPHTTPCode = {}));
/**
 * When in a request is made to the pairing endpoints, and mime type is 'application/pairing+tlv8'
 * one should use the below status codes.
 */
var HAPPairingHTTPCode;
(function (HAPPairingHTTPCode) {
    // noinspection JSUnusedGlobalSymbols
    HAPPairingHTTPCode[HAPPairingHTTPCode["OK"] = 200] = "OK";
    HAPPairingHTTPCode[HAPPairingHTTPCode["BAD_REQUEST"] = 400] = "BAD_REQUEST";
    HAPPairingHTTPCode[HAPPairingHTTPCode["METHOD_NOT_ALLOWED"] = 405] = "METHOD_NOT_ALLOWED";
    HAPPairingHTTPCode[HAPPairingHTTPCode["TOO_MANY_REQUESTS"] = 429] = "TOO_MANY_REQUESTS";
    HAPPairingHTTPCode[HAPPairingHTTPCode["CONNECTION_AUTHORIZATION_REQUIRED"] = 470] = "CONNECTION_AUTHORIZATION_REQUIRED";
    HAPPairingHTTPCode[HAPPairingHTTPCode["INTERNAL_SERVER_ERROR"] = 500] = "INTERNAL_SERVER_ERROR";
})(HAPPairingHTTPCode = exports.HAPPairingHTTPCode || (exports.HAPPairingHTTPCode = {}));
var HAPServerEventTypes;
(function (HAPServerEventTypes) {
    /**
     * Emitted when the server is fully set up and ready to receive connections.
     */
    HAPServerEventTypes["LISTENING"] = "listening";
    /**
     * Emitted when a client wishes for this server to identify itself before pairing. You must call the
     * callback to respond to the client with success.
     */
    HAPServerEventTypes["IDENTIFY"] = "identify";
    HAPServerEventTypes["ADD_PAIRING"] = "add-pairing";
    HAPServerEventTypes["REMOVE_PAIRING"] = "remove-pairing";
    HAPServerEventTypes["LIST_PAIRINGS"] = "list-pairings";
    /**
     * This event is emitted when a client completes the "pairing" process and exchanges encryption keys.
     * Note that this does not mean the "Add Accessory" process in iOS has completed.
     * You must call the callback to complete the process.
     */
    HAPServerEventTypes["PAIR"] = "pair";
    /**
     * This event is emitted when a client requests the complete representation of Accessory data for
     * this Accessory (for instance, what services, characteristics, etc. are supported) and any bridged
     * Accessories in the case of a Bridge Accessory. The listener must call the provided callback function
     * when the accessory data is ready. We will automatically JSON.stringify the data.
     */
    HAPServerEventTypes["ACCESSORIES"] = "accessories";
    /**
     * This event is emitted when a client wishes to retrieve the current value of one or more characteristics.
     * The listener must call the provided callback function when the values are ready. iOS clients can typically
     * wait up to 10 seconds for this call to return. We will automatically JSON.stringify the data (which must
     * be an array) and wrap it in an object with a top-level "characteristics" property.
     */
    HAPServerEventTypes["GET_CHARACTERISTICS"] = "get-characteristics";
    /**
     * This event is emitted when a client wishes to set the current value of one or more characteristics and/or
     * subscribe to one or more events. The 'events' param is an initially-empty object, associated with the current
     * connection, on which you may store event registration keys for later processing. The listener must call
     * the provided callback when the request has been processed.
     */
    HAPServerEventTypes["SET_CHARACTERISTICS"] = "set-characteristics";
    HAPServerEventTypes["REQUEST_RESOURCE"] = "request-resource";
    HAPServerEventTypes["CONNECTION_CLOSED"] = "connection-closed";
})(HAPServerEventTypes = exports.HAPServerEventTypes || (exports.HAPServerEventTypes = {}));
/**
 * The actual HAP server that iOS devices talk to.
 *
 * Notes
 * -----
 * It turns out that the IP-based version of HomeKit's HAP protocol operates over a sort of pseudo-HTTP.
 * Accessories are meant to host a TCP socket server that initially behaves exactly as an HTTP/1.1 server.
 * So iOS devices will open up a long-lived connection to this server and begin issuing HTTP requests.
 * So far, this conforms with HTTP/1.1 Keepalive. However, after the "pairing" process is complete, the
 * connection is expected to be "upgraded" to support full-packet encryption of both HTTP headers and data.
 * This encryption is NOT SSL. It is a customized ChaCha20+Poly1305 encryption layer.
 *
 * Additionally, this "HTTP Server" supports sending "event" responses at any time without warning. The iOS
 * device simply keeps the connection open after it's finished with HTTP request/response traffic, and while
 * the connection is open, the server can elect to issue "EVENT/1.0 200 OK" HTTP-style responses. These are
 * typically sent to inform the iOS device of a characteristic change for the accessory (like "Door was Unlocked").
 *
 * See eventedhttp.js for more detail on the implementation of this protocol.
 */
var HAPServer = /** @class */ (function (_super) {
    tslib_1.__extends(HAPServer, _super);
    function HAPServer(accessoryInfo) {
        var _this = _super.call(this) || this;
        _this.unsuccessfulPairAttempts = 0; // after 100 unsuccessful attempts the server won't accept any further attempts. Will currently be reset on a reboot
        _this.accessoryInfo = accessoryInfo;
        _this.allowInsecureRequest = false;
        // internal server that does all the actual communication
        _this.httpServer = new eventedhttp_1.EventedHTTPServer();
        _this.httpServer.on("listening" /* LISTENING */, _this.onListening.bind(_this));
        _this.httpServer.on("request" /* REQUEST */, _this.handleRequestOnHAPConnection.bind(_this));
        _this.httpServer.on("connection-closed" /* CONNECTION_CLOSED */, _this.handleConnectionClosed.bind(_this));
        return _this;
    }
    HAPServer.prototype.listen = function (port, host) {
        if (port === void 0) { port = 0; }
        if (host === "::") {
            // this will workaround "EAFNOSUPPORT: address family not supported" errors
            // on systems where IPv6 is not supported/enabled, we just use the node default then by supplying undefined
            host = undefined;
        }
        this.httpServer.listen(port, host);
    };
    HAPServer.prototype.stop = function () {
        this.httpServer.stop();
    };
    HAPServer.prototype.destroy = function () {
        this.stop();
        this.removeAllListeners();
    };
    /**
     * Send a even notification for given characteristic and changed value to all connected clients.
     * If {@param originator} is specified, the given {@link HAPConnection} will be excluded from the broadcast.
     *
     * @param aid - The accessory id of the updated characteristic.
     * @param iid - The instance id of the updated characteristic.
     * @param value - The newly set value of the characteristic.
     * @param originator - If specified, the connection will not get a event message.
     * @param immediateDelivery - The HAP spec requires some characteristics to be delivery immediately.
     *   Namely for the {@link ButtonEvent} and the {@link ProgrammableSwitchEvent} characteristics.
     */
    HAPServer.prototype.sendEventNotifications = function (aid, iid, value, originator, immediateDelivery) {
        try {
            this.httpServer.broadcastEvent(aid, iid, value, originator, immediateDelivery);
        }
        catch (error) {
            console.warn("[" + this.accessoryInfo.username + "] Error when sending event notifications: " + error.message);
        }
    };
    HAPServer.prototype.onListening = function (port, hostname) {
        this.emit("listening" /* LISTENING */, port, hostname);
    };
    // Called when an HTTP request was detected.
    HAPServer.prototype.handleRequestOnHAPConnection = function (connection, request, response) {
        var _this = this;
        debug("[%s] HAP Request: %s %s", this.accessoryInfo.username, request.method, request.url);
        var buffers = [];
        request.on('data', function (data) { return buffers.push(data); });
        request.on('end', function () {
            var url = new url_1.URL(request.url, "http://hap-nodejs.local"); // parse the url (query strings etc)
            var handler = _this.getHandler(url); // TODO check that content-type is supported by the handler?
            if (!handler) {
                debug("[%s] WARNING: Handler for %s not implemented", _this.accessoryInfo.username, request.url);
                response.writeHead(404 /* NOT_FOUND */, { 'Content-Type': 'application/hap+json' });
                response.end(JSON.stringify({ status: -70409 /* RESOURCE_DOES_NOT_EXIST */ }));
            }
            else {
                var data = Buffer.concat(buffers);
                try {
                    handler(connection, url, request, data, response);
                }
                catch (error) {
                    debug("[%s] Error executing route handler: %s", _this.accessoryInfo.username, error.stack);
                    response.writeHead(500 /* INTERNAL_SERVER_ERROR */, { 'Content-Type': 'application/hap+json' });
                    response.end(JSON.stringify({ status: -70403 /* RESOURCE_BUSY */ })); // resource busy try again, does somehow fit?
                }
            }
        });
    };
    HAPServer.prototype.handleConnectionClosed = function (connection) {
        this.emit("connection-closed" /* CONNECTION_CLOSED */, connection);
    };
    HAPServer.prototype.getHandler = function (url) {
        switch (url.pathname.toLowerCase()) {
            case "/identify":
                return this.handleIdentifyRequest.bind(this);
            case "/pair-setup":
                return this.handlePairSetup.bind(this);
            case "/pair-verify":
                return this.handlePairVerify.bind(this);
            case "/pairings":
                return this.handlePairings.bind(this);
            case "/accessories":
                return this.handleAccessories.bind(this);
            case "/characteristics":
                return this.handleCharacteristics.bind(this);
            case "/prepare":
                return this.handlePrepareWrite.bind(this);
            case "/resource":
                return this.handleResource.bind(this);
            default:
                return undefined;
        }
    };
    /**
     * UNPAIRED Accessory identification.
     */
    HAPServer.prototype.handleIdentifyRequest = function (connection, url, request, data, response) {
        var _this = this;
        // POST body is empty
        if (!this.allowInsecureRequest && this.accessoryInfo.paired()) {
            response.writeHead(400 /* BAD_REQUEST */, { "Content-Type": "application/hap+json" });
            response.end(JSON.stringify({ status: -70401 /* INSUFFICIENT_PRIVILEGES */ }));
            return;
        }
        this.emit("identify" /* IDENTIFY */, once_1.once(function (err) {
            if (!err) {
                debug("[%s] Identification success", _this.accessoryInfo.username);
                response.writeHead(204 /* NO_CONTENT */);
                response.end();
            }
            else {
                debug("[%s] Identification error: %s", _this.accessoryInfo.username, err.message);
                response.writeHead(500 /* INTERNAL_SERVER_ERROR */, { "Content-Type": "application/hap+json" });
                response.end(JSON.stringify({ status: -70403 /* RESOURCE_BUSY */ }));
            }
        }));
    };
    HAPServer.prototype.handlePairSetup = function (connection, url, request, data, response) {
        // Can only be directly paired with one iOS device
        if (!this.allowInsecureRequest && this.accessoryInfo.paired()) {
            response.writeHead(200 /* OK */, { "Content-Type": "application/pairing+tlv8" });
            response.end(tlv.encode(6 /* STATE */, 2 /* M2 */, 7 /* ERROR_CODE */, 6 /* UNAVAILABLE */));
            return;
        }
        if (this.unsuccessfulPairAttempts > 100) {
            debug("[%s] Reached maximum amount of unsuccessful pair attempts!", this.accessoryInfo.username);
            response.writeHead(200 /* OK */, { "Content-Type": "application/pairing+tlv8" });
            response.end(tlv.encode(6 /* STATE */, 2 /* M2 */, 7 /* ERROR_CODE */, 5 /* MAX_TRIES */));
            return;
        }
        var tlvData = tlv.decode(data);
        var sequence = tlvData[6 /* SEQUENCE_NUM */][0]; // value is single byte with sequence number
        if (sequence == 1 /* M1 */) {
            this.handlePairSetupM1(connection, request, response);
        }
        else if (sequence == 3 /* M3 */ && connection._pairSetupState === 2 /* M2 */) {
            this.handlePairSetupM3(connection, request, response, tlvData);
        }
        else if (sequence == 5 /* M5 */ && connection._pairSetupState === 4 /* M4 */) {
            this.handlePairSetupM5(connection, request, response, tlvData);
        }
        else {
            // Invalid state/sequence number
            response.writeHead(400 /* BAD_REQUEST */, { "Content-Type": "application/pairing+tlv8" });
            response.end(tlv.encode(6 /* STATE */, sequence + 1, 7 /* ERROR_CODE */, 1 /* UNKNOWN */));
            return;
        }
    };
    HAPServer.prototype.handlePairSetupM1 = function (connection, request, response) {
        var _this = this;
        debug("[%s] Pair step 1/5", this.accessoryInfo.username);
        var salt = crypto_1.default.randomBytes(16);
        var srpParams = fast_srp_hap_1.SRP.params.hap;
        fast_srp_hap_1.SRP.genKey(32).then(function (key) {
            // create a new SRP server
            var srpServer = new fast_srp_hap_1.SrpServer(srpParams, salt, Buffer.from("Pair-Setup"), Buffer.from(_this.accessoryInfo.pincode), key);
            var srpB = srpServer.computeB();
            // attach it to the current TCP session
            connection.srpServer = srpServer;
            response.writeHead(200 /* OK */, { "Content-Type": "application/pairing+tlv8" });
            response.end(tlv.encode(6 /* SEQUENCE_NUM */, 2 /* M2 */, 2 /* SALT */, salt, 3 /* PUBLIC_KEY */, srpB));
            connection._pairSetupState = 2 /* M2 */;
        }).catch(function (error) {
            debug("[%s] Error occurred when generating srp key: %s", _this.accessoryInfo.username, error.message);
            response.writeHead(200 /* OK */, { "Content-Type": "application/pairing+tlv8" });
            response.end(tlv.encode(6 /* STATE */, 2 /* M2 */, 7 /* ERROR_CODE */, 1 /* UNKNOWN */));
            return;
        });
    };
    HAPServer.prototype.handlePairSetupM3 = function (connection, request, response, tlvData) {
        debug("[%s] Pair step 2/5", this.accessoryInfo.username);
        var A = tlvData[3 /* PUBLIC_KEY */]; // "A is a public key that exists only for a single login session."
        var M1 = tlvData[4 /* PASSWORD_PROOF */]; // "M1 is the proof that you actually know your own password."
        // pull the SRP server we created in stepOne out of the current session
        var srpServer = connection.srpServer;
        srpServer.setA(A);
        try {
            srpServer.checkM1(M1);
        }
        catch (err) {
            // most likely the client supplied an incorrect pincode.
            this.unsuccessfulPairAttempts++;
            debug("[%s] Error while checking pincode: %s", this.accessoryInfo.username, err.message);
            response.writeHead(200 /* OK */, { "Content-Type": "application/pairing+tlv8" });
            response.end(tlv.encode(6 /* SEQUENCE_NUM */, 4 /* M4 */, 7 /* ERROR_CODE */, 2 /* AUTHENTICATION */));
            connection._pairSetupState = undefined;
            return;
        }
        // "M2 is the proof that the server actually knows your password."
        var M2 = srpServer.computeM2();
        response.writeHead(200 /* OK */, { "Content-Type": "application/pairing+tlv8" });
        response.end(tlv.encode(6 /* SEQUENCE_NUM */, 4 /* M4 */, 4 /* PASSWORD_PROOF */, M2));
        connection._pairSetupState = 4 /* M4 */;
    };
    HAPServer.prototype.handlePairSetupM5 = function (connection, request, response, tlvData) {
        debug("[%s] Pair step 3/5", this.accessoryInfo.username);
        // pull the SRP server we created in stepOne out of the current session
        var srpServer = connection.srpServer;
        var encryptedData = tlvData[5 /* ENCRYPTED_DATA */];
        var messageData = Buffer.alloc(encryptedData.length - 16);
        var authTagData = Buffer.alloc(16);
        encryptedData.copy(messageData, 0, 0, encryptedData.length - 16);
        encryptedData.copy(authTagData, 0, encryptedData.length - 16, encryptedData.length);
        var S_private = srpServer.computeK();
        var encSalt = Buffer.from("Pair-Setup-Encrypt-Salt");
        var encInfo = Buffer.from("Pair-Setup-Encrypt-Info");
        var outputKey = hapCrypto.HKDF("sha512", encSalt, S_private, encInfo, 32);
        var plaintext;
        try {
            plaintext = hapCrypto.chacha20_poly1305_decryptAndVerify(outputKey, Buffer.from("PS-Msg05"), null, messageData, authTagData);
        }
        catch (error) {
            debug("[%s] Error while decrypting and verifying M5 subTlv: %s", this.accessoryInfo.username);
            response.writeHead(200 /* OK */, { "Content-Type": "application/pairing+tlv8" });
            response.end(tlv.encode(6 /* SEQUENCE_NUM */, 4 /* M4 */, 7 /* ERROR_CODE */, 2 /* AUTHENTICATION */));
            connection._pairSetupState = undefined;
            return;
        }
        // decode the client payload and pass it on to the next step
        var M5Packet = tlv.decode(plaintext);
        var clientUsername = M5Packet[1 /* USERNAME */];
        var clientLTPK = M5Packet[3 /* PUBLIC_KEY */];
        var clientProof = M5Packet[10 /* PROOF */];
        this.handlePairSetupM5_2(connection, request, response, clientUsername, clientLTPK, clientProof, outputKey);
    };
    // M5-2
    HAPServer.prototype.handlePairSetupM5_2 = function (connection, request, response, clientUsername, clientLTPK, clientProof, hkdfEncKey) {
        debug("[%s] Pair step 4/5", this.accessoryInfo.username);
        var S_private = connection.srpServer.computeK();
        var controllerSalt = Buffer.from("Pair-Setup-Controller-Sign-Salt");
        var controllerInfo = Buffer.from("Pair-Setup-Controller-Sign-Info");
        var outputKey = hapCrypto.HKDF("sha512", controllerSalt, S_private, controllerInfo, 32);
        var completeData = Buffer.concat([outputKey, clientUsername, clientLTPK]);
        if (!tweetnacl_1.default.sign.detached.verify(completeData, clientProof, clientLTPK)) {
            debug("[%s] Invalid signature", this.accessoryInfo.username);
            response.writeHead(200 /* OK */, { "Content-Type": "application/pairing+tlv8" });
            response.end(tlv.encode(6 /* SEQUENCE_NUM */, 6 /* M6 */, 7 /* ERROR_CODE */, 2 /* AUTHENTICATION */));
            connection._pairSetupState = undefined;
            return;
        }
        this.handlePairSetupM5_3(connection, request, response, clientUsername, clientLTPK, hkdfEncKey);
    };
    // M5 - F + M6
    HAPServer.prototype.handlePairSetupM5_3 = function (connection, request, response, clientUsername, clientLTPK, hkdfEncKey) {
        var _this = this;
        debug("[%s] Pair step 5/5", this.accessoryInfo.username);
        var S_private = connection.srpServer.computeK();
        var accessorySalt = Buffer.from("Pair-Setup-Accessory-Sign-Salt");
        var accessoryInfo = Buffer.from("Pair-Setup-Accessory-Sign-Info");
        var outputKey = hapCrypto.HKDF("sha512", accessorySalt, S_private, accessoryInfo, 32);
        var serverLTPK = this.accessoryInfo.signPk;
        var usernameData = Buffer.from(this.accessoryInfo.username);
        var material = Buffer.concat([outputKey, usernameData, serverLTPK]);
        var privateKey = Buffer.from(this.accessoryInfo.signSk);
        var serverProof = tweetnacl_1.default.sign.detached(material, privateKey);
        var message = tlv.encode(1 /* USERNAME */, usernameData, 3 /* PUBLIC_KEY */, serverLTPK, 10 /* PROOF */, serverProof);
        var encrypted = hapCrypto.chacha20_poly1305_encryptAndSeal(hkdfEncKey, Buffer.from("PS-Msg06"), null, message);
        // finally, notify listeners that we have been paired with a client
        this.emit("pair" /* PAIR */, clientUsername.toString(), clientLTPK, once_1.once(function (err) {
            if (err) {
                debug("[%s] Error adding pairing info: %s", _this.accessoryInfo.username, err.message);
                response.writeHead(200 /* OK */, { "Content-Type": "application/pairing+tlv8" });
                response.end(tlv.encode(6 /* SEQUENCE_NUM */, 6 /* M6 */, 7 /* ERROR_CODE */, 1 /* UNKNOWN */));
                connection._pairSetupState = undefined;
                return;
            }
            // send final pairing response to client
            response.writeHead(200 /* OK */, { "Content-Type": "application/pairing+tlv8" });
            response.end(tlv.encode(6 /* SEQUENCE_NUM */, 6 /* M6 */, 5 /* ENCRYPTED_DATA */, Buffer.concat([encrypted.ciphertext, encrypted.authTag])));
            connection._pairSetupState = undefined;
        }));
    };
    HAPServer.prototype.handlePairVerify = function (connection, url, request, data, response) {
        var tlvData = tlv.decode(data);
        var sequence = tlvData[6 /* SEQUENCE_NUM */][0]; // value is single byte with sequence number
        if (sequence == 1 /* M1 */)
            this.handlePairVerifyM1(connection, request, response, tlvData);
        else if (sequence == 3 /* M3 */ && connection._pairVerifyState === 2 /* M2 */)
            this.handlePairVerifyM2(connection, request, response, tlvData);
        else {
            // Invalid state/sequence number
            response.writeHead(400 /* BAD_REQUEST */, { "Content-Type": "application/pairing+tlv8" });
            response.end(tlv.encode(6 /* STATE */, sequence + 1, 7 /* ERROR_CODE */, 1 /* UNKNOWN */));
            return;
        }
    };
    HAPServer.prototype.handlePairVerifyM1 = function (connection, request, response, tlvData) {
        debug("[%s] Pair verify step 1/2", this.accessoryInfo.username);
        var clientPublicKey = tlvData[3 /* PUBLIC_KEY */]; // Buffer
        // generate new encryption keys for this session
        var keyPair = hapCrypto.generateCurve25519KeyPair();
        var secretKey = Buffer.from(keyPair.secretKey);
        var publicKey = Buffer.from(keyPair.publicKey);
        var sharedSec = Buffer.from(hapCrypto.generateCurve25519SharedSecKey(secretKey, clientPublicKey));
        var usernameData = Buffer.from(this.accessoryInfo.username);
        var material = Buffer.concat([publicKey, usernameData, clientPublicKey]);
        var privateKey = Buffer.from(this.accessoryInfo.signSk);
        var serverProof = tweetnacl_1.default.sign.detached(material, privateKey);
        var encSalt = Buffer.from("Pair-Verify-Encrypt-Salt");
        var encInfo = Buffer.from("Pair-Verify-Encrypt-Info");
        var outputKey = hapCrypto.HKDF("sha512", encSalt, sharedSec, encInfo, 32).slice(0, 32);
        connection.encryption = new eventedhttp_1.HAPEncryption(clientPublicKey, secretKey, publicKey, sharedSec, outputKey);
        // compose the response data in TLV format
        var message = tlv.encode(1 /* USERNAME */, usernameData, 10 /* PROOF */, serverProof);
        var encrypted = hapCrypto.chacha20_poly1305_encryptAndSeal(outputKey, Buffer.from("PV-Msg02"), null, message);
        response.writeHead(200 /* OK */, { "Content-Type": "application/pairing+tlv8" });
        response.end(tlv.encode(6 /* SEQUENCE_NUM */, 2 /* M2 */, 5 /* ENCRYPTED_DATA */, Buffer.concat([encrypted.ciphertext, encrypted.authTag]), 3 /* PUBLIC_KEY */, publicKey));
        connection._pairVerifyState = 2 /* M2 */;
    };
    HAPServer.prototype.handlePairVerifyM2 = function (connection, request, response, objects) {
        debug("[%s] Pair verify step 2/2", this.accessoryInfo.username);
        var encryptedData = objects[5 /* ENCRYPTED_DATA */];
        var messageData = Buffer.alloc(encryptedData.length - 16);
        var authTagData = Buffer.alloc(16);
        encryptedData.copy(messageData, 0, 0, encryptedData.length - 16);
        encryptedData.copy(authTagData, 0, encryptedData.length - 16, encryptedData.length);
        // instance of HAPEncryption (created in handlePairVerifyStepOne)
        var enc = connection.encryption;
        var plaintext;
        try {
            plaintext = hapCrypto.chacha20_poly1305_decryptAndVerify(enc.hkdfPairEncryptionKey, Buffer.from("PV-Msg03"), null, messageData, authTagData);
        }
        catch (error) {
            debug("[%s] M3: Failed to decrypt and/or verify", this.accessoryInfo.username);
            response.writeHead(200 /* OK */, { "Content-Type": "application/pairing+tlv8" });
            response.end(tlv.encode(6 /* STATE */, 4 /* M4 */, 7 /* ERROR_CODE */, 2 /* AUTHENTICATION */));
            connection._pairVerifyState = undefined;
            return;
        }
        var decoded = tlv.decode(plaintext);
        var clientUsername = decoded[1 /* USERNAME */];
        var proof = decoded[10 /* PROOF */];
        var material = Buffer.concat([enc.clientPublicKey, clientUsername, enc.publicKey]);
        // since we're paired, we should have the public key stored for this client
        var clientPublicKey = this.accessoryInfo.getClientPublicKey(clientUsername.toString());
        // if we're not actually paired, then there's nothing to verify - this client thinks it's paired with us but we
        // disagree. Respond with invalid request (seems to match HomeKit Accessory Simulator behavior)
        if (!clientPublicKey) {
            debug("[%s] Client %s attempting to verify, but we are not paired; rejecting client", this.accessoryInfo.username, clientUsername);
            response.writeHead(200 /* OK */, { "Content-Type": "application/pairing+tlv8" });
            response.end(tlv.encode(6 /* STATE */, 4 /* M4 */, 7 /* ERROR_CODE */, 2 /* AUTHENTICATION */));
            connection._pairVerifyState = undefined;
            return;
        }
        if (!tweetnacl_1.default.sign.detached.verify(material, proof, clientPublicKey)) {
            debug("[%s] Client %s provided an invalid signature", this.accessoryInfo.username, clientUsername);
            response.writeHead(200 /* OK */, { "Content-Type": "application/pairing+tlv8" });
            response.end(tlv.encode(6 /* STATE */, 4 /* M4 */, 7 /* ERROR_CODE */, 2 /* AUTHENTICATION */));
            connection._pairVerifyState = undefined;
            return;
        }
        debug("[%s] Client %s verification complete", this.accessoryInfo.username, clientUsername);
        response.writeHead(200 /* OK */, { "Content-Type": "application/pairing+tlv8" });
        response.end(tlv.encode(6 /* SEQUENCE_NUM */, 4 /* M4 */));
        // now that the client has been verified, we must "upgrade" our pseudo-HTTP connection to include
        // TCP-level encryption. We'll do this by adding some more encryption vars to the session, and using them
        // in future calls to onEncrypt, onDecrypt.
        var encSalt = Buffer.from("Control-Salt");
        var infoRead = Buffer.from("Control-Read-Encryption-Key");
        var infoWrite = Buffer.from("Control-Write-Encryption-Key");
        enc.accessoryToControllerKey = hapCrypto.HKDF("sha512", encSalt, enc.sharedSecret, infoRead, 32);
        enc.controllerToAccessoryKey = hapCrypto.HKDF("sha512", encSalt, enc.sharedSecret, infoWrite, 32);
        // Our connection is now completely setup. We now want to subscribe this connection to special
        connection.connectionAuthenticated(clientUsername.toString());
        connection._pairVerifyState = undefined;
    };
    HAPServer.prototype.handlePairings = function (connection, url, request, data, response) {
        var _this = this;
        // Only accept /pairing request if there is a secure session
        if (!this.allowInsecureRequest && !connection.isAuthenticated()) {
            response.writeHead(470 /* CONNECTION_AUTHORIZATION_REQUIRED */, { "Content-Type": "application/hap+json" });
            response.end(JSON.stringify({ status: -70401 /* INSUFFICIENT_PRIVILEGES */ }));
            return;
        }
        var objects = tlv.decode(data);
        var method = objects[0 /* METHOD */][0]; // value is single byte with request type
        var state = objects[6 /* STATE */][0];
        if (state !== 1 /* M1 */) {
            return;
        }
        if (method === 3 /* ADD_PAIRING */) {
            var identifier = objects[1 /* IDENTIFIER */].toString();
            var publicKey = objects[3 /* PUBLIC_KEY */];
            var permissions = objects[11 /* PERMISSIONS */][0];
            this.emit("add-pairing" /* ADD_PAIRING */, connection, identifier, publicKey, permissions, once_1.once(function (error) {
                if (error > 0) {
                    debug("[%s] Pairings: failed ADD_PAIRING with code %d", _this.accessoryInfo.username, error);
                    response.writeHead(200 /* OK */, { "Content-Type": "application/pairing+tlv8" });
                    response.end(tlv.encode(6 /* STATE */, 2 /* M2 */, 7 /* ERROR_CODE */, error));
                    return;
                }
                response.writeHead(200 /* OK */, { "Content-Type": "application/pairing+tlv8" });
                response.end(tlv.encode(6 /* STATE */, 2 /* M2 */));
                debug("[%s] Pairings: successfully executed ADD_PAIRING", _this.accessoryInfo.username);
            }));
        }
        else if (method === 4 /* REMOVE_PAIRING */) {
            var identifier = objects[1 /* IDENTIFIER */].toString();
            this.emit("remove-pairing" /* REMOVE_PAIRING */, connection, identifier, once_1.once(function (error) {
                if (error > 0) {
                    debug("[%s] Pairings: failed REMOVE_PAIRING with code %d", _this.accessoryInfo.username, error);
                    response.writeHead(200 /* OK */, { "Content-Type": "application/pairing+tlv8" });
                    response.end(tlv.encode(6 /* STATE */, 2 /* M2 */, 7 /* ERROR_CODE */, error));
                    return;
                }
                response.writeHead(200 /* OK */, { "Content-Type": "application/pairing+tlv8" });
                response.end(tlv.encode(6 /* STATE */, 2 /* M2 */));
                debug("[%s] Pairings: successfully executed REMOVE_PAIRING", _this.accessoryInfo.username);
            }));
        }
        else if (method === 5 /* LIST_PAIRINGS */) {
            this.emit("list-pairings" /* LIST_PAIRINGS */, connection, once_1.once(function (error, data) {
                if (error > 0) {
                    debug("[%s] Pairings: failed LIST_PAIRINGS with code %d", _this.accessoryInfo.username, error);
                    response.writeHead(200 /* OK */, { "Content-Type": "application/pairing+tlv8" });
                    response.end(tlv.encode(6 /* STATE */, 2 /* M2 */, 7 /* ERROR_CODE */, error));
                    return;
                }
                var tlvList = [];
                data.forEach(function (value, index) {
                    if (index > 0) {
                        tlvList.push(255 /* SEPARATOR */, Buffer.alloc(0));
                    }
                    tlvList.push(1 /* IDENTIFIER */, value.username, 3 /* PUBLIC_KEY */, value.publicKey, 11 /* PERMISSIONS */, value.permission);
                });
                var list = tlv.encode.apply(tlv, tslib_1.__spread([6 /* STATE */, 2 /* M2 */], tlvList));
                response.writeHead(200 /* OK */, { "Content-Type": "application/pairing+tlv8" });
                response.end(list);
                debug("[%s] Pairings: successfully executed LIST_PAIRINGS", _this.accessoryInfo.username);
            }));
        }
    };
    HAPServer.prototype.handleAccessories = function (connection, url, request, data, response) {
        if (!this.allowInsecureRequest && !connection.isAuthenticated()) {
            response.writeHead(470 /* CONNECTION_AUTHORIZATION_REQUIRED */, { "Content-Type": "application/hap+json" });
            response.end(JSON.stringify({ status: -70401 /* INSUFFICIENT_PRIVILEGES */ }));
            return;
        }
        // call out to listeners to retrieve the latest accessories JSON
        this.emit("accessories" /* ACCESSORIES */, connection, once_1.once(function (error, result) {
            if (error) {
                response.writeHead(error.httpCode, { "Content-Type": "application/hap+json" });
                response.end(JSON.stringify({ status: error.status }));
            }
            else {
                response.writeHead(200 /* OK */, { "Content-Type": "application/hap+json" });
                response.end(JSON.stringify(result));
            }
        }));
    };
    HAPServer.prototype.handleCharacteristics = function (connection, url, request, data, response) {
        var e_1, _a;
        if (!this.allowInsecureRequest && !connection.isAuthenticated()) {
            response.writeHead(470 /* CONNECTION_AUTHORIZATION_REQUIRED */, { "Content-Type": "application/hap+json" });
            response.end(JSON.stringify({ status: -70401 /* INSUFFICIENT_PRIVILEGES */ }));
            return;
        }
        if (request.method === "GET") {
            var searchParams = url.searchParams;
            var idParam = searchParams.get("id");
            if (!idParam) {
                response.writeHead(400 /* BAD_REQUEST */, { "Content-Type": "application/hap+json" });
                response.end(JSON.stringify({ status: -70410 /* INVALID_VALUE_IN_REQUEST */ }));
                return;
            }
            var ids = [];
            try {
                for (var _b = tslib_1.__values(idParam.split(",")), _c = _b.next(); !_c.done; _c = _b.next()) { // ["1.9","2.14"]
                    var entry = _c.value;
                    var split = entry.split("."); // ["1","9"]
                    ids.push({
                        aid: parseInt(split[0], 10),
                        iid: parseInt(split[1], 10),
                    });
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            var readRequest = {
                ids: ids,
                includeMeta: internal_types_1.consideredTrue(searchParams.get("meta")),
                includePerms: internal_types_1.consideredTrue(searchParams.get("perms")),
                includeType: internal_types_1.consideredTrue(searchParams.get("type")),
                includeEvent: internal_types_1.consideredTrue(searchParams.get("ev")),
            };
            this.emit("get-characteristics" /* GET_CHARACTERISTICS */, connection, readRequest, once_1.once(function (error, readResponse) {
                var e_2, _a, e_3, _b;
                if (error) {
                    response.writeHead(error.httpCode, { "Content-Type": "application/hap+json" });
                    response.end(JSON.stringify({ status: error.status }));
                    return;
                }
                var characteristics = readResponse.characteristics;
                var errorOccurred = false; // determine if we send a 207 Multi-Status
                try {
                    for (var characteristics_1 = tslib_1.__values(characteristics), characteristics_1_1 = characteristics_1.next(); !characteristics_1_1.done; characteristics_1_1 = characteristics_1.next()) {
                        var data_1 = characteristics_1_1.value;
                        if (data_1.status) {
                            errorOccurred = true;
                            break;
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (characteristics_1_1 && !characteristics_1_1.done && (_a = characteristics_1.return)) _a.call(characteristics_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                if (errorOccurred) { // on a 207 Multi-Status EVERY characteristic MUST include a status property
                    try {
                        for (var characteristics_2 = tslib_1.__values(characteristics), characteristics_2_1 = characteristics_2.next(); !characteristics_2_1.done; characteristics_2_1 = characteristics_2.next()) {
                            var data_2 = characteristics_2_1.value;
                            if (!data_2.status) { // a status is undefined if the request was successful
                                data_2.status = 0 /* SUCCESS */; // a value of zero indicates success
                            }
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (characteristics_2_1 && !characteristics_2_1.done && (_b = characteristics_2.return)) _b.call(characteristics_2);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
                // 207 "multi-status" is returned when an error occurs reading a characteristic. otherwise 200 is returned
                response.writeHead(errorOccurred ? 207 /* MULTI_STATUS */ : 200 /* OK */, { "Content-Type": "application/hap+json" });
                response.end(JSON.stringify({ characteristics: characteristics }));
            }));
        }
        else if (request.method === "PUT") {
            if (!connection.isAuthenticated()) {
                if (!request.headers || (request.headers && request.headers["authorization"] !== this.accessoryInfo.pincode)) {
                    response.writeHead(470 /* CONNECTION_AUTHORIZATION_REQUIRED */, { "Content-Type": "application/hap+json" });
                    response.end(JSON.stringify({ status: -70401 /* INSUFFICIENT_PRIVILEGES */ }));
                    return;
                }
            }
            if (data.length === 0) {
                response.writeHead(400, { "Content-Type": "application/hap+json" });
                response.end(JSON.stringify({ status: -70410 /* INVALID_VALUE_IN_REQUEST */ }));
                return;
            }
            var writeRequest = JSON.parse(data.toString("utf8"));
            this.emit("set-characteristics" /* SET_CHARACTERISTICS */, connection, writeRequest, once_1.once(function (error, writeResponse) {
                var e_4, _a, e_5, _b;
                if (error) {
                    response.writeHead(error.httpCode, { "Content-Type": "application/hap+json" });
                    response.end(JSON.stringify({ status: error.status }));
                    return;
                }
                var characteristics = writeResponse.characteristics;
                var multiStatus = false;
                try {
                    for (var characteristics_3 = tslib_1.__values(characteristics), characteristics_3_1 = characteristics_3.next(); !characteristics_3_1.done; characteristics_3_1 = characteristics_3.next()) {
                        var data_3 = characteristics_3_1.value;
                        if (data_3.status || data_3.value !== undefined) {
                            // also send multiStatus on write response requests
                            multiStatus = true;
                            break;
                        }
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (characteristics_3_1 && !characteristics_3_1.done && (_a = characteristics_3.return)) _a.call(characteristics_3);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
                if (multiStatus) {
                    try {
                        for (var characteristics_4 = tslib_1.__values(characteristics), characteristics_4_1 = characteristics_4.next(); !characteristics_4_1.done; characteristics_4_1 = characteristics_4.next()) { // on a 207 Multi-Status EVERY characteristic MUST include a status property
                            var data_4 = characteristics_4_1.value;
                            if (data_4.status === undefined) {
                                data_4.status = 0 /* SUCCESS */;
                            }
                        }
                    }
                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                    finally {
                        try {
                            if (characteristics_4_1 && !characteristics_4_1.done && (_b = characteristics_4.return)) _b.call(characteristics_4);
                        }
                        finally { if (e_5) throw e_5.error; }
                    }
                    // 207 is "multi-status" since HomeKit may be setting multiple things and any one can fail independently
                    response.writeHead(207 /* MULTI_STATUS */, { "Content-Type": "application/hap+json" });
                    response.end(JSON.stringify({ characteristics: characteristics }));
                }
                else {
                    // if everything went fine send 204 no content response
                    response.writeHead(204 /* NO_CONTENT */);
                    response.end();
                }
            }));
        }
        else {
            response.writeHead(400 /* BAD_REQUEST */, { "Content-Type": "application/hap+json" }); // method not allowed
            response.end(JSON.stringify({ status: -70410 /* INVALID_VALUE_IN_REQUEST */ }));
        }
    };
    HAPServer.prototype.handlePrepareWrite = function (connection, url, request, data, response) {
        var _this = this;
        if (!this.allowInsecureRequest && !connection.isAuthenticated()) {
            response.writeHead(470 /* CONNECTION_AUTHORIZATION_REQUIRED */, { "Content-Type": "application/hap+json" });
            response.end(JSON.stringify({ status: -70401 /* INSUFFICIENT_PRIVILEGES */ }));
            return;
        }
        if (request.method == "PUT") {
            if (data.length == 0) {
                response.writeHead(400 /* BAD_REQUEST */, { "Content-Type": "application/hap+json" });
                response.end(JSON.stringify({ status: -70410 /* INVALID_VALUE_IN_REQUEST */ }));
                return;
            }
            var prepareRequest_1 = JSON.parse(data.toString());
            if (prepareRequest_1.pid && prepareRequest_1.ttl) {
                debug("[%s] Received prepare write request with pid %d and ttl %d", this.accessoryInfo.username, prepareRequest_1.pid, prepareRequest_1.ttl);
                if (connection.timedWriteTimeout) // clear any currently existing timeouts
                    clearTimeout(connection.timedWriteTimeout);
                connection.timedWritePid = prepareRequest_1.pid;
                connection.timedWriteTimeout = setTimeout(function () {
                    debug("[%s] Timed write request timed out for pid %d", _this.accessoryInfo.username, prepareRequest_1.pid);
                    connection.timedWritePid = undefined;
                    connection.timedWriteTimeout = undefined;
                }, prepareRequest_1.ttl);
                response.writeHead(200 /* OK */, { "Content-Type": "application/hap+json" });
                response.end(JSON.stringify({ status: 0 /* SUCCESS */ }));
                return;
            }
            else {
                response.writeHead(400 /* BAD_REQUEST */, { "Content-Type": "application/hap+json" });
                response.end(JSON.stringify({ status: -70410 /* INVALID_VALUE_IN_REQUEST */ }));
            }
        }
        else {
            response.writeHead(400 /* BAD_REQUEST */, { "Content-Type": "application/hap+json" });
            response.end(JSON.stringify({ status: -70410 /* INVALID_VALUE_IN_REQUEST */ }));
        }
    };
    HAPServer.prototype.handleResource = function (connection, url, request, data, response) {
        if (!connection.isAuthenticated()) {
            if (!(this.allowInsecureRequest && request.headers && request.headers.authorization === this.accessoryInfo.pincode)) {
                response.writeHead(470 /* CONNECTION_AUTHORIZATION_REQUIRED */, { "Content-Type": "application/hap+json" });
                response.end(JSON.stringify({ status: -70401 /* INSUFFICIENT_PRIVILEGES */ }));
                return;
            }
        }
        if (request.method === "POST") {
            if (data.length === 0) {
                response.writeHead(400 /* BAD_REQUEST */, { "Content-Type": "application/hap+json" });
                response.end(JSON.stringify({ status: -70410 /* INVALID_VALUE_IN_REQUEST */ }));
                return;
            }
            var resourceRequest = JSON.parse(data.toString());
            // call out to listeners to retrieve the resource, snapshot only right now
            this.emit("request-resource" /* REQUEST_RESOURCE */, resourceRequest, once_1.once(function (error, resource) {
                if (error) {
                    response.writeHead(error.httpCode, { "Content-Type": "application/hap+json" });
                    response.end(JSON.stringify({ status: error.status }));
                }
                else {
                    response.writeHead(200 /* OK */, { "Content-Type": "image/jpeg" });
                    response.end(resource);
                }
            }));
        }
        else {
            response.writeHead(400 /* BAD_REQUEST */, { "Content-Type": "application/hap+json" }); // method not allowed
            response.end(JSON.stringify({ status: -70410 /* INVALID_VALUE_IN_REQUEST */ }));
        }
    };
    return HAPServer;
}(events_1.EventEmitter));
exports.HAPServer = HAPServer;
//# sourceMappingURL=HAPServer.js.map

/***/ }),

/***/ 7383:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Service = exports.ServiceEventTypes = void 0;
var tslib_1 = __nccwpck_require__(4290);
var assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
var debug_1 = tslib_1.__importDefault(__nccwpck_require__(7984));
var events_1 = __nccwpck_require__(8614);
var Characteristic_1 = __nccwpck_require__(3859);
var uuid_1 = __nccwpck_require__(6814);
var debug = debug_1.default("HAP-NodeJS:Service");
/**
 * HAP spec allows a maximum of 100 characteristics per service!
 */
var MAX_CHARACTERISTICS = 100;
var ServiceEventTypes;
(function (ServiceEventTypes) {
    ServiceEventTypes["CHARACTERISTIC_CHANGE"] = "characteristic-change";
    ServiceEventTypes["SERVICE_CONFIGURATION_CHANGE"] = "service-configurationChange";
    ServiceEventTypes["CHARACTERISTIC_WARNING"] = "characteristic-warning";
})(ServiceEventTypes = exports.ServiceEventTypes || (exports.ServiceEventTypes = {}));
/**
 * Service represents a set of grouped values necessary to provide a logical function. For instance, a
 * "Door Lock Mechanism" service might contain two values, one for the "desired lock state" and one for the
 * "current lock state". A particular Service is distinguished from others by its "type", which is a UUID.
 * HomeKit provides a set of known Service UUIDs defined in HomeKit.ts along with a corresponding
 * concrete subclass that you can instantiate directly to setup the necessary values. These natively-supported
 * Services are expected to contain a particular set of Characteristics.
 *
 * Unlike Characteristics, where you cannot have two Characteristics with the same UUID in the same Service,
 * you can actually have multiple Services with the same UUID in a single Accessory. For instance, imagine
 * a Garage Door Opener with both a "security light" and a "backlight" for the display. Each light could be
 * a "Lightbulb" Service with the same UUID. To account for this situation, we define an extra "subtype"
 * property on Service, that can be a string or other string-convertible object that uniquely identifies the
 * Service among its peers in an Accessory. For instance, you might have `service1.subtype = 'security_light'`
 * for one and `service2.subtype = 'backlight'` for the other.
 *
 * You can also define custom Services by providing your own UUID for the type that you generate yourself.
 * Custom Services can contain an arbitrary set of Characteristics, but Siri will likely not be able to
 * work with these.
 */
var Service = /** @class */ (function (_super) {
    tslib_1.__extends(Service, _super);
    function Service(displayName, UUID, subtype) {
        if (displayName === void 0) { displayName = ""; }
        var _this = _super.call(this) || this;
        _this.iid = null; // assigned later by our containing Accessory
        _this.name = null;
        _this.characteristics = [];
        _this.optionalCharacteristics = [];
        /**
         * @private
         */
        _this.isHiddenService = false;
        /**
         * @private
         */
        _this.isPrimaryService = false; // do not write to this directly
        /**
         * @private
         */
        _this.linkedServices = [];
        assert_1.default(UUID, "Services must be created with a valid UUID.");
        _this.displayName = displayName;
        _this.UUID = UUID;
        _this.subtype = subtype;
        // every service has an optional Characteristic.Name property - we'll set it to our displayName
        // if one was given
        // if you don't provide a display name, some HomeKit apps may choose to hide the device.
        if (displayName) {
            // create the characteristic if necessary
            var nameCharacteristic = _this.getCharacteristic(Characteristic_1.Characteristic.Name) ||
                _this.addCharacteristic(Characteristic_1.Characteristic.Name);
            nameCharacteristic.updateValue(displayName);
        }
        return _this;
    }
    /**
     * Returns an id which uniquely identifies an service on the associated accessory.
     * The serviceId is a concatenation of the UUID for the service (defined by HAP) and the subtype (could be empty)
     * which is programmatically defined by the programmer.
     *
     * @returns the serviceId
     */
    Service.prototype.getServiceId = function () {
        return this.UUID + (this.subtype || "");
    };
    Service.prototype.addCharacteristic = function (input) {
        // characteristic might be a constructor like `Characteristic.Brightness` instead of an instance of Characteristic. Coerce if necessary.
        var e_1, _a;
        var constructorArgs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            constructorArgs[_i - 1] = arguments[_i];
        }
        var characteristic = typeof input === "function" ? new (input.bind.apply(input, tslib_1.__spread([void 0], constructorArgs)))() : input;
        try {
            // check for UUID conflict
            for (var _b = tslib_1.__values(this.characteristics), _c = _b.next(); !_c.done; _c = _b.next()) {
                var existing = _c.value;
                if (existing.UUID === characteristic.UUID) {
                    if (characteristic.UUID === '00000052-0000-1000-8000-0026BB765291') {
                        //This is a special workaround for the Firmware Revision characteristic.
                        return existing;
                    }
                    throw new Error("Cannot add a Characteristic with the same UUID as another Characteristic in this Service: " + existing.UUID);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (this.characteristics.length >= MAX_CHARACTERISTICS) {
            throw new Error("Cannot add more than " + MAX_CHARACTERISTICS + " characteristics to a single service!");
        }
        this.setupCharacteristicEventHandlers(characteristic);
        this.characteristics.push(characteristic);
        this.emit("service-configurationChange" /* SERVICE_CONFIGURATION_CHANGE */);
        return characteristic;
    };
    /**
     * Sets this service as the new primary service.
     * Any currently active primary service will be reset to be not primary.
     * This will happen immediately, if the service was already added to an accessory, or later
     * when the service gets added to an accessory.
     *
     * @param isPrimary {boolean} - optional boolean (default true) if the service should be the primary service
     */
    Service.prototype.setPrimaryService = function (isPrimary) {
        if (isPrimary === void 0) { isPrimary = true; }
        this.isPrimaryService = isPrimary;
        this.emit("service-configurationChange" /* SERVICE_CONFIGURATION_CHANGE */);
    };
    /**
     * Marks the service as hidden
     *
     * @param isHidden {boolean} - optional boolean (default true) if the service should be marked hidden
     */
    Service.prototype.setHiddenService = function (isHidden) {
        if (isHidden === void 0) { isHidden = true; }
        this.isHiddenService = isHidden;
        this.emit("service-configurationChange" /* SERVICE_CONFIGURATION_CHANGE */);
    };
    /**
     * Adds a new link to the specified service. The service MUST be already added to
     * the SAME accessory.
     *
     * @param service - The service this service should link to
     */
    Service.prototype.addLinkedService = function (service) {
        //TODO: Add a check if the service is on the same accessory.
        if (!this.linkedServices.includes(service)) {
            this.linkedServices.push(service);
        }
        this.emit("service-configurationChange" /* SERVICE_CONFIGURATION_CHANGE */);
    };
    /**
     * Removes a link to the specified service which was previously added with {@link addLinkedService}
     *
     * @param service - Previously linked service
     */
    Service.prototype.removeLinkedService = function (service) {
        //TODO: Add a check if the service is on the same accessory.
        var index = this.linkedServices.indexOf(service);
        if (index !== -1) {
            this.linkedServices.splice(index, 1);
        }
        this.emit("service-configurationChange" /* SERVICE_CONFIGURATION_CHANGE */);
    };
    Service.prototype.removeCharacteristic = function (characteristic) {
        var index = this.characteristics.indexOf(characteristic);
        if (index !== -1) {
            this.characteristics.splice(index, 1);
            characteristic.removeAllListeners();
            this.emit("service-configurationChange" /* SERVICE_CONFIGURATION_CHANGE */);
        }
    };
    Service.prototype.getCharacteristic = function (name) {
        // returns a characteristic object from the service
        // If  Service.prototype.getCharacteristic(Characteristic.Type)  does not find the characteristic,
        // but the type is in optionalCharacteristics, it adds the characteristic.type to the service and returns it.
        var e_2, _a, e_3, _b;
        var index, characteristic;
        try {
            for (var _c = tslib_1.__values(this.characteristics), _d = _c.next(); !_d.done; _d = _c.next()) {
                var characteristic_1 = _d.value;
                if (typeof name === 'string' && characteristic_1.displayName === name) {
                    return characteristic_1;
                }
                else if (typeof name === 'function' && ((characteristic_1 instanceof name) || (name.UUID === characteristic_1.UUID))) {
                    return characteristic_1;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_2) throw e_2.error; }
        }
        if (typeof name === 'function') {
            try {
                for (var _e = tslib_1.__values(this.optionalCharacteristics), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var characteristic_2 = _f.value;
                    if ((characteristic_2 instanceof name) || (name.UUID === characteristic_2.UUID)) {
                        return this.addCharacteristic(name);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_3) throw e_3.error; }
            }
            var instance = this.addCharacteristic(name);
            // Not found in optional Characteristics. Adding anyway, but warning about it if it isn't the Name.
            if (name.UUID !== Characteristic_1.Characteristic.Name.UUID) {
                this.emitCharacteristicWarningEvent(instance, "warn-message" /* WARN_MESSAGE */, "Characteristic not in required or optional characteristic section for service " + this.constructor.name + ". Adding anyway.");
            }
            return instance;
        }
    };
    Service.prototype.testCharacteristic = function (name) {
        var e_4, _a;
        try {
            // checks for the existence of a characteristic object in the service
            for (var _b = tslib_1.__values(this.characteristics), _c = _b.next(); !_c.done; _c = _b.next()) {
                var characteristic = _c.value;
                if (typeof name === 'string' && characteristic.displayName === name) {
                    return true;
                }
                else if (typeof name === 'function' && ((characteristic instanceof name) || (name.UUID === characteristic.UUID))) {
                    return true;
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return false;
    };
    Service.prototype.setCharacteristic = function (name, value) {
        this.getCharacteristic(name).setValue(value);
        return this; // for chaining
    };
    // A function to only updating the remote value, but not firing the 'set' event.
    Service.prototype.updateCharacteristic = function (name, value) {
        this.getCharacteristic(name).updateValue(value);
        return this;
    };
    Service.prototype.addOptionalCharacteristic = function (characteristic) {
        // characteristic might be a constructor like `Characteristic.Brightness` instead of an instance
        // of Characteristic. Coerce if necessary.
        if (typeof characteristic === 'function') {
            // @ts-ignore we are dealing with predefined characteristics here
            characteristic = new characteristic();
        }
        this.optionalCharacteristics.push(characteristic);
    };
    // noinspection JSUnusedGlobalSymbols
    /**
     * This method was created to copy all characteristics from another service to this.
     * It's only adopting is currently in homebridge to merge the AccessoryInformation service. So some things
     * my be explicitly tailored towards this use case.
     *
     * It will not remove characteristics which are present currently but not added on the other characteristic.
     * It will not replace the characteristic if the value is falsy (except of '0' or 'false')
     * @param service
     * @private used by homebridge
     */
    Service.prototype.replaceCharacteristicsFromService = function (service) {
        var _this = this;
        if (this.UUID !== service.UUID) {
            throw new Error("Incompatible services. Tried replacing characteristics of " + this.UUID + " with characteristics from " + service.UUID);
        }
        var foreignCharacteristics = {}; // index foreign characteristics by UUID
        service.characteristics.forEach(function (characteristic) { return foreignCharacteristics[characteristic.UUID] = characteristic; });
        this.characteristics.forEach(function (characteristic) {
            var foreignCharacteristic = foreignCharacteristics[characteristic.UUID];
            if (foreignCharacteristic) {
                delete foreignCharacteristics[characteristic.UUID];
                if (!foreignCharacteristic.value && foreignCharacteristic.value !== 0 && foreignCharacteristic.value !== false) {
                    return; // ignore falsy values except if its the number zero or literally false
                }
                characteristic.replaceBy(foreignCharacteristic);
            }
        });
        // add all additional characteristics which where not present already
        Object.values(foreignCharacteristics).forEach(function (characteristic) { return _this.addCharacteristic(characteristic); });
    };
    /**
     * @private
     */
    Service.prototype.getCharacteristicByIID = function (iid) {
        var e_5, _a;
        try {
            for (var _b = tslib_1.__values(this.characteristics), _c = _b.next(); !_c.done; _c = _b.next()) {
                var characteristic = _c.value;
                if (characteristic.iid === iid)
                    return characteristic;
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
    };
    /**
     * @private
     */
    Service.prototype._assignIDs = function (identifierCache, accessoryName, baseIID) {
        var e_6, _a;
        if (baseIID === void 0) { baseIID = 0; }
        // the Accessory Information service must have a (reserved by IdentifierCache) ID of 1
        if (this.UUID === '0000003E-0000-1000-8000-0026BB765291') {
            this.iid = 1;
        }
        else {
            // assign our own ID based on our UUID
            this.iid = baseIID + identifierCache.getIID(accessoryName, this.UUID, this.subtype);
        }
        try {
            // assign IIDs to our Characteristics
            for (var _b = tslib_1.__values(this.characteristics), _c = _b.next(); !_c.done; _c = _b.next()) {
                var characteristic = _c.value;
                characteristic._assignID(identifierCache, accessoryName, this.UUID, this.subtype);
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_6) throw e_6.error; }
        }
    };
    /**
     * Returns a JSON representation of this service suitable for delivering to HAP clients.
     * @private used to generate response to /accessories query
     */
    Service.prototype.toHAP = function (connection, contactGetHandlers) {
        var _this = this;
        if (contactGetHandlers === void 0) { contactGetHandlers = true; }
        return new Promise(function (resolve) {
            var e_7, _a, e_8, _b;
            assert_1.default(_this.iid, "iid cannot be undefined for service '" + _this.displayName + "'");
            assert_1.default(_this.characteristics.length, "service '" + _this.displayName + "' does not have any characteristics!");
            var service = {
                type: uuid_1.toShortForm(_this.UUID),
                iid: _this.iid,
                characteristics: [],
                hidden: _this.isHiddenService ? true : undefined,
                primary: _this.isPrimaryService ? true : undefined,
            };
            if (_this.linkedServices.length) {
                service.linked = [];
                try {
                    for (var _c = tslib_1.__values(_this.linkedServices), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var linked = _d.value;
                        if (!linked.iid) {
                            // we got a linked service which is not added to the accessory
                            // as it doesn't "exists" we just ignore it.
                            // we have some (at least one) plugins on homebridge which link to the AccessoryInformation service.
                            // homebridge always creates it's own AccessoryInformation service and ignores the user supplied one
                            // thus the link is automatically broken.
                            debug("iid of linked service '" + linked.displayName + "' " + linked.UUID + " is undefined on service '" + _this.displayName + "'");
                            continue;
                        }
                        service.linked.push(linked.iid);
                    }
                }
                catch (e_7_1) { e_7 = { error: e_7_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                    }
                    finally { if (e_7) throw e_7.error; }
                }
            }
            var missingCharacteristics = new Set();
            var timeout = setTimeout(function () {
                var e_9, _a;
                try {
                    for (var missingCharacteristics_1 = tslib_1.__values(missingCharacteristics), missingCharacteristics_1_1 = missingCharacteristics_1.next(); !missingCharacteristics_1_1.done; missingCharacteristics_1_1 = missingCharacteristics_1.next()) {
                        var characteristic = missingCharacteristics_1_1.value;
                        _this.emitCharacteristicWarningEvent(characteristic, "slow-read" /* SLOW_READ */, "The read handler for the characteristic '" + characteristic.displayName + "' was slow to respond!");
                    }
                }
                catch (e_9_1) { e_9 = { error: e_9_1 }; }
                finally {
                    try {
                        if (missingCharacteristics_1_1 && !missingCharacteristics_1_1.done && (_a = missingCharacteristics_1.return)) _a.call(missingCharacteristics_1);
                    }
                    finally { if (e_9) throw e_9.error; }
                }
                timeout = setTimeout(function () {
                    var e_10, _a;
                    timeout = undefined;
                    try {
                        for (var missingCharacteristics_2 = tslib_1.__values(missingCharacteristics), missingCharacteristics_2_1 = missingCharacteristics_2.next(); !missingCharacteristics_2_1.done; missingCharacteristics_2_1 = missingCharacteristics_2.next()) {
                            var characteristic = missingCharacteristics_2_1.value;
                            _this.emitCharacteristicWarningEvent(characteristic, "timeout-read" /* TIMEOUT_READ */, "The read handler for the characteristic '" + (characteristic === null || characteristic === void 0 ? void 0 : characteristic.displayName) +
                                "' didn't respond at all!. Please check that you properly call the callback!");
                            service.characteristics.push(characteristic.internalHAPRepresentation()); // value is set to null
                        }
                    }
                    catch (e_10_1) { e_10 = { error: e_10_1 }; }
                    finally {
                        try {
                            if (missingCharacteristics_2_1 && !missingCharacteristics_2_1.done && (_a = missingCharacteristics_2.return)) _a.call(missingCharacteristics_2);
                        }
                        finally { if (e_10) throw e_10.error; }
                    }
                    missingCharacteristics.clear();
                    resolve(service);
                }, 6000);
            }, 3000);
            var _loop_1 = function (characteristic) {
                missingCharacteristics.add(characteristic);
                characteristic.toHAP(connection, contactGetHandlers).then(function (value) {
                    if (!timeout) {
                        return; // if timeout is undefined, response was already sent out
                    }
                    missingCharacteristics.delete(characteristic);
                    service.characteristics.push(value);
                    if (missingCharacteristics.size === 0) {
                        if (timeout) {
                            clearTimeout(timeout);
                            timeout = undefined;
                        }
                        resolve(service);
                    }
                });
            };
            try {
                for (var _e = tslib_1.__values(_this.characteristics), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var characteristic = _f.value;
                    _loop_1(characteristic);
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_8) throw e_8.error; }
            }
        });
    };
    /**
     * Returns a JSON representation of this service without characteristic values.
     * @private used to generate the config hash
     */
    Service.prototype.internalHAPRepresentation = function () {
        var e_11, _a;
        assert_1.default(this.iid, "iid cannot be undefined for service '" + this.displayName + "'");
        assert_1.default(this.characteristics.length, "service '" + this.displayName + "' does not have any characteristics!");
        var service = {
            type: uuid_1.toShortForm(this.UUID),
            iid: this.iid,
            characteristics: this.characteristics.map(function (characteristic) { return characteristic.internalHAPRepresentation(); }),
            hidden: this.isHiddenService ? true : undefined,
            primary: this.isPrimaryService ? true : undefined,
        };
        if (this.linkedServices.length) {
            service.linked = [];
            try {
                for (var _b = tslib_1.__values(this.linkedServices), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var linked = _c.value;
                    if (!linked.iid) {
                        // we got a linked service which is not added to the accessory
                        // as it doesn't "exists" we just ignore it.
                        // we have some (at least one) plugins on homebridge which link to the AccessoryInformation service.
                        // homebridge always creates it's own AccessoryInformation service and ignores the user supplied one
                        // thus the link is automatically broken.
                        debug("iid of linked service '" + linked.displayName + "' " + linked.UUID + " is undefined on service '" + this.displayName + "'");
                        continue;
                    }
                    service.linked.push(linked.iid);
                }
            }
            catch (e_11_1) { e_11 = { error: e_11_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_11) throw e_11.error; }
            }
        }
        return service;
    };
    /**
     * @private
     */
    Service.prototype.setupCharacteristicEventHandlers = function (characteristic) {
        var _this = this;
        // listen for changes in characteristics and bubble them up
        characteristic.on("change" /* CHANGE */, function (change) {
            _this.emit("characteristic-change" /* CHARACTERISTIC_CHANGE */, tslib_1.__assign(tslib_1.__assign({}, change), { characteristic: characteristic }));
        });
        characteristic.on("characteristic-warning" /* CHARACTERISTIC_WARNING */, this.emitCharacteristicWarningEvent.bind(this, characteristic));
    };
    /**
     * @private
     */
    Service.prototype.emitCharacteristicWarningEvent = function (characteristic, type, message, stack) {
        this.emit("characteristic-warning" /* CHARACTERISTIC_WARNING */, {
            characteristic: characteristic,
            type: type,
            message: message,
            originatorChain: [this.displayName, characteristic.displayName],
            stack: stack,
        });
    };
    /**
     * @private
     */
    Service.prototype._sideloadCharacteristics = function (targetCharacteristics) {
        var e_12, _a;
        try {
            for (var targetCharacteristics_1 = tslib_1.__values(targetCharacteristics), targetCharacteristics_1_1 = targetCharacteristics_1.next(); !targetCharacteristics_1_1.done; targetCharacteristics_1_1 = targetCharacteristics_1.next()) {
                var target = targetCharacteristics_1_1.value;
                this.setupCharacteristicEventHandlers(target);
            }
        }
        catch (e_12_1) { e_12 = { error: e_12_1 }; }
        finally {
            try {
                if (targetCharacteristics_1_1 && !targetCharacteristics_1_1.done && (_a = targetCharacteristics_1.return)) _a.call(targetCharacteristics_1);
            }
            finally { if (e_12) throw e_12.error; }
        }
        this.characteristics = targetCharacteristics.slice();
    };
    /**
     * @private
     */
    Service.serialize = function (service) {
        var constructorName;
        if (service.constructor.name !== "Service") {
            constructorName = service.constructor.name;
        }
        return {
            displayName: service.displayName,
            UUID: service.UUID,
            subtype: service.subtype,
            constructorName: constructorName,
            hiddenService: service.isHiddenService,
            primaryService: service.isPrimaryService,
            characteristics: service.characteristics.map(function (characteristic) { return Characteristic_1.Characteristic.serialize(characteristic); }),
            optionalCharacteristics: service.optionalCharacteristics.map(function (characteristic) { return Characteristic_1.Characteristic.serialize(characteristic); }),
        };
    };
    /**
     * @private
     */
    Service.deserialize = function (json) {
        var service;
        if (json.constructorName && json.constructorName.charAt(0).toUpperCase() === json.constructorName.charAt(0)
            && Service[json.constructorName]) { // MUST start with uppercase character and must exist on Service object
            var constructor = Service[json.constructorName];
            service = new constructor(json.displayName, json.subtype);
        }
        else {
            service = new Service(json.displayName, json.UUID, json.subtype);
        }
        service.isHiddenService = !!json.hiddenService;
        service.isPrimaryService = !!json.primaryService;
        var characteristics = json.characteristics.map(function (serialized) { return Characteristic_1.Characteristic.deserialize(serialized); });
        service._sideloadCharacteristics(characteristics);
        if (json.optionalCharacteristics) {
            service.optionalCharacteristics = json.optionalCharacteristics.map(function (serialized) { return Characteristic_1.Characteristic.deserialize(serialized); });
        }
        return service;
    };
    return Service;
}(events_1.EventEmitter));
exports.Service = Service;
//# sourceMappingURL=Service.js.map

/***/ }),

/***/ 7757:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LegacyCameraSourceAdapter = void 0;
// noinspection JSDeprecatedSymbols
var LegacyCameraSourceAdapter = /** @class */ (function () {
    function LegacyCameraSourceAdapter(cameraSource) {
        this.cameraSource = cameraSource;
    }
    LegacyCameraSourceAdapter.prototype.handleSnapshotRequest = function (request, callback) {
        this.cameraSource.handleSnapshotRequest(request, function (error, buffer) {
            callback(error ? error : undefined, buffer);
        });
    };
    LegacyCameraSourceAdapter.prototype.prepareStream = function (request, callback) {
        this.cameraSource.prepareStream(request, function (response) {
            callback(undefined, response);
        });
    };
    LegacyCameraSourceAdapter.prototype.handleStreamRequest = function (request, callback) {
        // @ts-ignore
        this.cameraSource.handleStreamRequest(request);
        callback();
    };
    LegacyCameraSourceAdapter.prototype.forwardCloseConnection = function (sessionID) {
        // In the legacy type CameraSource API it was need that the plugin dev would forward this call to the
        // handleCloseConnection of the "StreamController". This is not needed anymore and is automatically handled
        // by HAP-NodeJS. However devs could possibly define other stuff in there so we still forward this call.
        this.cameraSource.handleCloseConnection(sessionID);
    };
    return LegacyCameraSourceAdapter;
}());
exports.LegacyCameraSourceAdapter = LegacyCameraSourceAdapter;
//# sourceMappingURL=Camera.js.map

/***/ }),

/***/ 9091:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4290);
var dgram_1 = tslib_1.__importDefault(__nccwpck_require__(6200));
/**
 * RTPProxy to proxy unencrypted RTP and RTCP
 *
 * At early days of HomeKit camera support, HomeKit allowed for unencrypted RTP stream.
 * The proxy was created to deal with RTCP and SSRC related stuff from external streams back in that days.
 * Later HomeKit removed support for unencrypted stream so it’s mostly no longer useful anymore, only really for testing
 * with a custom HAP controller.
 */
var RTPProxy = /** @class */ (function () {
    function RTPProxy(options) {
        var _this = this;
        this.options = options;
        this.startingPort = 10000;
        this.setup = function () {
            return _this.createSocketPair(_this.type)
                .then(function (sockets) {
                _this.incomingRTPSocket = sockets[0];
                _this.incomingRTCPSocket = sockets[1];
                return _this.createSocket(_this.type);
            }).then(function (socket) {
                _this.outgoingSocket = socket;
                _this.onBound();
            });
        };
        this.destroy = function () {
            if (_this.incomingRTPSocket) {
                _this.incomingRTPSocket.close();
            }
            if (_this.incomingRTCPSocket) {
                _this.incomingRTCPSocket.close();
            }
            if (_this.outgoingSocket) {
                _this.outgoingSocket.close();
            }
        };
        this.incomingRTPPort = function () {
            var address = _this.incomingRTPSocket.address();
            if (typeof address !== 'string') {
                return address.port;
            }
        };
        this.incomingRTCPPort = function () {
            var address = _this.incomingRTCPSocket.address();
            if (typeof address !== 'string') {
                return address.port;
            }
        };
        this.outgoingLocalPort = function () {
            var address = _this.outgoingSocket.address();
            if (typeof address !== 'string') {
                return address.port;
            }
            return 0; // won't happen
        };
        this.setServerAddress = function (address) {
            _this.serverAddress = address;
        };
        this.setServerRTPPort = function (port) {
            _this.serverRTPPort = port;
        };
        this.setServerRTCPPort = function (port) {
            _this.serverRTCPPort = port;
        };
        this.setIncomingPayloadType = function (pt) {
            _this.incomingPayloadType = pt;
        };
        this.setOutgoingPayloadType = function (pt) {
            _this.outgoingPayloadType = pt;
        };
        this.sendOut = function (msg) {
            // Just drop it if we're not setup yet, I guess.
            if (!_this.outgoingAddress || !_this.outgoingPort)
                return;
            _this.outgoingSocket.send(msg, _this.outgoingPort, _this.outgoingAddress);
        };
        this.sendBack = function (msg) {
            // Just drop it if we're not setup yet, I guess.
            if (!_this.serverAddress || !_this.serverRTCPPort)
                return;
            _this.outgoingSocket.send(msg, _this.serverRTCPPort, _this.serverAddress);
        };
        this.onBound = function () {
            if (_this.disabled)
                return;
            _this.incomingRTPSocket.on('message', function (msg) {
                _this.rtpMessage(msg);
            });
            _this.incomingRTCPSocket.on('message', function (msg) {
                _this.rtcpMessage(msg);
            });
            _this.outgoingSocket.on('message', function (msg) {
                _this.rtcpReply(msg);
            });
        };
        this.rtpMessage = function (msg) {
            if (msg.length < 12) {
                // Not a proper RTP packet. Just forward it.
                _this.sendOut(msg);
                return;
            }
            var mpt = msg.readUInt8(1);
            var pt = mpt & 0x7F;
            if (pt == _this.incomingPayloadType) {
                // @ts-ignore
                mpt = (mpt & 0x80) | _this.outgoingPayloadType;
                msg.writeUInt8(mpt, 1);
            }
            if (_this.incomingSSRC === null)
                _this.incomingSSRC = msg.readUInt32BE(4);
            msg.writeUInt32BE(_this.outgoingSSRC, 8);
            _this.sendOut(msg);
        };
        this.processRTCPMessage = function (msg, transform) {
            var rtcpPackets = [];
            var offset = 0;
            while ((offset + 4) <= msg.length) {
                var pt = msg.readUInt8(offset + 1);
                var len = msg.readUInt16BE(offset + 2) * 4;
                if ((offset + 4 + len) > msg.length)
                    break;
                var packet = msg.slice(offset, offset + 4 + len);
                packet = transform(pt, packet);
                if (packet)
                    rtcpPackets.push(packet);
                offset += 4 + len;
            }
            if (rtcpPackets.length > 0)
                return Buffer.concat(rtcpPackets);
            return null;
        };
        this.rtcpMessage = function (msg) {
            var processed = _this.processRTCPMessage(msg, function (pt, packet) {
                if (pt != 200 || packet.length < 8)
                    return packet;
                if (_this.incomingSSRC === null)
                    _this.incomingSSRC = packet.readUInt32BE(4);
                packet.writeUInt32BE(_this.outgoingSSRC, 4);
                return packet;
            });
            if (processed)
                _this.sendOut(processed);
        };
        this.rtcpReply = function (msg) {
            var processed = _this.processRTCPMessage(msg, function (pt, packet) {
                if (pt != 201 || packet.length < 12)
                    return packet;
                // Assume source 1 is the one we want to edit.
                // @ts-ignore
                packet.writeUInt32BE(_this.incomingSSRC, 8);
                return packet;
            });
            if (processed)
                _this.sendOut(processed);
        };
        this.createSocket = function (type) {
            return new Promise(function (resolve) {
                var retry = function () {
                    var socket = dgram_1.default.createSocket(type);
                    var bindErrorHandler = function () {
                        if (_this.startingPort == 65535)
                            _this.startingPort = 10000;
                        else
                            ++_this.startingPort;
                        socket.close();
                        retry();
                    };
                    socket.once('error', bindErrorHandler);
                    socket.on('listening', function () {
                        resolve(socket);
                    });
                    socket.bind(_this.startingPort);
                };
                retry();
            });
        };
        this.createSocketPair = function (type) {
            return new Promise(function (resolve) {
                var retry = function () {
                    var socket1 = dgram_1.default.createSocket(type);
                    var socket2 = dgram_1.default.createSocket(type);
                    var state = { socket1: 0, socket2: 0 };
                    var recheck = function () {
                        if (state.socket1 == 0 || state.socket2 == 0)
                            return;
                        if (state.socket1 == 2 && state.socket2 == 2) {
                            resolve([socket1, socket2]);
                            return;
                        }
                        if (_this.startingPort == 65534)
                            _this.startingPort = 10000;
                        else
                            ++_this.startingPort;
                        socket1.close();
                        socket2.close();
                        retry();
                    };
                    socket1.once('error', function () {
                        state.socket1 = 1;
                        recheck();
                    });
                    socket2.once('error', function () {
                        state.socket2 = 1;
                        recheck();
                    });
                    socket1.once('listening', function () {
                        state.socket1 = 2;
                        recheck();
                    });
                    socket2.once('listening', function () {
                        state.socket2 = 2;
                        recheck();
                    });
                    socket1.bind(_this.startingPort);
                    socket2.bind(_this.startingPort + 1);
                };
                retry();
            });
        };
        this.type = options.isIPV6 ? 'udp6' : 'udp4';
        this.startingPort = 10000;
        this.outgoingAddress = options.outgoingAddress;
        this.outgoingPort = options.outgoingPort;
        this.incomingPayloadType = 0;
        this.outgoingSSRC = options.outgoingSSRC;
        this.disabled = options.disabled;
        this.incomingSSRC = null;
        this.outgoingPayloadType = null;
    }
    return RTPProxy;
}());
exports.default = RTPProxy;
//# sourceMappingURL=RTPProxy.js.map

/***/ }),

/***/ 8533:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StreamController = exports.RTPStreamManagement = exports.StreamRequestTypes = exports.AudioStreamingSamplerate = exports.AudioStreamingCodecType = exports.SRTPCryptoSuites = exports.H264Level = exports.H264Profile = void 0;
var tslib_1 = __nccwpck_require__(4290);
var crypto_1 = tslib_1.__importDefault(__nccwpck_require__(6417));
var debug_1 = tslib_1.__importDefault(__nccwpck_require__(7984));
var net_1 = tslib_1.__importDefault(__nccwpck_require__(1631));
// noinspection JSDeprecatedSymbols
var index_1 = __nccwpck_require__(7585);
var Characteristic_1 = __nccwpck_require__(3859);
var controller_1 = __nccwpck_require__(9237);
var Service_1 = __nccwpck_require__(7383);
var tlv = tslib_1.__importStar(__nccwpck_require__(4041));
var RTPProxy_1 = tslib_1.__importDefault(__nccwpck_require__(9091));
var debug = debug_1.default('HAP-NodeJS:Camera:RTPStreamManagement');
// ---------------------------------- TLV DEFINITIONS START ----------------------------------
var StreamingStatusTypes;
(function (StreamingStatusTypes) {
    StreamingStatusTypes[StreamingStatusTypes["STATUS"] = 1] = "STATUS";
})(StreamingStatusTypes || (StreamingStatusTypes = {}));
var StreamingStatus;
(function (StreamingStatus) {
    StreamingStatus[StreamingStatus["AVAILABLE"] = 0] = "AVAILABLE";
    StreamingStatus[StreamingStatus["IN_USE"] = 1] = "IN_USE";
    StreamingStatus[StreamingStatus["UNAVAILABLE"] = 2] = "UNAVAILABLE";
})(StreamingStatus || (StreamingStatus = {}));
// ----------
var SupportedVideoStreamConfigurationTypes;
(function (SupportedVideoStreamConfigurationTypes) {
    SupportedVideoStreamConfigurationTypes[SupportedVideoStreamConfigurationTypes["VIDEO_CODEC_CONFIGURATION"] = 1] = "VIDEO_CODEC_CONFIGURATION";
})(SupportedVideoStreamConfigurationTypes || (SupportedVideoStreamConfigurationTypes = {}));
var VideoCodecConfigurationTypes;
(function (VideoCodecConfigurationTypes) {
    VideoCodecConfigurationTypes[VideoCodecConfigurationTypes["CODEC_TYPE"] = 1] = "CODEC_TYPE";
    VideoCodecConfigurationTypes[VideoCodecConfigurationTypes["CODEC_PARAMETERS"] = 2] = "CODEC_PARAMETERS";
    VideoCodecConfigurationTypes[VideoCodecConfigurationTypes["ATTRIBUTES"] = 3] = "ATTRIBUTES";
})(VideoCodecConfigurationTypes || (VideoCodecConfigurationTypes = {}));
var VideoCodecParametersTypes;
(function (VideoCodecParametersTypes) {
    VideoCodecParametersTypes[VideoCodecParametersTypes["PROFILE_ID"] = 1] = "PROFILE_ID";
    VideoCodecParametersTypes[VideoCodecParametersTypes["LEVEL"] = 2] = "LEVEL";
    VideoCodecParametersTypes[VideoCodecParametersTypes["PACKETIZATION_MODE"] = 3] = "PACKETIZATION_MODE";
    VideoCodecParametersTypes[VideoCodecParametersTypes["CVO_ENABLED"] = 4] = "CVO_ENABLED";
    VideoCodecParametersTypes[VideoCodecParametersTypes["CVO_ID"] = 5] = "CVO_ID";
})(VideoCodecParametersTypes || (VideoCodecParametersTypes = {}));
var VideoAttributesTypes;
(function (VideoAttributesTypes) {
    VideoAttributesTypes[VideoAttributesTypes["IMAGE_WIDTH"] = 1] = "IMAGE_WIDTH";
    VideoAttributesTypes[VideoAttributesTypes["IMAGE_HEIGHT"] = 2] = "IMAGE_HEIGHT";
    VideoAttributesTypes[VideoAttributesTypes["FRAME_RATE"] = 3] = "FRAME_RATE";
})(VideoAttributesTypes || (VideoAttributesTypes = {}));
var VideoCodecType;
(function (VideoCodecType) {
    VideoCodecType[VideoCodecType["H264"] = 0] = "H264";
})(VideoCodecType || (VideoCodecType = {}));
var H264Profile;
(function (H264Profile) {
    H264Profile[H264Profile["BASELINE"] = 0] = "BASELINE";
    H264Profile[H264Profile["MAIN"] = 1] = "MAIN";
    H264Profile[H264Profile["HIGH"] = 2] = "HIGH";
})(H264Profile = exports.H264Profile || (exports.H264Profile = {}));
var H264Level;
(function (H264Level) {
    H264Level[H264Level["LEVEL3_1"] = 0] = "LEVEL3_1";
    H264Level[H264Level["LEVEL3_2"] = 1] = "LEVEL3_2";
    H264Level[H264Level["LEVEL4_0"] = 2] = "LEVEL4_0";
})(H264Level = exports.H264Level || (exports.H264Level = {}));
var VideoCodecPacketizationMode;
(function (VideoCodecPacketizationMode) {
    VideoCodecPacketizationMode[VideoCodecPacketizationMode["NON_INTERLEAVED"] = 0] = "NON_INTERLEAVED";
})(VideoCodecPacketizationMode || (VideoCodecPacketizationMode = {}));
var VideoCodecCVO;
(function (VideoCodecCVO) {
    VideoCodecCVO[VideoCodecCVO["UNSUPPORTED"] = 1] = "UNSUPPORTED";
    VideoCodecCVO[VideoCodecCVO["SUPPORTED"] = 2] = "SUPPORTED";
})(VideoCodecCVO || (VideoCodecCVO = {}));
// ----------
var SupportedAudioStreamConfigurationTypes;
(function (SupportedAudioStreamConfigurationTypes) {
    SupportedAudioStreamConfigurationTypes[SupportedAudioStreamConfigurationTypes["AUDIO_CODEC_CONFIGURATION"] = 1] = "AUDIO_CODEC_CONFIGURATION";
    SupportedAudioStreamConfigurationTypes[SupportedAudioStreamConfigurationTypes["COMFORT_NOISE_SUPPORT"] = 2] = "COMFORT_NOISE_SUPPORT";
})(SupportedAudioStreamConfigurationTypes || (SupportedAudioStreamConfigurationTypes = {}));
var AudioCodecConfigurationTypes;
(function (AudioCodecConfigurationTypes) {
    AudioCodecConfigurationTypes[AudioCodecConfigurationTypes["CODEC_TYPE"] = 1] = "CODEC_TYPE";
    AudioCodecConfigurationTypes[AudioCodecConfigurationTypes["CODEC_PARAMETERS"] = 2] = "CODEC_PARAMETERS";
})(AudioCodecConfigurationTypes || (AudioCodecConfigurationTypes = {}));
var AudioCodecTypes;
(function (AudioCodecTypes) {
    AudioCodecTypes[AudioCodecTypes["PCMU"] = 0] = "PCMU";
    AudioCodecTypes[AudioCodecTypes["PCMA"] = 1] = "PCMA";
    AudioCodecTypes[AudioCodecTypes["AAC_ELD"] = 2] = "AAC_ELD";
    AudioCodecTypes[AudioCodecTypes["OPUS"] = 3] = "OPUS";
    AudioCodecTypes[AudioCodecTypes["MSBC"] = 4] = "MSBC";
    AudioCodecTypes[AudioCodecTypes["AMR"] = 5] = "AMR";
    AudioCodecTypes[AudioCodecTypes["AMR_WB"] = 6] = "AMR_WB";
})(AudioCodecTypes || (AudioCodecTypes = {}));
var AudioCodecParametersTypes;
(function (AudioCodecParametersTypes) {
    AudioCodecParametersTypes[AudioCodecParametersTypes["CHANNEL"] = 1] = "CHANNEL";
    AudioCodecParametersTypes[AudioCodecParametersTypes["BIT_RATE"] = 2] = "BIT_RATE";
    AudioCodecParametersTypes[AudioCodecParametersTypes["SAMPLE_RATE"] = 3] = "SAMPLE_RATE";
    AudioCodecParametersTypes[AudioCodecParametersTypes["PACKET_TIME"] = 4] = "PACKET_TIME"; // only present in selected audio codec parameters tlv
})(AudioCodecParametersTypes || (AudioCodecParametersTypes = {}));
var AudioBitrate;
(function (AudioBitrate) {
    AudioBitrate[AudioBitrate["VARIABLE"] = 0] = "VARIABLE";
    AudioBitrate[AudioBitrate["CONSTANT"] = 1] = "CONSTANT";
})(AudioBitrate || (AudioBitrate = {}));
var AudioSamplerate;
(function (AudioSamplerate) {
    AudioSamplerate[AudioSamplerate["KHZ_8"] = 0] = "KHZ_8";
    AudioSamplerate[AudioSamplerate["KHZ_16"] = 1] = "KHZ_16";
    AudioSamplerate[AudioSamplerate["KHZ_24"] = 2] = "KHZ_24";
    // 3, 4, 5 are theoretically defined, but no idea to what kHz value they correspond to
    // probably KHZ_32, KHZ_44_1, KHZ_48 (as supported by Secure Video recordings)
})(AudioSamplerate || (AudioSamplerate = {}));
// ----------
var SupportedRTPConfigurationTypes;
(function (SupportedRTPConfigurationTypes) {
    SupportedRTPConfigurationTypes[SupportedRTPConfigurationTypes["SRTP_CRYPTO_SUITE"] = 2] = "SRTP_CRYPTO_SUITE";
})(SupportedRTPConfigurationTypes || (SupportedRTPConfigurationTypes = {}));
var SRTPCryptoSuites;
(function (SRTPCryptoSuites) {
    SRTPCryptoSuites[SRTPCryptoSuites["AES_CM_128_HMAC_SHA1_80"] = 0] = "AES_CM_128_HMAC_SHA1_80";
    SRTPCryptoSuites[SRTPCryptoSuites["AES_CM_256_HMAC_SHA1_80"] = 1] = "AES_CM_256_HMAC_SHA1_80";
    SRTPCryptoSuites[SRTPCryptoSuites["NONE"] = 2] = "NONE";
})(SRTPCryptoSuites = exports.SRTPCryptoSuites || (exports.SRTPCryptoSuites = {}));
// ----------
var SetupEndpointsTypes;
(function (SetupEndpointsTypes) {
    SetupEndpointsTypes[SetupEndpointsTypes["SESSION_ID"] = 1] = "SESSION_ID";
    SetupEndpointsTypes[SetupEndpointsTypes["CONTROLLER_ADDRESS"] = 3] = "CONTROLLER_ADDRESS";
    SetupEndpointsTypes[SetupEndpointsTypes["VIDEO_SRTP_PARAMETERS"] = 4] = "VIDEO_SRTP_PARAMETERS";
    SetupEndpointsTypes[SetupEndpointsTypes["AUDIO_SRTP_PARAMETERS"] = 5] = "AUDIO_SRTP_PARAMETERS";
})(SetupEndpointsTypes || (SetupEndpointsTypes = {}));
var AddressTypes;
(function (AddressTypes) {
    AddressTypes[AddressTypes["ADDRESS_VERSION"] = 1] = "ADDRESS_VERSION";
    AddressTypes[AddressTypes["ADDRESS"] = 2] = "ADDRESS";
    AddressTypes[AddressTypes["VIDEO_RTP_PORT"] = 3] = "VIDEO_RTP_PORT";
    AddressTypes[AddressTypes["AUDIO_RTP_PORT"] = 4] = "AUDIO_RTP_PORT";
})(AddressTypes || (AddressTypes = {}));
var IPAddressVersion;
(function (IPAddressVersion) {
    IPAddressVersion[IPAddressVersion["IPV4"] = 0] = "IPV4";
    IPAddressVersion[IPAddressVersion["IPV6"] = 1] = "IPV6";
})(IPAddressVersion || (IPAddressVersion = {}));
var SRTPParametersTypes;
(function (SRTPParametersTypes) {
    SRTPParametersTypes[SRTPParametersTypes["SRTP_CRYPTO_SUITE"] = 1] = "SRTP_CRYPTO_SUITE";
    SRTPParametersTypes[SRTPParametersTypes["MASTER_KEY"] = 2] = "MASTER_KEY";
    SRTPParametersTypes[SRTPParametersTypes["MASTER_SALT"] = 3] = "MASTER_SALT"; // 14 bytes
})(SRTPParametersTypes || (SRTPParametersTypes = {}));
var SetupEndpointsResponseTypes;
(function (SetupEndpointsResponseTypes) {
    SetupEndpointsResponseTypes[SetupEndpointsResponseTypes["SESSION_ID"] = 1] = "SESSION_ID";
    SetupEndpointsResponseTypes[SetupEndpointsResponseTypes["STATUS"] = 2] = "STATUS";
    SetupEndpointsResponseTypes[SetupEndpointsResponseTypes["ACCESSORY_ADDRESS"] = 3] = "ACCESSORY_ADDRESS";
    SetupEndpointsResponseTypes[SetupEndpointsResponseTypes["VIDEO_SRTP_PARAMETERS"] = 4] = "VIDEO_SRTP_PARAMETERS";
    SetupEndpointsResponseTypes[SetupEndpointsResponseTypes["AUDIO_SRTP_PARAMETERS"] = 5] = "AUDIO_SRTP_PARAMETERS";
    SetupEndpointsResponseTypes[SetupEndpointsResponseTypes["VIDEO_SSRC"] = 6] = "VIDEO_SSRC";
    SetupEndpointsResponseTypes[SetupEndpointsResponseTypes["AUDIO_SSRC"] = 7] = "AUDIO_SSRC";
})(SetupEndpointsResponseTypes || (SetupEndpointsResponseTypes = {}));
var SetupEndpointsStatus;
(function (SetupEndpointsStatus) {
    SetupEndpointsStatus[SetupEndpointsStatus["SUCCESS"] = 0] = "SUCCESS";
    SetupEndpointsStatus[SetupEndpointsStatus["BUSY"] = 1] = "BUSY";
    SetupEndpointsStatus[SetupEndpointsStatus["ERROR"] = 2] = "ERROR";
})(SetupEndpointsStatus || (SetupEndpointsStatus = {}));
// ----------
var SelectedRTPStreamConfigurationTypes;
(function (SelectedRTPStreamConfigurationTypes) {
    SelectedRTPStreamConfigurationTypes[SelectedRTPStreamConfigurationTypes["SESSION_CONTROL"] = 1] = "SESSION_CONTROL";
    SelectedRTPStreamConfigurationTypes[SelectedRTPStreamConfigurationTypes["SELECTED_VIDEO_PARAMETERS"] = 2] = "SELECTED_VIDEO_PARAMETERS";
    SelectedRTPStreamConfigurationTypes[SelectedRTPStreamConfigurationTypes["SELECTED_AUDIO_PARAMETERS"] = 3] = "SELECTED_AUDIO_PARAMETERS";
})(SelectedRTPStreamConfigurationTypes || (SelectedRTPStreamConfigurationTypes = {}));
var SessionControlTypes;
(function (SessionControlTypes) {
    SessionControlTypes[SessionControlTypes["SESSION_IDENTIFIER"] = 1] = "SESSION_IDENTIFIER";
    SessionControlTypes[SessionControlTypes["COMMAND"] = 2] = "COMMAND";
})(SessionControlTypes || (SessionControlTypes = {}));
var SessionControlCommand;
(function (SessionControlCommand) {
    SessionControlCommand[SessionControlCommand["END_SESSION"] = 0] = "END_SESSION";
    SessionControlCommand[SessionControlCommand["START_SESSION"] = 1] = "START_SESSION";
    SessionControlCommand[SessionControlCommand["SUSPEND_SESSION"] = 2] = "SUSPEND_SESSION";
    SessionControlCommand[SessionControlCommand["RESUME_SESSION"] = 3] = "RESUME_SESSION";
    SessionControlCommand[SessionControlCommand["RECONFIGURE_SESSION"] = 4] = "RECONFIGURE_SESSION";
})(SessionControlCommand || (SessionControlCommand = {}));
var SelectedVideoParametersTypes;
(function (SelectedVideoParametersTypes) {
    SelectedVideoParametersTypes[SelectedVideoParametersTypes["CODEC_TYPE"] = 1] = "CODEC_TYPE";
    SelectedVideoParametersTypes[SelectedVideoParametersTypes["CODEC_PARAMETERS"] = 2] = "CODEC_PARAMETERS";
    SelectedVideoParametersTypes[SelectedVideoParametersTypes["ATTRIBUTES"] = 3] = "ATTRIBUTES";
    SelectedVideoParametersTypes[SelectedVideoParametersTypes["RTP_PARAMETERS"] = 4] = "RTP_PARAMETERS";
})(SelectedVideoParametersTypes || (SelectedVideoParametersTypes = {}));
var VideoRTPParametersTypes;
(function (VideoRTPParametersTypes) {
    VideoRTPParametersTypes[VideoRTPParametersTypes["PAYLOAD_TYPE"] = 1] = "PAYLOAD_TYPE";
    VideoRTPParametersTypes[VideoRTPParametersTypes["SYNCHRONIZATION_SOURCE"] = 2] = "SYNCHRONIZATION_SOURCE";
    VideoRTPParametersTypes[VideoRTPParametersTypes["MAX_BIT_RATE"] = 3] = "MAX_BIT_RATE";
    VideoRTPParametersTypes[VideoRTPParametersTypes["MIN_RTCP_INTERVAL"] = 4] = "MIN_RTCP_INTERVAL";
    VideoRTPParametersTypes[VideoRTPParametersTypes["MAX_MTU"] = 5] = "MAX_MTU";
})(VideoRTPParametersTypes || (VideoRTPParametersTypes = {}));
var SelectedAudioParametersTypes;
(function (SelectedAudioParametersTypes) {
    SelectedAudioParametersTypes[SelectedAudioParametersTypes["CODEC_TYPE"] = 1] = "CODEC_TYPE";
    SelectedAudioParametersTypes[SelectedAudioParametersTypes["CODEC_PARAMETERS"] = 2] = "CODEC_PARAMETERS";
    SelectedAudioParametersTypes[SelectedAudioParametersTypes["RTP_PARAMETERS"] = 3] = "RTP_PARAMETERS";
    SelectedAudioParametersTypes[SelectedAudioParametersTypes["COMFORT_NOISE"] = 4] = "COMFORT_NOISE";
})(SelectedAudioParametersTypes || (SelectedAudioParametersTypes = {}));
var AudioRTPParametersTypes;
(function (AudioRTPParametersTypes) {
    AudioRTPParametersTypes[AudioRTPParametersTypes["PAYLOAD_TYPE"] = 1] = "PAYLOAD_TYPE";
    AudioRTPParametersTypes[AudioRTPParametersTypes["SYNCHRONIZATION_SOURCE"] = 2] = "SYNCHRONIZATION_SOURCE";
    AudioRTPParametersTypes[AudioRTPParametersTypes["MAX_BIT_RATE"] = 3] = "MAX_BIT_RATE";
    AudioRTPParametersTypes[AudioRTPParametersTypes["MIN_RTCP_INTERVAL"] = 4] = "MIN_RTCP_INTERVAL";
    AudioRTPParametersTypes[AudioRTPParametersTypes["COMFORT_NOISE_PAYLOAD_TYPE"] = 6] = "COMFORT_NOISE_PAYLOAD_TYPE";
})(AudioRTPParametersTypes || (AudioRTPParametersTypes = {}));
function isLegacySRTPOptions(options) {
    return "srtp" in options;
}
var AudioStreamingCodecType;
(function (AudioStreamingCodecType) {
    AudioStreamingCodecType["PCMU"] = "PCMU";
    AudioStreamingCodecType["PCMA"] = "PCMA";
    AudioStreamingCodecType["AAC_ELD"] = "AAC-eld";
    AudioStreamingCodecType["OPUS"] = "OPUS";
    AudioStreamingCodecType["MSBC"] = "mSBC";
    AudioStreamingCodecType["AMR"] = "AMR";
    AudioStreamingCodecType["AMR_WB"] = "AMR-WB";
})(AudioStreamingCodecType = exports.AudioStreamingCodecType || (exports.AudioStreamingCodecType = {}));
var AudioStreamingSamplerate;
(function (AudioStreamingSamplerate) {
    AudioStreamingSamplerate[AudioStreamingSamplerate["KHZ_8"] = 8] = "KHZ_8";
    AudioStreamingSamplerate[AudioStreamingSamplerate["KHZ_16"] = 16] = "KHZ_16";
    AudioStreamingSamplerate[AudioStreamingSamplerate["KHZ_24"] = 24] = "KHZ_24";
})(AudioStreamingSamplerate = exports.AudioStreamingSamplerate || (exports.AudioStreamingSamplerate = {}));
var StreamRequestTypes;
(function (StreamRequestTypes) {
    StreamRequestTypes["RECONFIGURE"] = "reconfigure";
    StreamRequestTypes["START"] = "start";
    StreamRequestTypes["STOP"] = "stop";
})(StreamRequestTypes = exports.StreamRequestTypes || (exports.StreamRequestTypes = {}));
var RTPStreamManagement = /** @class */ (function () {
    function RTPStreamManagement(id, options, delegate, service) {
        this.videoOnly = false;
        this.sessionIdentifier = undefined;
        this.streamStatus = 0 /* AVAILABLE */; // use _updateStreamStatus to update this property
        this.delegate = delegate;
        this.requireProxy = options.proxy || false;
        this.disableAudioProxy = options.disable_audio_proxy || false;
        if (isLegacySRTPOptions(options)) {
            this.supportedCryptoSuites = [options.srtp ? 0 /* AES_CM_128_HMAC_SHA1_80 */ : 2 /* NONE */];
        }
        else {
            this.supportedCryptoSuites = options.supportedCryptoSuites;
        }
        if (this.supportedCryptoSuites.length === 0) {
            this.supportedCryptoSuites.push(2 /* NONE */);
        }
        if (!options.video) {
            throw new Error('Video parameters cannot be undefined in options');
        }
        this.supportedRTPConfiguration = RTPStreamManagement._supportedRTPConfiguration(this.supportedCryptoSuites);
        this.supportedVideoStreamConfiguration = RTPStreamManagement._supportedVideoStreamConfiguration(options.video);
        this.supportedAudioStreamConfiguration = this._supportedAudioStreamConfiguration(options.audio);
        this.selectedConfiguration = RTPStreamManagement.initialSelectedStreamConfiguration();
        this.setupEndpointsResponse = RTPStreamManagement.initialSetupEndpointsResponse();
        this.service = service || this.constructService(id);
        this.setupServiceHandlers();
    }
    RTPStreamManagement.prototype.forceStop = function () {
        this.handleSessionClosed();
    };
    RTPStreamManagement.prototype.getService = function () {
        return this.service;
    };
    // noinspection JSUnusedGlobalSymbols,JSUnusedLocalSymbols
    /**
     * @deprecated
     */
    RTPStreamManagement.prototype.handleCloseConnection = function (connectionID) {
        // This method is only here for legacy compatibility. It used to be called by legacy style CameraSource
        // implementations to signal that the associated HAP connection was closed.
        // This is now handled automatically. Thus we don't need to do anything anymore.
    };
    RTPStreamManagement.prototype.handleFactoryReset = function () {
        this.selectedConfiguration = RTPStreamManagement.initialSelectedStreamConfiguration();
        this.setupEndpointsResponse = RTPStreamManagement.initialSetupEndpointsResponse();
        // on a factory reset the assumption is that all connections were already terminated and thus "handleStopStream" was already called
    };
    RTPStreamManagement.prototype.destroy = function () {
        if (this.activeConnection) {
            this._handleStopStream();
        }
    };
    RTPStreamManagement.prototype.constructService = function (id) {
        var managementService = new Service_1.Service.CameraRTPStreamManagement('', id.toString());
        managementService.setCharacteristic(Characteristic_1.Characteristic.Active, true);
        managementService.setCharacteristic(Characteristic_1.Characteristic.SupportedRTPConfiguration, this.supportedRTPConfiguration);
        managementService.setCharacteristic(Characteristic_1.Characteristic.SupportedVideoStreamConfiguration, this.supportedVideoStreamConfiguration);
        managementService.setCharacteristic(Characteristic_1.Characteristic.SupportedAudioStreamConfiguration, this.supportedAudioStreamConfiguration);
        return managementService;
    };
    RTPStreamManagement.prototype.setupServiceHandlers = function () {
        var _this = this;
        this._updateStreamStatus(0 /* AVAILABLE */); // reset streaming status to available
        this.service.setCharacteristic(Characteristic_1.Characteristic.SetupEndpoints, this.setupEndpointsResponse); // reset SetupEndpoints to default
        this.service.getCharacteristic(Characteristic_1.Characteristic.SelectedRTPStreamConfiguration)
            .on("get" /* GET */, function (callback) {
            callback(null, _this.selectedConfiguration);
        })
            .on("set" /* SET */, this._handleSelectedStreamConfigurationWrite.bind(this));
        this.service.getCharacteristic(Characteristic_1.Characteristic.SetupEndpoints)
            .on("get" /* GET */, function (callback) {
            callback(null, _this.setupEndpointsResponse);
        })
            .on("set" /* SET */, function (value, callback, context, connection) {
            if (!connection) {
                debug("Set event handler for SetupEndpoints cannot be called from plugin. Connection undefined!");
                callback(-70410 /* INVALID_VALUE_IN_REQUEST */);
                return;
            }
            _this.handleSetupEndpoints(value, callback, connection);
        });
    };
    RTPStreamManagement.prototype.handleSessionClosed = function () {
        this.selectedConfiguration = RTPStreamManagement.initialSelectedStreamConfiguration();
        this.setupEndpointsResponse = RTPStreamManagement.initialSetupEndpointsResponse();
        if (this.activeConnectionClosedListener && this.activeConnection) {
            this.activeConnection.removeListener("closed" /* CLOSED */, this.activeConnectionClosedListener);
            this.activeConnectionClosedListener = undefined;
        }
        this._updateStreamStatus(0 /* AVAILABLE */);
        this.sessionIdentifier = undefined;
        this.activeConnection = undefined;
        // noinspection JSDeprecatedSymbols
        this.connectionID = undefined;
        this.ipVersion = undefined;
        if (this.videoProxy) {
            this.videoProxy.destroy();
            this.videoProxy = undefined;
        }
        if (this.audioProxy) {
            this.audioProxy.destroy();
            this.audioProxy = undefined;
        }
    };
    RTPStreamManagement.prototype._handleSelectedStreamConfigurationWrite = function (value, callback) {
        var _this = this;
        var data = Buffer.from(value, 'base64');
        var objects = tlv.decode(data);
        var sessionControl = tlv.decode(objects[1 /* SESSION_CONTROL */]);
        var sessionIdentifier = index_1.uuid.unparse(sessionControl[1 /* SESSION_IDENTIFIER */]);
        var requestType = sessionControl[2 /* COMMAND */][0];
        if (sessionIdentifier !== this.sessionIdentifier) {
            debug("Received unknown session Identifier with request to " + SessionControlCommand[requestType]);
            callback(-70410 /* INVALID_VALUE_IN_REQUEST */);
            return;
        }
        this.selectedConfiguration = value;
        // intercept the callback chain to check if an error occurred.
        var streamCallback = function (error, writeResponse) {
            callback(error, writeResponse); // does not support writeResponse, but how knows what comes in the future.
            if (error) {
                _this.handleSessionClosed();
            }
        };
        switch (requestType) {
            case SessionControlCommand.START_SESSION:
                var selectedVideoParameters = tlv.decode(objects[2 /* SELECTED_VIDEO_PARAMETERS */]);
                var selectedAudioParameters = tlv.decode(objects[3 /* SELECTED_AUDIO_PARAMETERS */]);
                this._handleStartStream(selectedVideoParameters, selectedAudioParameters, streamCallback);
                break;
            case SessionControlCommand.RECONFIGURE_SESSION:
                var reconfiguredVideoParameters = tlv.decode(objects[2 /* SELECTED_VIDEO_PARAMETERS */]);
                this.handleReconfigureStream(reconfiguredVideoParameters, streamCallback);
                break;
            case SessionControlCommand.END_SESSION:
                this._handleStopStream(streamCallback);
                break;
            case SessionControlCommand.RESUME_SESSION:
            case SessionControlCommand.SUSPEND_SESSION:
            default:
                debug("Unhandled request type " + SessionControlCommand[requestType]);
                callback(-70410 /* INVALID_VALUE_IN_REQUEST */);
                return;
        }
    };
    RTPStreamManagement.prototype._handleStartStream = function (videoConfiguration, audioConfiguration, callback) {
        // selected video configuration
        // noinspection JSUnusedLocalSymbols
        var videoCodec = videoConfiguration[1 /* CODEC_TYPE */]; // always 0x00 for h264
        var videoParametersTLV = videoConfiguration[2 /* CODEC_PARAMETERS */];
        var videoAttributesTLV = videoConfiguration[3 /* ATTRIBUTES */];
        var videoRTPParametersTLV = videoConfiguration[4 /* RTP_PARAMETERS */];
        // video parameters
        var videoParameters = tlv.decode(videoParametersTLV);
        var h264Profile = videoParameters[1 /* PROFILE_ID */][0];
        var h264Level = videoParameters[2 /* LEVEL */][0];
        var packetizationMode = videoParameters[3 /* PACKETIZATION_MODE */][0];
        var cvoEnabled = videoParameters[4 /* CVO_ENABLED */];
        var cvoId = undefined;
        if (cvoEnabled && cvoEnabled[0] === 2 /* SUPPORTED */) {
            cvoId = videoParameters[5 /* CVO_ID */].readUInt8(0);
        }
        // video attributes
        var videoAttributes = tlv.decode(videoAttributesTLV);
        var width = videoAttributes[1 /* IMAGE_WIDTH */].readUInt16LE(0);
        var height = videoAttributes[2 /* IMAGE_HEIGHT */].readUInt16LE(0);
        var frameRate = videoAttributes[3 /* FRAME_RATE */].readUInt8(0);
        // video rtp parameters
        var videoRTPParameters = tlv.decode(videoRTPParametersTLV);
        var videoPayloadType = videoRTPParameters[1 /* PAYLOAD_TYPE */].readUInt8(0); // 99
        var videoSSRC = videoRTPParameters[2 /* SYNCHRONIZATION_SOURCE */].readUInt32LE(0);
        var videoMaximumBitrate = videoRTPParameters[3 /* MAX_BIT_RATE */].readUInt16LE(0);
        var videoRTCPInterval = videoRTPParameters[4 /* MIN_RTCP_INTERVAL */].readFloatLE(0);
        var maxMTU = this.ipVersion === "ipv6" ? 1228 : 1378; // default values ipv4: 1378 bytes; ipv6: 1228 bytes
        if (videoRTPParameters[5 /* MAX_MTU */]) {
            maxMTU = videoRTPParameters[5 /* MAX_MTU */].readUInt16LE(0);
        }
        // selected audio configuration
        var audioCodec = audioConfiguration[1 /* CODEC_TYPE */][0];
        var audioParametersTLV = audioConfiguration[2 /* CODEC_PARAMETERS */];
        var audioRTPParametersTLV = audioConfiguration[3 /* RTP_PARAMETERS */];
        var comfortNoise = !!audioConfiguration[4 /* COMFORT_NOISE */].readUInt8(0);
        // audio parameters
        var audioParameters = tlv.decode(audioParametersTLV);
        var channels = audioParameters[1 /* CHANNEL */][0];
        var audioBitrate = audioParameters[2 /* BIT_RATE */][0];
        var samplerate = audioParameters[3 /* SAMPLE_RATE */][0];
        var rtpPacketTime = audioParameters[4 /* PACKET_TIME */].readUInt8(0);
        // audio rtp parameters
        var audioRTPParameters = tlv.decode(audioRTPParametersTLV);
        var audioPayloadType = audioRTPParameters[1 /* PAYLOAD_TYPE */].readUInt8(0); // 110
        var audioSSRC = audioRTPParameters[2 /* SYNCHRONIZATION_SOURCE */].readUInt32LE(0);
        var audioMaximumBitrate = audioRTPParameters[3 /* MAX_BIT_RATE */].readUInt16LE(0);
        var audioRTCPInterval = audioRTPParameters[4 /* MIN_RTCP_INTERVAL */].readFloatLE(0);
        var comfortNoisePayloadType = audioRTPParameters[6 /* COMFORT_NOISE_PAYLOAD_TYPE */].readUInt8(0); // 13
        if (this.requireProxy) {
            this.videoProxy.setOutgoingPayloadType(videoPayloadType);
            if (!this.disableAudioProxy) {
                this.audioProxy.setOutgoingPayloadType(audioPayloadType);
            }
        }
        var videoInfo = {
            profile: h264Profile,
            level: h264Level,
            packetizationMode: packetizationMode,
            cvoId: cvoId,
            width: width,
            height: height,
            fps: frameRate,
            pt: videoPayloadType,
            ssrc: videoSSRC,
            max_bit_rate: videoMaximumBitrate,
            rtcp_interval: videoRTCPInterval,
            mtu: maxMTU,
        };
        var audioCodecName;
        var samplerateNum;
        switch (audioCodec) {
            case 0 /* PCMU */:
                audioCodecName = "PCMU" /* PCMU */;
                break;
            case 1 /* PCMA */:
                audioCodecName = "PCMA" /* PCMA */;
                break;
            case 2 /* AAC_ELD */:
                audioCodecName = "AAC-eld" /* AAC_ELD */;
                break;
            case 3 /* OPUS */:
                audioCodecName = "OPUS" /* OPUS */;
                break;
            case 4 /* MSBC */:
                audioCodecName = "mSBC" /* MSBC */;
                break;
            case 5 /* AMR */:
                audioCodecName = "AMR" /* AMR */;
                break;
            case 6 /* AMR_WB */:
                audioCodecName = "AMR-WB" /* AMR_WB */;
                break;
            default:
                throw new Error("Encountered unknown selected audio codec " + audioCodec);
        }
        switch (samplerate) {
            case 0 /* KHZ_8 */:
                samplerateNum = 8;
                break;
            case 1 /* KHZ_16 */:
                samplerateNum = 16;
                break;
            case 2 /* KHZ_24 */:
                samplerateNum = 24;
                break;
            default:
                throw new Error("Encountered unknown selected audio samplerate " + samplerate);
        }
        var audioInfo = {
            codec: audioCodecName,
            channel: channels,
            bit_rate: audioBitrate,
            sample_rate: samplerateNum,
            packet_time: rtpPacketTime,
            pt: audioPayloadType,
            ssrc: audioSSRC,
            max_bit_rate: audioMaximumBitrate,
            rtcp_interval: audioRTCPInterval,
            comfort_pt: comfortNoisePayloadType,
            comfortNoiseEnabled: comfortNoise,
        };
        var request = {
            sessionID: this.sessionIdentifier,
            type: "start" /* START */,
            video: videoInfo,
            audio: audioInfo,
        };
        this.delegate.handleStreamRequest(request, function (error) { return callback(error); });
    };
    RTPStreamManagement.prototype.handleReconfigureStream = function (videoConfiguration, callback) {
        // selected video configuration
        var videoAttributesTLV = videoConfiguration[3 /* ATTRIBUTES */];
        var videoRTPParametersTLV = videoConfiguration[4 /* RTP_PARAMETERS */];
        // video attributes
        var videoAttributes = tlv.decode(videoAttributesTLV);
        var width = videoAttributes[1 /* IMAGE_WIDTH */].readUInt16LE(0);
        var height = videoAttributes[2 /* IMAGE_HEIGHT */].readUInt16LE(0);
        var frameRate = videoAttributes[3 /* FRAME_RATE */].readUInt8(0);
        // video rtp parameters
        var videoRTPParameters = tlv.decode(videoRTPParametersTLV);
        var videoMaximumBitrate = videoRTPParameters[3 /* MAX_BIT_RATE */].readUInt16LE(0);
        var videoRTCPInterval = videoRTPParameters[4 /* MIN_RTCP_INTERVAL */].readFloatLE(0) || 0.5; // seems to be always zero, use default of 0.5
        var reconfiguredVideoInfo = {
            width: width,
            height: height,
            fps: frameRate,
            max_bit_rate: videoMaximumBitrate,
            rtcp_interval: videoRTCPInterval,
        };
        var request = {
            sessionID: this.sessionIdentifier,
            type: "reconfigure" /* RECONFIGURE */,
            video: reconfiguredVideoInfo,
        };
        this.delegate.handleStreamRequest(request, function (error) { return callback(error); });
    };
    RTPStreamManagement.prototype._handleStopStream = function (callback) {
        var request = {
            sessionID: this.sessionIdentifier,
            type: "stop" /* STOP */,
        };
        this.handleSessionClosed();
        this.delegate.handleStreamRequest(request, function (error) { return callback ? callback(error) : undefined; });
    };
    RTPStreamManagement.prototype.handleSetupEndpoints = function (value, callback, connection) {
        var _this = this;
        var data = Buffer.from(value, 'base64');
        var objects = tlv.decode(data);
        var sessionIdentifier = index_1.uuid.unparse(objects[1 /* SESSION_ID */]);
        if (this.streamStatus !== 0 /* AVAILABLE */) {
            this.setupEndpointsResponse = tlv.encode(1 /* SESSION_ID */, index_1.uuid.write(sessionIdentifier), 2 /* STATUS */, 1 /* BUSY */).toString("base64");
            callback();
            return;
        }
        this.activeConnection = connection;
        this.activeConnection.on("closed" /* CLOSED */, (this.activeConnectionClosedListener = this._handleStopStream.bind(this)));
        // noinspection JSDeprecatedSymbols
        this.connectionID = connection.sessionID;
        this.sessionIdentifier = sessionIdentifier;
        this._updateStreamStatus(1 /* IN_USE */);
        // Address
        var targetAddressPayload = objects[3 /* CONTROLLER_ADDRESS */];
        var processedAddressInfo = tlv.decode(targetAddressPayload);
        var addressVersion = processedAddressInfo[1 /* ADDRESS_VERSION */][0];
        var controllerAddress = processedAddressInfo[2 /* ADDRESS */].toString('utf8');
        var targetVideoPort = processedAddressInfo[3 /* VIDEO_RTP_PORT */].readUInt16LE(0);
        var targetAudioPort = processedAddressInfo[4 /* AUDIO_RTP_PORT */].readUInt16LE(0);
        // Video SRTP Params
        var videoSRTPPayload = objects[4 /* VIDEO_SRTP_PARAMETERS */];
        var processedVideoInfo = tlv.decode(videoSRTPPayload);
        var videoCryptoSuite = processedVideoInfo[1 /* SRTP_CRYPTO_SUITE */][0];
        var videoMasterKey = processedVideoInfo[2 /* MASTER_KEY */];
        var videoMasterSalt = processedVideoInfo[3 /* MASTER_SALT */];
        // Audio SRTP Params
        var audioSRTPPayload = objects[5 /* AUDIO_SRTP_PARAMETERS */];
        var processedAudioInfo = tlv.decode(audioSRTPPayload);
        var audioCryptoSuite = processedAudioInfo[1 /* SRTP_CRYPTO_SUITE */][0];
        var audioMasterKey = processedAudioInfo[2 /* MASTER_KEY */];
        var audioMasterSalt = processedAudioInfo[3 /* MASTER_SALT */];
        debug('Session: ', sessionIdentifier, '\nControllerAddress: ', controllerAddress, '\nVideoPort: ', targetVideoPort, '\nAudioPort: ', targetAudioPort, '\nVideo Crypto: ', videoCryptoSuite, '\nVideo Master Key: ', videoMasterKey, '\nVideo Master Salt: ', videoMasterSalt, '\nAudio Crypto: ', audioCryptoSuite, '\nAudio Master Key: ', audioMasterKey, '\nAudio Master Salt: ', audioMasterSalt);
        var prepareRequest = {
            sessionID: sessionIdentifier,
            targetAddress: controllerAddress,
            addressVersion: addressVersion === 1 /* IPV6 */ ? "ipv6" : "ipv4",
            video: {
                port: targetVideoPort,
                srtpCryptoSuite: videoCryptoSuite,
                srtp_key: videoMasterKey,
                srtp_salt: videoMasterSalt,
            },
            audio: {
                port: targetAudioPort,
                srtpCryptoSuite: audioCryptoSuite,
                srtp_key: audioMasterKey,
                srtp_salt: audioMasterSalt,
            },
        };
        var promises = [];
        if (this.requireProxy) {
            prepareRequest.targetAddress = connection.getLocalAddress(addressVersion === 1 /* IPV6 */ ? "ipv6" : "ipv4"); // ip versions must be the same
            this.videoProxy = new RTPProxy_1.default({
                outgoingAddress: controllerAddress,
                outgoingPort: targetVideoPort,
                outgoingSSRC: crypto_1.default.randomBytes(4).readUInt32LE(0),
                disabled: false
            });
            promises.push(this.videoProxy.setup().then(function () {
                prepareRequest.video.proxy_rtp = _this.videoProxy.incomingRTPPort();
                prepareRequest.video.proxy_rtcp = _this.videoProxy.incomingRTCPPort();
            }));
            if (!this.disableAudioProxy) {
                this.audioProxy = new RTPProxy_1.default({
                    outgoingAddress: controllerAddress,
                    outgoingPort: targetAudioPort,
                    outgoingSSRC: crypto_1.default.randomBytes(4).readUInt32LE(0),
                    disabled: this.videoOnly
                });
                promises.push(this.audioProxy.setup().then(function () {
                    prepareRequest.audio.proxy_rtp = _this.audioProxy.incomingRTPPort();
                    prepareRequest.audio.proxy_rtcp = _this.audioProxy.incomingRTCPPort();
                }));
            }
        }
        Promise.all(promises).then(function () {
            _this.delegate.prepareStream(prepareRequest, index_1.once(function (error, response) {
                if (error || !response) {
                    debug("PrepareStream request encountered an error: " + (error ? error.message : undefined));
                    _this.setupEndpointsResponse = tlv.encode(1 /* SESSION_ID */, index_1.uuid.write(sessionIdentifier), 2 /* STATUS */, 2 /* ERROR */).toString("base64");
                    _this.handleSessionClosed();
                    callback(error);
                }
                else {
                    _this.generateSetupEndpointResponse(connection, sessionIdentifier, prepareRequest, response, callback);
                }
            }));
        });
    };
    RTPStreamManagement.prototype.generateSetupEndpointResponse = function (connection, identifier, request, response, callback) {
        var address;
        var addressVersion = request.addressVersion;
        var videoPort;
        var audioPort;
        var videoCryptoSuite;
        var videoSRTPKey;
        var videoSRTPSalt;
        var audioCryptoSuite;
        var audioSRTPKey;
        var audioSRTPSalt;
        var videoSSRC;
        var audioSSRC;
        if (!this.videoOnly && !response.audio) {
            throw new Error("Audio was enabled but not supplied in PrepareStreamResponse!");
        }
        // Provide default values if audio was not supplied
        var audio = response.audio || {
            port: request.audio.port,
            ssrc: controller_1.CameraController.generateSynchronisationSource(),
            srtp_key: request.audio.srtp_key,
            srtp_salt: request.audio.srtp_salt,
        };
        if (!this.requireProxy) {
            var videoInfo = response.video;
            var audioInfo = audio;
            if (response.addressOverride) {
                addressVersion = net_1.default.isIPv4(response.addressOverride) ? "ipv4" : "ipv6";
                address = response.addressOverride;
            }
            else {
                address = connection.getLocalAddress(addressVersion);
            }
            if (request.addressVersion !== addressVersion) {
                throw new Error("Incoming and outgoing ip address versions must match! Expected " + request.addressVersion + " but got " + addressVersion);
            }
            videoPort = videoInfo.port;
            audioPort = audioInfo.port;
            if (request.video.srtpCryptoSuite !== 2 /* NONE */
                && (videoInfo.srtp_key === undefined || videoInfo.srtp_salt === undefined)) {
                throw new Error("SRTP was selected for the prepared video stream, but no 'srtp_key' or 'srtp_salt' was specified!");
            }
            if (request.audio.srtpCryptoSuite !== 2 /* NONE */
                && (audioInfo.srtp_key === undefined || audioInfo.srtp_salt === undefined)) {
                throw new Error("SRTP was selected for the prepared audio stream, but no 'srtp_key' or 'srtp_salt' was specified!");
            }
            videoCryptoSuite = request.video.srtpCryptoSuite;
            videoSRTPKey = videoInfo.srtp_key || Buffer.alloc(0); // key and salt are zero-length for cryptoSuite = NONE
            videoSRTPSalt = videoInfo.srtp_salt || Buffer.alloc(0);
            audioCryptoSuite = request.audio.srtpCryptoSuite;
            audioSRTPKey = audioInfo.srtp_key || Buffer.alloc(0); // key and salt are zero-length for cryptoSuite = NONE
            audioSRTPSalt = audioInfo.srtp_salt || Buffer.alloc(0);
            videoSSRC = videoInfo.ssrc;
            audioSSRC = audioInfo.ssrc;
        }
        else {
            var videoInfo = response.video;
            address = connection.getLocalAddress(request.addressVersion);
            videoCryptoSuite = 2 /* NONE */;
            videoSRTPKey = Buffer.alloc(0);
            videoSRTPSalt = Buffer.alloc(0);
            audioCryptoSuite = 2 /* NONE */;
            audioSRTPKey = Buffer.alloc(0);
            audioSRTPSalt = Buffer.alloc(0);
            this.videoProxy.setIncomingPayloadType(videoInfo.proxy_pt);
            this.videoProxy.setServerAddress(videoInfo.proxy_server_address);
            this.videoProxy.setServerRTPPort(videoInfo.proxy_server_rtp);
            this.videoProxy.setServerRTCPPort(videoInfo.proxy_server_rtcp);
            videoPort = this.videoProxy.outgoingLocalPort();
            videoSSRC = this.videoProxy.outgoingSSRC;
            if (!this.disableAudioProxy) {
                var audioInfo = response.audio;
                this.audioProxy.setIncomingPayloadType(audioInfo.proxy_pt);
                this.audioProxy.setServerAddress(audioInfo.proxy_server_address);
                this.audioProxy.setServerRTPPort(audioInfo.proxy_server_rtp);
                this.audioProxy.setServerRTCPPort(audioInfo.proxy_server_rtcp);
                audioPort = this.audioProxy.outgoingLocalPort();
                audioSSRC = this.audioProxy.outgoingSSRC;
            }
            else {
                var audioInfo = response.audio;
                audioPort = audioInfo.port;
                audioSSRC = audioInfo.ssrc;
            }
        }
        this.ipVersion = addressVersion; // we need to save this in order to calculate some default mtu values later
        var accessoryAddress = tlv.encode(1 /* ADDRESS_VERSION */, addressVersion === "ipv4" ? 0 /* IPV4 */ : 1 /* IPV6 */, 2 /* ADDRESS */, address, 3 /* VIDEO_RTP_PORT */, tlv.writeUInt16(videoPort), 4 /* AUDIO_RTP_PORT */, tlv.writeUInt16(audioPort));
        var videoSRTPParameters = tlv.encode(1 /* SRTP_CRYPTO_SUITE */, videoCryptoSuite, 2 /* MASTER_KEY */, videoSRTPKey, 3 /* MASTER_SALT */, videoSRTPSalt);
        var audioSRTPParameters = tlv.encode(1 /* SRTP_CRYPTO_SUITE */, audioCryptoSuite, 2 /* MASTER_KEY */, audioSRTPKey, 3 /* MASTER_SALT */, audioSRTPSalt);
        this.setupEndpointsResponse = tlv.encode(1 /* SESSION_ID */, index_1.uuid.write(identifier), 2 /* STATUS */, 0 /* SUCCESS */, 3 /* ACCESSORY_ADDRESS */, accessoryAddress, 4 /* VIDEO_SRTP_PARAMETERS */, videoSRTPParameters, 5 /* AUDIO_SRTP_PARAMETERS */, audioSRTPParameters, 6 /* VIDEO_SSRC */, tlv.writeUInt32(videoSSRC), 7 /* AUDIO_SSRC */, tlv.writeUInt32(audioSSRC)).toString("base64");
        callback();
    };
    RTPStreamManagement.prototype._updateStreamStatus = function (status) {
        this.streamStatus = status;
        this.service.updateCharacteristic(Characteristic_1.Characteristic.StreamingStatus, tlv.encode(1 /* STATUS */, this.streamStatus).toString('base64'));
    };
    RTPStreamManagement._supportedRTPConfiguration = function (supportedCryptoSuites) {
        if (supportedCryptoSuites.length === 1 && supportedCryptoSuites[0] === 2 /* NONE */) {
            debug("Client claims it doesn't support SRTP. The stream may stops working with future iOS releases.");
        }
        return tlv.encode(2 /* SRTP_CRYPTO_SUITE */, supportedCryptoSuites).toString("base64");
    };
    RTPStreamManagement._supportedVideoStreamConfiguration = function (videoOptions) {
        if (!videoOptions.codec) {
            throw new Error('Video codec cannot be undefined');
        }
        if (!videoOptions.resolutions) {
            throw new Error('Video resolutions cannot be undefined');
        }
        var codecParameters = tlv.encode(1 /* PROFILE_ID */, videoOptions.codec.profiles, 2 /* LEVEL */, videoOptions.codec.levels, 3 /* PACKETIZATION_MODE */, 0 /* NON_INTERLEAVED */);
        if (videoOptions.cvoId != undefined) {
            codecParameters = Buffer.concat([
                codecParameters,
                tlv.encode(4 /* CVO_ENABLED */, 2 /* SUPPORTED */, 5 /* CVO_ID */, videoOptions.cvoId)
            ]);
        }
        var videoStreamConfiguration = tlv.encode(1 /* CODEC_TYPE */, 0 /* H264 */, 2 /* CODEC_PARAMETERS */, codecParameters, 3 /* ATTRIBUTES */, videoOptions.resolutions.map(function (resolution) {
            if (resolution.length != 3) {
                throw new Error('Unexpected video resolution');
            }
            var width = Buffer.alloc(2);
            var height = Buffer.alloc(2);
            var frameRate = Buffer.alloc(1);
            width.writeUInt16LE(resolution[0], 0);
            height.writeUInt16LE(resolution[1], 0);
            frameRate.writeUInt8(resolution[2], 0);
            return tlv.encode(1 /* IMAGE_WIDTH */, width, 2 /* IMAGE_HEIGHT */, height, 3 /* FRAME_RATE */, frameRate);
        }));
        return tlv.encode(1 /* VIDEO_CODEC_CONFIGURATION */, videoStreamConfiguration).toString('base64');
    };
    RTPStreamManagement.prototype.checkForLegacyAudioCodecRepresentation = function (codecs) {
        var codecMap = {};
        codecs.slice().forEach(function (codec) {
            var previous = codecMap[codec.type];
            if (previous) {
                if (typeof previous.samplerate === "number") {
                    previous.samplerate = [previous.samplerate];
                }
                previous.samplerate = previous.samplerate.concat(codec.samplerate);
                var index = codecs.indexOf(codec);
                if (index >= 0) {
                    codecs.splice(index, 1);
                }
            }
            else {
                codecMap[codec.type] = codec;
            }
        });
    };
    RTPStreamManagement.prototype._supportedAudioStreamConfiguration = function (audioOptions) {
        // Only AAC-ELD and OPUS are accepted by iOS currently, and we need to give it something it will accept
        // for it to start the video stream.
        var comfortNoise = audioOptions && !!audioOptions.comfort_noise;
        var supportedCodecs = (audioOptions && audioOptions.codecs) || [];
        this.checkForLegacyAudioCodecRepresentation(supportedCodecs);
        if (supportedCodecs.length === 0) { // Fake a Codec if we haven't got anything
            debug("Client doesn't support any audio codec that HomeKit supports.");
            this.videoOnly = true;
            supportedCodecs.push({
                type: "OPUS" /* OPUS */,
                samplerate: [16 /* KHZ_16 */, 24 /* KHZ_24 */],
            });
        }
        var codecConfigurations = supportedCodecs.map(function (codec) {
            var type;
            switch (codec.type) {
                case "OPUS" /* OPUS */:
                    type = 3 /* OPUS */;
                    break;
                case "AAC-eld" /* AAC_ELD */:
                    type = 2 /* AAC_ELD */;
                    break;
                case "PCMA" /* PCMA */:
                    type = 1 /* PCMA */;
                    break;
                case "PCMU" /* PCMU */:
                    type = 0 /* PCMU */;
                    break;
                case "mSBC" /* MSBC */:
                    type = 4 /* MSBC */;
                    break;
                case "AMR" /* AMR */:
                    type = 5 /* AMR */;
                    break;
                case "AMR-WB" /* AMR_WB */:
                    type = 6 /* AMR_WB */;
                    break;
                default:
                    throw new Error("Unsupported codec: " + codec.type);
            }
            var providedSamplerates = (typeof codec.samplerate === "number" ? [codec.samplerate] : codec.samplerate).map(function (rate) {
                var samplerate;
                switch (rate) {
                    case 8 /* KHZ_8 */:
                        samplerate = 0 /* KHZ_8 */;
                        break;
                    case 16 /* KHZ_16 */:
                        samplerate = 1 /* KHZ_16 */;
                        break;
                    case 24 /* KHZ_24 */:
                        samplerate = 2 /* KHZ_24 */;
                        break;
                    default:
                        console.log("Unsupported sample rate: ", codec.samplerate);
                        samplerate = -1;
                }
                return samplerate;
            }).filter(function (rate) { return rate !== -1; });
            if (providedSamplerates.length === 0) {
                throw new Error("Audio samplerate cannot be empty!");
            }
            var audioParameters = tlv.encode(1 /* CHANNEL */, Math.max(1, codec.audioChannels || 1), 2 /* BIT_RATE */, codec.bitrate || 0 /* VARIABLE */, 3 /* SAMPLE_RATE */, providedSamplerates);
            return tlv.encode(1 /* CODEC_TYPE */, type, 2 /* CODEC_PARAMETERS */, audioParameters);
        });
        return tlv.encode(1 /* AUDIO_CODEC_CONFIGURATION */, codecConfigurations, 2 /* COMFORT_NOISE_SUPPORT */, comfortNoise ? 1 : 0).toString("base64");
    };
    RTPStreamManagement.initialSetupEndpointsResponse = function () {
        return tlv.encode(2 /* STATUS */, 2 /* ERROR */).toString("base64");
    };
    RTPStreamManagement.initialSelectedStreamConfiguration = function () {
        return tlv.encode(1 /* SESSION_CONTROL */, tlv.encode(2 /* COMMAND */, SessionControlCommand.SUSPEND_SESSION)).toString("base64");
    };
    /**
     * @deprecated Please use the SRTPCryptoSuites const enum above. Scheduled to be removed in 2021-06.
     */
    // @ts-ignore
    RTPStreamManagement.SRTPCryptoSuites = SRTPCryptoSuites;
    /**
     * @deprecated Please use the H264Profile const enum above. Scheduled to be removed in 2021-06.
     */
    // @ts-ignore
    RTPStreamManagement.VideoCodecParamProfileIDTypes = H264Profile;
    /**
     * @deprecated won't be updated anymore. Please use the H264Level const enum above. Scheduled to be removed in 2021-06.
     */
    // @ts-ignore
    RTPStreamManagement.VideoCodecParamLevelTypes = Object.freeze({ TYPE3_1: 0, TYPE3_2: 1, TYPE4_0: 2 });
    return RTPStreamManagement;
}());
exports.RTPStreamManagement = RTPStreamManagement;
/**
 * @deprecated - only there for backwards compatibility, please use {@see RTPStreamManagement} directly
 */
var StreamController = /** @class */ (function (_super) {
    tslib_1.__extends(StreamController, _super);
    // noinspection JSDeprecatedSymbols
    function StreamController(id, options, delegate, service) {
        var _this = _super.call(this, id, options, new index_1.LegacyCameraSourceAdapter(delegate), service) || this;
        _this.options = options;
        return _this;
    }
    return StreamController;
}(RTPStreamManagement));
exports.StreamController = StreamController;
//# sourceMappingURL=RTPStreamManagement.js.map

/***/ }),

/***/ 4992:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4290);
tslib_1.__exportStar(__nccwpck_require__(7757), exports);
tslib_1.__exportStar(__nccwpck_require__(9091), exports);
tslib_1.__exportStar(__nccwpck_require__(8533), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9659:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdaptiveLightingController = exports.AdaptiveLightingControllerEvents = exports.AdaptiveLightingControllerMode = void 0;
var tslib_1 = __nccwpck_require__(4290);
var assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
var uuid = tslib_1.__importStar(__nccwpck_require__(6814));
var debug_1 = tslib_1.__importDefault(__nccwpck_require__(7984));
var events_1 = __nccwpck_require__(8614);
var __1 = __nccwpck_require__(7585);
var Characteristic_1 = __nccwpck_require__(3859);
var tlv = tslib_1.__importStar(__nccwpck_require__(4041));
var debug = debug_1.default("HAP-NodeJS:Controller:TransitionControl");
var SupportedCharacteristicValueTransitionConfigurationsTypes;
(function (SupportedCharacteristicValueTransitionConfigurationsTypes) {
    SupportedCharacteristicValueTransitionConfigurationsTypes[SupportedCharacteristicValueTransitionConfigurationsTypes["SUPPORTED_TRANSITION_CONFIGURATION"] = 1] = "SUPPORTED_TRANSITION_CONFIGURATION";
})(SupportedCharacteristicValueTransitionConfigurationsTypes || (SupportedCharacteristicValueTransitionConfigurationsTypes = {}));
var SupportedValueTransitionConfigurationTypes;
(function (SupportedValueTransitionConfigurationTypes) {
    SupportedValueTransitionConfigurationTypes[SupportedValueTransitionConfigurationTypes["CHARACTERISTIC_IID"] = 1] = "CHARACTERISTIC_IID";
    SupportedValueTransitionConfigurationTypes[SupportedValueTransitionConfigurationTypes["TRANSITION_TYPE"] = 2] = "TRANSITION_TYPE";
})(SupportedValueTransitionConfigurationTypes || (SupportedValueTransitionConfigurationTypes = {}));
var TransitionType;
(function (TransitionType) {
    TransitionType[TransitionType["BRIGHTNESS"] = 1] = "BRIGHTNESS";
    TransitionType[TransitionType["COLOR_TEMPERATURE"] = 2] = "COLOR_TEMPERATURE";
})(TransitionType || (TransitionType = {}));
var TransitionControlTypes;
(function (TransitionControlTypes) {
    TransitionControlTypes[TransitionControlTypes["READ_CURRENT_VALUE_TRANSITION_CONFIGURATION"] = 1] = "READ_CURRENT_VALUE_TRANSITION_CONFIGURATION";
    TransitionControlTypes[TransitionControlTypes["UPDATE_VALUE_TRANSITION_CONFIGURATION"] = 2] = "UPDATE_VALUE_TRANSITION_CONFIGURATION";
})(TransitionControlTypes || (TransitionControlTypes = {}));
var ReadValueTransitionConfiguration;
(function (ReadValueTransitionConfiguration) {
    ReadValueTransitionConfiguration[ReadValueTransitionConfiguration["CHARACTERISTIC_IID"] = 1] = "CHARACTERISTIC_IID";
})(ReadValueTransitionConfiguration || (ReadValueTransitionConfiguration = {}));
var UpdateValueTransitionConfigurationsTypes;
(function (UpdateValueTransitionConfigurationsTypes) {
    UpdateValueTransitionConfigurationsTypes[UpdateValueTransitionConfigurationsTypes["VALUE_TRANSITION_CONFIGURATION"] = 1] = "VALUE_TRANSITION_CONFIGURATION";
})(UpdateValueTransitionConfigurationsTypes || (UpdateValueTransitionConfigurationsTypes = {}));
var ValueTransitionConfigurationTypes;
(function (ValueTransitionConfigurationTypes) {
    // noinspection JSUnusedGlobalSymbols
    ValueTransitionConfigurationTypes[ValueTransitionConfigurationTypes["CHARACTERISTIC_IID"] = 1] = "CHARACTERISTIC_IID";
    ValueTransitionConfigurationTypes[ValueTransitionConfigurationTypes["TRANSITION_PARAMETERS"] = 2] = "TRANSITION_PARAMETERS";
    ValueTransitionConfigurationTypes[ValueTransitionConfigurationTypes["UNKNOWN_3"] = 3] = "UNKNOWN_3";
    ValueTransitionConfigurationTypes[ValueTransitionConfigurationTypes["UNKNOWN_4"] = 4] = "UNKNOWN_4";
    ValueTransitionConfigurationTypes[ValueTransitionConfigurationTypes["TRANSITION_CURVE_CONFIGURATION"] = 5] = "TRANSITION_CURVE_CONFIGURATION";
    ValueTransitionConfigurationTypes[ValueTransitionConfigurationTypes["UPDATE_INTERVAL"] = 6] = "UPDATE_INTERVAL";
    ValueTransitionConfigurationTypes[ValueTransitionConfigurationTypes["UNKNOWN_7"] = 7] = "UNKNOWN_7";
    ValueTransitionConfigurationTypes[ValueTransitionConfigurationTypes["NOTIFY_INTERVAL_THRESHOLD"] = 8] = "NOTIFY_INTERVAL_THRESHOLD";
})(ValueTransitionConfigurationTypes || (ValueTransitionConfigurationTypes = {}));
var ValueTransitionParametersTypes;
(function (ValueTransitionParametersTypes) {
    ValueTransitionParametersTypes[ValueTransitionParametersTypes["TRANSITION_ID"] = 1] = "TRANSITION_ID";
    ValueTransitionParametersTypes[ValueTransitionParametersTypes["START_TIME"] = 2] = "START_TIME";
    ValueTransitionParametersTypes[ValueTransitionParametersTypes["UNKNOWN_3"] = 3] = "UNKNOWN_3";
})(ValueTransitionParametersTypes || (ValueTransitionParametersTypes = {}));
var TransitionCurveConfigurationTypes;
(function (TransitionCurveConfigurationTypes) {
    TransitionCurveConfigurationTypes[TransitionCurveConfigurationTypes["TRANSITION_ENTRY"] = 1] = "TRANSITION_ENTRY";
    TransitionCurveConfigurationTypes[TransitionCurveConfigurationTypes["ADJUSTMENT_CHARACTERISTIC_IID"] = 2] = "ADJUSTMENT_CHARACTERISTIC_IID";
    TransitionCurveConfigurationTypes[TransitionCurveConfigurationTypes["ADJUSTMENT_MULTIPLIER_RANGE"] = 3] = "ADJUSTMENT_MULTIPLIER_RANGE";
})(TransitionCurveConfigurationTypes || (TransitionCurveConfigurationTypes = {}));
var TransitionEntryTypes;
(function (TransitionEntryTypes) {
    TransitionEntryTypes[TransitionEntryTypes["ADJUSTMENT_FACTOR"] = 1] = "ADJUSTMENT_FACTOR";
    TransitionEntryTypes[TransitionEntryTypes["VALUE"] = 2] = "VALUE";
    TransitionEntryTypes[TransitionEntryTypes["TRANSITION_OFFSET"] = 3] = "TRANSITION_OFFSET";
    TransitionEntryTypes[TransitionEntryTypes["DURATION"] = 4] = "DURATION";
})(TransitionEntryTypes || (TransitionEntryTypes = {}));
var TransitionAdjustmentMultiplierRange;
(function (TransitionAdjustmentMultiplierRange) {
    TransitionAdjustmentMultiplierRange[TransitionAdjustmentMultiplierRange["MINIMUM_ADJUSTMENT_MULTIPLIER"] = 1] = "MINIMUM_ADJUSTMENT_MULTIPLIER";
    TransitionAdjustmentMultiplierRange[TransitionAdjustmentMultiplierRange["MAXIMUM_ADJUSTMENT_MULTIPLIER"] = 2] = "MAXIMUM_ADJUSTMENT_MULTIPLIER";
})(TransitionAdjustmentMultiplierRange || (TransitionAdjustmentMultiplierRange = {}));
var ValueTransitionConfigurationResponseTypes;
(function (ValueTransitionConfigurationResponseTypes) {
    ValueTransitionConfigurationResponseTypes[ValueTransitionConfigurationResponseTypes["VALUE_CONFIGURATION_STATUS"] = 1] = "VALUE_CONFIGURATION_STATUS";
})(ValueTransitionConfigurationResponseTypes || (ValueTransitionConfigurationResponseTypes = {}));
var ValueTransitionConfigurationStatusTypes;
(function (ValueTransitionConfigurationStatusTypes) {
    ValueTransitionConfigurationStatusTypes[ValueTransitionConfigurationStatusTypes["CHARACTERISTIC_IID"] = 1] = "CHARACTERISTIC_IID";
    ValueTransitionConfigurationStatusTypes[ValueTransitionConfigurationStatusTypes["TRANSITION_PARAMETERS"] = 2] = "TRANSITION_PARAMETERS";
    ValueTransitionConfigurationStatusTypes[ValueTransitionConfigurationStatusTypes["TIME_SINCE_START"] = 3] = "TIME_SINCE_START";
})(ValueTransitionConfigurationStatusTypes || (ValueTransitionConfigurationStatusTypes = {}));
function isAdaptiveLightingContext(context) {
    return context && "controller" in context;
}
/**
 * Defines in which mode the {@link AdaptiveLightingController} will operate in.
 */
var AdaptiveLightingControllerMode;
(function (AdaptiveLightingControllerMode) {
    /**
     * In automatic mode pretty much everything from setup to transition scheduling is done by the controller.
     */
    AdaptiveLightingControllerMode[AdaptiveLightingControllerMode["AUTOMATIC"] = 1] = "AUTOMATIC";
    /**
     * In manual mode setup is done by the controller but the actual transition must be done by the user.
     * This is useful for lights which natively support transitions.
     */
    AdaptiveLightingControllerMode[AdaptiveLightingControllerMode["MANUAL"] = 2] = "MANUAL";
})(AdaptiveLightingControllerMode = exports.AdaptiveLightingControllerMode || (exports.AdaptiveLightingControllerMode = {}));
var AdaptiveLightingControllerEvents;
(function (AdaptiveLightingControllerEvents) {
    /**
     * This event is called once a HomeKit controller enables Adaptive Lighting
     * or a HomeHub sends a updated transition schedule for the next 24 hours.
     * This is also called on startup when AdaptiveLighting was previously enabled.
     */
    AdaptiveLightingControllerEvents["UPDATE"] = "update";
    /**
     * In yet unknown circumstances HomeKit may also send a dedicated disable command
     * via the control point characteristic. You may want to handle that in manual mode as well.
     * The current transition will still be associated with the controller object when this event is called.
     */
    AdaptiveLightingControllerEvents["DISABLED"] = "disable";
})(AdaptiveLightingControllerEvents = exports.AdaptiveLightingControllerEvents || (exports.AdaptiveLightingControllerEvents = {}));
/**
 * This class allows adding Adaptive Lighting support to Lightbulb services.
 * The Lightbulb service MUST have the {@link Characteristic.ColorTemperature} characteristic AND
 * the {@link Characteristic.Brightness} characteristic added.
 * The light may also expose {@link Characteristic.Hue} and {@link Characteristic.Saturation} characteristics
 * (though additional work is required to keep them in sync with the color temperature characteristic. see below)
 *
 * How Adaptive Lighting works:
 *  When enabling AdaptiveLighting the iDevice will send a transition schedule for the next 24 hours.
 *  This schedule will be renewed all 24 hours by a HomeHub in your home
 *  (updating the schedule according to your current day/night situation).
 *  Once enabled the lightbulb will execute the provided transitions. The color temperature value set is always
 *  dependent on the current brightness value. Meaning brighter light will be colder and darker light will be warmer.
 *  HomeKit considers Adaptive Lighting to be disabled as soon a write happens to either the
 *  Hue/Saturation or the ColorTemperature characteristics.
 *  The AdaptiveLighting state must persist across reboots.
 *
 * The AdaptiveLightingController can be operated in two modes: {@link AdaptiveLightingControllerMode.AUTOMATIC} and
 * {@link AdaptiveLightingControllerMode.MANUAL} with AUTOMATIC being the default.
 * The goal would be that the color transition is done DIRECTLY on the light itself, thus not creating any
 * additional/heavy traffic on the network.
 * So if your light hardware/API supports transitions please go the extra mile and use MANUAL mode.
 *
 *
 *
 * Below is an overview what you need to or consider when enabling AdaptiveLighting (categorized by mode).
 * The {@link AdaptiveLightingControllerMode} can be defined with the second constructor argument.
 *
 * <b>AUTOMATIC (Default mode):</b>
 *
 *  This is the easiest mode to setup and needs less to no work form your side for AdaptiveLighting to work.
 *  The AdaptiveLightingController will go through setup procedure with HomeKit and automatically update
 *  the color temperature characteristic base on the current transition schedule.
 *  It is also adjusting the color temperature when a write to the brightness characteristic happens.
 *  Additionally it will also handle turning off AdaptiveLighting, when it detects a write happening to the
 *  ColorTemperature, Hue or Saturation characteristic (though it can only detect writes coming from HomeKit and
 *  can't detect changes done to the physical devices directly! See below).
 *
 *  So what do you need to consider in automatic mode:
 *   - Brightness and ColorTemperature characteristics MUST be set up. Hue and Saturation may be added for color support.
 *   - Color temperature will be updated all 60 seconds by calling the SET handler of the ColorTemperature characteristic.
 *    So every transition behaves like a regular write to the ColorTemperature characteristic.
 *   - Every transition step is dependent on the current brightness value. Try to keep the internal cache updated
 *    as the controller won't call the GET handler every 60 seconds.
 *    (The cached brightness value is updated on SET/GET operations or by manually calling {@link Characteristic.updateValue}
 *    on the brightness characteristic).
 *   - Detecting changes on the lightbulb side:
 *    Any manual change to ColorTemperature or Hue/Saturation is considered as a signal to turn AdaptiveLighting off.
 *    In order to notify the AdaptiveLightingController of such an event happening OUTSIDE of HomeKit
 *    you must call {@link disableAdaptiveLighting} manually!
 *   - Be aware that even when the light is turned off the transition will continue to call the SET handler
 *    of the ColorTemperature characteristic.
 *   - When using Hue/Saturation:
 *    When using Hue/Saturation in combination with the ColorTemperature characteristic you need to update the
 *    respective other in a particular way depending if being in "color mode" or "color temperature mode".
 *    When a write happens to Hue/Saturation characteristic in is advised to set the internal value of the
 *    ColorTemperature to the minimal (NOT RAISING a event).
 *    When a write happens to the ColorTemperature characteristic just MUST convert to a proper representation
 *    in hue and saturation values, with RAISING a event.
 *    As noted above you MUST NOT call the {@link Characteristic.setValue} method for this, as this will be considered
 *    a write to the characteristic and will turn off AdaptiveLighting. Instead you should use
 *    {@link Characteristic.updateValue} for this.
 *    You can and SHOULD use the supplied utility method {@link ColorUtils.colorTemperatureToHueAndSaturation}
 *    for converting mired to hue and saturation values.
 *
 *
 * <b>MANUAL mode:</b>
 *
 *  Manual mode is recommended for any accessories which support transitions natively on the devices end.
 *  Like for example ZigBee lights which support sending transitions directly to the lightbulb which
 *  then get executed ON the lightbulb itself reducing unnecessary network traffic.
 *  Here is a quick overview what you have to consider to successfully implement AdaptiveLighting support.
 *  The AdaptiveLightingController will also in manual mode do all of the setup procedure.
 *  It will also save the transition schedule to disk to keep AdaptiveLighting enabled across reboots.
 *  The "only" thing you have to do yourself is handling the actual transitions, check that event notifications
 *  are only sent in the defined interval threshold, adjust the color temperature when brightness is changed
 *  and signal that Adaptive Lighting should be disabled if ColorTemperature, Hue or Saturation is changed manually.
 *
 *  First step is to setup up a event handler for the {@link AdaptiveLightingControllerEvents.UPDATE}, which is called
 *  when AdaptiveLighting is enabled, the HomeHub updates the schedule for the next 24 hours or AdaptiveLighting
 *  is restored from disk on startup.
 *  In the event handler you can get the current schedule via {@link AdaptiveLightingController.getAdaptiveLightingTransitionCurve},
 *  retrieve current intervals like {@link AdaptiveLightingController.getAdaptiveLightingUpdateInterval} or
 *  {@link AdaptiveLightingController.getAdaptiveLightingNotifyIntervalThreshold} and get the date in epoch millis
 *  when the current transition curve started using {@link AdaptiveLightingController.getAdaptiveLightingStartTimeOfTransition}.
 *  Additionally {@link AdaptiveLightingController.getAdaptiveLightingBrightnessMultiplierRange} can be used
 *  to get the valid range for the brightness value to calculate the brightness adjustment factor.
 *  The method {@link AdaptiveLightingController.isAdaptiveLightingActive} can be used to check if AdaptiveLighting is enabled.
 *  Besides actually running the transition (see {@link AdaptiveLightingTransitionCurveEntry}) you must
 *  correctly update the color temperature when the brightness of the lightbulb changes (see {@link AdaptiveLightingTransitionCurveEntry.brightnessAdjustmentFactor}),
 *  and signal when AdaptiveLighting got disabled by calling {@link AdaptiveLightingController.disableAdaptiveLighting}
 *  when ColorTemperature, Hue or Saturation where changed manually.
 *  Lastly you should set up a event handler for the {@link AdaptiveLightingControllerEvents.DISABLED} event.
 *  In yet unknown circumstances HomeKit may also send a dedicated disable command via the control point characteristic.
 *  Be prepared to handle that.
 */
var AdaptiveLightingController = /** @class */ (function (_super) {
    tslib_1.__extends(AdaptiveLightingController, _super);
    /**
     * Creates a new instance of the AdaptiveLightingController.
     * Refer to the {@link AdaptiveLightingController} documentation on how to use it.
     *
     * @param service - The lightbulb to which Adaptive Lighting support should be added.
     * @param options - Optional options to define the operating mode (automatic vs manual).
     */
    function AdaptiveLightingController(service, options) {
        var _a, _b;
        var _this = _super.call(this) || this;
        _this.didRunFirstInitializationStep = false;
        _this.lastEventNotificationSent = 0;
        _this.lastNotifiedTemperatureValue = 0;
        _this.lastNotifiedSaturationValue = 0;
        _this.lastNotifiedHueValue = 0;
        _this.lightbulb = service;
        _this.mode = (_a = options === null || options === void 0 ? void 0 : options.controllerMode) !== null && _a !== void 0 ? _a : 1 /* AUTOMATIC */;
        _this.customTemperatureAdjustment = (_b = options === null || options === void 0 ? void 0 : options.customTemperatureAdjustment) !== null && _b !== void 0 ? _b : 0;
        assert_1.default(_this.lightbulb.testCharacteristic(Characteristic_1.Characteristic.ColorTemperature), "Lightbulb must have the ColorTemperature characteristic added!");
        assert_1.default(_this.lightbulb.testCharacteristic(Characteristic_1.Characteristic.Brightness), "Lightbulb must have the Brightness characteristic added!");
        _this.adjustmentFactorChangedListener = _this.handleAdjustmentFactorChanged.bind(_this);
        _this.characteristicManualWrittenChangeListener = _this.handleCharacteristicManualWritten.bind(_this);
        return _this;
    }
    /**
     * @private
     */
    AdaptiveLightingController.prototype.controllerId = function () {
        return "characteristic-transition" /* CHARACTERISTIC_TRANSITION */ + "-" + this.lightbulb.getServiceId();
    };
    // ----------- PUBLIC API START -----------
    /**
     * Returns if a Adaptive Lighting transition is currently active.
     */
    AdaptiveLightingController.prototype.isAdaptiveLightingActive = function () {
        return !!this.activeTransition;
    };
    /**
     * This method can be called to manually disable the current active Adaptive Lighting transition.
     * When using {@link AdaptiveLightingControllerMode.AUTOMATIC} you won't need to call this method.
     * In {@link AdaptiveLightingControllerMode.MANUAL} you must call this method when Adaptive Lighting should be disabled.
     * This is the case when the user manually changes the value of Hue, Saturation or ColorTemperature characteristics
     * (or if any of those values is changed by physical interaction with the lightbulb).
     */
    AdaptiveLightingController.prototype.disableAdaptiveLighting = function () {
        if (this.updateTimeout) {
            clearTimeout(this.updateTimeout);
            this.updateTimeout = undefined;
        }
        if (this.activeTransition) {
            this.colorTemperatureCharacteristic.removeListener("change" /* CHANGE */, this.characteristicManualWrittenChangeListener);
            this.brightnessCharacteristic.removeListener("change" /* CHANGE */, this.adjustmentFactorChangedListener);
            if (this.hueCharacteristic) {
                this.hueCharacteristic.removeListener("change" /* CHANGE */, this.characteristicManualWrittenChangeListener);
            }
            if (this.saturationCharacteristic) {
                this.saturationCharacteristic.removeListener("change" /* CHANGE */, this.characteristicManualWrittenChangeListener);
            }
            this.activeTransition = undefined;
            this.stateChangeDelegate && this.stateChangeDelegate();
        }
        this.colorTemperatureCharacteristic = undefined;
        this.brightnessCharacteristic = undefined;
        this.hueCharacteristic = undefined;
        this.saturationCharacteristic = undefined;
        this.lastTransitionPointInfo = undefined;
        this.lastEventNotificationSent = 0;
        this.lastNotifiedTemperatureValue = 0;
        this.lastNotifiedSaturationValue = 0;
        this.lastNotifiedHueValue = 0;
        this.didRunFirstInitializationStep = false;
        this.activeTransitionCount.sendEventNotification(0);
        debug("[%s] Disabling adaptive lighting", this.lightbulb.displayName);
    };
    /**
     * Returns the time where the current transition curve was started in epoch time millis.
     * A transition curves is active for 24 hours typically and is renewed every 24 hours by a HomeHub.
     * Additionally see {@link getAdaptiveLightingTimeOffset}.
     */
    AdaptiveLightingController.prototype.getAdaptiveLightingStartTimeOfTransition = function () {
        if (!this.activeTransition) {
            throw new Error("There is no active transition!");
        }
        return this.activeTransition.transitionStartMillis;
    };
    /**
     * It is not necessarily given, that we have the same time (or rather the correct time) as the HomeKit controller
     * who set up the transition schedule.
     * Thus we record the delta between our current time and the the time send with the setup request.
     * <code>timeOffset</code> is defined as <code>Date.now() - getAdaptiveLightingStartTimeOfTransition();</code>.
     * So in the case were we actually have a correct local time, it most likely will be positive (due to network latency).
     * But of course it can also be negative.
     */
    AdaptiveLightingController.prototype.getAdaptiveLightingTimeOffset = function () {
        if (!this.activeTransition) {
            throw new Error("There is no active transition!");
        }
        return this.activeTransition.timeMillisOffset;
    };
    AdaptiveLightingController.prototype.getAdaptiveLightingTransitionCurve = function () {
        if (!this.activeTransition) {
            throw new Error("There is no active transition!");
        }
        return this.activeTransition.transitionCurve;
    };
    AdaptiveLightingController.prototype.getAdaptiveLightingBrightnessMultiplierRange = function () {
        if (!this.activeTransition) {
            throw new Error("There is no active transition!");
        }
        return this.activeTransition.brightnessAdjustmentRange;
    };
    /**
     * This method returns the interval (in milliseconds) in which the light should update its internal color temperature
     * (aka changes it physical color).
     * A lightbulb should ideally change this also when turned of in oder to have a smooth transition when turning the light on.
     *
     * Typically this evaluates to 60000 milliseconds (60 seconds).
     */
    AdaptiveLightingController.prototype.getAdaptiveLightingUpdateInterval = function () {
        if (!this.activeTransition) {
            throw new Error("There is no active transition!");
        }
        return this.activeTransition.updateInterval;
    };
    /**
     * Returns the minimum interval threshold (in milliseconds) a accessory may notify HomeKit controllers about a new
     * color temperature value via event notifications (what happens when you call {@link Characteristic.updateValue}).
     * Meaning the accessory should only send event notifications to subscribed HomeKit controllers at the specified interval.
     *
     * Typically this evaluates to 600000 milliseconds (10 minutes).
     */
    AdaptiveLightingController.prototype.getAdaptiveLightingNotifyIntervalThreshold = function () {
        if (!this.activeTransition) {
            throw new Error("There is no active transition!");
        }
        return this.activeTransition.notifyIntervalThreshold;
    };
    // ----------- PUBLIC API END -----------
    AdaptiveLightingController.prototype.handleActiveTransitionUpdated = function (calledFromDeserializer) {
        if (calledFromDeserializer === void 0) { calledFromDeserializer = false; }
        if (!calledFromDeserializer) {
            this.activeTransitionCount.sendEventNotification(1);
        }
        else {
            this.activeTransitionCount.value = 1;
        }
        if (this.mode === 1 /* AUTOMATIC */) {
            this.scheduleNextUpdate();
        }
        else if (this.mode === 2 /* MANUAL */) {
            this.emit("update" /* UPDATE */);
        }
        else {
            throw new Error("Unsupported adaptive lighting controller mode: " + this.mode);
        }
        if (!calledFromDeserializer) {
            this.stateChangeDelegate && this.stateChangeDelegate();
        }
    };
    AdaptiveLightingController.prototype.handleAdaptiveLightingEnabled = function () {
        if (!this.activeTransition) {
            throw new Error("There is no active transition!");
        }
        this.colorTemperatureCharacteristic = this.lightbulb.getCharacteristic(Characteristic_1.Characteristic.ColorTemperature);
        this.brightnessCharacteristic = this.lightbulb.getCharacteristic(Characteristic_1.Characteristic.Brightness);
        this.colorTemperatureCharacteristic.on("change" /* CHANGE */, this.characteristicManualWrittenChangeListener);
        this.brightnessCharacteristic.on("change" /* CHANGE */, this.adjustmentFactorChangedListener);
        if (this.lightbulb.testCharacteristic(Characteristic_1.Characteristic.Hue)) {
            this.hueCharacteristic = this.lightbulb.getCharacteristic(Characteristic_1.Characteristic.Hue)
                .on("change" /* CHANGE */, this.characteristicManualWrittenChangeListener);
        }
        if (this.lightbulb.testCharacteristic(Characteristic_1.Characteristic.Saturation)) {
            this.saturationCharacteristic = this.lightbulb.getCharacteristic(Characteristic_1.Characteristic.Saturation)
                .on("change" /* CHANGE */, this.characteristicManualWrittenChangeListener);
        }
    };
    AdaptiveLightingController.prototype.handleAdaptiveLightingDisabled = function () {
        if (this.mode === 2 /* MANUAL */ && this.activeTransition) { // only emit the event if a transition is actually enabled
            this.emit("disable" /* DISABLED */);
        }
        this.disableAdaptiveLighting();
    };
    AdaptiveLightingController.prototype.handleAdjustmentFactorChanged = function (change) {
        var _this = this;
        if (change.newValue === change.oldValue) {
            return;
        }
        // consider the following scenario:
        // a HomeKit controller queries the light (meaning e.g. Brightness, Hue and Saturation characteristics).
        // As of the implementation of the light the brightness characteristic get handler returns first
        // (and returns a value different than the cached value).
        // This change handler gets called and we will update the color temperature accordingly
        // (which also adjusts the internal cached values for Hue and Saturation).
        // After some short time the Hue or Saturation get handler return with the last known value to the plugin.
        // As those values now differ from the cached values (we already updated) we get a call to handleCharacteristicManualWritten
        // which again disables adaptive lighting.
        if (change.reason === "read" /* READ */) {
            // if the reason is a read request, we expect that Hue/Saturation are also read
            // thus we postpone our update to ColorTemperature a bit.
            // It doesn't ensure that those race conditions do not happen anymore, but with a 1s delay it reduces the possibility by a bit
            setTimeout(function () {
                if (!_this.activeTransition) {
                    return; // was disabled in the mean time
                }
                _this.scheduleNextUpdate(true);
            }, 1000).unref();
        }
        else {
            this.scheduleNextUpdate(true); // run a dry scheduleNextUpdate to adjust the colorTemperature using the new brightness value
        }
    };
    /**
     * This method is called when a change happens to the Hue/Saturation or ColorTemperature characteristic.
     * When such a write happens (caused by the user changing the color/temperature) Adaptive Lighting must be disabled.
     *
     * @param change
     */
    AdaptiveLightingController.prototype.handleCharacteristicManualWritten = function (change) {
        if (change.reason === "write" /* WRITE */ && !(isAdaptiveLightingContext(change.context) && change.context.controller === this)) {
            // we ignore write request which are the result of calls made to updateValue or sendEventNotification
            // or the result of a changed value returned by a read handler
            // or the change was done by the controller itself
            debug("[%s] Received a manual write to an characteristic (newValue: %d, oldValue: %d, reason: %s). Thus disabling adaptive lighting!", this.lightbulb.displayName, change.newValue, change.oldValue, change.reason);
            this.disableAdaptiveLighting();
        }
    };
    /**
     * Retrieve the {@link AdaptiveLightingTransitionPoint} for the current timestamp.
     * Returns undefined if the current transition schedule reached its end.
     */
    AdaptiveLightingController.prototype.getCurrentAdaptiveLightingTransitionPoint = function () {
        var _a, _b, _c, _d, _e;
        if (!this.activeTransition) {
            throw new Error("Cannot calculate current transition point if no transition is active!");
        }
        // adjustedNow is the now() date corrected to the time of the initiating controller
        var adjustedNow = Date.now() - this.activeTransition.timeMillisOffset;
        // "offset" since the start of the transition schedule
        var offset = adjustedNow - this.activeTransition.transitionStartMillis;
        var i = (_b = (_a = this.lastTransitionPointInfo) === null || _a === void 0 ? void 0 : _a.curveIndex) !== null && _b !== void 0 ? _b : 0;
        var lowerBoundTimeOffset = (_d = (_c = this.lastTransitionPointInfo) === null || _c === void 0 ? void 0 : _c.lowerBoundTimeOffset) !== null && _d !== void 0 ? _d : 0; // time offset to the lowerBound transition entry
        var lowerBound = undefined;
        var upperBound = undefined;
        for (; i + 1 < this.activeTransition.transitionCurve.length; i++) {
            var lowerBound0 = this.activeTransition.transitionCurve[i];
            var upperBound0 = this.activeTransition.transitionCurve[i + 1];
            var lowerBoundDuration = (_e = lowerBound0.duration) !== null && _e !== void 0 ? _e : 0;
            lowerBoundTimeOffset += lowerBound0.transitionTime;
            if (offset >= lowerBoundTimeOffset) {
                if (offset <= lowerBoundTimeOffset + lowerBoundDuration + upperBound0.transitionTime) {
                    lowerBound = lowerBound0;
                    upperBound = upperBound0;
                    break;
                }
            }
            else if (this.lastTransitionPointInfo) {
                // if we reached here the entry in the transitionCurve we are searching for is somewhere before current i.
                // This can only happen when we have a faulty lastTransitionPointInfo (otherwise we would start from i=0).
                // Thus we try again by searching from i=0
                this.lastTransitionPointInfo = undefined;
                return this.getCurrentAdaptiveLightingTransitionPoint();
            }
            lowerBoundTimeOffset += lowerBoundDuration;
        }
        if (!lowerBound || !upperBound) {
            this.lastTransitionPointInfo = undefined;
            return undefined;
        }
        this.lastTransitionPointInfo = {
            curveIndex: i,
            // we need to subtract lowerBound.transitionTime. When we start the loop above
            // with a saved transition point, we will always add lowerBound.transitionTime as first step.
            // Otherwise our calculations are simply wrong.
            lowerBoundTimeOffset: lowerBoundTimeOffset - lowerBound.transitionTime,
        };
        return {
            lowerBoundTimeOffset: lowerBoundTimeOffset,
            transitionOffset: offset - lowerBoundTimeOffset,
            lowerBound: lowerBound,
            upperBound: upperBound,
        };
    };
    AdaptiveLightingController.prototype.scheduleNextUpdate = function (dryRun) {
        var _this = this;
        var _a, _b, _c, _d, _e;
        if (dryRun === void 0) { dryRun = false; }
        if (!this.activeTransition) {
            throw new Error("tried scheduling transition when no transition was active!");
        }
        if (!dryRun) {
            this.updateTimeout = undefined;
        }
        if (!this.didRunFirstInitializationStep) {
            this.didRunFirstInitializationStep = true;
            this.handleAdaptiveLightingEnabled();
        }
        var transitionPoint = this.getCurrentAdaptiveLightingTransitionPoint();
        if (!transitionPoint) {
            debug("[%s] Reached end of transition curve!", this.lightbulb.displayName);
            if (!dryRun) {
                // the transition schedule is only for 24 hours, we reached the end?
                this.disableAdaptiveLighting();
            }
            return;
        }
        var lowerBound = transitionPoint.lowerBound;
        var upperBound = transitionPoint.upperBound;
        var interpolatedTemperature;
        var interpolatedAdjustmentFactor;
        if (lowerBound.duration && transitionPoint.transitionOffset <= lowerBound.duration) {
            interpolatedTemperature = lowerBound.temperature;
            interpolatedAdjustmentFactor = lowerBound.brightnessAdjustmentFactor;
        }
        else {
            var timePercentage = (transitionPoint.transitionOffset - ((_a = lowerBound.duration) !== null && _a !== void 0 ? _a : 0)) / upperBound.transitionTime;
            interpolatedTemperature = lowerBound.temperature + (upperBound.temperature - lowerBound.temperature) * timePercentage;
            interpolatedAdjustmentFactor = lowerBound.brightnessAdjustmentFactor + (upperBound.brightnessAdjustmentFactor - lowerBound.brightnessAdjustmentFactor) * timePercentage;
        }
        var adjustmentMultiplier = Math.max(this.activeTransition.brightnessAdjustmentRange.minBrightnessValue, Math.min(this.activeTransition.brightnessAdjustmentRange.maxBrightnessValue, this.brightnessCharacteristic.value // get handler is not called for optimal performance
        ));
        var temperature = Math.round(interpolatedTemperature + interpolatedAdjustmentFactor * adjustmentMultiplier);
        // apply any manually applied temperature adjustments
        temperature += this.customTemperatureAdjustment;
        var min = (_c = (_b = this.colorTemperatureCharacteristic) === null || _b === void 0 ? void 0 : _b.props.minValue) !== null && _c !== void 0 ? _c : 140;
        var max = (_e = (_d = this.colorTemperatureCharacteristic) === null || _d === void 0 ? void 0 : _d.props.maxValue) !== null && _e !== void 0 ? _e : 500;
        temperature = Math.max(min, Math.min(max, temperature));
        var color = __1.ColorUtils.colorTemperatureToHueAndSaturation(temperature);
        debug("[%s] Next temperature value is %d (for brightness %d adj: %s)", this.lightbulb.displayName, temperature, adjustmentMultiplier, this.customTemperatureAdjustment);
        var context = {
            controller: this,
            omitEventUpdate: true,
        };
        /*
         * We set saturation and hue values BEFORE we call the ColorTemperature SET handler (via setValue).
         * First thought was so the API user could get the values in the SET handler of the color temperature characteristic.
         * Do this is probably not really elegant cause this would only work when Adaptive Lighting is turned on
         * an the accessory MUST in any case update the Hue/Saturation values on a ColorTemperature write
         * (obviously only if Hue/Saturation characteristics are added to the service).
         *
         * The clever thing about this though is that, that it prevents notifications from being sent for Hue and Saturation
         * outside the specified notifyIntervalThreshold (see below where notifications are manually sent).
         * As the dev will or must call something like updateValue to propagate the updated hue and saturation values
         * to all HomeKit clients (so that the color is reflected in the UI), HAP-NodeJS won't send notifications
         * as the values are the same.
         * This of course only works if the plugin uses the exact same algorithm of "converting" the color temperature
         * value to the hue and saturation representation.
         */
        if (this.saturationCharacteristic) {
            this.saturationCharacteristic.value = color.saturation;
        }
        if (this.hueCharacteristic) {
            this.hueCharacteristic.value = color.hue;
        }
        this.colorTemperatureCharacteristic.handleSetRequest(temperature, undefined, context).catch(function (reason) {
            debug("[%s] Failed to next adaptive lighting transition point: %d", _this.lightbulb.displayName, reason);
        });
        if (!this.activeTransition) {
            console.warn("[" + this.lightbulb.displayName + "] Adaptive Lighting was probably disable my mistake by some call in the SET handler of the ColorTemperature characteristic! " +
                "Please check that you don't call setValue/setCharacteristic on the Hue, Saturation or ColorTemperature characteristic!");
            return;
        }
        var now = Date.now();
        if (!dryRun && now - this.lastEventNotificationSent >= this.activeTransition.notifyIntervalThreshold) {
            debug("[%s] Sending event notifications for current transition!", this.lightbulb.displayName);
            this.lastEventNotificationSent = now;
            var eventContext = {
                controller: this,
            };
            if (this.lastNotifiedTemperatureValue !== temperature) {
                this.colorTemperatureCharacteristic.sendEventNotification(temperature, eventContext);
                this.lastNotifiedTemperatureValue = temperature;
            }
            if (this.saturationCharacteristic && this.lastNotifiedSaturationValue !== color.saturation) {
                this.saturationCharacteristic.sendEventNotification(color.saturation, eventContext);
                this.lastNotifiedSaturationValue = color.saturation;
            }
            if (this.hueCharacteristic && this.lastNotifiedHueValue !== color.hue) {
                this.hueCharacteristic.sendEventNotification(color.hue, eventContext);
                this.lastNotifiedHueValue = color.hue;
            }
        }
        if (!dryRun) {
            this.updateTimeout = setTimeout(this.scheduleNextUpdate.bind(this), this.activeTransition.updateInterval);
        }
    };
    /**
     * @private
     */
    AdaptiveLightingController.prototype.constructServices = function () {
        return {};
    };
    /**
     * @private
     */
    AdaptiveLightingController.prototype.initWithServices = function (serviceMap) {
        // do nothing
    };
    /**
     * @private
     */
    AdaptiveLightingController.prototype.configureServices = function () {
        var _this = this;
        this.supportedTransitionConfiguration = this.lightbulb.getCharacteristic(Characteristic_1.Characteristic.SupportedCharacteristicValueTransitionConfiguration);
        this.transitionControl = this.lightbulb.getCharacteristic(Characteristic_1.Characteristic.CharacteristicValueTransitionControl)
            .updateValue("");
        this.activeTransitionCount = this.lightbulb.getCharacteristic(Characteristic_1.Characteristic.CharacteristicValueActiveTransitionCount)
            .updateValue(0);
        this.supportedTransitionConfiguration
            .onGet(this.handleSupportedTransitionConfigurationRead.bind(this));
        this.transitionControl
            .onGet(function () {
            return _this.buildTransitionControlResponseBuffer().toString("base64");
        })
            .onSet(function (value) {
            try {
                return _this.handleTransitionControlWrite(value);
            }
            catch (error) {
                console.warn("[%s] DEBUG: '" + value + "'");
                console.warn("[%s] Encountered error on CharacteristicValueTransitionControl characteristic: " + error.stack);
                _this.disableAdaptiveLighting();
                throw new __1.HapStatusError(-70402 /* SERVICE_COMMUNICATION_FAILURE */);
            }
        });
    };
    /**
     * @private
     */
    AdaptiveLightingController.prototype.handleControllerRemoved = function () {
        this.lightbulb.removeCharacteristic(this.supportedTransitionConfiguration);
        this.lightbulb.removeCharacteristic(this.transitionControl);
        this.lightbulb.removeCharacteristic(this.activeTransitionCount);
        this.supportedTransitionConfiguration = undefined;
        this.transitionControl = undefined;
        this.activeTransitionCount = undefined;
        this.removeAllListeners();
    };
    /**
     * @private
     */
    AdaptiveLightingController.prototype.handleFactoryReset = function () {
        this.handleAdaptiveLightingDisabled();
    };
    /**
     * @private
     */
    AdaptiveLightingController.prototype.serialize = function () {
        if (!this.activeTransition) {
            return undefined;
        }
        return {
            activeTransition: this.activeTransition,
        };
    };
    /**
     * @private
     */
    AdaptiveLightingController.prototype.deserialize = function (serialized) {
        this.activeTransition = serialized.activeTransition;
        // Data migrations from beta builds
        if (!this.activeTransition.transitionId) {
            // @ts-ignore
            this.activeTransition.transitionId = this.activeTransition.id1;
            // @ts-ignore
            delete this.activeTransition.id1;
        }
        if (!this.activeTransition.timeMillisOffset) { // compatibility to data produced by early betas
            this.activeTransition.timeMillisOffset = 0;
        }
        this.handleActiveTransitionUpdated(true);
    };
    /**
     * @private
     */
    AdaptiveLightingController.prototype.setupStateChangeDelegate = function (delegate) {
        this.stateChangeDelegate = delegate;
    };
    AdaptiveLightingController.prototype.handleSupportedTransitionConfigurationRead = function () {
        var brightnessIID = this.lightbulb.getCharacteristic(Characteristic_1.Characteristic.Brightness).iid;
        var temperatureIID = this.lightbulb.getCharacteristic(Characteristic_1.Characteristic.ColorTemperature).iid;
        assert_1.default(brightnessIID, "iid for brightness characteristic is undefined");
        assert_1.default(temperatureIID, "iid for temperature characteristic is undefined");
        return tlv.encode(1 /* SUPPORTED_TRANSITION_CONFIGURATION */, [
            tlv.encode(1 /* CHARACTERISTIC_IID */, tlv.writeVariableUIntLE(brightnessIID), 2 /* TRANSITION_TYPE */, 1 /* BRIGHTNESS */),
            tlv.encode(1 /* CHARACTERISTIC_IID */, tlv.writeVariableUIntLE(temperatureIID), 2 /* TRANSITION_TYPE */, 2 /* COLOR_TEMPERATURE */),
        ]).toString("base64");
    };
    AdaptiveLightingController.prototype.buildTransitionControlResponseBuffer = function (time) {
        if (!this.activeTransition) {
            return Buffer.alloc(0);
        }
        var active = this.activeTransition;
        var timeSinceStart = time !== null && time !== void 0 ? time : (Date.now() - active.timeMillisOffset - active.transitionStartMillis);
        var timeSinceStartBuffer = tlv.writeVariableUIntLE(timeSinceStart);
        var parameters = tlv.encode(1 /* TRANSITION_ID */, uuid.write(active.transitionId), 2 /* START_TIME */, Buffer.from(active.transitionStartBuffer, "hex"));
        if (active.id3) {
            parameters = Buffer.concat([
                parameters,
                tlv.encode(3 /* UNKNOWN_3 */, Buffer.from(active.id3, "hex")),
            ]);
        }
        var status = tlv.encode(1 /* CHARACTERISTIC_IID */, tlv.writeVariableUIntLE(active.iid), 2 /* TRANSITION_PARAMETERS */, parameters, 3 /* TIME_SINCE_START */, timeSinceStartBuffer);
        return tlv.encode(1 /* VALUE_CONFIGURATION_STATUS */, status);
    };
    AdaptiveLightingController.prototype.handleTransitionControlWrite = function (value) {
        if (typeof value !== "string") {
            throw new __1.HapStatusError(-70410 /* INVALID_VALUE_IN_REQUEST */);
        }
        var tlvData = tlv.decode(Buffer.from(value, "base64"));
        var responseBuffers = [];
        var readTransition = tlvData[1 /* READ_CURRENT_VALUE_TRANSITION_CONFIGURATION */];
        if (readTransition) {
            var readTransitionResponse = this.handleTransitionControlReadTransition(readTransition);
            if (readTransitionResponse) {
                responseBuffers.push(readTransitionResponse);
            }
        }
        var updateTransition = tlvData[2 /* UPDATE_VALUE_TRANSITION_CONFIGURATION */];
        if (updateTransition) {
            var updateTransitionResponse = this.handleTransitionControlUpdateTransition(updateTransition);
            if (updateTransitionResponse) {
                responseBuffers.push(updateTransitionResponse);
            }
        }
        return Buffer.concat(responseBuffers).toString("base64");
    };
    AdaptiveLightingController.prototype.handleTransitionControlReadTransition = function (buffer) {
        var readTransition = tlv.decode(buffer);
        var iid = tlv.readVariableUIntLE(readTransition[1 /* CHARACTERISTIC_IID */]);
        if (this.activeTransition) {
            if (this.activeTransition.iid !== iid) {
                console.warn("[" + this.lightbulb.displayName + "] iid of current adaptive lighting transition (" + this.activeTransition.iid + ") doesn't match the requested one " + iid);
                throw new __1.HapStatusError(-70410 /* INVALID_VALUE_IN_REQUEST */);
            }
            var parameters = tlv.encode(1 /* TRANSITION_ID */, uuid.write(this.activeTransition.transitionId), 2 /* START_TIME */, Buffer.from(this.activeTransition.transitionStartBuffer, "hex"));
            if (this.activeTransition.id3) {
                parameters = Buffer.concat([
                    parameters,
                    tlv.encode(3 /* UNKNOWN_3 */, Buffer.from(this.activeTransition.id3, "hex")),
                ]);
            }
            return tlv.encode(1 /* READ_CURRENT_VALUE_TRANSITION_CONFIGURATION */, tlv.encode(1 /* CHARACTERISTIC_IID */, tlv.writeVariableUIntLE(this.activeTransition.iid), 2 /* TRANSITION_PARAMETERS */, parameters, 3 /* UNKNOWN_3 */, 1, 5 /* TRANSITION_CURVE_CONFIGURATION */, tlv.encode(1 /* TRANSITION_ENTRY */, this.activeTransition.transitionCurve.map(function (entry, index, array) {
                var _a, _b;
                var duration = (_b = (_a = array[index - 1]) === null || _a === void 0 ? void 0 : _a.duration) !== null && _b !== void 0 ? _b : 0; // we store stuff differently :sweat_smile:
                return tlv.encode(1 /* ADJUSTMENT_FACTOR */, tlv.writeFloat32LE(entry.brightnessAdjustmentFactor), 2 /* VALUE */, tlv.writeFloat32LE(entry.temperature), 3 /* TRANSITION_OFFSET */, tlv.writeVariableUIntLE(entry.transitionTime), 4 /* DURATION */, tlv.writeVariableUIntLE(duration));
            }), 2 /* ADJUSTMENT_CHARACTERISTIC_IID */, tlv.writeVariableUIntLE(this.activeTransition.brightnessCharacteristicIID), 3 /* ADJUSTMENT_MULTIPLIER_RANGE */, tlv.encode(1 /* MINIMUM_ADJUSTMENT_MULTIPLIER */, tlv.writeUInt32(this.activeTransition.brightnessAdjustmentRange.minBrightnessValue), 2 /* MAXIMUM_ADJUSTMENT_MULTIPLIER */, tlv.writeUInt32(this.activeTransition.brightnessAdjustmentRange.maxBrightnessValue))), 6 /* UPDATE_INTERVAL */, tlv.writeVariableUIntLE(this.activeTransition.updateInterval), 8 /* NOTIFY_INTERVAL_THRESHOLD */, tlv.writeVariableUIntLE(this.activeTransition.notifyIntervalThreshold)));
        }
        else {
            return undefined; // returns empty string
        }
    };
    AdaptiveLightingController.prototype.handleTransitionControlUpdateTransition = function (buffer) {
        var e_1, _a;
        var _b, _c;
        var updateTransition = tlv.decode(buffer);
        var transitionConfiguration = tlv.decode(updateTransition[1 /* VALUE_TRANSITION_CONFIGURATION */]);
        var iid = tlv.readVariableUIntLE(transitionConfiguration[1 /* CHARACTERISTIC_IID */]);
        if (!this.lightbulb.getCharacteristicByIID(iid)) {
            throw new __1.HapStatusError(-70410 /* INVALID_VALUE_IN_REQUEST */);
        }
        var param3 = (_b = transitionConfiguration[3 /* UNKNOWN_3 */]) === null || _b === void 0 ? void 0 : _b.readUInt8(0); // when present it is always 1
        if (!param3) { // if HomeKit just sends the iid, we consider that as "disable adaptive lighting" (assumption)
            this.handleAdaptiveLightingDisabled();
            return tlv.encode(2 /* UPDATE_VALUE_TRANSITION_CONFIGURATION */, Buffer.alloc(0));
        }
        var parametersTLV = tlv.decode(transitionConfiguration[2 /* TRANSITION_PARAMETERS */]);
        var curveConfiguration = tlv.decodeWithLists(transitionConfiguration[5 /* TRANSITION_CURVE_CONFIGURATION */]);
        var updateInterval = (_c = transitionConfiguration[6 /* UPDATE_INTERVAL */]) === null || _c === void 0 ? void 0 : _c.readUInt16LE(0);
        var notifyIntervalThreshold = transitionConfiguration[8 /* NOTIFY_INTERVAL_THRESHOLD */].readUInt32LE(0);
        var transitionId = parametersTLV[1 /* TRANSITION_ID */];
        var startTime = parametersTLV[2 /* START_TIME */];
        var id3 = parametersTLV[3 /* UNKNOWN_3 */]; // this may be undefined
        var startTimeMillis = __1.epochMillisFromMillisSince2001_01_01Buffer(startTime);
        var timeMillisOffset = Date.now() - startTimeMillis;
        var transitionCurve = [];
        var previous = undefined;
        var transitions = curveConfiguration[1 /* TRANSITION_ENTRY */];
        try {
            for (var transitions_1 = tslib_1.__values(transitions), transitions_1_1 = transitions_1.next(); !transitions_1_1.done; transitions_1_1 = transitions_1.next()) {
                var entry = transitions_1_1.value;
                var tlvEntry = tlv.decode(entry);
                var adjustmentFactor = tlvEntry[1 /* ADJUSTMENT_FACTOR */].readFloatLE(0);
                var value = tlvEntry[2 /* VALUE */].readFloatLE(0);
                var transitionOffset = tlv.readVariableUIntLE(tlvEntry[3 /* TRANSITION_OFFSET */]);
                var duration = tlvEntry[4 /* DURATION */] ? tlv.readVariableUIntLE(tlvEntry[4 /* DURATION */]) : undefined;
                if (previous) {
                    previous.duration = duration;
                }
                previous = {
                    temperature: value,
                    brightnessAdjustmentFactor: adjustmentFactor,
                    transitionTime: transitionOffset,
                };
                transitionCurve.push(previous);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (transitions_1_1 && !transitions_1_1.done && (_a = transitions_1.return)) _a.call(transitions_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var adjustmentIID = tlv.readVariableUIntLE(curveConfiguration[2 /* ADJUSTMENT_CHARACTERISTIC_IID */]);
        var adjustmentMultiplierRange = tlv.decode(curveConfiguration[3 /* ADJUSTMENT_MULTIPLIER_RANGE */]);
        var minAdjustmentMultiplier = adjustmentMultiplierRange[1 /* MINIMUM_ADJUSTMENT_MULTIPLIER */].readUInt32LE(0);
        var maxAdjustmentMultiplier = adjustmentMultiplierRange[2 /* MAXIMUM_ADJUSTMENT_MULTIPLIER */].readUInt32LE(0);
        this.activeTransition = {
            iid: iid,
            transitionStartMillis: startTimeMillis,
            timeMillisOffset: timeMillisOffset,
            transitionId: uuid.unparse(transitionId),
            transitionStartBuffer: startTime.toString("hex"),
            id3: id3 === null || id3 === void 0 ? void 0 : id3.toString("hex"),
            brightnessCharacteristicIID: adjustmentIID,
            brightnessAdjustmentRange: {
                minBrightnessValue: minAdjustmentMultiplier,
                maxBrightnessValue: maxAdjustmentMultiplier,
            },
            transitionCurve: transitionCurve,
            updateInterval: updateInterval !== null && updateInterval !== void 0 ? updateInterval : 60000,
            notifyIntervalThreshold: notifyIntervalThreshold,
        };
        if (this.updateTimeout) {
            clearTimeout(this.updateTimeout);
            this.updateTimeout = undefined;
            debug("[%s] Adaptive lighting was renewed.", this.lightbulb.displayName);
        }
        else {
            debug("[%s] Adaptive lighting was enabled.", this.lightbulb.displayName);
        }
        this.handleActiveTransitionUpdated();
        return tlv.encode(2 /* UPDATE_VALUE_TRANSITION_CONFIGURATION */, this.buildTransitionControlResponseBuffer(0));
    };
    return AdaptiveLightingController;
}(events_1.EventEmitter));
exports.AdaptiveLightingController = AdaptiveLightingController;
//# sourceMappingURL=AdaptiveLightingController.js.map

/***/ }),

/***/ 4680:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CameraController = exports.CameraControllerEvents = void 0;
var tslib_1 = __nccwpck_require__(4290);
var crypto_1 = tslib_1.__importDefault(__nccwpck_require__(6417));
var debug_1 = tslib_1.__importDefault(__nccwpck_require__(7984));
var events_1 = __nccwpck_require__(8614);
var camera_1 = __nccwpck_require__(4992);
var Characteristic_1 = __nccwpck_require__(3859);
var Service_1 = __nccwpck_require__(7383);
var debug = debug_1.default("HAP-NodeJS:Camera:Controller");
var CameraControllerEvents;
(function (CameraControllerEvents) {
    /**
     *  Emitted when the mute state or the volume changed. The Apple Home App typically does not set those values
     *  except the mute state. When you adjust the volume in the Camera view it will reset the muted state if it was set previously.
     *  The value of volume has nothing to do with the volume slider in the Camera view of the Home app.
     */
    CameraControllerEvents["MICROPHONE_PROPERTIES_CHANGED"] = "microphone-change";
    /**
     * Emitted when the mute state or the volume changed. The Apple Home App typically does not set those values
     * except the mute state. When you unmute the device microphone it will reset the mute state if it was set previously.
     */
    CameraControllerEvents["SPEAKER_PROPERTIES_CHANGED"] = "speaker-change";
})(CameraControllerEvents = exports.CameraControllerEvents || (exports.CameraControllerEvents = {}));
/**
 * Everything needed to expose a HomeKit Camera.
 */
var CameraController = /** @class */ (function (_super) {
    tslib_1.__extends(CameraController, _super);
    function CameraController(options, legacyMode) {
        if (legacyMode === void 0) { legacyMode = false; }
        var _this = _super.call(this) || this;
        // private readonly recordingOptions: CameraRecordingOptions, // soon
        _this.legacyMode = false;
        /**
         * @private
         */
        _this.streamManagements = [];
        _this.microphoneMuted = false;
        _this.microphoneVolume = 100;
        _this.speakerMuted = false;
        _this.speakerVolume = 100;
        _this.streamCount = Math.max(1, options.cameraStreamCount || 1);
        _this.delegate = options.delegate;
        _this.streamingOptions = options.streamingOptions;
        _this.legacyMode = legacyMode; // legacy mode will prent from Microphone and Speaker services to get created to avoid collisions
        return _this;
    }
    /**
     * @private
     */
    CameraController.prototype.controllerId = function () {
        return "camera" /* CAMERA */;
    };
    // ----------------------------------- STREAM API ------------------------------------
    /**
     * Call this method if you want to forcefully suspend an ongoing streaming session.
     * This would be adequate if the the rtp server or media encoding encountered an unexpected error.
     *
     * @param sessionId {SessionIdentifier} - id of the current ongoing streaming session
     */
    CameraController.prototype.forceStopStreamingSession = function (sessionId) {
        this.streamManagements.forEach(function (management) {
            if (management.sessionIdentifier === sessionId) {
                management.forceStop();
            }
        });
    };
    CameraController.generateSynchronisationSource = function () {
        var ssrc = crypto_1.default.randomBytes(4); // range [-2.14748e+09 - 2.14748e+09]
        ssrc[0] = 0;
        return ssrc.readInt32BE(0);
    };
    // ----------------------------- MICROPHONE/SPEAKER API ------------------------------
    CameraController.prototype.setMicrophoneMuted = function (muted) {
        if (muted === void 0) { muted = true; }
        if (!this.microphoneService) {
            return;
        }
        this.microphoneMuted = muted;
        this.microphoneService.updateCharacteristic(Characteristic_1.Characteristic.Mute, muted);
    };
    CameraController.prototype.setMicrophoneVolume = function (volume) {
        if (!this.microphoneService) {
            return;
        }
        this.microphoneVolume = volume;
        this.microphoneService.updateCharacteristic(Characteristic_1.Characteristic.Volume, volume);
    };
    CameraController.prototype.setSpeakerMuted = function (muted) {
        if (muted === void 0) { muted = true; }
        if (!this.speakerService) {
            return;
        }
        this.speakerMuted = muted;
        this.speakerService.updateCharacteristic(Characteristic_1.Characteristic.Mute, muted);
    };
    CameraController.prototype.setSpeakerVolume = function (volume) {
        if (!this.speakerService) {
            return;
        }
        this.speakerVolume = volume;
        this.speakerService.updateCharacteristic(Characteristic_1.Characteristic.Volume, volume);
    };
    CameraController.prototype.emitMicrophoneChange = function () {
        this.emit("microphone-change" /* MICROPHONE_PROPERTIES_CHANGED */, this.microphoneMuted, this.microphoneVolume);
    };
    CameraController.prototype.emitSpeakerChange = function () {
        this.emit("speaker-change" /* SPEAKER_PROPERTIES_CHANGED */, this.speakerMuted, this.speakerVolume);
    };
    // -----------------------------------------------------------------------------------
    /**
     * @private
     */
    CameraController.prototype.constructServices = function () {
        for (var i = 0; i < this.streamCount; i++) {
            this.streamManagements.push(new camera_1.RTPStreamManagement(i, this.streamingOptions, this.delegate));
        }
        if (!this.legacyMode && this.streamingOptions.audio) {
            // In theory the Microphone Service is a necessity. In practice its not. lol. So we just add it if the user wants to support audio
            this.microphoneService = new Service_1.Service.Microphone('', '');
            this.microphoneService.setCharacteristic(Characteristic_1.Characteristic.Volume, this.microphoneVolume);
            if (this.streamingOptions.audio.twoWayAudio) {
                this.speakerService = new Service_1.Service.Speaker('', '');
                this.speakerService.setCharacteristic(Characteristic_1.Characteristic.Volume, this.speakerVolume);
            }
        }
        var serviceMap = {
            microphone: this.microphoneService,
            speaker: this.speakerService,
        };
        this.streamManagements.forEach(function (management, index) { return serviceMap[CameraController.STREAM_MANAGEMENT + index] = management.getService(); });
        return serviceMap;
    };
    /**
     * @private
     */
    CameraController.prototype.initWithServices = function (serviceMap) {
        var _a;
        var modifiedServiceMap = false;
        for (var i = 0; true; i++) {
            var streamManagementService = serviceMap[CameraController.STREAM_MANAGEMENT + i];
            if (i < this.streamCount) {
                if (streamManagementService) { // normal init
                    this.streamManagements.push(new camera_1.RTPStreamManagement(i, this.streamingOptions, this.delegate, streamManagementService));
                }
                else { // stream count got bigger, we need to create a new service
                    var management = new camera_1.RTPStreamManagement(i, this.streamingOptions, this.delegate);
                    this.streamManagements.push(management);
                    serviceMap[CameraController.STREAM_MANAGEMENT + i] = management.getService();
                    modifiedServiceMap = true;
                }
            }
            else {
                if (streamManagementService) { // stream count got reduced, we need to remove old service
                    delete serviceMap[CameraController.STREAM_MANAGEMENT + i];
                    modifiedServiceMap = true;
                }
                else {
                    break; // we finished counting and we got no saved service; we are finished
                }
            }
        }
        // MICROPHONE
        if (!this.legacyMode && this.streamingOptions.audio) { // microphone should be present
            if (serviceMap.microphone) {
                this.microphoneService = serviceMap.microphone;
            }
            else {
                // microphone wasn't created yet => create a new one
                this.microphoneService = new Service_1.Service.Microphone('', '');
                this.microphoneService.setCharacteristic(Characteristic_1.Characteristic.Volume, this.microphoneVolume);
                serviceMap.microphone = this.microphoneService;
                modifiedServiceMap = true;
            }
        }
        else if (serviceMap.microphone) { // microphone service supplied, though settings seemed to have changed
            // we need to remove it
            delete serviceMap.microphone;
            modifiedServiceMap = true;
        }
        // SPEAKER
        if (!this.legacyMode && ((_a = this.streamingOptions.audio) === null || _a === void 0 ? void 0 : _a.twoWayAudio)) { // speaker should be present
            if (serviceMap.speaker) {
                this.speakerService = serviceMap.speaker;
            }
            else {
                // speaker wasn't created yet => create a new one
                this.speakerService = new Service_1.Service.Speaker('', '');
                this.speakerService.setCharacteristic(Characteristic_1.Characteristic.Volume, this.speakerVolume);
                serviceMap.speaker = this.speakerService;
                modifiedServiceMap = true;
            }
        }
        else if (serviceMap.speaker) { // speaker service supplied, though settings seemed to have changed
            // we need to remove it
            delete serviceMap.speaker;
            modifiedServiceMap = true;
        }
        if (this.migrateFromDoorbell(serviceMap)) {
            modifiedServiceMap = true;
        }
        if (modifiedServiceMap) { // serviceMap must only be returned if anything actually changed
            return serviceMap;
        }
    };
    // overwritten in DoorbellController (to avoid cyclic dependencies, i hate typescript for that)
    CameraController.prototype.migrateFromDoorbell = function (serviceMap) {
        if (serviceMap.doorbell) { // See NOTICE in DoorbellController
            delete serviceMap.doorbell;
            return true;
        }
        return false;
    };
    /**
     * @private
     */
    CameraController.prototype.configureServices = function () {
        var _this = this;
        if (this.microphoneService) {
            this.microphoneService.getCharacteristic(Characteristic_1.Characteristic.Mute)
                .on("get" /* GET */, function (callback) {
                callback(undefined, _this.microphoneMuted);
            })
                .on("set" /* SET */, function (value, callback) {
                _this.microphoneMuted = value;
                callback();
                _this.emitMicrophoneChange();
            });
            this.microphoneService.getCharacteristic(Characteristic_1.Characteristic.Volume)
                .on("get" /* GET */, function (callback) {
                callback(undefined, _this.microphoneVolume);
            })
                .on("set" /* SET */, function (value, callback) {
                _this.microphoneVolume = value;
                callback();
                _this.emitMicrophoneChange();
            });
        }
        if (this.speakerService) {
            this.speakerService.getCharacteristic(Characteristic_1.Characteristic.Mute)
                .on("get" /* GET */, function (callback) {
                callback(undefined, _this.speakerMuted);
            })
                .on("set" /* SET */, function (value, callback) {
                _this.speakerMuted = value;
                callback();
                _this.emitSpeakerChange();
            });
            this.speakerService.getCharacteristic(Characteristic_1.Characteristic.Volume)
                .on("get" /* GET */, function (callback) {
                callback(undefined, _this.speakerVolume);
            })
                .on("set" /* SET */, function (value, callback) {
                _this.speakerVolume = value;
                callback();
                _this.emitSpeakerChange();
            });
        }
    };
    /**
     * @private
     */
    CameraController.prototype.handleControllerRemoved = function () {
        var e_1, _a;
        this.handleFactoryReset();
        try {
            for (var _b = tslib_1.__values(this.streamManagements), _c = _b.next(); !_c.done; _c = _b.next()) {
                var management = _c.value;
                management.destroy();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        this.streamManagements.splice(0, this.streamManagements.length);
        this.microphoneService = undefined;
        this.speakerService = undefined;
        this.removeAllListeners();
    };
    /**
     * @private
     */
    CameraController.prototype.handleFactoryReset = function () {
        this.streamManagements.forEach(function (management) { return management.handleFactoryReset(); });
        this.microphoneMuted = false;
        this.microphoneVolume = 100;
        this.speakerMuted = false;
        this.speakerVolume = 100;
    };
    /**
     * @private
     */
    CameraController.prototype.handleSnapshotRequest = function (height, width, accessoryName) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var timeout = setTimeout(function () {
                console.warn("[" + accessoryName + "] The image snapshot handler for the given accessory is slow to respond! See https://git.io/JtMGR for more info.");
                timeout = setTimeout(function () {
                    timeout = undefined;
                    console.warn("[" + accessoryName + "] The image snapshot handler for the given accessory didn't respond at all! See https://git.io/JtMGR for more info.");
                    reject(-70408 /* OPERATION_TIMED_OUT */);
                }, 17000);
                timeout.unref();
            }, 5000);
            timeout.unref();
            try {
                _this.delegate.handleSnapshotRequest({
                    height: height,
                    width: width,
                }, function (error, buffer) {
                    if (!timeout) {
                        return;
                    }
                    else {
                        clearTimeout(timeout);
                        timeout = undefined;
                    }
                    if (error) {
                        if (typeof error === "number") {
                            reject(error);
                        }
                        else {
                            debug("[%s] Error getting snapshot: %s", accessoryName, error.stack);
                            reject(-70402 /* SERVICE_COMMUNICATION_FAILURE */);
                        }
                        return;
                    }
                    if (!buffer || buffer.length === 0) {
                        console.warn("[" + accessoryName + "] Snapshot request handler provided empty image buffer!");
                        reject(-70402 /* SERVICE_COMMUNICATION_FAILURE */);
                    }
                    else {
                        resolve(buffer);
                    }
                });
            }
            catch (error) {
                if (!timeout) {
                    return;
                }
                else {
                    clearTimeout(timeout);
                    timeout = undefined;
                }
                console.warn("[" + accessoryName + "] Unhandled error thrown inside snapshot request handler: " + error.stack);
                reject(-70402 /* SERVICE_COMMUNICATION_FAILURE */);
            }
        });
    };
    /**
     * @private
     */
    CameraController.prototype.handleCloseConnection = function (sessionID) {
        if (this.delegate instanceof camera_1.LegacyCameraSourceAdapter) {
            this.delegate.forwardCloseConnection(sessionID);
        }
    };
    CameraController.STREAM_MANAGEMENT = "streamManagement"; // key to index all RTPStreamManagement services
    return CameraController;
}(events_1.EventEmitter));
exports.CameraController = CameraController;
//# sourceMappingURL=CameraController.js.map

/***/ }),

/***/ 9471:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isSerializableController = exports.DefaultControllerType = void 0;
var DefaultControllerType;
(function (DefaultControllerType) {
    DefaultControllerType["CAMERA"] = "camera";
    DefaultControllerType["REMOTE"] = "remote";
    DefaultControllerType["TV"] = "tv";
    DefaultControllerType["ROUTER"] = "router";
    DefaultControllerType["LOCK"] = "lock";
    DefaultControllerType["CHARACTERISTIC_TRANSITION"] = "characteristic-transition";
})(DefaultControllerType = exports.DefaultControllerType || (exports.DefaultControllerType = {}));
function isSerializableController(controller) {
    return "serialize" in controller && "deserialize" in controller && "setupStateChangeDelegate" in controller;
}
exports.isSerializableController = isSerializableController;
//# sourceMappingURL=Controller.js.map

/***/ }),

/***/ 6051:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DoorbellController = void 0;
var tslib_1 = __nccwpck_require__(4290);
var Characteristic_1 = __nccwpck_require__(3859);
var Service_1 = __nccwpck_require__(7383);
var CameraController_1 = __nccwpck_require__(4680);
var DoorbellController = /** @class */ (function (_super) {
    tslib_1.__extends(DoorbellController, _super);
    function DoorbellController(options) {
        return _super.call(this, options) || this;
    }
    DoorbellController.prototype.ringDoorbell = function () {
        this.doorbellService.updateCharacteristic(Characteristic_1.Characteristic.ProgrammableSwitchEvent, Characteristic_1.Characteristic.ProgrammableSwitchEvent.SINGLE_PRESS);
    };
    DoorbellController.prototype.constructServices = function () {
        this.doorbellService = new Service_1.Service.Doorbell('', '');
        this.doorbellService.setPrimaryService();
        var serviceMap = _super.prototype.constructServices.call(this);
        serviceMap.doorbell = this.doorbellService;
        return serviceMap;
    };
    DoorbellController.prototype.initWithServices = function (serviceMap) {
        var updatedServiceMap = _super.prototype.initWithServices.call(this, serviceMap);
        this.doorbellService = serviceMap.doorbell;
        if (!this.doorbellService) { // see NOTICE above
            this.doorbellService = new Service_1.Service.Doorbell('', '');
            this.doorbellService.setPrimaryService();
            serviceMap.doorbell = this.doorbellService;
            return serviceMap;
        }
        return updatedServiceMap;
    };
    DoorbellController.prototype.migrateFromDoorbell = function (serviceMap) {
        return false;
    };
    DoorbellController.prototype.handleControllerRemoved = function () {
        _super.prototype.handleControllerRemoved.call(this);
        this.doorbellService = undefined;
    };
    DoorbellController.prototype.configureServices = function () {
        _super.prototype.configureServices.call(this);
        this.doorbellService.getCharacteristic(Characteristic_1.Characteristic.ProgrammableSwitchEvent)
            .onGet(function () { return null; }); // a value of null represent nothing is pressed
    };
    return DoorbellController;
}(CameraController_1.CameraController));
exports.DoorbellController = DoorbellController;
//# sourceMappingURL=DoorbellController.js.map

/***/ }),

/***/ 1622:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SiriAudioSession = exports.SiriAudioSessionEvents = exports.HomeKitRemoteController = exports.RemoteController = exports.RemoteControllerEvents = exports.TargetUpdates = exports.AudioSamplerate = exports.AudioBitrate = exports.AudioCodecTypes = exports.ButtonState = exports.TargetCategory = exports.ButtonType = void 0;
var tslib_1 = __nccwpck_require__(4290);
var assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
var debug_1 = tslib_1.__importDefault(__nccwpck_require__(7984));
var events_1 = __nccwpck_require__(8614);
var Characteristic_1 = __nccwpck_require__(3859);
var datastream_1 = __nccwpck_require__(7580);
var Service_1 = __nccwpck_require__(7383);
var tlv = tslib_1.__importStar(__nccwpck_require__(4041));
var debug = debug_1.default('HAP-NodeJS:Remote:Controller');
var TargetControlCommands;
(function (TargetControlCommands) {
    TargetControlCommands[TargetControlCommands["MAXIMUM_TARGETS"] = 1] = "MAXIMUM_TARGETS";
    TargetControlCommands[TargetControlCommands["TICKS_PER_SECOND"] = 2] = "TICKS_PER_SECOND";
    TargetControlCommands[TargetControlCommands["SUPPORTED_BUTTON_CONFIGURATION"] = 3] = "SUPPORTED_BUTTON_CONFIGURATION";
    TargetControlCommands[TargetControlCommands["TYPE"] = 4] = "TYPE";
})(TargetControlCommands || (TargetControlCommands = {}));
var SupportedButtonConfigurationTypes;
(function (SupportedButtonConfigurationTypes) {
    SupportedButtonConfigurationTypes[SupportedButtonConfigurationTypes["BUTTON_ID"] = 1] = "BUTTON_ID";
    SupportedButtonConfigurationTypes[SupportedButtonConfigurationTypes["BUTTON_TYPE"] = 2] = "BUTTON_TYPE";
})(SupportedButtonConfigurationTypes || (SupportedButtonConfigurationTypes = {}));
var ButtonType;
(function (ButtonType) {
    // noinspection JSUnusedGlobalSymbols
    ButtonType[ButtonType["UNDEFINED"] = 0] = "UNDEFINED";
    ButtonType[ButtonType["MENU"] = 1] = "MENU";
    ButtonType[ButtonType["PLAY_PAUSE"] = 2] = "PLAY_PAUSE";
    ButtonType[ButtonType["TV_HOME"] = 3] = "TV_HOME";
    ButtonType[ButtonType["SELECT"] = 4] = "SELECT";
    ButtonType[ButtonType["ARROW_UP"] = 5] = "ARROW_UP";
    ButtonType[ButtonType["ARROW_RIGHT"] = 6] = "ARROW_RIGHT";
    ButtonType[ButtonType["ARROW_DOWN"] = 7] = "ARROW_DOWN";
    ButtonType[ButtonType["ARROW_LEFT"] = 8] = "ARROW_LEFT";
    ButtonType[ButtonType["VOLUME_UP"] = 9] = "VOLUME_UP";
    ButtonType[ButtonType["VOLUME_DOWN"] = 10] = "VOLUME_DOWN";
    ButtonType[ButtonType["SIRI"] = 11] = "SIRI";
    ButtonType[ButtonType["POWER"] = 12] = "POWER";
    ButtonType[ButtonType["GENERIC"] = 13] = "GENERIC";
})(ButtonType = exports.ButtonType || (exports.ButtonType = {}));
var TargetControlList;
(function (TargetControlList) {
    TargetControlList[TargetControlList["OPERATION"] = 1] = "OPERATION";
    TargetControlList[TargetControlList["TARGET_CONFIGURATION"] = 2] = "TARGET_CONFIGURATION";
})(TargetControlList || (TargetControlList = {}));
var Operation;
(function (Operation) {
    // noinspection JSUnusedGlobalSymbols
    Operation[Operation["UNDEFINED"] = 0] = "UNDEFINED";
    Operation[Operation["LIST"] = 1] = "LIST";
    Operation[Operation["ADD"] = 2] = "ADD";
    Operation[Operation["REMOVE"] = 3] = "REMOVE";
    Operation[Operation["RESET"] = 4] = "RESET";
    Operation[Operation["UPDATE"] = 5] = "UPDATE";
})(Operation || (Operation = {}));
var TargetConfigurationTypes;
(function (TargetConfigurationTypes) {
    TargetConfigurationTypes[TargetConfigurationTypes["TARGET_IDENTIFIER"] = 1] = "TARGET_IDENTIFIER";
    TargetConfigurationTypes[TargetConfigurationTypes["TARGET_NAME"] = 2] = "TARGET_NAME";
    TargetConfigurationTypes[TargetConfigurationTypes["TARGET_CATEGORY"] = 3] = "TARGET_CATEGORY";
    TargetConfigurationTypes[TargetConfigurationTypes["BUTTON_CONFIGURATION"] = 4] = "BUTTON_CONFIGURATION";
})(TargetConfigurationTypes || (TargetConfigurationTypes = {}));
var TargetCategory;
(function (TargetCategory) {
    // noinspection JSUnusedGlobalSymbols
    TargetCategory[TargetCategory["UNDEFINED"] = 0] = "UNDEFINED";
    TargetCategory[TargetCategory["APPLE_TV"] = 24] = "APPLE_TV";
})(TargetCategory = exports.TargetCategory || (exports.TargetCategory = {}));
var ButtonConfigurationTypes;
(function (ButtonConfigurationTypes) {
    ButtonConfigurationTypes[ButtonConfigurationTypes["BUTTON_ID"] = 1] = "BUTTON_ID";
    ButtonConfigurationTypes[ButtonConfigurationTypes["BUTTON_TYPE"] = 2] = "BUTTON_TYPE";
    ButtonConfigurationTypes[ButtonConfigurationTypes["BUTTON_NAME"] = 3] = "BUTTON_NAME";
})(ButtonConfigurationTypes || (ButtonConfigurationTypes = {}));
var ButtonEvent;
(function (ButtonEvent) {
    ButtonEvent[ButtonEvent["BUTTON_ID"] = 1] = "BUTTON_ID";
    ButtonEvent[ButtonEvent["BUTTON_STATE"] = 2] = "BUTTON_STATE";
    ButtonEvent[ButtonEvent["TIMESTAMP"] = 3] = "TIMESTAMP";
    ButtonEvent[ButtonEvent["ACTIVE_IDENTIFIER"] = 4] = "ACTIVE_IDENTIFIER";
})(ButtonEvent || (ButtonEvent = {}));
var ButtonState;
(function (ButtonState) {
    ButtonState[ButtonState["UP"] = 0] = "UP";
    ButtonState[ButtonState["DOWN"] = 1] = "DOWN";
})(ButtonState = exports.ButtonState || (exports.ButtonState = {}));
var SelectedAudioInputStreamConfigurationTypes;
(function (SelectedAudioInputStreamConfigurationTypes) {
    SelectedAudioInputStreamConfigurationTypes[SelectedAudioInputStreamConfigurationTypes["SELECTED_AUDIO_INPUT_STREAM_CONFIGURATION"] = 1] = "SELECTED_AUDIO_INPUT_STREAM_CONFIGURATION";
})(SelectedAudioInputStreamConfigurationTypes || (SelectedAudioInputStreamConfigurationTypes = {}));
// ----------
var SupportedAudioStreamConfigurationTypes;
(function (SupportedAudioStreamConfigurationTypes) {
    // noinspection JSUnusedGlobalSymbols
    SupportedAudioStreamConfigurationTypes[SupportedAudioStreamConfigurationTypes["AUDIO_CODEC_CONFIGURATION"] = 1] = "AUDIO_CODEC_CONFIGURATION";
    SupportedAudioStreamConfigurationTypes[SupportedAudioStreamConfigurationTypes["COMFORT_NOISE_SUPPORT"] = 2] = "COMFORT_NOISE_SUPPORT";
})(SupportedAudioStreamConfigurationTypes || (SupportedAudioStreamConfigurationTypes = {}));
var AudioCodecConfigurationTypes;
(function (AudioCodecConfigurationTypes) {
    AudioCodecConfigurationTypes[AudioCodecConfigurationTypes["CODEC_TYPE"] = 1] = "CODEC_TYPE";
    AudioCodecConfigurationTypes[AudioCodecConfigurationTypes["CODEC_PARAMETERS"] = 2] = "CODEC_PARAMETERS";
})(AudioCodecConfigurationTypes || (AudioCodecConfigurationTypes = {}));
var AudioCodecTypes;
(function (AudioCodecTypes) {
    // noinspection JSUnusedGlobalSymbols
    AudioCodecTypes[AudioCodecTypes["PCMU"] = 0] = "PCMU";
    AudioCodecTypes[AudioCodecTypes["PCMA"] = 1] = "PCMA";
    AudioCodecTypes[AudioCodecTypes["AAC_ELD"] = 2] = "AAC_ELD";
    AudioCodecTypes[AudioCodecTypes["OPUS"] = 3] = "OPUS";
    AudioCodecTypes[AudioCodecTypes["MSBC"] = 4] = "MSBC";
    AudioCodecTypes[AudioCodecTypes["AMR"] = 5] = "AMR";
    AudioCodecTypes[AudioCodecTypes["AMR_WB"] = 6] = "AMR_WB";
})(AudioCodecTypes = exports.AudioCodecTypes || (exports.AudioCodecTypes = {}));
var AudioCodecParametersTypes;
(function (AudioCodecParametersTypes) {
    AudioCodecParametersTypes[AudioCodecParametersTypes["CHANNEL"] = 1] = "CHANNEL";
    AudioCodecParametersTypes[AudioCodecParametersTypes["BIT_RATE"] = 2] = "BIT_RATE";
    AudioCodecParametersTypes[AudioCodecParametersTypes["SAMPLE_RATE"] = 3] = "SAMPLE_RATE";
    AudioCodecParametersTypes[AudioCodecParametersTypes["PACKET_TIME"] = 4] = "PACKET_TIME"; // only present in selected audio codec parameters tlv
})(AudioCodecParametersTypes || (AudioCodecParametersTypes = {}));
var AudioBitrate;
(function (AudioBitrate) {
    AudioBitrate[AudioBitrate["VARIABLE"] = 0] = "VARIABLE";
    AudioBitrate[AudioBitrate["CONSTANT"] = 1] = "CONSTANT";
})(AudioBitrate = exports.AudioBitrate || (exports.AudioBitrate = {}));
var AudioSamplerate;
(function (AudioSamplerate) {
    AudioSamplerate[AudioSamplerate["KHZ_8"] = 0] = "KHZ_8";
    AudioSamplerate[AudioSamplerate["KHZ_16"] = 1] = "KHZ_16";
    AudioSamplerate[AudioSamplerate["KHZ_24"] = 2] = "KHZ_24";
    // 3, 4, 5 are theoretically defined, but no idea to what kHz value they correspond to
    // probably KHZ_32, KHZ_44_1, KHZ_48 (as supported by Secure Video recordings)
})(AudioSamplerate = exports.AudioSamplerate || (exports.AudioSamplerate = {}));
var SiriAudioSessionState;
(function (SiriAudioSessionState) {
    SiriAudioSessionState[SiriAudioSessionState["STARTING"] = 0] = "STARTING";
    SiriAudioSessionState[SiriAudioSessionState["SENDING"] = 1] = "SENDING";
    SiriAudioSessionState[SiriAudioSessionState["CLOSING"] = 2] = "CLOSING";
    SiriAudioSessionState[SiriAudioSessionState["CLOSED"] = 3] = "CLOSED";
})(SiriAudioSessionState || (SiriAudioSessionState = {}));
var TargetUpdates;
(function (TargetUpdates) {
    TargetUpdates[TargetUpdates["NAME"] = 0] = "NAME";
    TargetUpdates[TargetUpdates["CATEGORY"] = 1] = "CATEGORY";
    TargetUpdates[TargetUpdates["UPDATED_BUTTONS"] = 2] = "UPDATED_BUTTONS";
    TargetUpdates[TargetUpdates["REMOVED_BUTTONS"] = 3] = "REMOVED_BUTTONS";
})(TargetUpdates = exports.TargetUpdates || (exports.TargetUpdates = {}));
var RemoteControllerEvents;
(function (RemoteControllerEvents) {
    /**
     * This event is emitted when the active state of the remote has changed.
     * active = true indicates that there is currently an apple tv listening of button presses and audio streams.
     */
    RemoteControllerEvents["ACTIVE_CHANGE"] = "active-change";
    /**
     * This event is emitted when the currently selected target has changed.
     * Possible reasons for a changed active identifier: manual change via api call, first target configuration
     * gets added, active target gets removed, accessory gets unpaired, reset request was sent.
     * An activeIdentifier of 0 indicates that no target is selected.
     */
    RemoteControllerEvents["ACTIVE_IDENTIFIER_CHANGE"] = "active-identifier-change";
    /**
     * This event is emitted when a new target configuration is received. As we currently do not persistently store
     * configured targets, this will be called at every startup for every Apple TV configured in the home.
     */
    RemoteControllerEvents["TARGET_ADDED"] = "target-add";
    /**
     * This event is emitted when a existing target was updated.
     * The 'updates' array indicates what exactly was changed for the target.
     */
    RemoteControllerEvents["TARGET_UPDATED"] = "target-update";
    /**
     * This event is emitted when a existing configuration for a target was removed.
     */
    RemoteControllerEvents["TARGET_REMOVED"] = "target-remove";
    /**
     * This event is emitted when a reset of the target configuration is requested.
     * With this event every configuration made should be reset. This event is also called
     * when the accessory gets unpaired.
     */
    RemoteControllerEvents["TARGETS_RESET"] = "targets-reset";
})(RemoteControllerEvents = exports.RemoteControllerEvents || (exports.RemoteControllerEvents = {}));
/**
 * Handles everything needed to implement a fully working HomeKit remote controller.
 */
var RemoteController = /** @class */ (function (_super) {
    tslib_1.__extends(RemoteController, _super);
    /**
     * Creates a new RemoteController.
     * If siri voice input is supported the constructor to an SiriAudioStreamProducer needs to be supplied.
     * Otherwise a remote without voice support will be created.
     *
     * For every audio session a new SiriAudioStreamProducer will be constructed.
     *
     * @param audioProducerConstructor {SiriAudioStreamProducerConstructor} - constructor for a SiriAudioStreamProducer
     * @param producerOptions - if supplied this argument will be supplied as third argument of the SiriAudioStreamProducer
     *                          constructor. This should be used to supply configurations to the stream producer.
     */
    function RemoteController(audioProducerConstructor, producerOptions) {
        var _this = _super.call(this) || this;
        _this.buttons = {}; // internal mapping of buttonId to buttonType for supported buttons
        _this.targetConfigurations = new Map();
        _this.targetConfigurationsString = "";
        _this.lastButtonEvent = "";
        _this.activeIdentifier = 0; // id of 0 means no device selected
        _this.dataStreamConnections = new Map(); // maps targetIdentifiers to active data stream connections
        _this.audioSupported = audioProducerConstructor !== undefined;
        _this.audioProducerConstructor = audioProducerConstructor;
        _this.audioProducerOptions = producerOptions;
        var configuration = _this.constructSupportedConfiguration();
        _this.supportedConfiguration = _this.buildTargetControlSupportedConfigurationTLV(configuration);
        var audioConfiguration = _this.constructSupportedAudioConfiguration();
        _this.supportedAudioConfiguration = RemoteController.buildSupportedAudioConfigurationTLV(audioConfiguration);
        _this.selectedAudioConfiguration = {
            codecType: 3 /* OPUS */,
            parameters: {
                channels: 1,
                bitrate: 0 /* VARIABLE */,
                samplerate: 1 /* KHZ_16 */,
                rtpTime: 20,
            }
        };
        _this.selectedAudioConfigurationString = RemoteController.buildSelectedAudioConfigurationTLV({
            audioCodecConfiguration: _this.selectedAudioConfiguration,
        });
        return _this;
    }
    /**
     * @private
     */
    RemoteController.prototype.controllerId = function () {
        return "remote" /* REMOTE */;
    };
    /**
     * Set a new target as active target. A value of 0 indicates that no target is selected currently.
     *
     * @param activeIdentifier {number} - target identifier
     */
    RemoteController.prototype.setActiveIdentifier = function (activeIdentifier) {
        var _this = this;
        if (activeIdentifier === this.activeIdentifier) {
            return;
        }
        if (activeIdentifier !== 0 && !this.targetConfigurations.has(activeIdentifier)) {
            throw Error("Tried setting unconfigured targetIdentifier to active");
        }
        debug("%d is now the active target", activeIdentifier);
        this.activeIdentifier = activeIdentifier;
        this.targetControlService.getCharacteristic(Characteristic_1.Characteristic.ActiveIdentifier).updateValue(activeIdentifier);
        if (this.activeAudioSession) {
            this.handleSiriAudioStop();
        }
        setTimeout(function () { return _this.emit("active-identifier-change" /* ACTIVE_IDENTIFIER_CHANGE */, activeIdentifier); }, 0);
        this.setInactive();
    };
    /**
     * @returns if the current target is active, meaning the active device is listening for button events or audio sessions
     */
    RemoteController.prototype.isActive = function () {
        return !!this.activeConnection;
    };
    /**
     * Checks if the supplied targetIdentifier is configured.
     *
     * @param targetIdentifier {number}
     */
    RemoteController.prototype.isConfigured = function (targetIdentifier) {
        return this.targetConfigurations.has(targetIdentifier);
    };
    /**
     * Returns the targetIdentifier for a give device name
     *
     * @param name {string} - the name of the device
     * @returns the targetIdentifier of the device or undefined if not existent
     */
    RemoteController.prototype.getTargetIdentifierByName = function (name) {
        var e_1, _a;
        try {
            for (var _b = tslib_1.__values(Object.entries(this.targetConfigurations)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = tslib_1.__read(_c.value, 2), activeIdentifier = _d[0], configuration = _d[1];
                if (configuration.targetName === name) {
                    return parseInt(activeIdentifier, 10);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return undefined;
    };
    /**
     * Sends a button event to press the supplied button.
     *
     * @param button {ButtonType} - button to be pressed
     */
    RemoteController.prototype.pushButton = function (button) {
        this.sendButtonEvent(button, 1 /* DOWN */);
    };
    /**
     * Sends a button event that the supplied button was released.
     *
     * @param button {ButtonType} - button which was released
     */
    RemoteController.prototype.releaseButton = function (button) {
        this.sendButtonEvent(button, 0 /* UP */);
    };
    /**
     * Presses a supplied button for a given time.
     *
     * @param button {ButtonType} - button to be pressed and released
     * @param time {number} - time in milliseconds (defaults to 200ms)
     */
    RemoteController.prototype.pushAndReleaseButton = function (button, time) {
        var _this = this;
        if (time === void 0) { time = 200; }
        this.pushButton(button);
        setTimeout(function () { return _this.releaseButton(button); }, time);
    };
    /**
     * This method adds and configures the remote services for a give accessory.
     *
     * @param accessory {Accessory} - the give accessory this remote should be added to
     * @deprecated - use {@link Accessory.configureController} instead
     */
    RemoteController.prototype.addServicesToAccessory = function (accessory) {
        accessory.configureController(this);
    };
    // ---------------------------------- CONFIGURATION ----------------------------------
    // override methods if you would like to change anything (but should not be necessary most likely)
    RemoteController.prototype.constructSupportedConfiguration = function () {
        var _this = this;
        var configuration = {
            maximumTargets: 10,
            ticksPerSecond: 1000,
            supportedButtonConfiguration: [],
            hardwareImplemented: this.audioSupported // siri is only allowed for hardware implemented remotes
        };
        var supportedButtons = [
            1 /* MENU */, 2 /* PLAY_PAUSE */, 3 /* TV_HOME */, 4 /* SELECT */,
            5 /* ARROW_UP */, 6 /* ARROW_RIGHT */, 7 /* ARROW_DOWN */, 8 /* ARROW_LEFT */,
            9 /* VOLUME_UP */, 10 /* VOLUME_DOWN */, 12 /* POWER */, 13 /* GENERIC */
        ];
        if (this.audioSupported) { // add siri button if this remote supports it
            supportedButtons.push(11 /* SIRI */);
        }
        supportedButtons.forEach(function (button) {
            var buttonConfiguration = {
                buttonID: 100 + button,
                buttonType: button
            };
            configuration.supportedButtonConfiguration.push(buttonConfiguration);
            _this.buttons[button] = buttonConfiguration.buttonID; // also saving mapping of type to id locally
        });
        return configuration;
    };
    RemoteController.prototype.constructSupportedAudioConfiguration = function () {
        // the following parameters are expected from HomeKit for a remote
        return {
            audioCodecConfiguration: {
                codecType: 3 /* OPUS */,
                parameters: {
                    channels: 1,
                    bitrate: 0 /* VARIABLE */,
                    samplerate: 1 /* KHZ_16 */,
                }
            },
        };
    };
    // --------------------------------- TARGET CONTROL ----------------------------------
    RemoteController.prototype.handleTargetControlWrite = function (value, callback) {
        var data = Buffer.from(value, 'base64');
        var objects = tlv.decode(data);
        var operation = objects[1 /* OPERATION */][0];
        var targetConfiguration = undefined;
        if (objects[2 /* TARGET_CONFIGURATION */]) { // if target configuration was sent, parse it
            targetConfiguration = this.parseTargetConfigurationTLV(objects[2 /* TARGET_CONFIGURATION */]);
        }
        debug("Received TargetControl write operation %s", Operation[operation]);
        var handler;
        switch (operation) {
            case Operation.ADD:
                handler = this.handleAddTarget.bind(this);
                break;
            case Operation.UPDATE:
                handler = this.handleUpdateTarget.bind(this);
                break;
            case Operation.REMOVE:
                handler = this.handleRemoveTarget.bind(this);
                break;
            case Operation.RESET:
                handler = this.handleResetTargets.bind(this);
                break;
            case Operation.LIST:
                handler = this.handleListTargets.bind(this);
                break;
            default:
                callback(-70410 /* INVALID_VALUE_IN_REQUEST */, undefined);
                return;
        }
        var status = handler(targetConfiguration);
        if (status === 0 /* SUCCESS */) {
            callback(undefined, this.targetConfigurationsString); // passing value for write response
            if (operation === Operation.ADD && this.activeIdentifier === 0) {
                this.setActiveIdentifier(targetConfiguration.targetIdentifier);
            }
        }
        else {
            callback(new Error(status + ""));
        }
    };
    RemoteController.prototype.handleAddTarget = function (targetConfiguration) {
        var _this = this;
        if (!targetConfiguration) {
            return -70410 /* INVALID_VALUE_IN_REQUEST */;
        }
        this.targetConfigurations.set(targetConfiguration.targetIdentifier, targetConfiguration);
        debug("Configured new target '" + targetConfiguration.targetName + "' with targetIdentifier '" + targetConfiguration.targetIdentifier + "'");
        setTimeout(function () { return _this.emit("target-add" /* TARGET_ADDED */, targetConfiguration); }, 0);
        this.updatedTargetConfiguration(); // set response
        return 0 /* SUCCESS */;
    };
    RemoteController.prototype.handleUpdateTarget = function (targetConfiguration) {
        var e_2, _a;
        var _this = this;
        if (!targetConfiguration) {
            return -70410 /* INVALID_VALUE_IN_REQUEST */;
        }
        var updates = [];
        var configuredTarget = this.targetConfigurations.get(targetConfiguration.targetIdentifier);
        if (!configuredTarget) {
            return -70410 /* INVALID_VALUE_IN_REQUEST */;
        }
        if (targetConfiguration.targetName) {
            debug("Target name was updated '%s' => '%s' (%d)", configuredTarget.targetName, targetConfiguration.targetName, configuredTarget.targetIdentifier);
            configuredTarget.targetName = targetConfiguration.targetName;
            updates.push(0 /* NAME */);
        }
        if (targetConfiguration.targetCategory) {
            debug("Target category was updated '%d' => '%d' for target '%s' (%d)", configuredTarget.targetCategory, targetConfiguration.targetCategory, configuredTarget.targetName, configuredTarget.targetIdentifier);
            configuredTarget.targetCategory = targetConfiguration.targetCategory;
            updates.push(1 /* CATEGORY */);
        }
        if (targetConfiguration.buttonConfiguration) {
            debug("%d button configurations were updated for target '%s' (%d)", Object.keys(targetConfiguration.buttonConfiguration).length, configuredTarget.targetName, configuredTarget.targetIdentifier);
            try {
                for (var _b = tslib_1.__values(Object.values(targetConfiguration.buttonConfiguration)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var configuration = _c.value;
                    var savedConfiguration = configuredTarget.buttonConfiguration[configuration.buttonID];
                    savedConfiguration.buttonType = configuration.buttonType;
                    savedConfiguration.buttonName = configuration.buttonName;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            updates.push(2 /* UPDATED_BUTTONS */);
        }
        setTimeout(function () { return _this.emit("target-update" /* TARGET_UPDATED */, targetConfiguration, updates); }, 0);
        this.updatedTargetConfiguration(); // set response
        return 0 /* SUCCESS */;
    };
    RemoteController.prototype.handleRemoveTarget = function (targetConfiguration) {
        var _this = this;
        if (!targetConfiguration) {
            return -70410 /* INVALID_VALUE_IN_REQUEST */;
        }
        var configuredTarget = this.targetConfigurations.get(targetConfiguration.targetIdentifier);
        if (!configuredTarget) {
            return -70410 /* INVALID_VALUE_IN_REQUEST */;
        }
        if (targetConfiguration.buttonConfiguration) {
            for (var key in targetConfiguration.buttonConfiguration) {
                if (Object.prototype.hasOwnProperty.call(targetConfiguration.buttonConfiguration, key)) {
                    delete configuredTarget.buttonConfiguration[key];
                }
            }
            debug("Removed %d button configurations of target '%s' (%d)", Object.keys(targetConfiguration.buttonConfiguration).length, configuredTarget.targetName, configuredTarget.targetIdentifier);
            setTimeout(function () { return _this.emit("target-update" /* TARGET_UPDATED */, configuredTarget, [3 /* REMOVED_BUTTONS */]); }, 0);
        }
        else {
            this.targetConfigurations.delete(targetConfiguration.targetIdentifier);
            debug("Target '%s' (%d) was removed", configuredTarget.targetName, configuredTarget.targetIdentifier);
            setTimeout(function () { return _this.emit("target-remove" /* TARGET_REMOVED */, targetConfiguration.targetIdentifier); }, 0);
            var keys = Object.keys(this.targetConfigurations);
            this.setActiveIdentifier(keys.length === 0 ? 0 : parseInt(keys[0], 10)); // switch to next available remote
        }
        this.updatedTargetConfiguration(); // set response
        return 0 /* SUCCESS */;
    };
    RemoteController.prototype.handleResetTargets = function (targetConfiguration) {
        var _this = this;
        if (targetConfiguration) {
            return -70410 /* INVALID_VALUE_IN_REQUEST */;
        }
        debug("Resetting all target configurations");
        this.targetConfigurations = new Map();
        this.updatedTargetConfiguration(); // set response
        setTimeout(function () { return _this.emit("targets-reset" /* TARGETS_RESET */); }, 0);
        this.setActiveIdentifier(0); // resetting active identifier (also sets active to false)
        return 0 /* SUCCESS */;
    };
    RemoteController.prototype.handleListTargets = function (targetConfiguration) {
        if (targetConfiguration) {
            return -70410 /* INVALID_VALUE_IN_REQUEST */;
        }
        // this.targetConfigurationsString is updated after each change, so we basically don't need to do anything here
        debug("Returning " + Object.keys(this.targetConfigurations).length + " target configurations");
        return 0 /* SUCCESS */;
    };
    RemoteController.prototype.handleActiveWrite = function (value, callback, connection) {
        if (this.activeIdentifier === 0) {
            debug("Tried to change active state. There is no active target set though");
            callback(-70410 /* INVALID_VALUE_IN_REQUEST */);
            return;
        }
        if (this.activeConnection) {
            this.activeConnection.removeListener("closed" /* CLOSED */, this.activeConnectionDisconnectListener);
            this.activeConnection = undefined;
            this.activeConnectionDisconnectListener = undefined;
        }
        this.activeConnection = value ? connection : undefined;
        if (this.activeConnection) { // register listener when hap connection disconnects
            this.activeConnectionDisconnectListener = this.handleActiveSessionDisconnected.bind(this, this.activeConnection);
            this.activeConnection.on("closed" /* CLOSED */, this.activeConnectionDisconnectListener);
        }
        var activeTarget = this.targetConfigurations.get(this.activeIdentifier);
        if (!activeTarget) {
            callback(-70410 /* INVALID_VALUE_IN_REQUEST */);
            return;
        }
        debug("Remote with activeTarget '%s' (%d) was set to %s", activeTarget.targetName, this.activeIdentifier, value ? "ACTIVE" : "INACTIVE");
        callback();
        this.emit("active-change" /* ACTIVE_CHANGE */, value);
    };
    RemoteController.prototype.setInactive = function () {
        var _this = this;
        if (this.activeConnection === undefined) {
            return;
        }
        this.activeConnection.removeListener("closed" /* CLOSED */, this.activeConnectionDisconnectListener);
        this.activeConnection = undefined;
        this.activeConnectionDisconnectListener = undefined;
        this.targetControlService.getCharacteristic(Characteristic_1.Characteristic.Active).updateValue(false);
        debug("Remote was set to INACTIVE");
        setTimeout(function () { return _this.emit("active-change" /* ACTIVE_CHANGE */, false); }, 0);
    };
    RemoteController.prototype.handleActiveSessionDisconnected = function (connection) {
        if (connection !== this.activeConnection) {
            return;
        }
        debug("Active hap session disconnected!");
        this.setInactive();
    };
    RemoteController.prototype.sendButtonEvent = function (button, buttonState) {
        var buttonID = this.buttons[button];
        if (buttonID === undefined || buttonID === 0) {
            throw new Error("Tried sending button event for unsupported button (" + button + ")");
        }
        if (this.activeIdentifier === 0) { // cannot press button if no device is selected
            throw new Error("Tried sending button event although no target was selected");
        }
        if (!this.isActive()) { // cannot press button if device is not active (aka no apple tv is listening)
            throw new Error("Tried sending button event although target was not marked as active");
        }
        if (button === 11 /* SIRI */ && this.audioSupported) {
            if (buttonState === 1 /* DOWN */) { // start streaming session
                this.handleSiriAudioStart();
            }
            else if (buttonState === 0 /* UP */) { // stop streaming session
                this.handleSiriAudioStop();
            }
            return;
        }
        var buttonIdTlv = tlv.encode(1 /* BUTTON_ID */, buttonID);
        var buttonStateTlv = tlv.encode(2 /* BUTTON_STATE */, buttonState);
        var timestampTlv = tlv.encode(3 /* TIMESTAMP */, tlv.writeUInt64(new Date().getTime())
        // timestamp should be uint64. bigint though is only supported by node 10.4.0 and above
        // thus we just interpret timestamp as a regular number
        );
        var activeIdentifierTlv = tlv.encode(4 /* ACTIVE_IDENTIFIER */, tlv.writeUInt32(this.activeIdentifier));
        this.lastButtonEvent = Buffer.concat([
            buttonIdTlv, buttonStateTlv, timestampTlv, activeIdentifierTlv
        ]).toString('base64');
        this.targetControlService.getCharacteristic(Characteristic_1.Characteristic.ButtonEvent).sendEventNotification(this.lastButtonEvent);
    };
    RemoteController.prototype.parseTargetConfigurationTLV = function (data) {
        var configTLV = tlv.decode(data);
        var identifier = tlv.readUInt32(configTLV[1 /* TARGET_IDENTIFIER */]);
        var name = undefined;
        if (configTLV[2 /* TARGET_NAME */])
            name = configTLV[2 /* TARGET_NAME */].toString();
        var category = undefined;
        if (configTLV[3 /* TARGET_CATEGORY */])
            category = tlv.readUInt16(configTLV[3 /* TARGET_CATEGORY */]);
        var buttonConfiguration = {};
        if (configTLV[4 /* BUTTON_CONFIGURATION */]) {
            var buttonConfigurationTLV = tlv.decodeList(configTLV[4 /* BUTTON_CONFIGURATION */], 1 /* BUTTON_ID */);
            buttonConfigurationTLV.forEach(function (entry) {
                var buttonId = entry[1 /* BUTTON_ID */][0];
                var buttonType = tlv.readUInt16(entry[2 /* BUTTON_TYPE */]);
                var buttonName;
                if (entry[3 /* BUTTON_NAME */]) {
                    buttonName = entry[3 /* BUTTON_NAME */].toString();
                }
                else {
                    // @ts-ignore
                    buttonName = ButtonType[buttonType];
                }
                buttonConfiguration[buttonId] = {
                    buttonID: buttonId,
                    buttonType: buttonType,
                    buttonName: buttonName
                };
            });
        }
        return {
            targetIdentifier: identifier,
            targetName: name,
            targetCategory: category,
            buttonConfiguration: buttonConfiguration
        };
    };
    RemoteController.prototype.updatedTargetConfiguration = function () {
        var e_3, _a, e_4, _b;
        var bufferList = [];
        try {
            for (var _c = tslib_1.__values(Object.values(this.targetConfigurations)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var configuration = _d.value;
                var targetIdentifier = tlv.encode(1 /* TARGET_IDENTIFIER */, tlv.writeUInt32(configuration.targetIdentifier));
                var targetName = tlv.encode(2 /* TARGET_NAME */, configuration.targetName);
                var targetCategory = tlv.encode(3 /* TARGET_CATEGORY */, tlv.writeUInt16(configuration.targetCategory));
                var buttonConfigurationBuffers = [];
                try {
                    for (var _e = (e_4 = void 0, tslib_1.__values(configuration.buttonConfiguration.values())), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var value = _f.value;
                        var tlvBuffer = tlv.encode(1 /* BUTTON_ID */, value.buttonID, 2 /* BUTTON_TYPE */, tlv.writeUInt16(value.buttonType));
                        if (value.buttonName) {
                            tlvBuffer = Buffer.concat([
                                tlvBuffer,
                                tlv.encode(3 /* BUTTON_NAME */, value.buttonName)
                            ]);
                        }
                        buttonConfigurationBuffers.push(tlvBuffer);
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
                var buttonConfiguration = tlv.encode(4 /* BUTTON_CONFIGURATION */, Buffer.concat(buttonConfigurationBuffers));
                var targetConfiguration = Buffer.concat([targetIdentifier, targetName, targetCategory, buttonConfiguration]);
                bufferList.push(tlv.encode(2 /* TARGET_CONFIGURATION */, targetConfiguration));
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_3) throw e_3.error; }
        }
        this.targetConfigurationsString = Buffer.concat(bufferList).toString('base64');
        this.stateChangeDelegate && this.stateChangeDelegate();
    };
    RemoteController.prototype.buildTargetControlSupportedConfigurationTLV = function (configuration) {
        var maximumTargets = tlv.encode(1 /* MAXIMUM_TARGETS */, configuration.maximumTargets);
        var ticksPerSecond = tlv.encode(2 /* TICKS_PER_SECOND */, tlv.writeUInt64(configuration.ticksPerSecond));
        var supportedButtonConfigurationBuffers = [];
        configuration.supportedButtonConfiguration.forEach(function (value) {
            var tlvBuffer = tlv.encode(1 /* BUTTON_ID */, value.buttonID, 2 /* BUTTON_TYPE */, tlv.writeUInt16(value.buttonType));
            supportedButtonConfigurationBuffers.push(tlvBuffer);
        });
        var supportedButtonConfiguration = tlv.encode(3 /* SUPPORTED_BUTTON_CONFIGURATION */, Buffer.concat(supportedButtonConfigurationBuffers));
        var type = tlv.encode(4 /* TYPE */, configuration.hardwareImplemented ? 1 : 0);
        return Buffer.concat([maximumTargets, ticksPerSecond, supportedButtonConfiguration, type]).toString('base64');
    };
    // --------------------------------- SIRI/DATA STREAM --------------------------------
    RemoteController.prototype.handleTargetControlWhoAmI = function (connection, message) {
        var targetIdentifier = message["identifier"];
        this.dataStreamConnections.set(targetIdentifier, connection);
        debug("Discovered HDS connection for targetIdentifier %s", targetIdentifier);
        connection.addProtocolHandler("dataSend" /* DATA_SEND */, this);
    };
    RemoteController.prototype.handleSiriAudioStart = function () {
        if (!this.audioSupported) {
            throw new Error("Cannot start siri stream on remote where siri is not supported");
        }
        if (!this.isActive()) {
            debug("Tried opening Siri audio stream, however no controller is connected!");
            return;
        }
        if (this.activeAudioSession && (!this.activeAudioSession.isClosing() || this.nextAudioSession)) {
            // there is already a session running, which is not in closing state and/or there is even already a
            // nextAudioSession running. ignoring start request
            debug("Tried opening Siri audio stream, however there is already one in progress");
            return;
        }
        var connection = this.dataStreamConnections.get(this.activeIdentifier); // get connection for current target
        if (connection === undefined) { // target seems not connected, ignore it
            debug("Tried opening Siri audio stream however target is not connected via HDS");
            return;
        }
        var audioSession = new SiriAudioSession(connection, this.selectedAudioConfiguration, this.audioProducerConstructor, this.audioProducerOptions);
        if (!this.activeAudioSession) {
            this.activeAudioSession = audioSession;
        }
        else {
            // we checked above that this only happens if the activeAudioSession is in closing state,
            // so no collision with the input device can happen
            this.nextAudioSession = audioSession;
        }
        audioSession.on("close" /* CLOSE */, this.handleSiriAudioSessionClosed.bind(this, audioSession));
        audioSession.start();
    };
    RemoteController.prototype.handleSiriAudioStop = function () {
        if (this.activeAudioSession) {
            if (!this.activeAudioSession.isClosing()) {
                this.activeAudioSession.stop();
                return;
            }
            else if (this.nextAudioSession && !this.nextAudioSession.isClosing()) {
                this.nextAudioSession.stop();
                return;
            }
        }
        debug("handleSiriAudioStop called although no audio session was started");
    };
    RemoteController.prototype.handleDataSendAckEvent = function (message) {
        var streamId = message["streamId"];
        var endOfStream = message["endOfStream"];
        if (this.activeAudioSession && this.activeAudioSession.streamId === streamId) {
            this.activeAudioSession.handleDataSendAckEvent(endOfStream);
        }
        else if (this.nextAudioSession && this.nextAudioSession.streamId === streamId) {
            this.nextAudioSession.handleDataSendAckEvent(endOfStream);
        }
        else {
            debug("Received dataSend acknowledgment event for unknown streamId '%s'", streamId);
        }
    };
    RemoteController.prototype.handleDataSendCloseEvent = function (message) {
        var streamId = message["streamId"];
        var reason = message["reason"];
        if (this.activeAudioSession && this.activeAudioSession.streamId === streamId) {
            this.activeAudioSession.handleDataSendCloseEvent(reason);
        }
        else if (this.nextAudioSession && this.nextAudioSession.streamId === streamId) {
            this.nextAudioSession.handleDataSendCloseEvent(reason);
        }
        else {
            debug("Received dataSend close event for unknown streamId '%s'", streamId);
        }
    };
    RemoteController.prototype.handleSiriAudioSessionClosed = function (session) {
        if (session === this.activeAudioSession) {
            this.activeAudioSession = this.nextAudioSession;
            this.nextAudioSession = undefined;
        }
        else if (session === this.nextAudioSession) {
            this.nextAudioSession = undefined;
        }
    };
    RemoteController.prototype.handleDataStreamConnectionClosed = function (connection) {
        var e_5, _a;
        try {
            for (var _b = tslib_1.__values(this.dataStreamConnections), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = tslib_1.__read(_c.value, 2), targetIdentifier = _d[0], connection0 = _d[1];
                if (connection === connection0) {
                    debug("HDS connection disconnected for targetIdentifier %s", targetIdentifier);
                    this.dataStreamConnections.delete(targetIdentifier);
                    break;
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
    };
    // ------------------------------- AUDIO CONFIGURATION -------------------------------
    RemoteController.prototype.handleSelectedAudioConfigurationWrite = function (value, callback) {
        var data = Buffer.from(value, 'base64');
        var objects = tlv.decode(data);
        var selectedAudioStreamConfiguration = tlv.decode(objects[1 /* SELECTED_AUDIO_INPUT_STREAM_CONFIGURATION */]);
        var codec = selectedAudioStreamConfiguration[1 /* CODEC_TYPE */][0];
        var parameters = tlv.decode(selectedAudioStreamConfiguration[2 /* CODEC_PARAMETERS */]);
        var channels = parameters[1 /* CHANNEL */][0];
        var bitrate = parameters[2 /* BIT_RATE */][0];
        var samplerate = parameters[3 /* SAMPLE_RATE */][0];
        this.selectedAudioConfiguration = {
            codecType: codec,
            parameters: {
                channels: channels,
                bitrate: bitrate,
                samplerate: samplerate,
                rtpTime: 20
            }
        };
        this.selectedAudioConfigurationString = RemoteController.buildSelectedAudioConfigurationTLV({
            audioCodecConfiguration: this.selectedAudioConfiguration,
        });
        callback();
    };
    RemoteController.buildSupportedAudioConfigurationTLV = function (configuration) {
        var codecConfigurationTLV = RemoteController.buildCodecConfigurationTLV(configuration.audioCodecConfiguration);
        var supportedAudioStreamConfiguration = tlv.encode(1 /* AUDIO_CODEC_CONFIGURATION */, codecConfigurationTLV);
        return supportedAudioStreamConfiguration.toString('base64');
    };
    RemoteController.buildSelectedAudioConfigurationTLV = function (configuration) {
        var codecConfigurationTLV = RemoteController.buildCodecConfigurationTLV(configuration.audioCodecConfiguration);
        var supportedAudioStreamConfiguration = tlv.encode(1 /* SELECTED_AUDIO_INPUT_STREAM_CONFIGURATION */, codecConfigurationTLV);
        return supportedAudioStreamConfiguration.toString('base64');
    };
    RemoteController.buildCodecConfigurationTLV = function (codecConfiguration) {
        var parameters = codecConfiguration.parameters;
        var parametersTLV = tlv.encode(1 /* CHANNEL */, parameters.channels, 2 /* BIT_RATE */, parameters.bitrate, 3 /* SAMPLE_RATE */, parameters.samplerate);
        if (parameters.rtpTime) {
            parametersTLV = Buffer.concat([
                parametersTLV,
                tlv.encode(4 /* PACKET_TIME */, parameters.rtpTime)
            ]);
        }
        return tlv.encode(1 /* CODEC_TYPE */, codecConfiguration.codecType, 2 /* CODEC_PARAMETERS */, parametersTLV);
    };
    // -----------------------------------------------------------------------------------
    /**
     * @private
     */
    RemoteController.prototype.constructServices = function () {
        var _a;
        this.targetControlManagementService = new Service_1.Service.TargetControlManagement('', '');
        this.targetControlManagementService.setCharacteristic(Characteristic_1.Characteristic.TargetControlSupportedConfiguration, this.supportedConfiguration);
        this.targetControlManagementService.setCharacteristic(Characteristic_1.Characteristic.TargetControlList, this.targetConfigurationsString);
        this.targetControlManagementService.setPrimaryService();
        // you can also expose multiple TargetControl services to control multiple apple tvs simultaneously.
        // should we extend this class to support multiple TargetControl services or should users just create a second accessory?
        this.targetControlService = new Service_1.Service.TargetControl('', '');
        this.targetControlService.setCharacteristic(Characteristic_1.Characteristic.ActiveIdentifier, 0);
        this.targetControlService.setCharacteristic(Characteristic_1.Characteristic.Active, false);
        this.targetControlService.setCharacteristic(Characteristic_1.Characteristic.ButtonEvent, this.lastButtonEvent);
        if (this.audioSupported) {
            this.siriService = new Service_1.Service.Siri('', '');
            this.siriService.setCharacteristic(Characteristic_1.Characteristic.SiriInputType, Characteristic_1.Characteristic.SiriInputType.PUSH_BUTTON_TRIGGERED_APPLE_TV);
            this.audioStreamManagementService = new Service_1.Service.AudioStreamManagement('', '');
            this.audioStreamManagementService.setCharacteristic(Characteristic_1.Characteristic.SupportedAudioStreamConfiguration, this.supportedAudioConfiguration);
            this.audioStreamManagementService.setCharacteristic(Characteristic_1.Characteristic.SelectedAudioStreamConfiguration, this.selectedAudioConfigurationString);
            this.dataStreamManagement = new datastream_1.DataStreamManagement();
            this.siriService.addLinkedService(this.dataStreamManagement.getService());
            this.siriService.addLinkedService(this.audioStreamManagementService);
        }
        return {
            targetControlManagement: this.targetControlManagementService,
            targetControl: this.targetControlService,
            siri: this.siriService,
            audioStreamManagement: this.audioStreamManagementService,
            dataStreamTransportManagement: (_a = this.dataStreamManagement) === null || _a === void 0 ? void 0 : _a.getService()
        };
    };
    /**
     * @private
     */
    RemoteController.prototype.initWithServices = function (serviceMap) {
        this.targetControlManagementService = serviceMap.targetControlManagement;
        this.targetControlService = serviceMap.targetControl;
        this.siriService = serviceMap.siri;
        this.audioStreamManagementService = serviceMap.audioStreamManagement;
        this.dataStreamManagement = new datastream_1.DataStreamManagement(serviceMap.dataStreamTransportManagement);
    };
    /**
     * @private
     */
    RemoteController.prototype.configureServices = function () {
        var _a;
        var _this = this;
        if (!this.targetControlManagementService || !this.targetControlService) {
            throw new Error("Unexpected state: Services not configured!"); // playing it save
        }
        this.targetControlManagementService.getCharacteristic(Characteristic_1.Characteristic.TargetControlList)
            .on("get" /* GET */, function (callback) {
            callback(null, _this.targetConfigurationsString);
        })
            .on("set" /* SET */, this.handleTargetControlWrite.bind(this));
        this.targetControlService.getCharacteristic(Characteristic_1.Characteristic.ActiveIdentifier)
            .on("get" /* GET */, function (callback) {
            callback(undefined, _this.activeIdentifier);
        });
        this.targetControlService.getCharacteristic(Characteristic_1.Characteristic.Active)
            .on("get" /* GET */, function (callback) {
            callback(undefined, _this.isActive());
        })
            .on("set" /* SET */, function (value, callback, context, connection) {
            if (!connection) {
                debug("Set event handler for Remote.Active cannot be called from plugin. Connection undefined!");
                callback(-70410 /* INVALID_VALUE_IN_REQUEST */);
                return;
            }
            _this.handleActiveWrite(value, callback, connection);
        });
        this.targetControlService.getCharacteristic(Characteristic_1.Characteristic.ButtonEvent)
            .on("get" /* GET */, function (callback) {
            callback(undefined, _this.lastButtonEvent);
        });
        if (this.audioSupported) {
            this.audioStreamManagementService.getCharacteristic(Characteristic_1.Characteristic.SelectedAudioStreamConfiguration)
                .on("get" /* GET */, function (callback) {
                callback(null, _this.selectedAudioConfigurationString);
            })
                .on("set" /* SET */, this.handleSelectedAudioConfigurationWrite.bind(this))
                .updateValue(this.selectedAudioConfigurationString);
            this.dataStreamManagement
                .onEventMessage("targetControl" /* TARGET_CONTROL */, "whoami" /* WHOAMI */, this.handleTargetControlWhoAmI.bind(this))
                .onServerEvent("connection-closed" /* CONNECTION_CLOSED */, this.handleDataStreamConnectionClosed.bind(this));
            this.eventHandler = (_a = {},
                _a["ack" /* ACK */] = this.handleDataSendAckEvent.bind(this),
                _a["close" /* CLOSE */] = this.handleDataSendCloseEvent.bind(this),
                _a);
        }
    };
    /**
     * @private
     */
    RemoteController.prototype.handleControllerRemoved = function () {
        var _a;
        this.targetControlManagementService = undefined;
        this.targetControlService = undefined;
        this.siriService = undefined;
        this.audioStreamManagementService = undefined;
        this.eventHandler = undefined;
        this.requestHandler = undefined;
        (_a = this.dataStreamManagement) === null || _a === void 0 ? void 0 : _a.destroy();
        this.dataStreamManagement = undefined;
        // the call to dataStreamManagement.destroy will close any open data stream connection
        // which will result in a call to this.handleDataStreamConnectionClosed, cleaning up this.dataStreamConnections.
        // It will also result in a call to SiriAudioSession.handleDataStreamConnectionClosed (if there are any open session)
        // which again results in a call to this.handleSiriAudioSessionClosed,cleaning up this.activeAudioSession and this.nextAudioSession.
    };
    /**
     * @private
     */
    RemoteController.prototype.handleFactoryReset = function () {
        debug("Running factory reset. Resetting targets...");
        this.handleResetTargets(undefined);
        this.lastButtonEvent = "";
    };
    /**
     * @private
     */
    RemoteController.prototype.serialize = function () {
        if (!this.activeIdentifier && Object.keys(this.targetConfigurations).length === 0) {
            return undefined;
        }
        return {
            activeIdentifier: this.activeIdentifier,
            targetConfigurations: tslib_1.__spread(this.targetConfigurations).reduce(function (obj, _a) {
                var _b = tslib_1.__read(_a, 2), key = _b[0], value = _b[1];
                obj[key] = value;
                return obj;
            }, {}),
        };
    };
    /**
     * @private
     */
    RemoteController.prototype.deserialize = function (serialized) {
        this.activeIdentifier = serialized.activeIdentifier;
        this.targetConfigurations = Object.entries(serialized.targetConfigurations).reduce(function (map, _a) {
            var _b = tslib_1.__read(_a, 2), key = _b[0], value = _b[1];
            var identifier = parseInt(key, 10);
            map.set(identifier, value);
            return map;
        }, new Map());
        this.updatedTargetConfiguration();
    };
    /**
     * @private
     */
    RemoteController.prototype.setupStateChangeDelegate = function (delegate) {
        this.stateChangeDelegate = delegate;
    };
    return RemoteController;
}(events_1.EventEmitter));
exports.RemoteController = RemoteController;
// noinspection JSUnusedGlobalSymbols
/**
 * @deprecated - only there for backwards compatibility, please use {@see RemoteController} directly
 */
var HomeKitRemoteController = /** @class */ (function (_super) {
    tslib_1.__extends(HomeKitRemoteController, _super);
    function HomeKitRemoteController() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return HomeKitRemoteController;
}(RemoteController)); // backwards compatibility
exports.HomeKitRemoteController = HomeKitRemoteController;
var SiriAudioSessionEvents;
(function (SiriAudioSessionEvents) {
    SiriAudioSessionEvents["CLOSE"] = "close";
})(SiriAudioSessionEvents = exports.SiriAudioSessionEvents || (exports.SiriAudioSessionEvents = {}));
/**
 * Represents an ongoing audio transmission
 */
var SiriAudioSession = /** @class */ (function (_super) {
    tslib_1.__extends(SiriAudioSession, _super);
    function SiriAudioSession(connection, selectedAudioConfiguration, producerConstructor, producerOptions) {
        var _this = _super.call(this) || this;
        _this.producerRunning = false; // indicates if the producer is running
        _this.state = 0 /* STARTING */;
        _this.endOfStream = false;
        _this.audioFrameQueue = [];
        _this.maxQueueSize = 1024;
        _this.sequenceNumber = 0;
        _this.connection = connection;
        _this.selectedAudioConfiguration = selectedAudioConfiguration;
        _this.producer = new producerConstructor(_this.handleSiriAudioFrame.bind(_this), _this.handleProducerError.bind(_this), producerOptions);
        _this.connection.on("closed" /* CLOSED */, _this.closeListener = _this.handleDataStreamConnectionClosed.bind(_this));
        return _this;
    }
    /**
     * Called when siri button is pressed
     */
    SiriAudioSession.prototype.start = function () {
        var _this = this;
        debug("Sending request to start siri audio stream");
        // opening dataSend
        this.connection.sendRequest("dataSend" /* DATA_SEND */, "open" /* OPEN */, {
            target: "controller",
            type: "audio.siri"
        }, function (error, status, message) {
            if (_this.state === 3 /* CLOSED */) {
                debug("Ignoring dataSend open response as the session is already closed");
                return;
            }
            assert_1.default.strictEqual(_this.state, 0 /* STARTING */);
            _this.state = 1 /* SENDING */;
            if (error || status) {
                if (error) { // errors get produced by hap-nodejs
                    debug("Error occurred trying to start siri audio stream: %s", error.message);
                }
                else if (status) { // status codes are those returned by the hds response
                    debug("Controller responded with non-zero status code: %s", datastream_1.HDSStatus[status]);
                }
                _this.closed();
            }
            else {
                _this.streamId = message["streamId"];
                if (!_this.producerRunning) { // audio producer errored in the meantime
                    _this.sendDataSendCloseEvent(datastream_1.DataSendCloseReason.CANCELLED);
                }
                else {
                    debug("Successfully setup siri audio stream with streamId %d", _this.streamId);
                }
            }
        });
        this.startAudioProducer(); // start audio producer and queue frames in the meantime
    };
    /**
     * @returns if the audio session is closing
     */
    SiriAudioSession.prototype.isClosing = function () {
        return this.state >= 2 /* CLOSING */;
    };
    /**
     * Called when siri button is released (or active identifier is changed to another device)
     */
    SiriAudioSession.prototype.stop = function () {
        assert_1.default(this.state <= 1 /* SENDING */, "state was higher than SENDING");
        debug("Stopping siri audio stream with streamId %d", this.streamId);
        this.endOfStream = true; // mark as endOfStream
        this.stopAudioProducer();
        if (this.state === 1 /* SENDING */) {
            this.handleSiriAudioFrame(undefined); // send out last few audio frames with endOfStream property set
            this.state = 2 /* CLOSING */; // we are waiting for an acknowledgment (triggered by endOfStream property)
        }
        else { // if state is not SENDING (aka state is STARTING) the callback for DATA_SEND OPEN did not yet return (or never will)
            this.closed();
        }
    };
    SiriAudioSession.prototype.startAudioProducer = function () {
        var _this = this;
        this.producer.startAudioProduction(this.selectedAudioConfiguration);
        this.producerRunning = true;
        this.producerTimer = setTimeout(function () {
            debug("Didn't receive any frames from audio producer for stream with streamId %s. Canceling the stream now.", _this.streamId);
            _this.producerTimer = undefined;
            _this.handleProducerError(datastream_1.DataSendCloseReason.CANCELLED);
        }, 3000);
        this.producerTimer.unref();
    };
    SiriAudioSession.prototype.stopAudioProducer = function () {
        this.producer.stopAudioProduction();
        this.producerRunning = false;
        if (this.producerTimer) {
            clearTimeout(this.producerTimer);
            this.producerTimer = undefined;
        }
    };
    SiriAudioSession.prototype.handleSiriAudioFrame = function (frame) {
        var _this = this;
        if (this.state >= 2 /* CLOSING */) {
            return;
        }
        if (this.producerTimer) { // if producerTimer is defined, then this is the first frame we are receiving
            clearTimeout(this.producerTimer);
            this.producerTimer = undefined;
        }
        if (frame && this.audioFrameQueue.length < this.maxQueueSize) { // add frame to queue whilst it is not full
            this.audioFrameQueue.push(frame);
        }
        if (this.state !== 1 /* SENDING */) { // dataSend isn't open yet
            return;
        }
        var queued;
        var _loop_1 = function () {
            var packets = [];
            queued.forEach(function (frame) {
                var packetData = {
                    data: frame.data,
                    metadata: {
                        rms: new datastream_1.Float32(frame.rms),
                        sequenceNumber: new datastream_1.Int64(_this.sequenceNumber++),
                    }
                };
                packets.push(packetData);
            });
            var message = {
                packets: packets,
                streamId: new datastream_1.Int64(this_1.streamId),
                endOfStream: this_1.endOfStream,
            };
            try {
                this_1.connection.sendEvent("dataSend" /* DATA_SEND */, "data" /* DATA */, message);
            }
            catch (error) {
                debug("Error occurred when trying to send audio frame of hds connection: %s", error.message);
                this_1.stopAudioProducer();
                this_1.closed();
            }
            if (this_1.endOfStream) {
                return "break";
            }
        };
        var this_1 = this;
        while ((queued = this.popSome()) !== null) {
            var state_1 = _loop_1();
            if (state_1 === "break")
                break;
        }
    };
    SiriAudioSession.prototype.handleProducerError = function (error) {
        if (this.state >= 2 /* CLOSING */) {
            return;
        }
        this.stopAudioProducer(); // ensure backend is closed
        if (this.state === 1 /* SENDING */) { // if state is less than sending dataSend isn't open (yet)
            this.sendDataSendCloseEvent(error); // cancel submission
        }
    };
    SiriAudioSession.prototype.handleDataSendAckEvent = function (endOfStream) {
        assert_1.default.strictEqual(endOfStream, true);
        debug("Received acknowledgment for siri audio stream with streamId %s, closing it now", this.streamId);
        this.sendDataSendCloseEvent(datastream_1.DataSendCloseReason.NORMAL);
    };
    SiriAudioSession.prototype.handleDataSendCloseEvent = function (reason) {
        debug("Received close event from controller with reason %s for stream with streamId %s", datastream_1.DataSendCloseReason[reason], this.streamId);
        if (this.state <= 1 /* SENDING */) {
            this.stopAudioProducer();
        }
        this.closed();
    };
    SiriAudioSession.prototype.sendDataSendCloseEvent = function (reason) {
        assert_1.default(this.state >= 1 /* SENDING */, "state was less than SENDING");
        assert_1.default(this.state <= 2 /* CLOSING */, "state was higher than CLOSING");
        this.connection.sendEvent("dataSend" /* DATA_SEND */, "close" /* CLOSE */, {
            streamId: new datastream_1.Int64(this.streamId),
            reason: new datastream_1.Int64(reason),
        });
        this.closed();
    };
    SiriAudioSession.prototype.handleDataStreamConnectionClosed = function () {
        debug("Closing audio session with streamId %d", this.streamId);
        if (this.state <= 1 /* SENDING */) {
            this.stopAudioProducer();
        }
        this.closed();
    };
    SiriAudioSession.prototype.closed = function () {
        var lastState = this.state;
        this.state = 3 /* CLOSED */;
        if (lastState !== 3 /* CLOSED */) {
            this.emit("close" /* CLOSE */);
            this.connection.removeListener("closed" /* CLOSED */, this.closeListener);
        }
        this.removeAllListeners();
    };
    SiriAudioSession.prototype.popSome = function () {
        if (this.audioFrameQueue.length < 5 && !this.endOfStream) {
            return null;
        }
        var size = Math.min(this.audioFrameQueue.length, 5); // 5 frames per hap packet seems fine
        var result = [];
        for (var i = 0; i < size; i++) {
            var element = this.audioFrameQueue.shift(); // removes first element
            result.push(element);
        }
        return result;
    };
    return SiriAudioSession;
}(events_1.EventEmitter));
exports.SiriAudioSession = SiriAudioSession;
//# sourceMappingURL=RemoteController.js.map

/***/ }),

/***/ 9237:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4290);
tslib_1.__exportStar(__nccwpck_require__(9471), exports);
tslib_1.__exportStar(__nccwpck_require__(9659), exports);
tslib_1.__exportStar(__nccwpck_require__(1622), exports);
tslib_1.__exportStar(__nccwpck_require__(4680), exports);
tslib_1.__exportStar(__nccwpck_require__(6051), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9278:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataStreamManagement = exports.DataStreamStatus = void 0;
var tslib_1 = __nccwpck_require__(4290);
var debug_1 = tslib_1.__importDefault(__nccwpck_require__(7984));
var Characteristic_1 = __nccwpck_require__(3859);
var Service_1 = __nccwpck_require__(7383);
var tlv = tslib_1.__importStar(__nccwpck_require__(4041));
var DataStreamServer_1 = __nccwpck_require__(3989);
var debug = debug_1.default('HAP-NodeJS:DataStream:Management');
var TransferTransportConfigurationTypes;
(function (TransferTransportConfigurationTypes) {
    TransferTransportConfigurationTypes[TransferTransportConfigurationTypes["TRANSFER_TRANSPORT_CONFIGURATION"] = 1] = "TRANSFER_TRANSPORT_CONFIGURATION";
})(TransferTransportConfigurationTypes || (TransferTransportConfigurationTypes = {}));
var TransportTypeTypes;
(function (TransportTypeTypes) {
    TransportTypeTypes[TransportTypeTypes["TRANSPORT_TYPE"] = 1] = "TRANSPORT_TYPE";
})(TransportTypeTypes || (TransportTypeTypes = {}));
var SetupDataStreamSessionTypes;
(function (SetupDataStreamSessionTypes) {
    SetupDataStreamSessionTypes[SetupDataStreamSessionTypes["SESSION_COMMAND_TYPE"] = 1] = "SESSION_COMMAND_TYPE";
    SetupDataStreamSessionTypes[SetupDataStreamSessionTypes["TRANSPORT_TYPE"] = 2] = "TRANSPORT_TYPE";
    SetupDataStreamSessionTypes[SetupDataStreamSessionTypes["CONTROLLER_KEY_SALT"] = 3] = "CONTROLLER_KEY_SALT";
})(SetupDataStreamSessionTypes || (SetupDataStreamSessionTypes = {}));
var SetupDataStreamWriteResponseTypes;
(function (SetupDataStreamWriteResponseTypes) {
    SetupDataStreamWriteResponseTypes[SetupDataStreamWriteResponseTypes["STATUS"] = 1] = "STATUS";
    SetupDataStreamWriteResponseTypes[SetupDataStreamWriteResponseTypes["TRANSPORT_TYPE_SESSION_PARAMETERS"] = 2] = "TRANSPORT_TYPE_SESSION_PARAMETERS";
    SetupDataStreamWriteResponseTypes[SetupDataStreamWriteResponseTypes["ACCESSORY_KEY_SALT"] = 3] = "ACCESSORY_KEY_SALT";
})(SetupDataStreamWriteResponseTypes || (SetupDataStreamWriteResponseTypes = {}));
var TransportSessionConfiguration;
(function (TransportSessionConfiguration) {
    TransportSessionConfiguration[TransportSessionConfiguration["TCP_LISTENING_PORT"] = 1] = "TCP_LISTENING_PORT";
})(TransportSessionConfiguration || (TransportSessionConfiguration = {}));
var TransportType;
(function (TransportType) {
    TransportType[TransportType["HOMEKIT_DATA_STREAM"] = 0] = "HOMEKIT_DATA_STREAM";
})(TransportType || (TransportType = {}));
var SessionCommandType;
(function (SessionCommandType) {
    SessionCommandType[SessionCommandType["START_SESSION"] = 0] = "START_SESSION";
})(SessionCommandType || (SessionCommandType = {}));
var DataStreamStatus;
(function (DataStreamStatus) {
    DataStreamStatus[DataStreamStatus["SUCCESS"] = 0] = "SUCCESS";
    DataStreamStatus[DataStreamStatus["GENERIC_ERROR"] = 1] = "GENERIC_ERROR";
    DataStreamStatus[DataStreamStatus["BUSY"] = 2] = "BUSY";
})(DataStreamStatus = exports.DataStreamStatus || (exports.DataStreamStatus = {}));
var DataStreamManagement = /** @class */ (function () {
    function DataStreamManagement(service) {
        // one server per accessory is probably the best practice
        this.dataStreamServer = new DataStreamServer_1.DataStreamServer(); // TODO how to handle Remote+future HKSV controller at the same time?
        this.lastSetupDataStreamTransportResponse = ""; // stripped. excludes ACCESSORY_KEY_SALT
        var supportedConfiguration = [TransportType.HOMEKIT_DATA_STREAM];
        this.supportedDataStreamTransportConfiguration = this.buildSupportedDataStreamTransportConfigurationTLV(supportedConfiguration);
        this.dataStreamTransportManagementService = service || this.constructService();
        this.setupServiceHandlers();
    }
    DataStreamManagement.prototype.destroy = function () {
        this.dataStreamServer.destroy(); // removes ALL listeners
        this.dataStreamTransportManagementService.getCharacteristic(Characteristic_1.Characteristic.SetupDataStreamTransport)
            .removeOnGet()
            .removeAllListeners("set" /* SET */);
        this.lastSetupDataStreamTransportResponse = "";
    };
    /**
     * @returns the DataStreamTransportManagement service
     */
    DataStreamManagement.prototype.getService = function () {
        return this.dataStreamTransportManagementService;
    };
    /**
     * Registers a new event handler to handle incoming event messages.
     * The handler is only called for a connection if for the give protocol no ProtocolHandler
     * was registered on the connection level.
     *
     * @param protocol {string | Protocols} - name of the protocol to register the handler for
     * @param event {string | Topics} - name of the event (also referred to as topic. See {Topics} for some known ones)
     * @param handler {GlobalEventHandler} - function to be called for every occurring event
     */
    DataStreamManagement.prototype.onEventMessage = function (protocol, event, handler) {
        this.dataStreamServer.onEventMessage(protocol, event, handler);
        return this;
    };
    /**
     * Removes an registered event handler.
     *
     * @param protocol {string | Protocols} - name of the protocol to unregister the handler for
     * @param event {string | Topics} - name of the event (also referred to as topic. See {Topics} for some known ones)
     * @param handler {GlobalEventHandler} - registered event handler
     */
    DataStreamManagement.prototype.removeEventHandler = function (protocol, event, handler) {
        this.dataStreamServer.removeEventHandler(protocol, event, handler);
        return this;
    };
    /**
     * Registers a new request handler to handle incoming request messages.
     * The handler is only called for a connection if for the give protocol no ProtocolHandler
     * was registered on the connection level.
     *
     * @param protocol {string | Protocols} - name of the protocol to register the handler for
     * @param request {string | Topics} - name of the request (also referred to as topic. See {Topics} for some known ones)
     * @param handler {GlobalRequestHandler} - function to be called for every occurring request
     */
    DataStreamManagement.prototype.onRequestMessage = function (protocol, request, handler) {
        this.dataStreamServer.onRequestMessage(protocol, request, handler);
        return this;
    };
    /**
     * Removes an registered request handler.
     *
     * @param protocol {string | Protocols} - name of the protocol to unregister the handler for
     * @param request {string | Topics} - name of the request (also referred to as topic. See {Topics} for some known ones)
     * @param handler {GlobalRequestHandler} - registered request handler
     */
    DataStreamManagement.prototype.removeRequestHandler = function (protocol, request, handler) {
        this.dataStreamServer.removeRequestHandler(protocol, request, handler);
        return this;
    };
    /**
     * Forwards any event listener for an DataStreamServer event to the DataStreamServer instance
     *
     * @param event - the event to register for
     * @param listener - the event handler
     */
    DataStreamManagement.prototype.onServerEvent = function (event, listener) {
        // @ts-expect-error
        this.dataStreamServer.on(event, listener);
        return this;
    };
    DataStreamManagement.prototype.handleSetupDataStreamTransportWrite = function (value, callback, connection) {
        var _this = this;
        var data = Buffer.from(value, 'base64');
        var objects = tlv.decode(data);
        var sessionCommandType = objects[1 /* SESSION_COMMAND_TYPE */][0];
        var transportType = objects[2 /* TRANSPORT_TYPE */][0];
        var controllerKeySalt = objects[3 /* CONTROLLER_KEY_SALT */];
        debug("Received setup write with command %s and transport type %s", SessionCommandType[sessionCommandType], TransportType[transportType]);
        if (sessionCommandType === SessionCommandType.START_SESSION) {
            if (transportType !== TransportType.HOMEKIT_DATA_STREAM || controllerKeySalt.length !== 32) {
                callback(-70410 /* INVALID_VALUE_IN_REQUEST */);
                return;
            }
            this.dataStreamServer.prepareSession(connection, controllerKeySalt, function (error, preparedSession) {
                if (error || !preparedSession) {
                    callback(error !== null && error !== void 0 ? error : new Error("PreparedSession was undefined!"));
                    return;
                }
                var listeningPort = tlv.encode(1 /* TCP_LISTENING_PORT */, tlv.writeUInt16(preparedSession.port));
                var response = Buffer.concat([
                    tlv.encode(1 /* STATUS */, 0 /* SUCCESS */),
                    tlv.encode(2 /* TRANSPORT_TYPE_SESSION_PARAMETERS */, listeningPort)
                ]);
                _this.lastSetupDataStreamTransportResponse = response.toString('base64'); // save last response without accessory key salt
                response = Buffer.concat([
                    response,
                    tlv.encode(3 /* ACCESSORY_KEY_SALT */, preparedSession.accessoryKeySalt)
                ]);
                callback(null, response.toString('base64'));
            });
        }
        else {
            callback(-70410 /* INVALID_VALUE_IN_REQUEST */);
            return;
        }
    };
    DataStreamManagement.prototype.buildSupportedDataStreamTransportConfigurationTLV = function (supportedConfiguration) {
        var buffers = [];
        supportedConfiguration.forEach(function (type) {
            var transportType = tlv.encode(1 /* TRANSPORT_TYPE */, type);
            var transferTransportConfiguration = tlv.encode(1 /* TRANSFER_TRANSPORT_CONFIGURATION */, transportType);
            buffers.push(transferTransportConfiguration);
        });
        return Buffer.concat(buffers).toString('base64');
    };
    DataStreamManagement.prototype.constructService = function () {
        var dataStreamTransportManagement = new Service_1.Service.DataStreamTransportManagement('', '');
        dataStreamTransportManagement.setCharacteristic(Characteristic_1.Characteristic.SupportedDataStreamTransportConfiguration, this.supportedDataStreamTransportConfiguration);
        dataStreamTransportManagement.setCharacteristic(Characteristic_1.Characteristic.Version, DataStreamServer_1.DataStreamServer.version);
        return dataStreamTransportManagement;
    };
    DataStreamManagement.prototype.setupServiceHandlers = function () {
        var _this = this;
        this.dataStreamTransportManagementService.getCharacteristic(Characteristic_1.Characteristic.SetupDataStreamTransport)
            .onGet(function () { return _this.lastSetupDataStreamTransportResponse; })
            .on("set" /* SET */, function (value, callback, context, connection) {
            if (!connection) {
                debug("Set event handler for SetupDataStreamTransport cannot be called from plugin! Connection undefined!");
                callback(-70410 /* INVALID_VALUE_IN_REQUEST */);
                return;
            }
            _this.handleSetupDataStreamTransportWrite(value, callback, connection);
        })
            .updateValue(this.lastSetupDataStreamTransportResponse);
    };
    return DataStreamManagement;
}());
exports.DataStreamManagement = DataStreamManagement;
//# sourceMappingURL=DataStreamManagement.js.map

/***/ }),

/***/ 237:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataStreamWriter = exports.DataStreamReader = exports.DataStreamParser = exports.DataFormatTags = exports.UUID = exports.SecondsSince2001 = exports.Float64 = exports.Float32 = exports.Int64 = exports.Int32 = exports.Int16 = exports.Int8 = exports.ValueWrapper = void 0;
var tslib_1 = __nccwpck_require__(4290);
var uuid = tslib_1.__importStar(__nccwpck_require__(6814));
var hapCrypto = tslib_1.__importStar(__nccwpck_require__(6272));
var assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
var debug_1 = tslib_1.__importDefault(__nccwpck_require__(7984));
// welcome to hell :)
// in this file lies madness and frustration. and its not only about HDS. also JavaScript is hell
var debug = debug_1.default("HAP-NodeJS:DataStream:Parser");
var Magics = /** @class */ (function () {
    function Magics() {
    }
    Magics.TERMINATOR = { type: "terminator" };
    return Magics;
}());
var ValueWrapper = /** @class */ (function () {
    function ValueWrapper(value) {
        this.value = value;
    }
    ValueWrapper.prototype.equals = function (obj) {
        return this.constructor.name === obj.constructor.name && obj.value === this.value;
    };
    return ValueWrapper;
}());
exports.ValueWrapper = ValueWrapper;
var Int8 = /** @class */ (function (_super) {
    tslib_1.__extends(Int8, _super);
    function Int8() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Int8;
}(ValueWrapper));
exports.Int8 = Int8;
var Int16 = /** @class */ (function (_super) {
    tslib_1.__extends(Int16, _super);
    function Int16() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Int16;
}(ValueWrapper));
exports.Int16 = Int16;
var Int32 = /** @class */ (function (_super) {
    tslib_1.__extends(Int32, _super);
    function Int32() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Int32;
}(ValueWrapper));
exports.Int32 = Int32;
var Int64 = /** @class */ (function (_super) {
    tslib_1.__extends(Int64, _super);
    function Int64() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Int64;
}(ValueWrapper));
exports.Int64 = Int64;
var Float32 = /** @class */ (function (_super) {
    tslib_1.__extends(Float32, _super);
    function Float32() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Float32;
}(ValueWrapper));
exports.Float32 = Float32;
var Float64 = /** @class */ (function (_super) {
    tslib_1.__extends(Float64, _super);
    function Float64() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Float64;
}(ValueWrapper));
exports.Float64 = Float64;
var SecondsSince2001 = /** @class */ (function (_super) {
    tslib_1.__extends(SecondsSince2001, _super);
    function SecondsSince2001() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return SecondsSince2001;
}(ValueWrapper));
exports.SecondsSince2001 = SecondsSince2001;
var UUID = /** @class */ (function (_super) {
    tslib_1.__extends(UUID, _super);
    function UUID(value) {
        var _this = this;
        assert_1.default(uuid.isValid(value), "invalid uuid format");
        _this = _super.call(this, value) || this;
        return _this;
    }
    return UUID;
}(ValueWrapper));
exports.UUID = UUID;
var DataFormatTags;
(function (DataFormatTags) {
    DataFormatTags[DataFormatTags["INVALID"] = 0] = "INVALID";
    DataFormatTags[DataFormatTags["TRUE"] = 1] = "TRUE";
    DataFormatTags[DataFormatTags["FALSE"] = 2] = "FALSE";
    DataFormatTags[DataFormatTags["TERMINATOR"] = 3] = "TERMINATOR";
    DataFormatTags[DataFormatTags["NULL"] = 4] = "NULL";
    DataFormatTags[DataFormatTags["UUID"] = 5] = "UUID";
    DataFormatTags[DataFormatTags["DATE"] = 6] = "DATE";
    DataFormatTags[DataFormatTags["INTEGER_MINUS_ONE"] = 7] = "INTEGER_MINUS_ONE";
    DataFormatTags[DataFormatTags["INTEGER_RANGE_START_0"] = 8] = "INTEGER_RANGE_START_0";
    DataFormatTags[DataFormatTags["INTEGER_RANGE_STOP_39"] = 46] = "INTEGER_RANGE_STOP_39";
    DataFormatTags[DataFormatTags["INT8"] = 48] = "INT8";
    DataFormatTags[DataFormatTags["INT16LE"] = 49] = "INT16LE";
    DataFormatTags[DataFormatTags["INT32LE"] = 50] = "INT32LE";
    DataFormatTags[DataFormatTags["INT64LE"] = 51] = "INT64LE";
    DataFormatTags[DataFormatTags["FLOAT32LE"] = 53] = "FLOAT32LE";
    DataFormatTags[DataFormatTags["FLOAT64LE"] = 54] = "FLOAT64LE";
    DataFormatTags[DataFormatTags["UTF8_LENGTH_START"] = 64] = "UTF8_LENGTH_START";
    DataFormatTags[DataFormatTags["UTF8_LENGTH_STOP"] = 96] = "UTF8_LENGTH_STOP";
    DataFormatTags[DataFormatTags["UTF8_LENGTH8"] = 97] = "UTF8_LENGTH8";
    DataFormatTags[DataFormatTags["UTF8_LENGTH16LE"] = 98] = "UTF8_LENGTH16LE";
    DataFormatTags[DataFormatTags["UTF8_LENGTH32LE"] = 99] = "UTF8_LENGTH32LE";
    DataFormatTags[DataFormatTags["UTF8_LENGTH64LE"] = 100] = "UTF8_LENGTH64LE";
    DataFormatTags[DataFormatTags["UTF8_NULL_TERMINATED"] = 111] = "UTF8_NULL_TERMINATED";
    DataFormatTags[DataFormatTags["DATA_LENGTH_START"] = 112] = "DATA_LENGTH_START";
    DataFormatTags[DataFormatTags["DATA_LENGTH_STOP"] = 144] = "DATA_LENGTH_STOP";
    DataFormatTags[DataFormatTags["DATA_LENGTH8"] = 145] = "DATA_LENGTH8";
    DataFormatTags[DataFormatTags["DATA_LENGTH16LE"] = 146] = "DATA_LENGTH16LE";
    DataFormatTags[DataFormatTags["DATA_LENGTH32LE"] = 147] = "DATA_LENGTH32LE";
    DataFormatTags[DataFormatTags["DATA_LENGTH64LE"] = 148] = "DATA_LENGTH64LE";
    DataFormatTags[DataFormatTags["DATA_TERMINATED"] = 159] = "DATA_TERMINATED";
    DataFormatTags[DataFormatTags["COMPRESSION_START"] = 160] = "COMPRESSION_START";
    DataFormatTags[DataFormatTags["COMPRESSION_STOP"] = 207] = "COMPRESSION_STOP";
    DataFormatTags[DataFormatTags["ARRAY_LENGTH_START"] = 208] = "ARRAY_LENGTH_START";
    DataFormatTags[DataFormatTags["ARRAY_LENGTH_STOP"] = 222] = "ARRAY_LENGTH_STOP";
    DataFormatTags[DataFormatTags["ARRAY_TERMINATED"] = 223] = "ARRAY_TERMINATED";
    DataFormatTags[DataFormatTags["DICTIONARY_LENGTH_START"] = 224] = "DICTIONARY_LENGTH_START";
    DataFormatTags[DataFormatTags["DICTIONARY_LENGTH_STOP"] = 238] = "DICTIONARY_LENGTH_STOP";
    DataFormatTags[DataFormatTags["DICTIONARY_TERMINATED"] = 239] = "DICTIONARY_TERMINATED";
})(DataFormatTags = exports.DataFormatTags || (exports.DataFormatTags = {}));
var DataStreamParser = /** @class */ (function () {
    function DataStreamParser() {
    }
    DataStreamParser.decode = function (buffer) {
        var tag = buffer.readTag();
        if (tag === 0 /* INVALID */) {
            throw new Error("HDSDecoder: zero tag detected on index " + buffer.readerIndex);
        }
        else if (tag === 1 /* TRUE */) {
            return buffer.readTrue();
        }
        else if (tag === 2 /* FALSE */) {
            return buffer.readFalse();
        }
        else if (tag === 3 /* TERMINATOR */) {
            return Magics.TERMINATOR;
        }
        else if (tag === 4 /* NULL */) {
            return null;
        }
        else if (tag === 5 /* UUID */) {
            return buffer.readUUID();
        }
        else if (tag === 6 /* DATE */) {
            return buffer.readSecondsSince2001_01_01();
        }
        else if (tag === 7 /* INTEGER_MINUS_ONE */) {
            return buffer.readNegOne();
        }
        else if (tag >= 8 /* INTEGER_RANGE_START_0 */ && tag <= 46 /* INTEGER_RANGE_STOP_39 */) {
            return buffer.readIntRange(tag); // integer values from 0-39
        }
        else if (tag === 48 /* INT8 */) {
            return buffer.readInt8();
        }
        else if (tag === 49 /* INT16LE */) {
            return buffer.readInt16LE();
        }
        else if (tag === 50 /* INT32LE */) {
            return buffer.readInt32LE();
        }
        else if (tag === 51 /* INT64LE */) {
            return buffer.readInt64LE();
        }
        else if (tag === 53 /* FLOAT32LE */) {
            return buffer.readFloat32LE();
        }
        else if (tag === 54 /* FLOAT64LE */) {
            return buffer.readFloat64LE();
        }
        else if (tag >= 64 /* UTF8_LENGTH_START */ && tag <= 96 /* UTF8_LENGTH_STOP */) {
            var length = tag - 64 /* UTF8_LENGTH_START */;
            return buffer.readUTF8(length);
        }
        else if (tag === 97 /* UTF8_LENGTH8 */) {
            return buffer.readUTF8_Length8();
        }
        else if (tag === 98 /* UTF8_LENGTH16LE */) {
            return buffer.readUTF8_Length16LE();
        }
        else if (tag === 99 /* UTF8_LENGTH32LE */) {
            return buffer.readUTF8_Length32LE();
        }
        else if (tag === 100 /* UTF8_LENGTH64LE */) {
            return buffer.readUTF8_Length64LE();
        }
        else if (tag === 111 /* UTF8_NULL_TERMINATED */) {
            return buffer.readUTF8_NULL_terminated();
        }
        else if (tag >= 112 /* DATA_LENGTH_START */ && tag <= 144 /* DATA_LENGTH_STOP */) {
            var length = tag - 112 /* DATA_LENGTH_START */;
            buffer.readData(length);
        }
        else if (tag === 145 /* DATA_LENGTH8 */) {
            return buffer.readData_Length8();
        }
        else if (tag === 146 /* DATA_LENGTH16LE */) {
            return buffer.readData_Length16LE();
        }
        else if (tag === 147 /* DATA_LENGTH32LE */) {
            return buffer.readData_Length32LE();
        }
        else if (tag === 148 /* DATA_LENGTH64LE */) {
            return buffer.readData_Length64LE();
        }
        else if (tag === 159 /* DATA_TERMINATED */) {
            return buffer.readData_terminated();
        }
        else if (tag >= 160 /* COMPRESSION_START */ && tag <= 207 /* COMPRESSION_STOP */) {
            var index = tag - 160 /* COMPRESSION_START */;
            return buffer.decompressData(index);
        }
        else if (tag >= 208 /* ARRAY_LENGTH_START */ && tag <= 222 /* ARRAY_LENGTH_STOP */) {
            var length = tag - 208 /* ARRAY_LENGTH_START */;
            var array = [];
            for (var i = 0; i < length; i++) {
                array.push(this.decode(buffer));
            }
            return array;
        }
        else if (tag === 223 /* ARRAY_TERMINATED */) {
            var array = [];
            var element = void 0;
            while ((element = this.decode(buffer)) != Magics.TERMINATOR) {
                array.push(element);
            }
            return array;
        }
        else if (tag >= 224 /* DICTIONARY_LENGTH_START */ && tag <= 238 /* DICTIONARY_LENGTH_STOP */) {
            var length = tag - 224 /* DICTIONARY_LENGTH_START */;
            var dictionary = {};
            for (var i = 0; i < length; i++) {
                var key = this.decode(buffer);
                dictionary[key] = this.decode(buffer);
            }
            return dictionary;
        }
        else if (tag === 239 /* DICTIONARY_TERMINATED */) {
            var dictionary = {};
            var key = void 0;
            while ((key = this.decode(buffer)) != Magics.TERMINATOR) {
                dictionary[key] = this.decode(buffer); // decode value
            }
            return dictionary;
        }
        else {
            throw new Error("HDSDecoder: encountered unknown tag on index " + buffer.readerIndex + ": " + tag.toString(16));
        }
    };
    DataStreamParser.encode = function (data, buffer) {
        var _this = this;
        if (data === undefined) {
            throw new Error("HDSEncoder: cannot encode undefined");
        }
        if (data === null) {
            buffer.writeTag(4 /* NULL */);
            return;
        }
        switch (typeof data) {
            case "boolean":
                if (data) {
                    buffer.writeTrue();
                }
                else {
                    buffer.writeFalse();
                }
                break;
            case "number":
                if (Number.isInteger(data)) {
                    buffer.writeNumber(data);
                }
                else {
                    buffer.writeFloat64LE(new Float64(data));
                }
                break;
            case "string":
                buffer.writeUTF8(data);
                break;
            case "object":
                if (Array.isArray(data)) {
                    var length = data.length;
                    if (length <= 12) {
                        buffer.writeTag(208 /* ARRAY_LENGTH_START */ + length);
                    }
                    else {
                        buffer.writeTag(223 /* ARRAY_TERMINATED */);
                    }
                    data.forEach(function (element) {
                        _this.encode(element, buffer);
                    });
                    if (length > 12) {
                        buffer.writeTag(3 /* TERMINATOR */);
                    }
                }
                else if (data instanceof ValueWrapper) {
                    if (data instanceof Int8) {
                        buffer.writeInt8(data);
                    }
                    else if (data instanceof Int16) {
                        buffer.writeInt16LE(data);
                    }
                    else if (data instanceof Int32) {
                        buffer.writeInt32LE(data);
                    }
                    else if (data instanceof Int64) {
                        buffer.writeInt64LE(data);
                    }
                    else if (data instanceof Float32) {
                        buffer.writeFloat32LE(data);
                    }
                    else if (data instanceof Float64) {
                        buffer.writeFloat64LE(data);
                    }
                    else if (data instanceof SecondsSince2001) {
                        buffer.writeSecondsSince2001_01_01(data);
                    }
                    else if (data instanceof UUID) {
                        buffer.writeUUID(data.value);
                    }
                    else {
                        throw new Error("Unknown wrapped object 'ValueWrapper' of class " + data.constructor.name);
                    }
                }
                else if (data instanceof Buffer) {
                    buffer.writeData(data);
                }
                else { // object is treated as dictionary
                    var entries = Object.entries(data);
                    if (entries.length <= 14) {
                        buffer.writeTag(224 /* DICTIONARY_LENGTH_START */ + entries.length);
                    }
                    else {
                        buffer.writeTag(239 /* DICTIONARY_TERMINATED */);
                    }
                    entries.forEach(function (entry) {
                        _this.encode(entry[0], buffer); // encode key
                        _this.encode(entry[1], buffer); // encode value
                    });
                    if (entries.length > 14) {
                        buffer.writeTag(3 /* TERMINATOR */);
                    }
                }
                break;
            default:
                throw new Error("HDSEncoder: no idea how to encode value of type '" + (typeof data) + "': " + data);
        }
    };
    return DataStreamParser;
}());
exports.DataStreamParser = DataStreamParser;
var DataStreamReader = /** @class */ (function () {
    function DataStreamReader(data) {
        this.trackedCompressedData = [];
        this.data = data;
        this.readerIndex = 0;
    }
    DataStreamReader.prototype.finished = function () {
        if (this.readerIndex < this.data.length) {
            var remainingHex = this.data.slice(this.readerIndex, this.data.length).toString("hex");
            debug("WARNING Finished reading HDS stream, but there are still %d bytes remaining () %s", this.data.length - this.readerIndex, remainingHex);
        }
    };
    DataStreamReader.prototype.decompressData = function (index) {
        if (index >= this.trackedCompressedData.length) {
            throw new Error("HDSDecoder: Tried decompression of data for an index out of range (index " + index + " and got " + this.trackedCompressedData.length + " elements)");
        }
        return this.trackedCompressedData[index];
    };
    DataStreamReader.prototype.trackData = function (data) {
        this.trackedCompressedData.push(data);
        return data;
    };
    DataStreamReader.prototype.ensureLength = function (bytes) {
        if (this.readerIndex + bytes > this.data.length) {
            var remaining = this.data.length - this.readerIndex;
            throw new Error("HDSDecoder: End of data stream. Tried reading " + bytes + " bytes however got only " + remaining + " remaining!");
        }
    };
    DataStreamReader.prototype.readTag = function () {
        this.ensureLength(1);
        return this.data.readUInt8(this.readerIndex++);
    };
    DataStreamReader.prototype.readTrue = function () {
        return this.trackData(true); // do those tag encoded values get cached?
    };
    DataStreamReader.prototype.readFalse = function () {
        return this.trackData(false);
    };
    DataStreamReader.prototype.readNegOne = function () {
        return this.trackData(-1);
    };
    DataStreamReader.prototype.readIntRange = function (tag) {
        return this.trackData(tag - 8 /* INTEGER_RANGE_START_0 */); // integer values from 0-39
    };
    DataStreamReader.prototype.readInt8 = function () {
        this.ensureLength(1);
        return this.trackData(this.data.readInt8(this.readerIndex++));
    };
    DataStreamReader.prototype.readInt16LE = function () {
        this.ensureLength(2);
        var value = this.data.readInt16LE(this.readerIndex);
        this.readerIndex += 2;
        return this.trackData(value);
    };
    DataStreamReader.prototype.readInt32LE = function () {
        this.ensureLength(4);
        var value = this.data.readInt32LE(this.readerIndex);
        this.readerIndex += 4;
        return this.trackData(value);
    };
    DataStreamReader.prototype.readInt64LE = function () {
        this.ensureLength(8);
        var low = this.data.readInt32LE(this.readerIndex);
        var value = this.data.readInt32LE(this.readerIndex + 4) * 0x100000000 + low;
        if (low < 0) {
            value += 0x100000000;
        }
        this.readerIndex += 8;
        return this.trackData(value);
    };
    DataStreamReader.prototype.readFloat32LE = function () {
        this.ensureLength(4);
        var value = this.data.readFloatLE(this.readerIndex);
        this.readerIndex += 4;
        return this.trackData(value);
    };
    DataStreamReader.prototype.readFloat64LE = function () {
        this.ensureLength(8);
        var value = this.data.readDoubleLE(this.readerIndex);
        return this.trackData(value);
    };
    DataStreamReader.prototype.readLength8 = function () {
        this.ensureLength(1);
        return this.data.readUInt8(this.readerIndex++);
    };
    DataStreamReader.prototype.readLength16LE = function () {
        this.ensureLength(2);
        var value = this.data.readUInt16LE(this.readerIndex);
        this.readerIndex += 2;
        return value;
    };
    DataStreamReader.prototype.readLength32LE = function () {
        this.ensureLength(4);
        var value = this.data.readUInt32LE(this.readerIndex);
        this.readerIndex += 4;
        return value;
    };
    DataStreamReader.prototype.readLength64LE = function () {
        this.ensureLength(8);
        var low = this.data.readUInt32LE(this.readerIndex);
        var value = this.data.readUInt32LE(this.readerIndex + 4) * 0x100000000 + low;
        this.readerIndex += 8;
        return value;
    };
    DataStreamReader.prototype.readUTF8 = function (length) {
        this.ensureLength(length);
        var value = this.data.toString('utf8', this.readerIndex, this.readerIndex + length);
        this.readerIndex += length;
        return this.trackData(value);
    };
    DataStreamReader.prototype.readUTF8_Length8 = function () {
        var length = this.readLength8();
        return this.readUTF8(length);
    };
    DataStreamReader.prototype.readUTF8_Length16LE = function () {
        var length = this.readLength16LE();
        return this.readUTF8(length);
    };
    DataStreamReader.prototype.readUTF8_Length32LE = function () {
        var length = this.readLength32LE();
        return this.readUTF8(length);
    };
    DataStreamReader.prototype.readUTF8_Length64LE = function () {
        var length = this.readLength64LE();
        return this.readUTF8(length);
    };
    DataStreamReader.prototype.readUTF8_NULL_terminated = function () {
        var offset = this.readerIndex;
        var nextByte;
        for (;;) {
            nextByte = this.data[offset];
            if (nextByte === undefined) {
                throw new Error("HDSDecoder: Reached end of data stream while reading NUL terminated string!");
            }
            else if (nextByte === 0) {
                break;
            }
            else {
                offset++;
            }
        }
        var value = this.data.toString('utf8', this.readerIndex, offset);
        this.readerIndex = offset + 1;
        return this.trackData(value);
    };
    DataStreamReader.prototype.readData = function (length) {
        this.ensureLength(length);
        var value = this.data.slice(this.readerIndex, this.readerIndex + length);
        this.readerIndex += length;
        return this.trackData(value);
    };
    DataStreamReader.prototype.readData_Length8 = function () {
        var length = this.readLength8();
        return this.readData(length);
    };
    DataStreamReader.prototype.readData_Length16LE = function () {
        var length = this.readLength16LE();
        return this.readData(length);
    };
    DataStreamReader.prototype.readData_Length32LE = function () {
        var length = this.readLength32LE();
        return this.readData(length);
    };
    DataStreamReader.prototype.readData_Length64LE = function () {
        var length = this.readLength64LE();
        return this.readData(length);
    };
    DataStreamReader.prototype.readData_terminated = function () {
        var offset = this.readerIndex;
        var nextByte;
        for (;;) {
            nextByte = this.data[offset];
            if (nextByte === undefined) {
                throw new Error("HDSDecoder: Reached end of data stream while reading terminated data!");
            }
            else if (nextByte === 3 /* TERMINATOR */) {
                break;
            }
            else {
                offset++;
            }
        }
        var value = this.data.slice(this.readerIndex, offset);
        this.readerIndex = offset + 1;
        return this.trackData(value);
    };
    DataStreamReader.prototype.readSecondsSince2001_01_01 = function () {
        // second since 2001-01-01 00:00:00
        return this.readFloat64LE();
    };
    DataStreamReader.prototype.readUUID = function () {
        this.ensureLength(16);
        var value = uuid.unparse(this.data, this.readerIndex);
        this.readerIndex += 16;
        return this.trackData(value);
    };
    return DataStreamReader;
}());
exports.DataStreamReader = DataStreamReader;
var WrittenDataList = /** @class */ (function () {
    function WrittenDataList() {
        this.writtenData = [];
    }
    WrittenDataList.prototype.push = function (data) {
        this.writtenData.push(data);
    };
    WrittenDataList.prototype.indexOf = function (data) {
        for (var i = 0; i < this.writtenData.length; i++) {
            var data0 = this.writtenData[i];
            if (data === data0) {
                return i;
            }
            if (data instanceof ValueWrapper && data0 instanceof ValueWrapper) {
                if (data.equals(data0)) {
                    return i;
                }
            }
        }
        return -1;
    };
    return WrittenDataList;
}());
var DataStreamWriter = /** @class */ (function () {
    function DataStreamWriter() {
        this.writtenData = new WrittenDataList();
        this.data = Buffer.alloc(DataStreamWriter.chunkSize);
        this.writerIndex = 0;
    }
    DataStreamWriter.prototype.length = function () {
        return this.writerIndex; // since writerIndex points to the next FREE index it also represents the length
    };
    DataStreamWriter.prototype.getData = function () {
        return this.data.slice(0, this.writerIndex);
    };
    DataStreamWriter.prototype.ensureLength = function (bytes) {
        var neededBytes = (this.writerIndex + bytes) - this.data.length;
        if (neededBytes > 0) {
            var chunks = Math.ceil(neededBytes / DataStreamWriter.chunkSize);
            // don't know if it's best for performance to immediately concatenate the buffers. That way it's
            // the easiest way to handle writing though.
            this.data = Buffer.concat([this.data, Buffer.alloc(chunks * DataStreamWriter.chunkSize)]);
        }
    };
    DataStreamWriter.prototype.compressDataIfPossible = function (data) {
        var index = this.writtenData.indexOf(data);
        if (index < 0) {
            // data is not present yet
            this.writtenData.push(data);
            return false;
        }
        else if (index <= 207 /* COMPRESSION_STOP */ - 160 /* COMPRESSION_START */) {
            // data was already written and the index is in the applicable range => shorten the payload
            this.writeTag(160 /* COMPRESSION_START */ + index);
            return true;
        }
        return false;
    };
    DataStreamWriter.prototype.writeTag = function (tag) {
        this.ensureLength(1);
        this.data.writeUInt8(tag, this.writerIndex++);
    };
    DataStreamWriter.prototype.writeTrue = function () {
        this.writeTag(1 /* TRUE */);
    };
    DataStreamWriter.prototype.writeFalse = function () {
        this.writeTag(2 /* FALSE */);
    };
    DataStreamWriter.prototype.writeNumber = function (number) {
        if (number === -1) {
            this.writeTag(7 /* INTEGER_MINUS_ONE */);
        }
        else if (number >= 0 && number <= 39) {
            this.writeTag(8 /* INTEGER_RANGE_START_0 */ + number);
        }
        else if (number >= -128 && number <= 127) {
            this.writeInt8(new Int8(number));
        }
        else if (number >= -32768 && number <= 32767) {
            this.writeInt16LE(new Int16(number));
        }
        else if (number >= -2147483648 && number <= -2147483648) {
            this.writeInt32LE(new Int32(number));
        }
        else if (number >= Number.MIN_SAFE_INTEGER && number <= Number.MAX_SAFE_INTEGER) { // use correct uin64 restriction when we convert to bigint
            this.writeInt64LE(new Int64(number));
        }
        else {
            throw new Error("Tried writing unrepresentable number (" + number + ")");
        }
    };
    DataStreamWriter.prototype.writeInt8 = function (int8) {
        if (this.compressDataIfPossible(int8)) {
            return;
        }
        this.ensureLength(2);
        this.writeTag(48 /* INT8 */);
        this.data.writeInt8(int8.value, this.writerIndex++);
    };
    DataStreamWriter.prototype.writeInt16LE = function (int16) {
        if (this.compressDataIfPossible(int16)) {
            return;
        }
        this.ensureLength(3);
        this.writeTag(49 /* INT16LE */);
        this.data.writeInt16LE(int16.value, this.writerIndex);
        this.writerIndex += 2;
    };
    DataStreamWriter.prototype.writeInt32LE = function (int32) {
        if (this.compressDataIfPossible(int32)) {
            return;
        }
        this.ensureLength(5);
        this.writeTag(50 /* INT32LE */);
        this.data.writeInt32LE(int32.value, this.writerIndex);
        this.writerIndex += 4;
    };
    DataStreamWriter.prototype.writeInt64LE = function (int64) {
        if (this.compressDataIfPossible(int64)) {
            return;
        }
        this.ensureLength(9);
        this.writeTag(51 /* INT64LE */);
        this.data.writeUInt32LE(int64.value, this.writerIndex); // TODO correctly implement int64; currently it's basically an int32
        this.data.writeUInt32LE(0, this.writerIndex + 4);
        this.writerIndex += 8;
    };
    DataStreamWriter.prototype.writeFloat32LE = function (float32) {
        if (this.compressDataIfPossible(float32)) {
            return;
        }
        this.ensureLength(5);
        this.writeTag(53 /* FLOAT32LE */);
        this.data.writeFloatLE(float32.value, this.writerIndex);
        this.writerIndex += 4;
    };
    DataStreamWriter.prototype.writeFloat64LE = function (float64) {
        if (this.compressDataIfPossible(float64)) {
            return;
        }
        this.ensureLength(9);
        this.writeTag(54 /* FLOAT64LE */);
        this.data.writeDoubleLE(float64.value, this.writerIndex);
        this.writerIndex += 8;
    };
    DataStreamWriter.prototype.writeLength8 = function (length) {
        this.ensureLength(1);
        this.data.writeUInt8(length, this.writerIndex++);
    };
    DataStreamWriter.prototype.writeLength16LE = function (length) {
        this.ensureLength(2);
        this.data.writeUInt16LE(length, this.writerIndex);
        this.writerIndex += 2;
    };
    DataStreamWriter.prototype.writeLength32LE = function (length) {
        this.ensureLength(4);
        this.data.writeUInt32LE(length, this.writerIndex);
        this.writerIndex += 4;
    };
    DataStreamWriter.prototype.writeLength64LE = function (length) {
        this.ensureLength(8);
        hapCrypto.writeUInt64LE(length, this.data, this.writerIndex);
        this.writerIndex += 8;
    };
    DataStreamWriter.prototype.writeUTF8 = function (utf8) {
        if (this.compressDataIfPossible(utf8)) {
            return;
        }
        var length = Buffer.byteLength(utf8);
        if (length <= 32) {
            this.ensureLength(1 + length);
            this.writeTag(64 /* UTF8_LENGTH_START */ + utf8.length);
            this._writeUTF8(utf8);
        }
        else if (length <= 255) {
            this.writeUTF8_Length8(utf8);
        }
        else if (length <= 65535) {
            this.writeUTF8_Length16LE(utf8);
        }
        else if (length <= 4294967295) {
            this.writeUTF8_Length32LE(utf8);
        }
        else if (length <= Number.MAX_SAFE_INTEGER) { // use correct uin64 restriction when we convert to bigint
            this.writeUTF8_Length64LE(utf8);
        }
        else {
            this.writeUTF8_NULL_terminated(utf8);
        }
    };
    DataStreamWriter.prototype._writeUTF8 = function (utf8) {
        var byteLength = Buffer.byteLength(utf8);
        this.ensureLength(byteLength);
        this.data.write(utf8, this.writerIndex, undefined, "utf8");
        this.writerIndex += byteLength;
    };
    DataStreamWriter.prototype.writeUTF8_Length8 = function (utf8) {
        var length = Buffer.byteLength(utf8);
        this.ensureLength(2 + length);
        this.writeTag(97 /* UTF8_LENGTH8 */);
        this.writeLength8(length);
        this._writeUTF8(utf8);
    };
    DataStreamWriter.prototype.writeUTF8_Length16LE = function (utf8) {
        var length = Buffer.byteLength(utf8);
        this.ensureLength(3 + length);
        this.writeTag(98 /* UTF8_LENGTH16LE */);
        this.writeLength16LE(length);
        this._writeUTF8(utf8);
    };
    DataStreamWriter.prototype.writeUTF8_Length32LE = function (utf8) {
        var length = Buffer.byteLength(utf8);
        this.ensureLength(5 + length);
        this.writeTag(99 /* UTF8_LENGTH32LE */);
        this.writeLength32LE(length);
        this._writeUTF8(utf8);
    };
    DataStreamWriter.prototype.writeUTF8_Length64LE = function (utf8) {
        var length = Buffer.byteLength(utf8);
        this.ensureLength(9 + length);
        this.writeTag(100 /* UTF8_LENGTH64LE */);
        this.writeLength64LE(length);
        this._writeUTF8(utf8);
    };
    DataStreamWriter.prototype.writeUTF8_NULL_terminated = function (utf8) {
        this.ensureLength(1 + Buffer.byteLength(utf8) + 1);
        this.writeTag(111 /* UTF8_NULL_TERMINATED */);
        this._writeUTF8(utf8);
        this.data.writeUInt8(0, this.writerIndex++);
    };
    DataStreamWriter.prototype.writeData = function (data) {
        if (this.compressDataIfPossible(data)) {
            return;
        }
        if (data.length <= 32) {
            this.writeTag(112 /* DATA_LENGTH_START */ + data.length);
            this._writeData(data);
        }
        else if (data.length <= 255) {
            this.writeData_Length8(data);
        }
        else if (data.length <= 65535) {
            this.writeData_Length16LE(data);
        }
        else if (data.length <= 4294967295) {
            this.writeData_Length32LE(data);
        }
        else if (data.length <= Number.MAX_SAFE_INTEGER) {
            this.writeData_Length64LE(data);
        }
        else {
            this.writeData_terminated(data);
        }
    };
    DataStreamWriter.prototype._writeData = function (data) {
        this.ensureLength(data.length);
        for (var i = 0; i < data.length; i++) {
            this.data[this.writerIndex++] = data[i];
        }
    };
    DataStreamWriter.prototype.writeData_Length8 = function (data) {
        this.ensureLength(2 + data.length);
        this.writeTag(145 /* DATA_LENGTH8 */);
        this.writeLength8(data.length);
        this._writeData(data);
    };
    DataStreamWriter.prototype.writeData_Length16LE = function (data) {
        this.ensureLength(3 + data.length);
        this.writeTag(146 /* DATA_LENGTH16LE */);
        this.writeLength16LE(data.length);
        this._writeData(data);
    };
    DataStreamWriter.prototype.writeData_Length32LE = function (data) {
        this.ensureLength(5 + data.length);
        this.writeTag(147 /* DATA_LENGTH32LE */);
        this.writeLength32LE(data.length);
        this._writeData(data);
    };
    DataStreamWriter.prototype.writeData_Length64LE = function (data) {
        this.ensureLength(9 + data.length);
        this.writeTag(148 /* DATA_LENGTH64LE */);
        this.writeLength64LE(data.length);
        this._writeData(data);
    };
    DataStreamWriter.prototype.writeData_terminated = function (data) {
        this.ensureLength(1 + data.length + 1);
        this.writeTag(159 /* DATA_TERMINATED */);
        this._writeData(data);
        this.writeTag(3 /* TERMINATOR */);
    };
    DataStreamWriter.prototype.writeSecondsSince2001_01_01 = function (seconds) {
        if (this.compressDataIfPossible(seconds)) {
            return;
        }
        this.ensureLength(9);
        this.writeTag(6 /* DATE */);
        this.data.writeDoubleLE(seconds.value, this.writerIndex);
        this.writerIndex += 8;
    };
    DataStreamWriter.prototype.writeUUID = function (uuid_string) {
        assert_1.default(uuid.isValid(uuid_string), "supplied uuid is invalid");
        if (this.compressDataIfPossible(new UUID(uuid_string))) {
            return;
        }
        this.ensureLength(17);
        this.writeTag(5 /* UUID */);
        uuid.write(uuid_string, this.data, this.writerIndex);
        this.writerIndex += 16;
    };
    DataStreamWriter.chunkSize = 128; // seems to be a good default
    return DataStreamWriter;
}());
exports.DataStreamWriter = DataStreamWriter;
//# sourceMappingURL=DataStreamParser.js.map

/***/ }),

/***/ 3989:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataStreamConnection = exports.DataStreamConnectionEvent = exports.DataStreamServer = exports.DataStreamServerEvent = exports.DataSendCloseReason = exports.HDSStatus = exports.Topics = exports.Protocols = void 0;
var tslib_1 = __nccwpck_require__(4290);
var assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
var crypto_1 = tslib_1.__importDefault(__nccwpck_require__(6417));
var debug_1 = tslib_1.__importDefault(__nccwpck_require__(7984));
var events_1 = __nccwpck_require__(8614);
var net_1 = tslib_1.__importDefault(__nccwpck_require__(1631));
var hapCrypto = tslib_1.__importStar(__nccwpck_require__(6272));
var DataStreamParser_1 = __nccwpck_require__(237);
var debug = debug_1.default('HAP-NodeJS:DataStream:Server');
var Protocols;
(function (Protocols) {
    Protocols["CONTROL"] = "control";
    Protocols["TARGET_CONTROL"] = "targetControl";
    Protocols["DATA_SEND"] = "dataSend";
})(Protocols = exports.Protocols || (exports.Protocols = {}));
var Topics;
(function (Topics) {
    // control
    Topics["HELLO"] = "hello";
    // targetControl
    Topics["WHOAMI"] = "whoami";
    // dataSend
    Topics["OPEN"] = "open";
    Topics["DATA"] = "data";
    Topics["ACK"] = "ack";
    Topics["CLOSE"] = "close";
})(Topics = exports.Topics || (exports.Topics = {}));
var HDSStatus;
(function (HDSStatus) {
    // noinspection JSUnusedGlobalSymbols
    HDSStatus[HDSStatus["SUCCESS"] = 0] = "SUCCESS";
    HDSStatus[HDSStatus["OUT_OF_MEMORY"] = 1] = "OUT_OF_MEMORY";
    HDSStatus[HDSStatus["TIMEOUT"] = 2] = "TIMEOUT";
    HDSStatus[HDSStatus["HEADER_ERROR"] = 3] = "HEADER_ERROR";
    HDSStatus[HDSStatus["PAYLOAD_ERROR"] = 4] = "PAYLOAD_ERROR";
    HDSStatus[HDSStatus["MISSING_PROTOCOL"] = 5] = "MISSING_PROTOCOL";
    HDSStatus[HDSStatus["PROTOCOL_SPECIFIC_ERROR"] = 6] = "PROTOCOL_SPECIFIC_ERROR";
})(HDSStatus = exports.HDSStatus || (exports.HDSStatus = {}));
var DataSendCloseReason;
(function (DataSendCloseReason) {
    // noinspection JSUnusedGlobalSymbols
    DataSendCloseReason[DataSendCloseReason["NORMAL"] = 0] = "NORMAL";
    DataSendCloseReason[DataSendCloseReason["NOT_ALLOWED"] = 1] = "NOT_ALLOWED";
    DataSendCloseReason[DataSendCloseReason["BUSY"] = 2] = "BUSY";
    DataSendCloseReason[DataSendCloseReason["CANCELLED"] = 3] = "CANCELLED";
    DataSendCloseReason[DataSendCloseReason["UNSUPPORTED"] = 4] = "UNSUPPORTED";
    DataSendCloseReason[DataSendCloseReason["UNEXPECTED_FAILURE"] = 5] = "UNEXPECTED_FAILURE";
    DataSendCloseReason[DataSendCloseReason["TIMEOUT"] = 6] = "TIMEOUT";
})(DataSendCloseReason = exports.DataSendCloseReason || (exports.DataSendCloseReason = {}));
var ServerState;
(function (ServerState) {
    ServerState[ServerState["UNINITIALIZED"] = 0] = "UNINITIALIZED";
    ServerState[ServerState["BINDING"] = 1] = "BINDING";
    ServerState[ServerState["LISTENING"] = 2] = "LISTENING";
    ServerState[ServerState["CLOSING"] = 3] = "CLOSING";
})(ServerState || (ServerState = {}));
var ConnectionState;
(function (ConnectionState) {
    ConnectionState[ConnectionState["UNIDENTIFIED"] = 0] = "UNIDENTIFIED";
    ConnectionState[ConnectionState["EXPECTING_HELLO"] = 1] = "EXPECTING_HELLO";
    ConnectionState[ConnectionState["READY"] = 2] = "READY";
    ConnectionState[ConnectionState["CLOSING"] = 3] = "CLOSING";
    ConnectionState[ConnectionState["CLOSED"] = 4] = "CLOSED";
})(ConnectionState || (ConnectionState = {}));
var MessageType;
(function (MessageType) {
    MessageType[MessageType["EVENT"] = 1] = "EVENT";
    MessageType[MessageType["REQUEST"] = 2] = "REQUEST";
    MessageType[MessageType["RESPONSE"] = 3] = "RESPONSE";
})(MessageType || (MessageType = {}));
var DataStreamServerEvent;
(function (DataStreamServerEvent) {
    /**
     * This event is emitted when a new client socket is received. At this point we have no idea to what
     * hap session this connection will be matched.
     */
    DataStreamServerEvent["CONNECTION_OPENED"] = "connection-opened";
    /**
     * This event is emitted when the socket of a connection gets closed.
     */
    DataStreamServerEvent["CONNECTION_CLOSED"] = "connection-closed";
})(DataStreamServerEvent = exports.DataStreamServerEvent || (exports.DataStreamServerEvent = {}));
/**
 * DataStreamServer which listens for incoming tcp connections and handles identification of new connections
 */
var DataStreamServer = /** @class */ (function (_super) {
    tslib_1.__extends(DataStreamServer, _super);
    function DataStreamServer() {
        var _this = _super.call(this) || this;
        _this.state = 0 /* UNINITIALIZED */;
        _this.preparedSessions = [];
        _this.connections = [];
        _this.removeListenersOnceClosed = false;
        _this.internalEventEmitter = new events_1.EventEmitter(); // used for message event and message request handlers
        return _this;
    }
    /**
     * Registers a new event handler to handle incoming event messages.
     * The handler is only called for a connection if for the give protocol no ProtocolHandler
     * was registered on the connection level.
     *
     * @param protocol {string | Protocols} - name of the protocol to register the handler for
     * @param event {string | Topics} - name of the event (also referred to as topic. See {Topics} for some known ones)
     * @param handler {GlobalEventHandler} - function to be called for every occurring event
     */
    DataStreamServer.prototype.onEventMessage = function (protocol, event, handler) {
        this.internalEventEmitter.on(protocol + "-e-" + event, handler);
        return this;
    };
    /**
     * Removes an registered event handler.
     *
     * @param protocol {string | Protocols} - name of the protocol to unregister the handler for
     * @param event {string | Topics} - name of the event (also referred to as topic. See {Topics} for some known ones)
     * @param handler {GlobalEventHandler} - registered event handler
     */
    DataStreamServer.prototype.removeEventHandler = function (protocol, event, handler) {
        this.internalEventEmitter.removeListener(protocol + "-e-" + event, handler);
        return this;
    };
    /**
     * Registers a new request handler to handle incoming request messages.
     * The handler is only called for a connection if for the give protocol no ProtocolHandler
     * was registered on the connection level.
     *
     * @param protocol {string | Protocols} - name of the protocol to register the handler for
     * @param request {string | Topics} - name of the request (also referred to as topic. See {Topics} for some known ones)
     * @param handler {GlobalRequestHandler} - function to be called for every occurring request
     */
    DataStreamServer.prototype.onRequestMessage = function (protocol, request, handler) {
        this.internalEventEmitter.on(protocol + "-r-" + request, handler);
        return this;
    };
    /**
     * Removes an registered request handler.
     *
     * @param protocol {string | Protocols} - name of the protocol to unregister the handler for
     * @param request {string | Topics} - name of the request (also referred to as topic. See {Topics} for some known ones)
     * @param handler {GlobalRequestHandler} - registered request handler
     */
    DataStreamServer.prototype.removeRequestHandler = function (protocol, request, handler) {
        this.internalEventEmitter.removeListener(protocol + "-r-" + request, handler);
        return this;
    };
    DataStreamServer.prototype.prepareSession = function (connection, controllerKeySalt, callback) {
        var _this = this;
        debug("Preparing for incoming HDS connection from %s", connection.sessionID);
        var accessoryKeySalt = crypto_1.default.randomBytes(32);
        var salt = Buffer.concat([controllerKeySalt, accessoryKeySalt]);
        var accessoryToControllerEncryptionKey = hapCrypto.HKDF("sha512", salt, connection.encryption.sharedSecret, DataStreamServer.accessoryToControllerInfo, 32);
        var controllerToAccessoryEncryptionKey = hapCrypto.HKDF("sha512", salt, connection.encryption.sharedSecret, DataStreamServer.controllerToAccessoryInfo, 32);
        var preparedSession = {
            connection: connection,
            accessoryToControllerEncryptionKey: accessoryToControllerEncryptionKey,
            controllerToAccessoryEncryptionKey: controllerToAccessoryEncryptionKey,
            accessoryKeySalt: accessoryKeySalt,
            connectTimeout: setTimeout(function () { return _this.timeoutPreparedSession(preparedSession); }, 10000),
        };
        preparedSession.connectTimeout.unref();
        this.preparedSessions.push(preparedSession);
        this.checkTCPServerEstablished(preparedSession, function (error) {
            if (error) {
                callback(error);
            }
            else {
                callback(undefined, preparedSession);
            }
        });
    };
    DataStreamServer.prototype.timeoutPreparedSession = function (preparedSession) {
        debug("Prepared HDS session timed out out since no connection was opened for 10 seconds (%s)", preparedSession.connection.sessionID);
        var index = this.preparedSessions.indexOf(preparedSession);
        if (index >= 0) {
            this.preparedSessions.splice(index, 1);
        }
        this.checkCloseable();
    };
    DataStreamServer.prototype.checkTCPServerEstablished = function (preparedSession, callback) {
        var _this = this;
        switch (this.state) {
            case 0 /* UNINITIALIZED */:
                debug("Starting up TCP server.");
                this.tcpServer = net_1.default.createServer();
                this.tcpServer.once('listening', this.listening.bind(this, preparedSession, callback));
                this.tcpServer.on('connection', this.onConnection.bind(this));
                this.tcpServer.on('close', this.closed.bind(this));
                this.tcpServer.listen();
                this.state = 1 /* BINDING */;
                break;
            case 1 /* BINDING */:
                debug("TCP server already running. Waiting for it to bind.");
                this.tcpServer.once('listening', this.listening.bind(this, preparedSession, callback));
                break;
            case 2 /* LISTENING */:
                debug("Instructing client to connect to already running TCP server");
                preparedSession.port = this.tcpPort;
                callback();
                break;
            case 3 /* CLOSING */:
                debug("TCP socket is currently closing. Trying again when server is fully closed and opening a new one then.");
                this.tcpServer.once('close', function () { return setTimeout(function () { return _this.checkTCPServerEstablished(preparedSession, callback); }, 10); });
                break;
        }
    };
    DataStreamServer.prototype.listening = function (preparedSession, callback) {
        this.state = 2 /* LISTENING */;
        var address = this.tcpServer.address();
        if (address && typeof address !== "string") { // address is only typeof string when listening to a pipe or unix socket
            this.tcpPort = address.port;
            preparedSession.port = address.port;
            debug("TCP server is now listening for new data stream connections on port %s", address.port);
            callback();
        }
    };
    DataStreamServer.prototype.onConnection = function (socket) {
        debug("[%s] New DataStream connection was established", socket.remoteAddress);
        var connection = new DataStreamConnection(socket);
        connection.on("identification" /* IDENTIFICATION */, this.handleSessionIdentification.bind(this, connection));
        connection.on("handle-message-globally" /* HANDLE_MESSAGE_GLOBALLY */, this.handleMessageGlobally.bind(this, connection));
        connection.on("closed" /* CLOSED */, this.connectionClosed.bind(this, connection));
        this.connections.push(connection);
        this.emit("connection-opened" /* CONNECTION_OPENED */, connection);
    };
    DataStreamServer.prototype.handleSessionIdentification = function (connection, firstFrame, callback) {
        var identifiedSession = undefined;
        for (var i = 0; i < this.preparedSessions.length; i++) {
            var preparedSession = this.preparedSessions[i];
            // if we successfully decrypt the first frame with this key we know to which session this connection belongs
            if (connection.decryptHDSFrame(firstFrame, preparedSession.controllerToAccessoryEncryptionKey)) {
                identifiedSession = preparedSession;
                break;
            }
        }
        callback(identifiedSession);
        if (identifiedSession) {
            debug("[%s] Connection was successfully identified (linked with sessionId: %s)", connection.remoteAddress, identifiedSession.connection.sessionID);
            var index = this.preparedSessions.indexOf(identifiedSession);
            if (index >= 0) {
                this.preparedSessions.splice(index, 1);
            }
            clearTimeout(identifiedSession.connectTimeout);
            identifiedSession.connectTimeout = undefined;
            // we have currently no experience with data stream connections, maybe it would be good to index active connections
            // by their hap sessionId in order to clear out old but still open connections when the controller opens a new one
            // on the other hand the keepAlive should handle that also :thinking:
        }
        else { // we looped through all session and didn't find anything
            debug("[%s] Could not identify connection. Terminating.", connection.remoteAddress);
            connection.close(); // disconnecting since first message was not a valid hello
        }
    };
    DataStreamServer.prototype.handleMessageGlobally = function (connection, message) {
        var _a;
        assert_1.default.notStrictEqual(message.type, 3 /* RESPONSE */); // responses can't physically get here
        var separator = "";
        var args = [];
        if (message.type === 1 /* EVENT */) {
            separator = "-e-";
        }
        else if (message.type === 2 /* REQUEST */) {
            separator = "-r-";
            args.push(message.id);
        }
        args.push(message.message);
        var hadListeners;
        try {
            hadListeners = (_a = this.internalEventEmitter).emit.apply(_a, tslib_1.__spread([message.protocol + separator + message.topic, connection], args));
        }
        catch (error) {
            hadListeners = true;
            debug("[%s] Error occurred while dispatching handler for HDS message: %o", connection.remoteAddress, message);
            debug(error.stack);
        }
        if (!hadListeners) {
            debug("[%s] WARNING no handler was found for message: %o", connection.remoteAddress, message);
        }
    };
    DataStreamServer.prototype.connectionClosed = function (connection) {
        debug("[%s] DataStream connection closed", connection.remoteAddress);
        this.connections.splice(this.connections.indexOf(connection), 1);
        this.emit("connection-closed" /* CONNECTION_CLOSED */, connection);
        this.checkCloseable();
        if (this.state === 3 /* CLOSING */ && this.removeListenersOnceClosed && this.connections.length === 0) {
            this.removeAllListeners(); // see this.destroy()
        }
    };
    DataStreamServer.prototype.checkCloseable = function () {
        if (this.connections.length === 0 && this.preparedSessions.length === 0 && this.state < 3 /* CLOSING */) {
            debug("Last connection disconnected. Closing the server now.");
            this.state = 3 /* CLOSING */;
            this.tcpServer.close();
        }
    };
    /**
     * This method will fully stop the DataStreamServer
     */
    DataStreamServer.prototype.destroy = function () {
        var e_1, _a;
        if (this.state > 0 /* UNINITIALIZED */ && this.state < 3 /* CLOSING */) {
            this.tcpServer.close();
            try {
                for (var _b = tslib_1.__values(this.connections), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var connection = _c.value;
                    connection.close();
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        this.state = 3 /* CLOSING */;
        this.removeListenersOnceClosed = true;
        this.internalEventEmitter.removeAllListeners();
    };
    DataStreamServer.prototype.closed = function () {
        this.tcpServer = undefined;
        this.tcpPort = undefined;
        this.state = 0 /* UNINITIALIZED */;
    };
    DataStreamServer.version = "1.0";
    DataStreamServer.accessoryToControllerInfo = Buffer.from("HDS-Read-Encryption-Key");
    DataStreamServer.controllerToAccessoryInfo = Buffer.from("HDS-Write-Encryption-Key");
    return DataStreamServer;
}(events_1.EventEmitter));
exports.DataStreamServer = DataStreamServer;
var DataStreamConnectionEvent;
(function (DataStreamConnectionEvent) {
    /**
     * This event is emitted when the first HDSFrame is received from a new connection.
     * The connection expects the handler to identify the connection by trying to match the decryption keys.
     * If identification was successful the PreparedDataStreamSession should be supplied to the callback,
     * otherwise undefined should be supplied.
     */
    DataStreamConnectionEvent["IDENTIFICATION"] = "identification";
    /**
     * This event is emitted when no handler could be found for the given protocol of a event or request message.
     */
    DataStreamConnectionEvent["HANDLE_MESSAGE_GLOBALLY"] = "handle-message-globally";
    /**
     * This event is emitted when the socket of the connection was closed.
     */
    DataStreamConnectionEvent["CLOSED"] = "closed";
})(DataStreamConnectionEvent = exports.DataStreamConnectionEvent || (exports.DataStreamConnectionEvent = {}));
/**
 * DataStream connection which holds any necessary state information, encryption an decryption keys, manages
 * protocol handlers and also handles sending and receiving of data stream frames.
 */
var DataStreamConnection = /** @class */ (function (_super) {
    tslib_1.__extends(DataStreamConnection, _super);
    function DataStreamConnection(socket) {
        var _a;
        var _this = _super.call(this) || this;
        /*
            Since our DataStream server does only listen on one port and this port is supplied to every client
            which wants to connect, we do not really know which client is who when we receive a tcp connection.
            Thus, we find the correct PreparedDataStreamSession object by testing the encryption keys of all available
            prepared sessions. Then we can reference this hds connection with the correct hap connection and mark it as identified.
         */
        _this.state = 0 /* UNIDENTIFIED */;
        _this.protocolHandlers = {}; // used to store protocolHandlers identified by their protocol name
        _this.responseHandlers = {}; // used to store responseHandlers indexed by their respective requestId
        _this.responseTimers = {}; // used to store response timeouts indexed by their respective requestId
        _this.socket = socket;
        _this.remoteAddress = socket.remoteAddress;
        _this.socket.setNoDelay(true); // disable Nagle algorithm
        _this.socket.setKeepAlive(true);
        _this.accessoryToControllerNonce = 0;
        _this.accessoryToControllerNonceBuffer = Buffer.alloc(8);
        _this.controllerToAccessoryNonce = 0;
        _this.controllerToAccessoryNonceBuffer = Buffer.alloc(8);
        _this.hapConnectionClosedListener = _this.onHAPSessionClosed.bind(_this);
        _this.addProtocolHandler("control" /* CONTROL */, {
            requestHandler: (_a = {},
                _a["hello" /* HELLO */] = _this.handleHello.bind(_this),
                _a)
        });
        _this.helloTimer = setTimeout(function () {
            debug("[%s] Hello message did not arrive in time. Killing the connection", _this.remoteAddress);
            _this.close();
        }, 10000);
        _this.socket.on('data', _this.onSocketData.bind(_this));
        _this.socket.on('error', _this.onSocketError.bind(_this));
        _this.socket.on('close', _this.onSocketClose.bind(_this));
        return _this;
    }
    DataStreamConnection.prototype.handleHello = function (id, _message) {
        // that hello is indeed the _first_ message received is verified in onSocketData(...)
        debug("[%s] Received hello message from client", this.remoteAddress);
        clearTimeout(this.helloTimer);
        this.helloTimer = undefined;
        this.state = 2 /* READY */;
        this.sendResponse("control" /* CONTROL */, "hello" /* HELLO */, id);
    };
    /**
     * Registers a new protocol handler to handle incoming messages.
     * The same protocol cannot be registered multiple times.
     *
     * @param protocol {string | Protocols} - name of the protocol to register the handler for
     * @param protocolHandler {DataStreamProtocolHandler} - object to be registered as protocol handler
     */
    DataStreamConnection.prototype.addProtocolHandler = function (protocol, protocolHandler) {
        if (this.protocolHandlers[protocol] !== undefined) {
            return false;
        }
        this.protocolHandlers[protocol] = protocolHandler;
        return true;
    };
    /**
     * Removes a protocol handler if it is registered.
     *
     * @param protocol {string | Protocols} - name of the protocol to unregister the handler for
     * @param protocolHandler {DataStreamProtocolHandler} - object which will be unregistered
     */
    DataStreamConnection.prototype.removeProtocolHandler = function (protocol, protocolHandler) {
        var current = this.protocolHandlers[protocol];
        if (current === protocolHandler) {
            delete this.protocolHandlers[protocol];
        }
    };
    /**
     * Sends a new event message to the connected client.
     *
     * @param protocol {string | Protocols} - name of the protocol
     * @param event {string | Topics} - name of the event (also referred to as topic. See {Topics} for some known ones)
     * @param message {Record<any, any>} - message dictionary which gets sent along the event
     */
    DataStreamConnection.prototype.sendEvent = function (protocol, event, message) {
        if (message === void 0) { message = {}; }
        var header = {};
        header["protocol"] = protocol;
        header["event"] = event;
        this.sendHDSFrame(header, message);
    };
    /**
     * Sends a new request message to the connected client.
     *
     * @param protocol {string | Protocols} - name of the protocol
     * @param request {string | Topics} - name of the request (also referred to as topic. See {Topics} for some known ones)
     * @param message {Record<any, any>} - message dictionary which gets sent along the request
     * @param callback {ResponseHandler} - handler which gets supplied with an error object if the response didn't
     *                                     arrive in time or the status and the message dictionary from the response
     */
    DataStreamConnection.prototype.sendRequest = function (protocol, request, message, callback) {
        var _this = this;
        if (message === void 0) { message = {}; }
        var requestId;
        do { // generate unused requestId
            // currently writing int64 to data stream is not really supported, so 32-bit int will be the max
            requestId = Math.floor(Math.random() * 4294967295);
        } while (this.responseHandlers[requestId] !== undefined);
        this.responseHandlers[requestId] = callback;
        this.responseTimers[requestId] = setTimeout(function () {
            // we did not receive a response => close socket
            _this.close();
            var handler = _this.responseHandlers[requestId];
            delete _this.responseHandlers[requestId];
            delete _this.responseTimers[requestId];
            // handler should be able to cleanup their stuff
            handler(new Error("timeout"), undefined, {});
        }, 10000); // 10s timer
        var header = {};
        header["protocol"] = protocol;
        header["request"] = request;
        header["id"] = new DataStreamParser_1.Int64(requestId);
        this.sendHDSFrame(header, message);
    };
    /**
     * Send a new response message to a received request message to the client.
     *
     * @param protocol {string | Protocols} - name of the protocol
     * @param response {string | Topics} - name of the response (also referred to as topic. See {Topics} for some known ones)
     * @param id {number} - id from the request, to associate the response to the request
     * @param status {HDSStatus} - status indication if the request was successful. A status of zero indicates success.
     * @param message {Record<any, any>} - message dictionary which gets sent along the response
     */
    DataStreamConnection.prototype.sendResponse = function (protocol, response, id, status, message) {
        if (status === void 0) { status = HDSStatus.SUCCESS; }
        if (message === void 0) { message = {}; }
        var header = {};
        header["protocol"] = protocol;
        header["response"] = response;
        header["id"] = new DataStreamParser_1.Int64(id);
        header["status"] = new DataStreamParser_1.Int64(status);
        this.sendHDSFrame(header, message);
    };
    DataStreamConnection.prototype.onSocketData = function (data) {
        var _this = this;
        if (this.state >= 3 /* CLOSING */) {
            return;
        }
        var frameIndex = 0;
        var frames = this.decodeHDSFrames(data);
        if (frames.length === 0) { // not enough data
            return;
        }
        if (this.state === 0 /* UNIDENTIFIED */) {
            // at the beginning we are only interested in trying to decrypt the first frame in order to test decryption keys
            var firstFrame = frames[frameIndex++];
            this.emit("identification" /* IDENTIFICATION */, firstFrame, function (identifiedSession) {
                if (identifiedSession) {
                    // horray, we found our connection
                    _this.connection = identifiedSession.connection;
                    _this.accessoryToControllerEncryptionKey = identifiedSession.accessoryToControllerEncryptionKey;
                    _this.controllerToAccessoryEncryptionKey = identifiedSession.controllerToAccessoryEncryptionKey;
                    _this.state = 1 /* EXPECTING_HELLO */;
                    // below listener is removed in .close()
                    _this.connection.on("closed" /* CLOSED */, _this.hapConnectionClosedListener); // register close listener
                }
            });
            if (this.state === 0 /* UNIDENTIFIED */) {
                // did not find a prepared connection, server already closed this connection; nothing to do here
                return;
            }
        }
        for (; frameIndex < frames.length; frameIndex++) { // decrypt all remaining frames
            if (!this.decryptHDSFrame(frames[frameIndex])) {
                debug("[%s] HDS frame decryption or authentication failed. Connection will be terminated!", this.remoteAddress);
                this.close();
                return;
            }
        }
        var messages = this.decodePayloads(frames); // decode contents of payload
        if (this.state === 1 /* EXPECTING_HELLO */) {
            var firstMessage = messages[0];
            if (firstMessage.protocol !== "control" /* CONTROL */ || firstMessage.type !== 2 /* REQUEST */ || firstMessage.topic !== "hello" /* HELLO */) {
                // first message is not the expected hello request
                debug("[%s] First message received was not the expected hello message. Instead got: %o", this.remoteAddress, firstMessage);
                this.close();
                return;
            }
        }
        messages.forEach(function (message) {
            if (message.type === 3 /* RESPONSE */) {
                // protocol and topic are currently not tested here; just assumed their are correct;
                // probably they are as the requestId is unique per connection no matter what protocol is used
                var responseHandler = _this.responseHandlers[message.id];
                var responseTimer = _this.responseTimers[message.id];
                if (responseTimer) {
                    clearTimeout(responseTimer);
                    delete _this.responseTimers[message.id];
                }
                if (!responseHandler) {
                    // we got a response to a request we did not send; we ignore it for now, since nobody will be hurt
                    debug("WARNING we received a response to a request we have not sent: %o", message);
                    return;
                }
                try {
                    responseHandler(undefined, message.status, message.message);
                }
                catch (error) {
                    debug("[%s] Error occurred while dispatching response handler for HDS message: %o", _this.remoteAddress, message);
                    debug(error.stack);
                }
                delete _this.responseHandlers[message.id];
            }
            else {
                var handler = _this.protocolHandlers[message.protocol];
                if (handler === undefined) {
                    // send message to the server to check if there are some global handlers for it
                    _this.emit("handle-message-globally" /* HANDLE_MESSAGE_GLOBALLY */, message);
                    return;
                }
                if (message.type === 1 /* EVENT */) {
                    var eventHandler = void 0;
                    if (!handler.eventHandler || !(eventHandler = handler.eventHandler[message.topic])) {
                        debug("[%s] WARNING no event handler was found for message: %o", _this.remoteAddress, message);
                        return;
                    }
                    try {
                        eventHandler(message.message);
                    }
                    catch (error) {
                        debug("[%s] Error occurred while dispatching event handler for HDS message: %o", _this.remoteAddress, message);
                        debug(error.stack);
                    }
                }
                else if (message.type === 2 /* REQUEST */) {
                    var requestHandler = void 0;
                    if (!handler.requestHandler || !(requestHandler = handler.requestHandler[message.topic])) {
                        debug("[%s] WARNING no request handler was found for message: %o", _this.remoteAddress, message);
                        return;
                    }
                    try {
                        requestHandler(message.id, message.message);
                    }
                    catch (error) {
                        debug("[%s] Error occurred while dispatching request handler for HDS message: %o", _this.remoteAddress, message);
                        debug(error.stack);
                    }
                }
                else {
                    debug("[%s] Encountered unknown message type with id %d", _this.remoteAddress, message.type);
                }
            }
        });
    };
    DataStreamConnection.prototype.decodeHDSFrames = function (data) {
        if (this.frameBuffer !== undefined) {
            data = Buffer.concat([this.frameBuffer, data]);
            this.frameBuffer = undefined;
        }
        var totalBufferLength = data.length;
        var frames = [];
        for (var frameBegin = 0; frameBegin < totalBufferLength;) {
            if (frameBegin + 4 > totalBufferLength) {
                // we don't have enough data in the buffer for the next header
                this.frameBuffer = data.slice(frameBegin);
                break;
            }
            var payloadType = data.readUInt8(frameBegin); // type defining structure of payload; 8-bit; currently expected to be 1
            var payloadLength = data.readUIntBE(frameBegin + 1, 3); // read 24-bit big-endian uint length field
            if (payloadLength > DataStreamConnection.MAX_PAYLOAD_LENGTH) {
                debug("[%s] Connection send payload with size bigger than the maximum allow for data stream", this.remoteAddress);
                this.close();
                return [];
            }
            var remainingBufferLength = totalBufferLength - frameBegin - 4; // subtract 4 for payloadType (1-byte) and payloadLength (3-byte)
            // check if the data from this frame is already there (payload + 16-byte authTag)
            if (payloadLength + 16 > remainingBufferLength) {
                // Frame is fragmented, so we wait until we receive more
                this.frameBuffer = data.slice(frameBegin);
                break;
            }
            var payloadBegin = frameBegin + 4;
            var authTagBegin = payloadBegin + payloadLength;
            var header = data.slice(frameBegin, payloadBegin); // header is also authenticated using authTag
            var cipheredPayload = data.slice(payloadBegin, authTagBegin);
            var plaintextPayload = Buffer.alloc(payloadLength);
            var authTag = data.slice(authTagBegin, authTagBegin + 16);
            frameBegin = authTagBegin + 16; // move to next frame
            if (payloadType === 1) {
                var hdsFrame = {
                    header: header,
                    cipheredPayload: cipheredPayload,
                    authTag: authTag,
                };
                frames.push(hdsFrame);
            }
            else {
                debug("[%s] Encountered unknown payload type %d for payload: %s", this.remoteAddress, plaintextPayload.toString('hex'));
            }
        }
        return frames;
    };
    DataStreamConnection.prototype.decryptHDSFrame = function (frame, keyOverwrite) {
        hapCrypto.writeUInt64LE(this.controllerToAccessoryNonce, this.controllerToAccessoryNonceBuffer, 0); // update nonce buffer
        var key = keyOverwrite || this.controllerToAccessoryEncryptionKey;
        try {
            frame.plaintextPayload = hapCrypto.chacha20_poly1305_decryptAndVerify(key, this.controllerToAccessoryNonceBuffer, frame.header, frame.cipheredPayload, frame.authTag);
            this.controllerToAccessoryNonce++; // we had a successful encryption, increment the nonce
            return true;
        }
        catch (error) {
            // frame decryption or authentication failed. Could happen when our guess for a PreparedDataStreamSession is wrong
            return false;
        }
    };
    DataStreamConnection.prototype.decodePayloads = function (frames) {
        var _this = this;
        var messages = [];
        frames.forEach(function (frame) {
            var payload = frame.plaintextPayload;
            if (!payload) {
                throw new Error("Reached illegal state. Encountered HDSFrame with wasn't decrypted yet!");
            }
            var headerLength = payload.readUInt8(0);
            var messageLength = payload.length - headerLength - 1;
            var headerBegin = 1;
            var messageBegin = headerBegin + headerLength;
            var headerPayload = new DataStreamParser_1.DataStreamReader(payload.slice(headerBegin, headerBegin + headerLength));
            var messagePayload = new DataStreamParser_1.DataStreamReader(payload.slice(messageBegin, messageBegin + messageLength));
            var headerDictionary;
            var messageDictionary;
            try {
                headerDictionary = DataStreamParser_1.DataStreamParser.decode(headerPayload);
                headerPayload.finished();
            }
            catch (error) {
                debug("[%s] Failed to decode header payload: %s", _this.remoteAddress, error.message);
                return;
            }
            try {
                messageDictionary = DataStreamParser_1.DataStreamParser.decode(messagePayload);
                messagePayload.finished();
            }
            catch (error) {
                debug("[%s] Failed to decode message payload: %s (header: %o)", _this.remoteAddress, error.message, headerDictionary);
                return;
            }
            var type;
            var protocol = headerDictionary["protocol"];
            var topic;
            var id = undefined;
            var status = undefined;
            if (headerDictionary["event"] !== undefined) {
                type = 1 /* EVENT */;
                topic = headerDictionary["event"];
            }
            else if (headerDictionary["request"] !== undefined) {
                type = 2 /* REQUEST */;
                topic = headerDictionary["request"];
                id = headerDictionary["id"];
            }
            else if (headerDictionary["response"] !== undefined) {
                type = 3 /* RESPONSE */;
                topic = headerDictionary["response"];
                id = headerDictionary["id"];
                status = headerDictionary["status"];
            }
            else {
                debug("[%s] Encountered unknown payload header format: %o (message: %o)", _this.remoteAddress, headerDictionary, messageDictionary);
                return;
            }
            var message = {
                type: type,
                protocol: protocol,
                topic: topic,
                id: id,
                status: status,
                message: messageDictionary,
            };
            messages.push(message);
        });
        return messages;
    };
    DataStreamConnection.prototype.sendHDSFrame = function (header, message) {
        if (this.state >= 3 /* CLOSING */) {
            throw Error("Cannot send message on closing/closed socket!");
        }
        var headerWriter = new DataStreamParser_1.DataStreamWriter();
        var messageWriter = new DataStreamParser_1.DataStreamWriter();
        DataStreamParser_1.DataStreamParser.encode(header, headerWriter);
        DataStreamParser_1.DataStreamParser.encode(message, messageWriter);
        var payloadHeaderBuffer = Buffer.alloc(1);
        payloadHeaderBuffer.writeUInt8(headerWriter.length(), 0);
        var payloadBuffer = Buffer.concat([payloadHeaderBuffer, headerWriter.getData(), messageWriter.getData()]);
        if (payloadBuffer.length > DataStreamConnection.MAX_PAYLOAD_LENGTH) {
            throw new Error("Tried sending payload with length larger than the maximum allowed for data stream");
        }
        var frameTypeBuffer = Buffer.alloc(1);
        frameTypeBuffer.writeUInt8(1, 0);
        var frameLengthBuffer = Buffer.alloc(4);
        frameLengthBuffer.writeUInt32BE(payloadBuffer.length, 0);
        frameLengthBuffer = frameLengthBuffer.slice(1, 4); // a bit hacky but the only real way to write 24-bit int in node
        var frameHeader = Buffer.concat([frameTypeBuffer, frameLengthBuffer]);
        hapCrypto.writeUInt64LE(this.accessoryToControllerNonce++, this.accessoryToControllerNonceBuffer);
        var encrypted = hapCrypto.chacha20_poly1305_encryptAndSeal(this.accessoryToControllerEncryptionKey, this.accessoryToControllerNonceBuffer, frameHeader, payloadBuffer);
        this.socket.write(Buffer.concat([frameHeader, encrypted.ciphertext, encrypted.authTag]));
        /* Useful for debugging outgoing packages and detecting encoding errors
        console.log("SENT DATA: " + payloadBuffer.toString("hex"));
        const frame: HDSFrame = {
            header: frameHeader,
            plaintextPayload: payloadBuffer,
            cipheredPayload: cipheredPayload,
            authTag: authTag,
        };
        const sentMessage = this.decodePayloads([frame])[0];
        console.log("Sent message: " + JSON.stringify(sentMessage, null, 4));
        //*/
    };
    DataStreamConnection.prototype.close = function () {
        var _a;
        if (this.state >= 3 /* CLOSING */) {
            return; // connection is already closing/closed
        }
        (_a = this.connection) === null || _a === void 0 ? void 0 : _a.removeListener("closed" /* CLOSED */, this.hapConnectionClosedListener);
        this.state = 3 /* CLOSING */;
        this.socket.end();
    };
    DataStreamConnection.prototype.onHAPSessionClosed = function () {
        // If the hap connection is closed it is probably also a good idea to close the data stream connection
        debug("[%s] HAP connection disconnected. Also closing DataStream connection now.", this.remoteAddress);
        this.close();
    };
    DataStreamConnection.prototype.onSocketError = function (error) {
        debug("[%s] Encountered socket error: %s", this.remoteAddress, error.message);
        // onSocketClose will be called next
    };
    DataStreamConnection.prototype.onSocketClose = function () {
        // this instance is now considered completely dead
        this.state = 4 /* CLOSED */;
        this.emit("closed" /* CLOSED */);
        this.removeAllListeners();
    };
    DataStreamConnection.MAX_PAYLOAD_LENGTH = 1048575;
    return DataStreamConnection;
}(events_1.EventEmitter));
exports.DataStreamConnection = DataStreamConnection;
//# sourceMappingURL=DataStreamServer.js.map

/***/ }),

/***/ 7580:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4290);
tslib_1.__exportStar(__nccwpck_require__(9278), exports);
tslib_1.__exportStar(__nccwpck_require__(3989), exports);
tslib_1.__exportStar(__nccwpck_require__(237), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 1969:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

// THIS FILE IS AUTO-GENERATED - DO NOT MODIFY
// V=860
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CurrentTime = exports.CurrentTiltAngle = exports.CurrentTemperature = exports.CurrentSlatState = exports.CurrentRelativeHumidity = exports.CurrentPosition = exports.CurrentMediaState = exports.CurrentHumidifierDehumidifierState = exports.CurrentHorizontalTiltAngle = exports.CurrentHeatingCoolingState = exports.CurrentHeaterCoolerState = exports.CurrentFanState = exports.CurrentDoorState = exports.CurrentAmbientLightLevel = exports.CurrentAirPurifierState = exports.CoolingThresholdTemperature = exports.ContactSensorState = exports.ConfiguredName = exports.ConfigureBridgedAccessoryStatus = exports.ConfigureBridgedAccessory = exports.ColorTemperature = exports.ClosedCaptions = exports.ChargingState = exports.CharacteristicValueTransitionControl = exports.CharacteristicValueActiveTransitionCount = exports.CCASignalDetectThreshold = exports.CCAEnergyDetectThreshold = exports.Category = exports.CarbonMonoxidePeakLevel = exports.CarbonMonoxideLevel = exports.CarbonMonoxideDetected = exports.CarbonDioxidePeakLevel = exports.CarbonDioxideLevel = exports.CarbonDioxideDetected = exports.CameraOperatingModeIndicator = exports.ButtonEvent = exports.Brightness = exports.BatteryLevel = exports.AudioFeedback = exports.AppMatchingIdentifier = exports.AirQuality = exports.AirParticulateSize = exports.AirParticulateDensity = exports.AdministratorOnlyAccess = exports.ActivityInterval = exports.ActiveIdentifier = exports.Active = exports.AccessoryIdentifier = exports.AccessoryFlags = exports.AccessControlLevel = void 0;
exports.Model = exports.MaximumTransmitPower = exports.Manufacturer = exports.ManuallyDisabled = exports.ManagedNetworkEnable = exports.MACTransmissionCounters = exports.MACRetransmissionMaximum = exports.Logs = exports.LockTargetState = exports.LockPhysicalControls = exports.LockManagementAutoSecurityTimeout = exports.LockLastKnownAction = exports.LockCurrentState = exports.LockControlPoint = exports.ListPairings = exports.LinkQuality = exports.LeakDetected = exports.IsConfigured = exports.InUse = exports.InputSourceType = exports.InputDeviceType = exports.ImageRotation = exports.ImageMirroring = exports.Identify = exports.Identifier = exports.Hue = exports.HomeKitCameraActive = exports.HoldPosition = exports.HeatingThresholdTemperature = exports.HeartBeat = exports.HardwareRevision = exports.FirmwareUpdateStatus = exports.FirmwareUpdateReadiness = exports.FirmwareRevision = exports.FilterLifeLevel = exports.FilterChangeIndication = exports.EventTransmissionCounters = exports.EventSnapshotsActive = exports.EventRetransmissionMaximum = exports.DisplayOrder = exports.DiscoveredBridgedAccessories = exports.DiscoverBridgedAccessories = exports.DigitalZoom = exports.DiagonalFieldOfView = exports.DayoftheWeek = exports.DataStreamHAPTransportInterrupt = exports.DataStreamHAPTransport = exports.CurrentVisibilityState = exports.CurrentVerticalTiltAngle = exports.CurrentTransport = void 0;
exports.SelectedAudioStreamConfiguration = exports.SecuritySystemTargetState = exports.SecuritySystemCurrentState = exports.SecuritySystemAlarmType = exports.Saturation = exports.RouterStatus = exports.RotationSpeed = exports.RotationDirection = exports.ResetFilterIndication = exports.RemoteKey = exports.RemainingDuration = exports.RelayState = exports.RelayEnabled = exports.RelayControlPoint = exports.RelativeHumidityHumidifierThreshold = exports.RelativeHumidityDehumidifierThreshold = exports.RecordingAudioActive = exports.ReceiverSensitivity = exports.ReceivedSignalStrengthIndication = exports.Reachable = exports.ProgramMode = exports.ProgrammableSwitchOutputState = exports.ProgrammableSwitchEvent = exports.ProductData = exports.PowerModeSelection = exports.PositionState = exports.PM2_5Density = exports.PM10Density = exports.Ping = exports.PictureMode = exports.PeriodicSnapshotsActive = exports.PasswordSetting = exports.PairVerify = exports.PairSetup = exports.PairingFeatures = exports.OzoneDensity = exports.OutletInUse = exports.OpticalZoom = exports.OperatingStateResponse = exports.On = exports.OccupancyDetected = exports.ObstructionDetected = exports.NitrogenDioxideDensity = exports.NightVision = exports.NetworkClientStatusControl = exports.NetworkClientProfileControl = exports.NetworkAccessViolationControl = exports.Name = exports.Mute = exports.MotionDetected = void 0;
exports.TargetRelativeHumidity = exports.TargetPosition = exports.TargetMediaState = exports.TargetHumidifierDehumidifierState = exports.TargetHorizontalTiltAngle = exports.TargetHeatingCoolingState = exports.TargetHeaterCoolerState = exports.TargetFanState = exports.TargetDoorState = exports.TargetControlSupportedConfiguration = exports.TargetControlList = exports.TargetAirQuality = exports.TargetAirPurifierState = exports.SwingMode = exports.SupportedVideoStreamConfiguration = exports.SupportedVideoRecordingConfiguration = exports.SupportedTransferTransportConfiguration = exports.SupportedRTPConfiguration = exports.SupportedRouterConfiguration = exports.SupportedFirmwareUpdateConfiguration = exports.SupportedDiagnosticsSnapshot = exports.SupportedDataStreamTransportConfiguration = exports.SupportedCharacteristicValueTransitionConfiguration = exports.SupportedCameraRecordingConfiguration = exports.SupportedAudioStreamConfiguration = exports.SupportedAudioRecordingConfiguration = exports.SulphurDioxideDensity = exports.StreamingStatus = exports.StatusTampered = exports.StatusLowBattery = exports.StatusJammed = exports.StatusFault = exports.StatusActive = exports.StagedFirmwareVersion = exports.SoftwareRevision = exports.SmokeDetected = exports.SleepInterval = exports.SleepDiscoveryMode = exports.SlatType = exports.SiriInputType = exports.SignalToNoiseRatio = exports.SetupTransferTransport = exports.SetupEndpoints = exports.SetupDataStreamTransport = exports.SetDuration = exports.ServiceLabelNamespace = exports.ServiceLabelIndex = exports.SerialNumber = exports.SelectedRTPStreamConfiguration = exports.SelectedCameraRecordingConfiguration = void 0;
exports.WiFiSatelliteStatus = exports.WiFiConfigurationControl = exports.WiFiCapabilities = exports.WaterLevel = exports.WANStatusList = exports.WANConfigurationList = exports.WakeConfiguration = exports.VolumeSelector = exports.VolumeControlType = exports.Volume = exports.VOCDensity = exports.VideoAnalysisActive = exports.Version = exports.ValveType = exports.TunneledAccessoryStateNumber = exports.TunneledAccessoryConnected = exports.TunneledAccessoryAdvertising = exports.TunnelConnectionTimeout = exports.TransmitPower = exports.TimeUpdate = exports.ThreadStatus = exports.ThreadOpenThreadVersion = exports.ThreadNodeCapabilities = exports.ThreadControlPoint = exports.ThirdPartyCameraActive = exports.TemperatureDisplayUnits = exports.TargetVisibilityState = exports.TargetVerticalTiltAngle = exports.TargetTiltAngle = exports.TargetTemperature = exports.TargetSlatState = void 0;
var tslib_1 = __nccwpck_require__(4290);
var Characteristic_1 = __nccwpck_require__(3859);
/**
 * Characteristic "Access Control Level"
 */
var AccessControlLevel = /** @class */ (function (_super) {
    tslib_1.__extends(AccessControlLevel, _super);
    function AccessControlLevel() {
        var _this = _super.call(this, "Access Control Level", AccessControlLevel.UUID, {
            format: "uint16" /* UINT16 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 2,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    AccessControlLevel.UUID = "000000E5-0000-1000-8000-0026BB765291";
    return AccessControlLevel;
}(Characteristic_1.Characteristic));
exports.AccessControlLevel = AccessControlLevel;
Characteristic_1.Characteristic.AccessControlLevel = AccessControlLevel;
/**
 * Characteristic "Accessory Flags"
 */
var AccessoryFlags = /** @class */ (function (_super) {
    tslib_1.__extends(AccessoryFlags, _super);
    function AccessoryFlags() {
        var _this = _super.call(this, "Accessory Flags", AccessoryFlags.UUID, {
            format: "uint32" /* UINT32 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    AccessoryFlags.UUID = "000000A6-0000-1000-8000-0026BB765291";
    AccessoryFlags.REQUIRES_ADDITIONAL_SETUP_BIT_MASK = 1;
    return AccessoryFlags;
}(Characteristic_1.Characteristic));
exports.AccessoryFlags = AccessoryFlags;
Characteristic_1.Characteristic.AccessoryFlags = AccessoryFlags;
/**
 * Characteristic "Accessory Identifier"
 */
var AccessoryIdentifier = /** @class */ (function (_super) {
    tslib_1.__extends(AccessoryIdentifier, _super);
    function AccessoryIdentifier() {
        var _this = _super.call(this, "Accessory Identifier", AccessoryIdentifier.UUID, {
            format: "string" /* STRING */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    AccessoryIdentifier.UUID = "00000057-0000-1000-8000-0026BB765291";
    return AccessoryIdentifier;
}(Characteristic_1.Characteristic));
exports.AccessoryIdentifier = AccessoryIdentifier;
Characteristic_1.Characteristic.AccessoryIdentifier = AccessoryIdentifier;
/**
 * Characteristic "Active"
 */
var Active = /** @class */ (function (_super) {
    tslib_1.__extends(Active, _super);
    function Active() {
        var _this = _super.call(this, "Active", Active.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    Active.UUID = "000000B0-0000-1000-8000-0026BB765291";
    Active.INACTIVE = 0;
    Active.ACTIVE = 1;
    return Active;
}(Characteristic_1.Characteristic));
exports.Active = Active;
Characteristic_1.Characteristic.Active = Active;
/**
 * Characteristic "Active Identifier"
 */
var ActiveIdentifier = /** @class */ (function (_super) {
    tslib_1.__extends(ActiveIdentifier, _super);
    function ActiveIdentifier() {
        var _this = _super.call(this, "Active Identifier", ActiveIdentifier.UUID, {
            format: "uint32" /* UINT32 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ActiveIdentifier.UUID = "000000E7-0000-1000-8000-0026BB765291";
    return ActiveIdentifier;
}(Characteristic_1.Characteristic));
exports.ActiveIdentifier = ActiveIdentifier;
Characteristic_1.Characteristic.ActiveIdentifier = ActiveIdentifier;
/**
 * Characteristic "Activity Interval"
 * @since iOS 14
 */
var ActivityInterval = /** @class */ (function (_super) {
    tslib_1.__extends(ActivityInterval, _super);
    function ActivityInterval() {
        var _this = _super.call(this, "Activity Interval", ActivityInterval.UUID, {
            format: "uint32" /* UINT32 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ActivityInterval.UUID = "0000023B-0000-1000-8000-0026BB765291";
    return ActivityInterval;
}(Characteristic_1.Characteristic));
exports.ActivityInterval = ActivityInterval;
Characteristic_1.Characteristic.ActivityInterval = ActivityInterval;
/**
 * Characteristic "Administrator Only Access"
 */
var AdministratorOnlyAccess = /** @class */ (function (_super) {
    tslib_1.__extends(AdministratorOnlyAccess, _super);
    function AdministratorOnlyAccess() {
        var _this = _super.call(this, "Administrator Only Access", AdministratorOnlyAccess.UUID, {
            format: "bool" /* BOOL */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    AdministratorOnlyAccess.UUID = "00000001-0000-1000-8000-0026BB765291";
    return AdministratorOnlyAccess;
}(Characteristic_1.Characteristic));
exports.AdministratorOnlyAccess = AdministratorOnlyAccess;
Characteristic_1.Characteristic.AdministratorOnlyAccess = AdministratorOnlyAccess;
/**
 * Characteristic "Air Particulate Density"
 */
var AirParticulateDensity = /** @class */ (function (_super) {
    tslib_1.__extends(AirParticulateDensity, _super);
    function AirParticulateDensity() {
        var _this = _super.call(this, "Air Particulate Density", AirParticulateDensity.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 1000,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    AirParticulateDensity.UUID = "00000064-0000-1000-8000-0026BB765291";
    return AirParticulateDensity;
}(Characteristic_1.Characteristic));
exports.AirParticulateDensity = AirParticulateDensity;
Characteristic_1.Characteristic.AirParticulateDensity = AirParticulateDensity;
/**
 * Characteristic "Air Particulate Size"
 */
var AirParticulateSize = /** @class */ (function (_super) {
    tslib_1.__extends(AirParticulateSize, _super);
    function AirParticulateSize() {
        var _this = _super.call(this, "Air Particulate Size", AirParticulateSize.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    AirParticulateSize.UUID = "00000065-0000-1000-8000-0026BB765291";
    AirParticulateSize._2_5_M = 0;
    AirParticulateSize._10_M = 1;
    return AirParticulateSize;
}(Characteristic_1.Characteristic));
exports.AirParticulateSize = AirParticulateSize;
Characteristic_1.Characteristic.AirParticulateSize = AirParticulateSize;
/**
 * Characteristic "Air Quality"
 */
var AirQuality = /** @class */ (function (_super) {
    tslib_1.__extends(AirQuality, _super);
    function AirQuality() {
        var _this = _super.call(this, "Air Quality", AirQuality.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 5,
            minStep: 1,
            validValues: [0, 1, 2, 3, 4, 5],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    AirQuality.UUID = "00000095-0000-1000-8000-0026BB765291";
    AirQuality.UNKNOWN = 0;
    AirQuality.EXCELLENT = 1;
    AirQuality.GOOD = 2;
    AirQuality.FAIR = 3;
    AirQuality.INFERIOR = 4;
    AirQuality.POOR = 5;
    return AirQuality;
}(Characteristic_1.Characteristic));
exports.AirQuality = AirQuality;
Characteristic_1.Characteristic.AirQuality = AirQuality;
/**
 * Characteristic "App Matching Identifier"
 */
var AppMatchingIdentifier = /** @class */ (function (_super) {
    tslib_1.__extends(AppMatchingIdentifier, _super);
    function AppMatchingIdentifier() {
        var _this = _super.call(this, "App Matching Identifier", AppMatchingIdentifier.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    AppMatchingIdentifier.UUID = "000000A4-0000-1000-8000-0026BB765291";
    return AppMatchingIdentifier;
}(Characteristic_1.Characteristic));
exports.AppMatchingIdentifier = AppMatchingIdentifier;
Characteristic_1.Characteristic.AppMatchingIdentifier = AppMatchingIdentifier;
/**
 * Characteristic "Audio Feedback"
 */
var AudioFeedback = /** @class */ (function (_super) {
    tslib_1.__extends(AudioFeedback, _super);
    function AudioFeedback() {
        var _this = _super.call(this, "Audio Feedback", AudioFeedback.UUID, {
            format: "bool" /* BOOL */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    AudioFeedback.UUID = "00000005-0000-1000-8000-0026BB765291";
    return AudioFeedback;
}(Characteristic_1.Characteristic));
exports.AudioFeedback = AudioFeedback;
Characteristic_1.Characteristic.AudioFeedback = AudioFeedback;
/**
 * Characteristic "Battery Level"
 */
var BatteryLevel = /** @class */ (function (_super) {
    tslib_1.__extends(BatteryLevel, _super);
    function BatteryLevel() {
        var _this = _super.call(this, "Battery Level", BatteryLevel.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            unit: "percentage" /* PERCENTAGE */,
            minValue: 0,
            maxValue: 100,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    BatteryLevel.UUID = "00000068-0000-1000-8000-0026BB765291";
    return BatteryLevel;
}(Characteristic_1.Characteristic));
exports.BatteryLevel = BatteryLevel;
Characteristic_1.Characteristic.BatteryLevel = BatteryLevel;
/**
 * Characteristic "Brightness"
 */
var Brightness = /** @class */ (function (_super) {
    tslib_1.__extends(Brightness, _super);
    function Brightness() {
        var _this = _super.call(this, "Brightness", Brightness.UUID, {
            format: "int" /* INT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            unit: "percentage" /* PERCENTAGE */,
            minValue: 0,
            maxValue: 100,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    Brightness.UUID = "00000008-0000-1000-8000-0026BB765291";
    return Brightness;
}(Characteristic_1.Characteristic));
exports.Brightness = Brightness;
Characteristic_1.Characteristic.Brightness = Brightness;
/**
 * Characteristic "Button Event"
 */
var ButtonEvent = /** @class */ (function (_super) {
    tslib_1.__extends(ButtonEvent, _super);
    function ButtonEvent() {
        var _this = _super.call(this, "Button Event", ButtonEvent.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            adminOnlyAccess: [2 /* NOTIFY */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ButtonEvent.UUID = "00000126-0000-1000-8000-0026BB765291";
    return ButtonEvent;
}(Characteristic_1.Characteristic));
exports.ButtonEvent = ButtonEvent;
Characteristic_1.Characteristic.ButtonEvent = ButtonEvent;
/**
 * Characteristic "Camera Operating Mode Indicator"
 */
var CameraOperatingModeIndicator = /** @class */ (function (_super) {
    tslib_1.__extends(CameraOperatingModeIndicator, _super);
    function CameraOperatingModeIndicator() {
        var _this = _super.call(this, "Camera Operating Mode Indicator", CameraOperatingModeIndicator.UUID, {
            format: "bool" /* BOOL */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */, "tw" /* TIMED_WRITE */],
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CameraOperatingModeIndicator.UUID = "0000021D-0000-1000-8000-0026BB765291";
    CameraOperatingModeIndicator.DISABLE = 0;
    CameraOperatingModeIndicator.ENABLE = 1;
    return CameraOperatingModeIndicator;
}(Characteristic_1.Characteristic));
exports.CameraOperatingModeIndicator = CameraOperatingModeIndicator;
Characteristic_1.Characteristic.CameraOperatingModeIndicator = CameraOperatingModeIndicator;
/**
 * Characteristic "Carbon Dioxide Detected"
 */
var CarbonDioxideDetected = /** @class */ (function (_super) {
    tslib_1.__extends(CarbonDioxideDetected, _super);
    function CarbonDioxideDetected() {
        var _this = _super.call(this, "Carbon Dioxide Detected", CarbonDioxideDetected.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CarbonDioxideDetected.UUID = "00000092-0000-1000-8000-0026BB765291";
    CarbonDioxideDetected.CO2_LEVELS_NORMAL = 0;
    CarbonDioxideDetected.CO2_LEVELS_ABNORMAL = 1;
    return CarbonDioxideDetected;
}(Characteristic_1.Characteristic));
exports.CarbonDioxideDetected = CarbonDioxideDetected;
Characteristic_1.Characteristic.CarbonDioxideDetected = CarbonDioxideDetected;
/**
 * Characteristic "Carbon Dioxide Level"
 */
var CarbonDioxideLevel = /** @class */ (function (_super) {
    tslib_1.__extends(CarbonDioxideLevel, _super);
    function CarbonDioxideLevel() {
        var _this = _super.call(this, "Carbon Dioxide Level", CarbonDioxideLevel.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 100000,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CarbonDioxideLevel.UUID = "00000093-0000-1000-8000-0026BB765291";
    return CarbonDioxideLevel;
}(Characteristic_1.Characteristic));
exports.CarbonDioxideLevel = CarbonDioxideLevel;
Characteristic_1.Characteristic.CarbonDioxideLevel = CarbonDioxideLevel;
/**
 * Characteristic "Carbon Dioxide Peak Level"
 */
var CarbonDioxidePeakLevel = /** @class */ (function (_super) {
    tslib_1.__extends(CarbonDioxidePeakLevel, _super);
    function CarbonDioxidePeakLevel() {
        var _this = _super.call(this, "Carbon Dioxide Peak Level", CarbonDioxidePeakLevel.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 100000,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CarbonDioxidePeakLevel.UUID = "00000094-0000-1000-8000-0026BB765291";
    return CarbonDioxidePeakLevel;
}(Characteristic_1.Characteristic));
exports.CarbonDioxidePeakLevel = CarbonDioxidePeakLevel;
Characteristic_1.Characteristic.CarbonDioxidePeakLevel = CarbonDioxidePeakLevel;
/**
 * Characteristic "Carbon Monoxide Detected"
 */
var CarbonMonoxideDetected = /** @class */ (function (_super) {
    tslib_1.__extends(CarbonMonoxideDetected, _super);
    function CarbonMonoxideDetected() {
        var _this = _super.call(this, "Carbon Monoxide Detected", CarbonMonoxideDetected.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CarbonMonoxideDetected.UUID = "00000069-0000-1000-8000-0026BB765291";
    CarbonMonoxideDetected.CO_LEVELS_NORMAL = 0;
    CarbonMonoxideDetected.CO_LEVELS_ABNORMAL = 1;
    return CarbonMonoxideDetected;
}(Characteristic_1.Characteristic));
exports.CarbonMonoxideDetected = CarbonMonoxideDetected;
Characteristic_1.Characteristic.CarbonMonoxideDetected = CarbonMonoxideDetected;
/**
 * Characteristic "Carbon Monoxide Level"
 */
var CarbonMonoxideLevel = /** @class */ (function (_super) {
    tslib_1.__extends(CarbonMonoxideLevel, _super);
    function CarbonMonoxideLevel() {
        var _this = _super.call(this, "Carbon Monoxide Level", CarbonMonoxideLevel.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 100,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CarbonMonoxideLevel.UUID = "00000090-0000-1000-8000-0026BB765291";
    return CarbonMonoxideLevel;
}(Characteristic_1.Characteristic));
exports.CarbonMonoxideLevel = CarbonMonoxideLevel;
Characteristic_1.Characteristic.CarbonMonoxideLevel = CarbonMonoxideLevel;
/**
 * Characteristic "Carbon Monoxide Peak Level"
 */
var CarbonMonoxidePeakLevel = /** @class */ (function (_super) {
    tslib_1.__extends(CarbonMonoxidePeakLevel, _super);
    function CarbonMonoxidePeakLevel() {
        var _this = _super.call(this, "Carbon Monoxide Peak Level", CarbonMonoxidePeakLevel.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 100,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CarbonMonoxidePeakLevel.UUID = "00000091-0000-1000-8000-0026BB765291";
    return CarbonMonoxidePeakLevel;
}(Characteristic_1.Characteristic));
exports.CarbonMonoxidePeakLevel = CarbonMonoxidePeakLevel;
Characteristic_1.Characteristic.CarbonMonoxidePeakLevel = CarbonMonoxidePeakLevel;
/**
 * Characteristic "Category"
 * @deprecated Removed and not used anymore
 */
var Category = /** @class */ (function (_super) {
    tslib_1.__extends(Category, _super);
    function Category() {
        var _this = _super.call(this, "Category", Category.UUID, {
            format: "uint16" /* UINT16 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 1,
            maxValue: 16,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    Category.UUID = "000000A3-0000-1000-8000-0026BB765291";
    return Category;
}(Characteristic_1.Characteristic));
exports.Category = Category;
// noinspection JSDeprecatedSymbols
Characteristic_1.Characteristic.Category = Category;
/**
 * Characteristic "CCA Energy Detect Threshold"
 * @since iOS 14
 */
var CCAEnergyDetectThreshold = /** @class */ (function (_super) {
    tslib_1.__extends(CCAEnergyDetectThreshold, _super);
    function CCAEnergyDetectThreshold() {
        var _this = _super.call(this, "CCA Energy Detect Threshold", CCAEnergyDetectThreshold.UUID, {
            format: "int" /* INT */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CCAEnergyDetectThreshold.UUID = "00000246-0000-1000-8000-0026BB765291";
    return CCAEnergyDetectThreshold;
}(Characteristic_1.Characteristic));
exports.CCAEnergyDetectThreshold = CCAEnergyDetectThreshold;
Characteristic_1.Characteristic.CCAEnergyDetectThreshold = CCAEnergyDetectThreshold;
/**
 * Characteristic "CCA Signal Detect Threshold"
 * @since iOS 14
 */
var CCASignalDetectThreshold = /** @class */ (function (_super) {
    tslib_1.__extends(CCASignalDetectThreshold, _super);
    function CCASignalDetectThreshold() {
        var _this = _super.call(this, "CCA Signal Detect Threshold", CCASignalDetectThreshold.UUID, {
            format: "int" /* INT */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CCASignalDetectThreshold.UUID = "00000245-0000-1000-8000-0026BB765291";
    return CCASignalDetectThreshold;
}(Characteristic_1.Characteristic));
exports.CCASignalDetectThreshold = CCASignalDetectThreshold;
Characteristic_1.Characteristic.CCASignalDetectThreshold = CCASignalDetectThreshold;
/**
 * Characteristic "Characteristic Value Active Transition Count"
 * @since iOS 14
 */
var CharacteristicValueActiveTransitionCount = /** @class */ (function (_super) {
    tslib_1.__extends(CharacteristicValueActiveTransitionCount, _super);
    function CharacteristicValueActiveTransitionCount() {
        var _this = _super.call(this, "Characteristic Value Active Transition Count", CharacteristicValueActiveTransitionCount.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CharacteristicValueActiveTransitionCount.UUID = "0000024B-0000-1000-8000-0026BB765291";
    return CharacteristicValueActiveTransitionCount;
}(Characteristic_1.Characteristic));
exports.CharacteristicValueActiveTransitionCount = CharacteristicValueActiveTransitionCount;
Characteristic_1.Characteristic.CharacteristicValueActiveTransitionCount = CharacteristicValueActiveTransitionCount;
/**
 * Characteristic "Characteristic Value Transition Control"
 * @since iOS 14
 */
var CharacteristicValueTransitionControl = /** @class */ (function (_super) {
    tslib_1.__extends(CharacteristicValueTransitionControl, _super);
    function CharacteristicValueTransitionControl() {
        var _this = _super.call(this, "Characteristic Value Transition Control", CharacteristicValueTransitionControl.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */, "wr" /* WRITE_RESPONSE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CharacteristicValueTransitionControl.UUID = "00000143-0000-1000-8000-0026BB765291";
    return CharacteristicValueTransitionControl;
}(Characteristic_1.Characteristic));
exports.CharacteristicValueTransitionControl = CharacteristicValueTransitionControl;
Characteristic_1.Characteristic.CharacteristicValueTransitionControl = CharacteristicValueTransitionControl;
/**
 * Characteristic "Charging State"
 */
var ChargingState = /** @class */ (function (_super) {
    tslib_1.__extends(ChargingState, _super);
    function ChargingState() {
        var _this = _super.call(this, "Charging State", ChargingState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 2,
            minStep: 1,
            validValues: [0, 1, 2],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ChargingState.UUID = "0000008F-0000-1000-8000-0026BB765291";
    ChargingState.NOT_CHARGING = 0;
    ChargingState.CHARGING = 1;
    ChargingState.NOT_CHARGEABLE = 2;
    return ChargingState;
}(Characteristic_1.Characteristic));
exports.ChargingState = ChargingState;
Characteristic_1.Characteristic.ChargingState = ChargingState;
/**
 * Characteristic "Closed Captions"
 */
var ClosedCaptions = /** @class */ (function (_super) {
    tslib_1.__extends(ClosedCaptions, _super);
    function ClosedCaptions() {
        var _this = _super.call(this, "Closed Captions", ClosedCaptions.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ClosedCaptions.UUID = "000000DD-0000-1000-8000-0026BB765291";
    ClosedCaptions.DISABLED = 0;
    ClosedCaptions.ENABLED = 1;
    return ClosedCaptions;
}(Characteristic_1.Characteristic));
exports.ClosedCaptions = ClosedCaptions;
Characteristic_1.Characteristic.ClosedCaptions = ClosedCaptions;
/**
 * Characteristic "Color Temperature"
 */
var ColorTemperature = /** @class */ (function (_super) {
    tslib_1.__extends(ColorTemperature, _super);
    function ColorTemperature() {
        var _this = _super.call(this, "Color Temperature", ColorTemperature.UUID, {
            format: "int" /* INT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minValue: 140,
            maxValue: 500,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ColorTemperature.UUID = "000000CE-0000-1000-8000-0026BB765291";
    return ColorTemperature;
}(Characteristic_1.Characteristic));
exports.ColorTemperature = ColorTemperature;
Characteristic_1.Characteristic.ColorTemperature = ColorTemperature;
/**
 * Characteristic "Configure Bridged Accessory"
 * @deprecated Removed and not used anymore
 */
var ConfigureBridgedAccessory = /** @class */ (function (_super) {
    tslib_1.__extends(ConfigureBridgedAccessory, _super);
    function ConfigureBridgedAccessory() {
        var _this = _super.call(this, "Configure Bridged Accessory", ConfigureBridgedAccessory.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ConfigureBridgedAccessory.UUID = "000000A0-0000-1000-8000-0026BB765291";
    return ConfigureBridgedAccessory;
}(Characteristic_1.Characteristic));
exports.ConfigureBridgedAccessory = ConfigureBridgedAccessory;
// noinspection JSDeprecatedSymbols
Characteristic_1.Characteristic.ConfigureBridgedAccessory = ConfigureBridgedAccessory;
/**
 * Characteristic "Configure Bridged Accessory Status"
 * @deprecated Removed and not used anymore
 */
var ConfigureBridgedAccessoryStatus = /** @class */ (function (_super) {
    tslib_1.__extends(ConfigureBridgedAccessoryStatus, _super);
    function ConfigureBridgedAccessoryStatus() {
        var _this = _super.call(this, "Configure Bridged Accessory Status", ConfigureBridgedAccessoryStatus.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ConfigureBridgedAccessoryStatus.UUID = "0000009D-0000-1000-8000-0026BB765291";
    return ConfigureBridgedAccessoryStatus;
}(Characteristic_1.Characteristic));
exports.ConfigureBridgedAccessoryStatus = ConfigureBridgedAccessoryStatus;
// noinspection JSDeprecatedSymbols
Characteristic_1.Characteristic.ConfigureBridgedAccessoryStatus = ConfigureBridgedAccessoryStatus;
/**
 * Characteristic "Configured Name"
 */
var ConfiguredName = /** @class */ (function (_super) {
    tslib_1.__extends(ConfiguredName, _super);
    function ConfiguredName() {
        var _this = _super.call(this, "Configured Name", ConfiguredName.UUID, {
            format: "string" /* STRING */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ConfiguredName.UUID = "000000E3-0000-1000-8000-0026BB765291";
    return ConfiguredName;
}(Characteristic_1.Characteristic));
exports.ConfiguredName = ConfiguredName;
Characteristic_1.Characteristic.ConfiguredName = ConfiguredName;
/**
 * Characteristic "Contact Sensor State"
 */
var ContactSensorState = /** @class */ (function (_super) {
    tslib_1.__extends(ContactSensorState, _super);
    function ContactSensorState() {
        var _this = _super.call(this, "Contact Sensor State", ContactSensorState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ContactSensorState.UUID = "0000006A-0000-1000-8000-0026BB765291";
    ContactSensorState.CONTACT_DETECTED = 0;
    ContactSensorState.CONTACT_NOT_DETECTED = 1;
    return ContactSensorState;
}(Characteristic_1.Characteristic));
exports.ContactSensorState = ContactSensorState;
Characteristic_1.Characteristic.ContactSensorState = ContactSensorState;
/**
 * Characteristic "Cooling Threshold Temperature"
 */
var CoolingThresholdTemperature = /** @class */ (function (_super) {
    tslib_1.__extends(CoolingThresholdTemperature, _super);
    function CoolingThresholdTemperature() {
        var _this = _super.call(this, "Cooling Threshold Temperature", CoolingThresholdTemperature.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            unit: "celsius" /* CELSIUS */,
            minValue: 10,
            maxValue: 35,
            minStep: 0.1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CoolingThresholdTemperature.UUID = "0000000D-0000-1000-8000-0026BB765291";
    return CoolingThresholdTemperature;
}(Characteristic_1.Characteristic));
exports.CoolingThresholdTemperature = CoolingThresholdTemperature;
Characteristic_1.Characteristic.CoolingThresholdTemperature = CoolingThresholdTemperature;
/**
 * Characteristic "Current Air Purifier State"
 */
var CurrentAirPurifierState = /** @class */ (function (_super) {
    tslib_1.__extends(CurrentAirPurifierState, _super);
    function CurrentAirPurifierState() {
        var _this = _super.call(this, "Current Air Purifier State", CurrentAirPurifierState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 2,
            minStep: 1,
            validValues: [0, 1, 2],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CurrentAirPurifierState.UUID = "000000A9-0000-1000-8000-0026BB765291";
    CurrentAirPurifierState.INACTIVE = 0;
    CurrentAirPurifierState.IDLE = 1;
    CurrentAirPurifierState.PURIFYING_AIR = 2;
    return CurrentAirPurifierState;
}(Characteristic_1.Characteristic));
exports.CurrentAirPurifierState = CurrentAirPurifierState;
Characteristic_1.Characteristic.CurrentAirPurifierState = CurrentAirPurifierState;
/**
 * Characteristic "Current Ambient Light Level"
 */
var CurrentAmbientLightLevel = /** @class */ (function (_super) {
    tslib_1.__extends(CurrentAmbientLightLevel, _super);
    function CurrentAmbientLightLevel() {
        var _this = _super.call(this, "Current Ambient Light Level", CurrentAmbientLightLevel.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            unit: "lux" /* LUX */,
            minValue: 0.0001,
            maxValue: 100000,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CurrentAmbientLightLevel.UUID = "0000006B-0000-1000-8000-0026BB765291";
    return CurrentAmbientLightLevel;
}(Characteristic_1.Characteristic));
exports.CurrentAmbientLightLevel = CurrentAmbientLightLevel;
Characteristic_1.Characteristic.CurrentAmbientLightLevel = CurrentAmbientLightLevel;
/**
 * Characteristic "Current Door State"
 */
var CurrentDoorState = /** @class */ (function (_super) {
    tslib_1.__extends(CurrentDoorState, _super);
    function CurrentDoorState() {
        var _this = _super.call(this, "Current Door State", CurrentDoorState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 4,
            minStep: 1,
            validValues: [0, 1, 2, 3, 4],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CurrentDoorState.UUID = "0000000E-0000-1000-8000-0026BB765291";
    CurrentDoorState.OPEN = 0;
    CurrentDoorState.CLOSED = 1;
    CurrentDoorState.OPENING = 2;
    CurrentDoorState.CLOSING = 3;
    CurrentDoorState.STOPPED = 4;
    return CurrentDoorState;
}(Characteristic_1.Characteristic));
exports.CurrentDoorState = CurrentDoorState;
Characteristic_1.Characteristic.CurrentDoorState = CurrentDoorState;
/**
 * Characteristic "Current Fan State"
 */
var CurrentFanState = /** @class */ (function (_super) {
    tslib_1.__extends(CurrentFanState, _super);
    function CurrentFanState() {
        var _this = _super.call(this, "Current Fan State", CurrentFanState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 2,
            minStep: 1,
            validValues: [0, 1, 2],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CurrentFanState.UUID = "000000AF-0000-1000-8000-0026BB765291";
    CurrentFanState.INACTIVE = 0;
    CurrentFanState.IDLE = 1;
    CurrentFanState.BLOWING_AIR = 2;
    return CurrentFanState;
}(Characteristic_1.Characteristic));
exports.CurrentFanState = CurrentFanState;
Characteristic_1.Characteristic.CurrentFanState = CurrentFanState;
/**
 * Characteristic "Current Heater-Cooler State"
 */
var CurrentHeaterCoolerState = /** @class */ (function (_super) {
    tslib_1.__extends(CurrentHeaterCoolerState, _super);
    function CurrentHeaterCoolerState() {
        var _this = _super.call(this, "Current Heater-Cooler State", CurrentHeaterCoolerState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 3,
            minStep: 1,
            validValues: [0, 1, 2, 3],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CurrentHeaterCoolerState.UUID = "000000B1-0000-1000-8000-0026BB765291";
    CurrentHeaterCoolerState.INACTIVE = 0;
    CurrentHeaterCoolerState.IDLE = 1;
    CurrentHeaterCoolerState.HEATING = 2;
    CurrentHeaterCoolerState.COOLING = 3;
    return CurrentHeaterCoolerState;
}(Characteristic_1.Characteristic));
exports.CurrentHeaterCoolerState = CurrentHeaterCoolerState;
Characteristic_1.Characteristic.CurrentHeaterCoolerState = CurrentHeaterCoolerState;
/**
 * Characteristic "Current Heating Cooling State"
 */
var CurrentHeatingCoolingState = /** @class */ (function (_super) {
    tslib_1.__extends(CurrentHeatingCoolingState, _super);
    function CurrentHeatingCoolingState() {
        var _this = _super.call(this, "Current Heating Cooling State", CurrentHeatingCoolingState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 2,
            minStep: 1,
            validValues: [0, 1, 2],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CurrentHeatingCoolingState.UUID = "0000000F-0000-1000-8000-0026BB765291";
    CurrentHeatingCoolingState.OFF = 0;
    CurrentHeatingCoolingState.HEAT = 1;
    CurrentHeatingCoolingState.COOL = 2;
    return CurrentHeatingCoolingState;
}(Characteristic_1.Characteristic));
exports.CurrentHeatingCoolingState = CurrentHeatingCoolingState;
Characteristic_1.Characteristic.CurrentHeatingCoolingState = CurrentHeatingCoolingState;
/**
 * Characteristic "Current Horizontal Tilt Angle"
 */
var CurrentHorizontalTiltAngle = /** @class */ (function (_super) {
    tslib_1.__extends(CurrentHorizontalTiltAngle, _super);
    function CurrentHorizontalTiltAngle() {
        var _this = _super.call(this, "Current Horizontal Tilt Angle", CurrentHorizontalTiltAngle.UUID, {
            format: "int" /* INT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            unit: "arcdegrees" /* ARC_DEGREE */,
            minValue: -90,
            maxValue: 90,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CurrentHorizontalTiltAngle.UUID = "0000006C-0000-1000-8000-0026BB765291";
    return CurrentHorizontalTiltAngle;
}(Characteristic_1.Characteristic));
exports.CurrentHorizontalTiltAngle = CurrentHorizontalTiltAngle;
Characteristic_1.Characteristic.CurrentHorizontalTiltAngle = CurrentHorizontalTiltAngle;
/**
 * Characteristic "Current Humidifier-Dehumidifier State"
 */
var CurrentHumidifierDehumidifierState = /** @class */ (function (_super) {
    tslib_1.__extends(CurrentHumidifierDehumidifierState, _super);
    function CurrentHumidifierDehumidifierState() {
        var _this = _super.call(this, "Current Humidifier-Dehumidifier State", CurrentHumidifierDehumidifierState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 3,
            minStep: 1,
            validValues: [0, 1, 2, 3],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CurrentHumidifierDehumidifierState.UUID = "000000B3-0000-1000-8000-0026BB765291";
    CurrentHumidifierDehumidifierState.INACTIVE = 0;
    CurrentHumidifierDehumidifierState.IDLE = 1;
    CurrentHumidifierDehumidifierState.HUMIDIFYING = 2;
    CurrentHumidifierDehumidifierState.DEHUMIDIFYING = 3;
    return CurrentHumidifierDehumidifierState;
}(Characteristic_1.Characteristic));
exports.CurrentHumidifierDehumidifierState = CurrentHumidifierDehumidifierState;
Characteristic_1.Characteristic.CurrentHumidifierDehumidifierState = CurrentHumidifierDehumidifierState;
/**
 * Characteristic "Current Media State"
 */
var CurrentMediaState = /** @class */ (function (_super) {
    tslib_1.__extends(CurrentMediaState, _super);
    function CurrentMediaState() {
        var _this = _super.call(this, "Current Media State", CurrentMediaState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 5,
            minStep: 1,
            validValues: [0, 1, 2, 4, 5],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CurrentMediaState.UUID = "000000E0-0000-1000-8000-0026BB765291";
    CurrentMediaState.PLAY = 0;
    CurrentMediaState.PAUSE = 1;
    CurrentMediaState.STOP = 2;
    CurrentMediaState.LOADING = 4;
    CurrentMediaState.INTERRUPTED = 5;
    return CurrentMediaState;
}(Characteristic_1.Characteristic));
exports.CurrentMediaState = CurrentMediaState;
Characteristic_1.Characteristic.CurrentMediaState = CurrentMediaState;
/**
 * Characteristic "Current Position"
 */
var CurrentPosition = /** @class */ (function (_super) {
    tslib_1.__extends(CurrentPosition, _super);
    function CurrentPosition() {
        var _this = _super.call(this, "Current Position", CurrentPosition.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            unit: "percentage" /* PERCENTAGE */,
            minValue: 0,
            maxValue: 100,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CurrentPosition.UUID = "0000006D-0000-1000-8000-0026BB765291";
    return CurrentPosition;
}(Characteristic_1.Characteristic));
exports.CurrentPosition = CurrentPosition;
Characteristic_1.Characteristic.CurrentPosition = CurrentPosition;
/**
 * Characteristic "Current Relative Humidity"
 */
var CurrentRelativeHumidity = /** @class */ (function (_super) {
    tslib_1.__extends(CurrentRelativeHumidity, _super);
    function CurrentRelativeHumidity() {
        var _this = _super.call(this, "Current Relative Humidity", CurrentRelativeHumidity.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            unit: "percentage" /* PERCENTAGE */,
            minValue: 0,
            maxValue: 100,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CurrentRelativeHumidity.UUID = "00000010-0000-1000-8000-0026BB765291";
    return CurrentRelativeHumidity;
}(Characteristic_1.Characteristic));
exports.CurrentRelativeHumidity = CurrentRelativeHumidity;
Characteristic_1.Characteristic.CurrentRelativeHumidity = CurrentRelativeHumidity;
/**
 * Characteristic "Current Slat State"
 */
var CurrentSlatState = /** @class */ (function (_super) {
    tslib_1.__extends(CurrentSlatState, _super);
    function CurrentSlatState() {
        var _this = _super.call(this, "Current Slat State", CurrentSlatState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 2,
            minStep: 1,
            validValues: [0, 1, 2],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CurrentSlatState.UUID = "000000AA-0000-1000-8000-0026BB765291";
    CurrentSlatState.FIXED = 0;
    CurrentSlatState.JAMMED = 1;
    CurrentSlatState.SWINGING = 2;
    return CurrentSlatState;
}(Characteristic_1.Characteristic));
exports.CurrentSlatState = CurrentSlatState;
Characteristic_1.Characteristic.CurrentSlatState = CurrentSlatState;
/**
 * Characteristic "Current Temperature"
 */
var CurrentTemperature = /** @class */ (function (_super) {
    tslib_1.__extends(CurrentTemperature, _super);
    function CurrentTemperature() {
        var _this = _super.call(this, "Current Temperature", CurrentTemperature.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            unit: "celsius" /* CELSIUS */,
            minValue: -273.15,
            maxValue: 100,
            minStep: 0.1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CurrentTemperature.UUID = "00000011-0000-1000-8000-0026BB765291";
    return CurrentTemperature;
}(Characteristic_1.Characteristic));
exports.CurrentTemperature = CurrentTemperature;
Characteristic_1.Characteristic.CurrentTemperature = CurrentTemperature;
/**
 * Characteristic "Current Tilt Angle"
 */
var CurrentTiltAngle = /** @class */ (function (_super) {
    tslib_1.__extends(CurrentTiltAngle, _super);
    function CurrentTiltAngle() {
        var _this = _super.call(this, "Current Tilt Angle", CurrentTiltAngle.UUID, {
            format: "int" /* INT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            unit: "arcdegrees" /* ARC_DEGREE */,
            minValue: -90,
            maxValue: 90,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CurrentTiltAngle.UUID = "000000C1-0000-1000-8000-0026BB765291";
    return CurrentTiltAngle;
}(Characteristic_1.Characteristic));
exports.CurrentTiltAngle = CurrentTiltAngle;
Characteristic_1.Characteristic.CurrentTiltAngle = CurrentTiltAngle;
/**
 * Characteristic "Current Time"
 * @deprecated Removed and not used anymore
 */
var CurrentTime = /** @class */ (function (_super) {
    tslib_1.__extends(CurrentTime, _super);
    function CurrentTime() {
        var _this = _super.call(this, "Current Time", CurrentTime.UUID, {
            format: "string" /* STRING */,
            perms: ["pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CurrentTime.UUID = "0000009B-0000-1000-8000-0026BB765291";
    return CurrentTime;
}(Characteristic_1.Characteristic));
exports.CurrentTime = CurrentTime;
// noinspection JSDeprecatedSymbols
Characteristic_1.Characteristic.CurrentTime = CurrentTime;
/**
 * Characteristic "Current Transport"
 * @since iOS 14
 */
var CurrentTransport = /** @class */ (function (_super) {
    tslib_1.__extends(CurrentTransport, _super);
    function CurrentTransport() {
        var _this = _super.call(this, "Current Transport", CurrentTransport.UUID, {
            format: "bool" /* BOOL */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CurrentTransport.UUID = "0000022B-0000-1000-8000-0026BB765291";
    return CurrentTransport;
}(Characteristic_1.Characteristic));
exports.CurrentTransport = CurrentTransport;
Characteristic_1.Characteristic.CurrentTransport = CurrentTransport;
/**
 * Characteristic "Current Vertical Tilt Angle"
 */
var CurrentVerticalTiltAngle = /** @class */ (function (_super) {
    tslib_1.__extends(CurrentVerticalTiltAngle, _super);
    function CurrentVerticalTiltAngle() {
        var _this = _super.call(this, "Current Vertical Tilt Angle", CurrentVerticalTiltAngle.UUID, {
            format: "int" /* INT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            unit: "arcdegrees" /* ARC_DEGREE */,
            minValue: -90,
            maxValue: 90,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CurrentVerticalTiltAngle.UUID = "0000006E-0000-1000-8000-0026BB765291";
    return CurrentVerticalTiltAngle;
}(Characteristic_1.Characteristic));
exports.CurrentVerticalTiltAngle = CurrentVerticalTiltAngle;
Characteristic_1.Characteristic.CurrentVerticalTiltAngle = CurrentVerticalTiltAngle;
/**
 * Characteristic "Current Visibility State"
 */
var CurrentVisibilityState = /** @class */ (function (_super) {
    tslib_1.__extends(CurrentVisibilityState, _super);
    function CurrentVisibilityState() {
        var _this = _super.call(this, "Current Visibility State", CurrentVisibilityState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    CurrentVisibilityState.UUID = "00000135-0000-1000-8000-0026BB765291";
    CurrentVisibilityState.SHOWN = 0;
    CurrentVisibilityState.HIDDEN = 1;
    return CurrentVisibilityState;
}(Characteristic_1.Characteristic));
exports.CurrentVisibilityState = CurrentVisibilityState;
Characteristic_1.Characteristic.CurrentVisibilityState = CurrentVisibilityState;
/**
 * Characteristic "Data Stream HAP Transport"
 * @since iOS 14
 */
var DataStreamHAPTransport = /** @class */ (function (_super) {
    tslib_1.__extends(DataStreamHAPTransport, _super);
    function DataStreamHAPTransport() {
        var _this = _super.call(this, "Data Stream HAP Transport", DataStreamHAPTransport.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */, "wr" /* WRITE_RESPONSE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    DataStreamHAPTransport.UUID = "00000138-0000-1000-8000-0026BB765291";
    return DataStreamHAPTransport;
}(Characteristic_1.Characteristic));
exports.DataStreamHAPTransport = DataStreamHAPTransport;
Characteristic_1.Characteristic.DataStreamHAPTransport = DataStreamHAPTransport;
/**
 * Characteristic "Data Stream HAP Transport Interrupt"
 * @since iOS 14
 */
var DataStreamHAPTransportInterrupt = /** @class */ (function (_super) {
    tslib_1.__extends(DataStreamHAPTransportInterrupt, _super);
    function DataStreamHAPTransportInterrupt() {
        var _this = _super.call(this, "Data Stream HAP Transport Interrupt", DataStreamHAPTransportInterrupt.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    DataStreamHAPTransportInterrupt.UUID = "00000139-0000-1000-8000-0026BB765291";
    return DataStreamHAPTransportInterrupt;
}(Characteristic_1.Characteristic));
exports.DataStreamHAPTransportInterrupt = DataStreamHAPTransportInterrupt;
Characteristic_1.Characteristic.DataStreamHAPTransportInterrupt = DataStreamHAPTransportInterrupt;
/**
 * Characteristic "Day of the Week"
 * @deprecated Removed and not used anymore
 */
var DayoftheWeek = /** @class */ (function (_super) {
    tslib_1.__extends(DayoftheWeek, _super);
    function DayoftheWeek() {
        var _this = _super.call(this, "Day of the Week", DayoftheWeek.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minValue: 1,
            maxValue: 7,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    DayoftheWeek.UUID = "00000098-0000-1000-8000-0026BB765291";
    return DayoftheWeek;
}(Characteristic_1.Characteristic));
exports.DayoftheWeek = DayoftheWeek;
// noinspection JSDeprecatedSymbols
Characteristic_1.Characteristic.DayoftheWeek = DayoftheWeek;
/**
 * Characteristic "Diagonal Field Of View"
 * @since iOS 13.2
 */
var DiagonalFieldOfView = /** @class */ (function (_super) {
    tslib_1.__extends(DiagonalFieldOfView, _super);
    function DiagonalFieldOfView() {
        var _this = _super.call(this, "Diagonal Field Of View", DiagonalFieldOfView.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            unit: "arcdegrees" /* ARC_DEGREE */,
            minValue: 0,
            maxValue: 360,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    DiagonalFieldOfView.UUID = "00000224-0000-1000-8000-0026BB765291";
    return DiagonalFieldOfView;
}(Characteristic_1.Characteristic));
exports.DiagonalFieldOfView = DiagonalFieldOfView;
Characteristic_1.Characteristic.DiagonalFieldOfView = DiagonalFieldOfView;
/**
 * Characteristic "Digital Zoom"
 */
var DigitalZoom = /** @class */ (function (_super) {
    tslib_1.__extends(DigitalZoom, _super);
    function DigitalZoom() {
        var _this = _super.call(this, "Digital Zoom", DigitalZoom.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minStep: 0.1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    DigitalZoom.UUID = "0000011D-0000-1000-8000-0026BB765291";
    return DigitalZoom;
}(Characteristic_1.Characteristic));
exports.DigitalZoom = DigitalZoom;
Characteristic_1.Characteristic.DigitalZoom = DigitalZoom;
/**
 * Characteristic "Discover Bridged Accessories"
 * @deprecated Removed and not used anymore
 */
var DiscoverBridgedAccessories = /** @class */ (function (_super) {
    tslib_1.__extends(DiscoverBridgedAccessories, _super);
    function DiscoverBridgedAccessories() {
        var _this = _super.call(this, "Discover Bridged Accessories", DiscoverBridgedAccessories.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    DiscoverBridgedAccessories.UUID = "0000009E-0000-1000-8000-0026BB765291";
    return DiscoverBridgedAccessories;
}(Characteristic_1.Characteristic));
exports.DiscoverBridgedAccessories = DiscoverBridgedAccessories;
// noinspection JSDeprecatedSymbols
Characteristic_1.Characteristic.DiscoverBridgedAccessories = DiscoverBridgedAccessories;
/**
 * Characteristic "Discovered Bridged Accessories"
 * @deprecated Removed and not used anymore
 */
var DiscoveredBridgedAccessories = /** @class */ (function (_super) {
    tslib_1.__extends(DiscoveredBridgedAccessories, _super);
    function DiscoveredBridgedAccessories() {
        var _this = _super.call(this, "Discovered Bridged Accessories", DiscoveredBridgedAccessories.UUID, {
            format: "uint16" /* UINT16 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    DiscoveredBridgedAccessories.UUID = "0000009F-0000-1000-8000-0026BB765291";
    return DiscoveredBridgedAccessories;
}(Characteristic_1.Characteristic));
exports.DiscoveredBridgedAccessories = DiscoveredBridgedAccessories;
// noinspection JSDeprecatedSymbols
Characteristic_1.Characteristic.DiscoveredBridgedAccessories = DiscoveredBridgedAccessories;
/**
 * Characteristic "Display Order"
 */
var DisplayOrder = /** @class */ (function (_super) {
    tslib_1.__extends(DisplayOrder, _super);
    function DisplayOrder() {
        var _this = _super.call(this, "Display Order", DisplayOrder.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    DisplayOrder.UUID = "00000136-0000-1000-8000-0026BB765291";
    return DisplayOrder;
}(Characteristic_1.Characteristic));
exports.DisplayOrder = DisplayOrder;
Characteristic_1.Characteristic.DisplayOrder = DisplayOrder;
/**
 * Characteristic "Event Retransmission Maximum"
 * @since iOS 14
 */
var EventRetransmissionMaximum = /** @class */ (function (_super) {
    tslib_1.__extends(EventRetransmissionMaximum, _super);
    function EventRetransmissionMaximum() {
        var _this = _super.call(this, "Event Retransmission Maximum", EventRetransmissionMaximum.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    EventRetransmissionMaximum.UUID = "0000023D-0000-1000-8000-0026BB765291";
    return EventRetransmissionMaximum;
}(Characteristic_1.Characteristic));
exports.EventRetransmissionMaximum = EventRetransmissionMaximum;
Characteristic_1.Characteristic.EventRetransmissionMaximum = EventRetransmissionMaximum;
/**
 * Characteristic "Event Snapshots Active"
 */
var EventSnapshotsActive = /** @class */ (function (_super) {
    tslib_1.__extends(EventSnapshotsActive, _super);
    function EventSnapshotsActive() {
        var _this = _super.call(this, "Event Snapshots Active", EventSnapshotsActive.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    EventSnapshotsActive.UUID = "00000223-0000-1000-8000-0026BB765291";
    EventSnapshotsActive.DISABLE = 0;
    EventSnapshotsActive.ENABLE = 1;
    return EventSnapshotsActive;
}(Characteristic_1.Characteristic));
exports.EventSnapshotsActive = EventSnapshotsActive;
Characteristic_1.Characteristic.EventSnapshotsActive = EventSnapshotsActive;
/**
 * Characteristic "Event Transmission Counters"
 * @since iOS 14
 */
var EventTransmissionCounters = /** @class */ (function (_super) {
    tslib_1.__extends(EventTransmissionCounters, _super);
    function EventTransmissionCounters() {
        var _this = _super.call(this, "Event Transmission Counters", EventTransmissionCounters.UUID, {
            format: "uint32" /* UINT32 */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    EventTransmissionCounters.UUID = "0000023E-0000-1000-8000-0026BB765291";
    return EventTransmissionCounters;
}(Characteristic_1.Characteristic));
exports.EventTransmissionCounters = EventTransmissionCounters;
Characteristic_1.Characteristic.EventTransmissionCounters = EventTransmissionCounters;
/**
 * Characteristic "Filter Change Indication"
 */
var FilterChangeIndication = /** @class */ (function (_super) {
    tslib_1.__extends(FilterChangeIndication, _super);
    function FilterChangeIndication() {
        var _this = _super.call(this, "Filter Change Indication", FilterChangeIndication.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    FilterChangeIndication.UUID = "000000AC-0000-1000-8000-0026BB765291";
    FilterChangeIndication.FILTER_OK = 0;
    FilterChangeIndication.CHANGE_FILTER = 1;
    return FilterChangeIndication;
}(Characteristic_1.Characteristic));
exports.FilterChangeIndication = FilterChangeIndication;
Characteristic_1.Characteristic.FilterChangeIndication = FilterChangeIndication;
/**
 * Characteristic "Filter Life Level"
 */
var FilterLifeLevel = /** @class */ (function (_super) {
    tslib_1.__extends(FilterLifeLevel, _super);
    function FilterLifeLevel() {
        var _this = _super.call(this, "Filter Life Level", FilterLifeLevel.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 100,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    FilterLifeLevel.UUID = "000000AB-0000-1000-8000-0026BB765291";
    return FilterLifeLevel;
}(Characteristic_1.Characteristic));
exports.FilterLifeLevel = FilterLifeLevel;
Characteristic_1.Characteristic.FilterLifeLevel = FilterLifeLevel;
/**
 * Characteristic "Firmware Revision"
 */
var FirmwareRevision = /** @class */ (function (_super) {
    tslib_1.__extends(FirmwareRevision, _super);
    function FirmwareRevision() {
        var _this = _super.call(this, "Firmware Revision", FirmwareRevision.UUID, {
            format: "string" /* STRING */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    FirmwareRevision.UUID = "00000052-0000-1000-8000-0026BB765291";
    return FirmwareRevision;
}(Characteristic_1.Characteristic));
exports.FirmwareRevision = FirmwareRevision;
Characteristic_1.Characteristic.FirmwareRevision = FirmwareRevision;
/**
 * Characteristic "Firmware Update Readiness"
 */
var FirmwareUpdateReadiness = /** @class */ (function (_super) {
    tslib_1.__extends(FirmwareUpdateReadiness, _super);
    function FirmwareUpdateReadiness() {
        var _this = _super.call(this, "Firmware Update Readiness", FirmwareUpdateReadiness.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    FirmwareUpdateReadiness.UUID = "00000234-0000-1000-8000-0026BB765291";
    return FirmwareUpdateReadiness;
}(Characteristic_1.Characteristic));
exports.FirmwareUpdateReadiness = FirmwareUpdateReadiness;
Characteristic_1.Characteristic.FirmwareUpdateReadiness = FirmwareUpdateReadiness;
/**
 * Characteristic "Firmware Update Status"
 */
var FirmwareUpdateStatus = /** @class */ (function (_super) {
    tslib_1.__extends(FirmwareUpdateStatus, _super);
    function FirmwareUpdateStatus() {
        var _this = _super.call(this, "Firmware Update Status", FirmwareUpdateStatus.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    FirmwareUpdateStatus.UUID = "00000235-0000-1000-8000-0026BB765291";
    return FirmwareUpdateStatus;
}(Characteristic_1.Characteristic));
exports.FirmwareUpdateStatus = FirmwareUpdateStatus;
Characteristic_1.Characteristic.FirmwareUpdateStatus = FirmwareUpdateStatus;
/**
 * Characteristic "Hardware Revision"
 */
var HardwareRevision = /** @class */ (function (_super) {
    tslib_1.__extends(HardwareRevision, _super);
    function HardwareRevision() {
        var _this = _super.call(this, "Hardware Revision", HardwareRevision.UUID, {
            format: "string" /* STRING */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    HardwareRevision.UUID = "00000053-0000-1000-8000-0026BB765291";
    return HardwareRevision;
}(Characteristic_1.Characteristic));
exports.HardwareRevision = HardwareRevision;
Characteristic_1.Characteristic.HardwareRevision = HardwareRevision;
/**
 * Characteristic "Heart Beat"
 * @since iOS 14
 */
var HeartBeat = /** @class */ (function (_super) {
    tslib_1.__extends(HeartBeat, _super);
    function HeartBeat() {
        var _this = _super.call(this, "Heart Beat", HeartBeat.UUID, {
            format: "uint32" /* UINT32 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    HeartBeat.UUID = "0000024A-0000-1000-8000-0026BB765291";
    return HeartBeat;
}(Characteristic_1.Characteristic));
exports.HeartBeat = HeartBeat;
Characteristic_1.Characteristic.HeartBeat = HeartBeat;
/**
 * Characteristic "Heating Threshold Temperature"
 */
var HeatingThresholdTemperature = /** @class */ (function (_super) {
    tslib_1.__extends(HeatingThresholdTemperature, _super);
    function HeatingThresholdTemperature() {
        var _this = _super.call(this, "Heating Threshold Temperature", HeatingThresholdTemperature.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            unit: "celsius" /* CELSIUS */,
            minValue: 0,
            maxValue: 25,
            minStep: 0.1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    HeatingThresholdTemperature.UUID = "00000012-0000-1000-8000-0026BB765291";
    return HeatingThresholdTemperature;
}(Characteristic_1.Characteristic));
exports.HeatingThresholdTemperature = HeatingThresholdTemperature;
Characteristic_1.Characteristic.HeatingThresholdTemperature = HeatingThresholdTemperature;
/**
 * Characteristic "Hold Position"
 */
var HoldPosition = /** @class */ (function (_super) {
    tslib_1.__extends(HoldPosition, _super);
    function HoldPosition() {
        var _this = _super.call(this, "Hold Position", HoldPosition.UUID, {
            format: "bool" /* BOOL */,
            perms: ["pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    HoldPosition.UUID = "0000006F-0000-1000-8000-0026BB765291";
    return HoldPosition;
}(Characteristic_1.Characteristic));
exports.HoldPosition = HoldPosition;
Characteristic_1.Characteristic.HoldPosition = HoldPosition;
/**
 * Characteristic "HomeKit Camera Active"
 */
var HomeKitCameraActive = /** @class */ (function (_super) {
    tslib_1.__extends(HomeKitCameraActive, _super);
    function HomeKitCameraActive() {
        var _this = _super.call(this, "HomeKit Camera Active", HomeKitCameraActive.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    HomeKitCameraActive.UUID = "0000021B-0000-1000-8000-0026BB765291";
    HomeKitCameraActive.OFF = 0;
    HomeKitCameraActive.ON = 1;
    return HomeKitCameraActive;
}(Characteristic_1.Characteristic));
exports.HomeKitCameraActive = HomeKitCameraActive;
Characteristic_1.Characteristic.HomeKitCameraActive = HomeKitCameraActive;
/**
 * Characteristic "Hue"
 */
var Hue = /** @class */ (function (_super) {
    tslib_1.__extends(Hue, _super);
    function Hue() {
        var _this = _super.call(this, "Hue", Hue.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            unit: "arcdegrees" /* ARC_DEGREE */,
            minValue: 0,
            maxValue: 360,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    Hue.UUID = "00000013-0000-1000-8000-0026BB765291";
    return Hue;
}(Characteristic_1.Characteristic));
exports.Hue = Hue;
Characteristic_1.Characteristic.Hue = Hue;
/**
 * Characteristic "Identifier"
 */
var Identifier = /** @class */ (function (_super) {
    tslib_1.__extends(Identifier, _super);
    function Identifier() {
        var _this = _super.call(this, "Identifier", Identifier.UUID, {
            format: "uint32" /* UINT32 */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    Identifier.UUID = "000000E6-0000-1000-8000-0026BB765291";
    return Identifier;
}(Characteristic_1.Characteristic));
exports.Identifier = Identifier;
Characteristic_1.Characteristic.Identifier = Identifier;
/**
 * Characteristic "Identify"
 */
var Identify = /** @class */ (function (_super) {
    tslib_1.__extends(Identify, _super);
    function Identify() {
        var _this = _super.call(this, "Identify", Identify.UUID, {
            format: "bool" /* BOOL */,
            perms: ["pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    Identify.UUID = "00000014-0000-1000-8000-0026BB765291";
    return Identify;
}(Characteristic_1.Characteristic));
exports.Identify = Identify;
Characteristic_1.Characteristic.Identify = Identify;
/**
 * Characteristic "Image Mirroring"
 */
var ImageMirroring = /** @class */ (function (_super) {
    tslib_1.__extends(ImageMirroring, _super);
    function ImageMirroring() {
        var _this = _super.call(this, "Image Mirroring", ImageMirroring.UUID, {
            format: "bool" /* BOOL */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ImageMirroring.UUID = "0000011F-0000-1000-8000-0026BB765291";
    return ImageMirroring;
}(Characteristic_1.Characteristic));
exports.ImageMirroring = ImageMirroring;
Characteristic_1.Characteristic.ImageMirroring = ImageMirroring;
/**
 * Characteristic "Image Rotation"
 */
var ImageRotation = /** @class */ (function (_super) {
    tslib_1.__extends(ImageRotation, _super);
    function ImageRotation() {
        var _this = _super.call(this, "Image Rotation", ImageRotation.UUID, {
            format: "int" /* INT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            unit: "arcdegrees" /* ARC_DEGREE */,
            minValue: 0,
            maxValue: 360,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ImageRotation.UUID = "0000011E-0000-1000-8000-0026BB765291";
    return ImageRotation;
}(Characteristic_1.Characteristic));
exports.ImageRotation = ImageRotation;
Characteristic_1.Characteristic.ImageRotation = ImageRotation;
/**
 * Characteristic "Input Device Type"
 */
var InputDeviceType = /** @class */ (function (_super) {
    tslib_1.__extends(InputDeviceType, _super);
    function InputDeviceType() {
        var _this = _super.call(this, "Input Device Type", InputDeviceType.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 6,
            minStep: 1,
            validValues: [0, 1, 2, 3, 4, 5, 6],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    InputDeviceType.UUID = "000000DC-0000-1000-8000-0026BB765291";
    InputDeviceType.OTHER = 0;
    InputDeviceType.TV = 1;
    InputDeviceType.RECORDING = 2;
    InputDeviceType.TUNER = 3;
    InputDeviceType.PLAYBACK = 4;
    InputDeviceType.AUDIO_SYSTEM = 5;
    return InputDeviceType;
}(Characteristic_1.Characteristic));
exports.InputDeviceType = InputDeviceType;
Characteristic_1.Characteristic.InputDeviceType = InputDeviceType;
/**
 * Characteristic "Input Source Type"
 */
var InputSourceType = /** @class */ (function (_super) {
    tslib_1.__extends(InputSourceType, _super);
    function InputSourceType() {
        var _this = _super.call(this, "Input Source Type", InputSourceType.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 10,
            minStep: 1,
            validValues: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    InputSourceType.UUID = "000000DB-0000-1000-8000-0026BB765291";
    InputSourceType.OTHER = 0;
    InputSourceType.HOME_SCREEN = 1;
    InputSourceType.TUNER = 2;
    InputSourceType.HDMI = 3;
    InputSourceType.COMPOSITE_VIDEO = 4;
    InputSourceType.S_VIDEO = 5;
    InputSourceType.COMPONENT_VIDEO = 6;
    InputSourceType.DVI = 7;
    InputSourceType.AIRPLAY = 8;
    InputSourceType.USB = 9;
    InputSourceType.APPLICATION = 10;
    return InputSourceType;
}(Characteristic_1.Characteristic));
exports.InputSourceType = InputSourceType;
Characteristic_1.Characteristic.InputSourceType = InputSourceType;
/**
 * Characteristic "In Use"
 */
var InUse = /** @class */ (function (_super) {
    tslib_1.__extends(InUse, _super);
    function InUse() {
        var _this = _super.call(this, "In Use", InUse.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    InUse.UUID = "000000D2-0000-1000-8000-0026BB765291";
    InUse.NOT_IN_USE = 0;
    InUse.IN_USE = 1;
    return InUse;
}(Characteristic_1.Characteristic));
exports.InUse = InUse;
Characteristic_1.Characteristic.InUse = InUse;
/**
 * Characteristic "Is Configured"
 */
var IsConfigured = /** @class */ (function (_super) {
    tslib_1.__extends(IsConfigured, _super);
    function IsConfigured() {
        var _this = _super.call(this, "Is Configured", IsConfigured.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    IsConfigured.UUID = "000000D6-0000-1000-8000-0026BB765291";
    IsConfigured.NOT_CONFIGURED = 0;
    IsConfigured.CONFIGURED = 1;
    return IsConfigured;
}(Characteristic_1.Characteristic));
exports.IsConfigured = IsConfigured;
Characteristic_1.Characteristic.IsConfigured = IsConfigured;
/**
 * Characteristic "Leak Detected"
 */
var LeakDetected = /** @class */ (function (_super) {
    tslib_1.__extends(LeakDetected, _super);
    function LeakDetected() {
        var _this = _super.call(this, "Leak Detected", LeakDetected.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    LeakDetected.UUID = "00000070-0000-1000-8000-0026BB765291";
    LeakDetected.LEAK_NOT_DETECTED = 0;
    LeakDetected.LEAK_DETECTED = 1;
    return LeakDetected;
}(Characteristic_1.Characteristic));
exports.LeakDetected = LeakDetected;
Characteristic_1.Characteristic.LeakDetected = LeakDetected;
/**
 * Characteristic "Link Quality"
 * @deprecated Removed and not used anymore
 */
var LinkQuality = /** @class */ (function (_super) {
    tslib_1.__extends(LinkQuality, _super);
    function LinkQuality() {
        var _this = _super.call(this, "Link Quality", LinkQuality.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 1,
            maxValue: 4,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    LinkQuality.UUID = "0000009C-0000-1000-8000-0026BB765291";
    return LinkQuality;
}(Characteristic_1.Characteristic));
exports.LinkQuality = LinkQuality;
// noinspection JSDeprecatedSymbols
Characteristic_1.Characteristic.LinkQuality = LinkQuality;
/**
 * Characteristic "List Pairings"
 */
var ListPairings = /** @class */ (function (_super) {
    tslib_1.__extends(ListPairings, _super);
    function ListPairings() {
        var _this = _super.call(this, "List Pairings", ListPairings.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ListPairings.UUID = "00000050-0000-1000-8000-0026BB765291";
    return ListPairings;
}(Characteristic_1.Characteristic));
exports.ListPairings = ListPairings;
Characteristic_1.Characteristic.ListPairings = ListPairings;
/**
 * Characteristic "Lock Control Point"
 */
var LockControlPoint = /** @class */ (function (_super) {
    tslib_1.__extends(LockControlPoint, _super);
    function LockControlPoint() {
        var _this = _super.call(this, "Lock Control Point", LockControlPoint.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    LockControlPoint.UUID = "00000019-0000-1000-8000-0026BB765291";
    return LockControlPoint;
}(Characteristic_1.Characteristic));
exports.LockControlPoint = LockControlPoint;
Characteristic_1.Characteristic.LockControlPoint = LockControlPoint;
/**
 * Characteristic "Lock Current State"
 */
var LockCurrentState = /** @class */ (function (_super) {
    tslib_1.__extends(LockCurrentState, _super);
    function LockCurrentState() {
        var _this = _super.call(this, "Lock Current State", LockCurrentState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 3,
            minStep: 1,
            validValues: [0, 1, 2, 3],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    LockCurrentState.UUID = "0000001D-0000-1000-8000-0026BB765291";
    LockCurrentState.UNSECURED = 0;
    LockCurrentState.SECURED = 1;
    LockCurrentState.JAMMED = 2;
    LockCurrentState.UNKNOWN = 3;
    return LockCurrentState;
}(Characteristic_1.Characteristic));
exports.LockCurrentState = LockCurrentState;
Characteristic_1.Characteristic.LockCurrentState = LockCurrentState;
/**
 * Characteristic "Lock Last Known Action"
 */
var LockLastKnownAction = /** @class */ (function (_super) {
    tslib_1.__extends(LockLastKnownAction, _super);
    function LockLastKnownAction() {
        var _this = _super.call(this, "Lock Last Known Action", LockLastKnownAction.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 10,
            minStep: 1,
            validValues: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    LockLastKnownAction.UUID = "0000001C-0000-1000-8000-0026BB765291";
    LockLastKnownAction.SECURED_PHYSICALLY_INTERIOR = 0;
    LockLastKnownAction.UNSECURED_PHYSICALLY_INTERIOR = 1;
    LockLastKnownAction.SECURED_PHYSICALLY_EXTERIOR = 2;
    LockLastKnownAction.UNSECURED_PHYSICALLY_EXTERIOR = 3;
    LockLastKnownAction.SECURED_BY_KEYPAD = 4;
    LockLastKnownAction.UNSECURED_BY_KEYPAD = 5;
    LockLastKnownAction.SECURED_REMOTELY = 6;
    LockLastKnownAction.UNSECURED_REMOTELY = 7;
    LockLastKnownAction.SECURED_BY_AUTO_SECURE_TIMEOUT = 8;
    LockLastKnownAction.SECURED_PHYSICALLY = 9;
    LockLastKnownAction.UNSECURED_PHYSICALLY = 10;
    return LockLastKnownAction;
}(Characteristic_1.Characteristic));
exports.LockLastKnownAction = LockLastKnownAction;
Characteristic_1.Characteristic.LockLastKnownAction = LockLastKnownAction;
/**
 * Characteristic "Lock Management Auto Security Timeout"
 */
var LockManagementAutoSecurityTimeout = /** @class */ (function (_super) {
    tslib_1.__extends(LockManagementAutoSecurityTimeout, _super);
    function LockManagementAutoSecurityTimeout() {
        var _this = _super.call(this, "Lock Management Auto Security Timeout", LockManagementAutoSecurityTimeout.UUID, {
            format: "uint32" /* UINT32 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            unit: "seconds" /* SECONDS */,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    LockManagementAutoSecurityTimeout.UUID = "0000001A-0000-1000-8000-0026BB765291";
    return LockManagementAutoSecurityTimeout;
}(Characteristic_1.Characteristic));
exports.LockManagementAutoSecurityTimeout = LockManagementAutoSecurityTimeout;
Characteristic_1.Characteristic.LockManagementAutoSecurityTimeout = LockManagementAutoSecurityTimeout;
/**
 * Characteristic "Lock Physical Controls"
 */
var LockPhysicalControls = /** @class */ (function (_super) {
    tslib_1.__extends(LockPhysicalControls, _super);
    function LockPhysicalControls() {
        var _this = _super.call(this, "Lock Physical Controls", LockPhysicalControls.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    LockPhysicalControls.UUID = "000000A7-0000-1000-8000-0026BB765291";
    LockPhysicalControls.CONTROL_LOCK_DISABLED = 0;
    LockPhysicalControls.CONTROL_LOCK_ENABLED = 1;
    return LockPhysicalControls;
}(Characteristic_1.Characteristic));
exports.LockPhysicalControls = LockPhysicalControls;
Characteristic_1.Characteristic.LockPhysicalControls = LockPhysicalControls;
/**
 * Characteristic "Lock Target State"
 */
var LockTargetState = /** @class */ (function (_super) {
    tslib_1.__extends(LockTargetState, _super);
    function LockTargetState() {
        var _this = _super.call(this, "Lock Target State", LockTargetState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    LockTargetState.UUID = "0000001E-0000-1000-8000-0026BB765291";
    LockTargetState.UNSECURED = 0;
    LockTargetState.SECURED = 1;
    return LockTargetState;
}(Characteristic_1.Characteristic));
exports.LockTargetState = LockTargetState;
Characteristic_1.Characteristic.LockTargetState = LockTargetState;
/**
 * Characteristic "Logs"
 */
var Logs = /** @class */ (function (_super) {
    tslib_1.__extends(Logs, _super);
    function Logs() {
        var _this = _super.call(this, "Logs", Logs.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    Logs.UUID = "0000001F-0000-1000-8000-0026BB765291";
    return Logs;
}(Characteristic_1.Characteristic));
exports.Logs = Logs;
Characteristic_1.Characteristic.Logs = Logs;
/**
 * Characteristic "MAC Retransmission Maximum"
 * @since iOS 14
 */
var MACRetransmissionMaximum = /** @class */ (function (_super) {
    tslib_1.__extends(MACRetransmissionMaximum, _super);
    function MACRetransmissionMaximum() {
        var _this = _super.call(this, "MAC Retransmission Maximum", MACRetransmissionMaximum.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    MACRetransmissionMaximum.UUID = "00000247-0000-1000-8000-0026BB765291";
    return MACRetransmissionMaximum;
}(Characteristic_1.Characteristic));
exports.MACRetransmissionMaximum = MACRetransmissionMaximum;
Characteristic_1.Characteristic.MACRetransmissionMaximum = MACRetransmissionMaximum;
/**
 * Characteristic "MAC Transmission Counters"
 */
var MACTransmissionCounters = /** @class */ (function (_super) {
    tslib_1.__extends(MACTransmissionCounters, _super);
    function MACTransmissionCounters() {
        var _this = _super.call(this, "MAC Transmission Counters", MACTransmissionCounters.UUID, {
            format: "data" /* DATA */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    MACTransmissionCounters.UUID = "00000248-0000-1000-8000-0026BB765291";
    return MACTransmissionCounters;
}(Characteristic_1.Characteristic));
exports.MACTransmissionCounters = MACTransmissionCounters;
Characteristic_1.Characteristic.MACTransmissionCounters = MACTransmissionCounters;
/**
 * Characteristic "Managed Network Enable"
 */
var ManagedNetworkEnable = /** @class */ (function (_super) {
    tslib_1.__extends(ManagedNetworkEnable, _super);
    function ManagedNetworkEnable() {
        var _this = _super.call(this, "Managed Network Enable", ManagedNetworkEnable.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */, "tw" /* TIMED_WRITE */],
            minValue: 0,
            maxValue: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ManagedNetworkEnable.UUID = "00000215-0000-1000-8000-0026BB765291";
    ManagedNetworkEnable.DISABLED = 0;
    ManagedNetworkEnable.ENABLED = 1;
    return ManagedNetworkEnable;
}(Characteristic_1.Characteristic));
exports.ManagedNetworkEnable = ManagedNetworkEnable;
Characteristic_1.Characteristic.ManagedNetworkEnable = ManagedNetworkEnable;
/**
 * Characteristic "Manually Disabled"
 */
var ManuallyDisabled = /** @class */ (function (_super) {
    tslib_1.__extends(ManuallyDisabled, _super);
    function ManuallyDisabled() {
        var _this = _super.call(this, "Manually Disabled", ManuallyDisabled.UUID, {
            format: "bool" /* BOOL */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ManuallyDisabled.UUID = "00000227-0000-1000-8000-0026BB765291";
    ManuallyDisabled.ENABLED = 0;
    ManuallyDisabled.DISABLED = 1;
    return ManuallyDisabled;
}(Characteristic_1.Characteristic));
exports.ManuallyDisabled = ManuallyDisabled;
Characteristic_1.Characteristic.ManuallyDisabled = ManuallyDisabled;
/**
 * Characteristic "Manufacturer"
 */
var Manufacturer = /** @class */ (function (_super) {
    tslib_1.__extends(Manufacturer, _super);
    function Manufacturer() {
        var _this = _super.call(this, "Manufacturer", Manufacturer.UUID, {
            format: "string" /* STRING */,
            perms: ["pr" /* PAIRED_READ */],
            maxLen: 64,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    Manufacturer.UUID = "00000020-0000-1000-8000-0026BB765291";
    return Manufacturer;
}(Characteristic_1.Characteristic));
exports.Manufacturer = Manufacturer;
Characteristic_1.Characteristic.Manufacturer = Manufacturer;
/**
 * Characteristic "Maximum Transmit Power"
 * @since iOS 14
 */
var MaximumTransmitPower = /** @class */ (function (_super) {
    tslib_1.__extends(MaximumTransmitPower, _super);
    function MaximumTransmitPower() {
        var _this = _super.call(this, "Maximum Transmit Power", MaximumTransmitPower.UUID, {
            format: "int" /* INT */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    MaximumTransmitPower.UUID = "00000243-0000-1000-8000-0026BB765291";
    return MaximumTransmitPower;
}(Characteristic_1.Characteristic));
exports.MaximumTransmitPower = MaximumTransmitPower;
Characteristic_1.Characteristic.MaximumTransmitPower = MaximumTransmitPower;
/**
 * Characteristic "Model"
 */
var Model = /** @class */ (function (_super) {
    tslib_1.__extends(Model, _super);
    function Model() {
        var _this = _super.call(this, "Model", Model.UUID, {
            format: "string" /* STRING */,
            perms: ["pr" /* PAIRED_READ */],
            maxLen: 64,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    Model.UUID = "00000021-0000-1000-8000-0026BB765291";
    return Model;
}(Characteristic_1.Characteristic));
exports.Model = Model;
Characteristic_1.Characteristic.Model = Model;
/**
 * Characteristic "Motion Detected"
 */
var MotionDetected = /** @class */ (function (_super) {
    tslib_1.__extends(MotionDetected, _super);
    function MotionDetected() {
        var _this = _super.call(this, "Motion Detected", MotionDetected.UUID, {
            format: "bool" /* BOOL */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    MotionDetected.UUID = "00000022-0000-1000-8000-0026BB765291";
    return MotionDetected;
}(Characteristic_1.Characteristic));
exports.MotionDetected = MotionDetected;
Characteristic_1.Characteristic.MotionDetected = MotionDetected;
/**
 * Characteristic "Mute"
 */
var Mute = /** @class */ (function (_super) {
    tslib_1.__extends(Mute, _super);
    function Mute() {
        var _this = _super.call(this, "Mute", Mute.UUID, {
            format: "bool" /* BOOL */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    Mute.UUID = "0000011A-0000-1000-8000-0026BB765291";
    return Mute;
}(Characteristic_1.Characteristic));
exports.Mute = Mute;
Characteristic_1.Characteristic.Mute = Mute;
/**
 * Characteristic "Name"
 */
var Name = /** @class */ (function (_super) {
    tslib_1.__extends(Name, _super);
    function Name() {
        var _this = _super.call(this, "Name", Name.UUID, {
            format: "string" /* STRING */,
            perms: ["pr" /* PAIRED_READ */],
            maxLen: 64,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    Name.UUID = "00000023-0000-1000-8000-0026BB765291";
    return Name;
}(Characteristic_1.Characteristic));
exports.Name = Name;
Characteristic_1.Characteristic.Name = Name;
/**
 * Characteristic "Network Access Violation Control"
 */
var NetworkAccessViolationControl = /** @class */ (function (_super) {
    tslib_1.__extends(NetworkAccessViolationControl, _super);
    function NetworkAccessViolationControl() {
        var _this = _super.call(this, "Network Access Violation Control", NetworkAccessViolationControl.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */, "tw" /* TIMED_WRITE */, "wr" /* WRITE_RESPONSE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    NetworkAccessViolationControl.UUID = "0000021F-0000-1000-8000-0026BB765291";
    return NetworkAccessViolationControl;
}(Characteristic_1.Characteristic));
exports.NetworkAccessViolationControl = NetworkAccessViolationControl;
Characteristic_1.Characteristic.NetworkAccessViolationControl = NetworkAccessViolationControl;
/**
 * Characteristic "Network Client Profile Control"
 */
var NetworkClientProfileControl = /** @class */ (function (_super) {
    tslib_1.__extends(NetworkClientProfileControl, _super);
    function NetworkClientProfileControl() {
        var _this = _super.call(this, "Network Client Profile Control", NetworkClientProfileControl.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */, "tw" /* TIMED_WRITE */, "wr" /* WRITE_RESPONSE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    NetworkClientProfileControl.UUID = "0000020C-0000-1000-8000-0026BB765291";
    return NetworkClientProfileControl;
}(Characteristic_1.Characteristic));
exports.NetworkClientProfileControl = NetworkClientProfileControl;
Characteristic_1.Characteristic.NetworkClientProfileControl = NetworkClientProfileControl;
/**
 * Characteristic "Network Client Status Control"
 */
var NetworkClientStatusControl = /** @class */ (function (_super) {
    tslib_1.__extends(NetworkClientStatusControl, _super);
    function NetworkClientStatusControl() {
        var _this = _super.call(this, "Network Client Status Control", NetworkClientStatusControl.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */, "wr" /* WRITE_RESPONSE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    NetworkClientStatusControl.UUID = "0000020D-0000-1000-8000-0026BB765291";
    return NetworkClientStatusControl;
}(Characteristic_1.Characteristic));
exports.NetworkClientStatusControl = NetworkClientStatusControl;
Characteristic_1.Characteristic.NetworkClientStatusControl = NetworkClientStatusControl;
/**
 * Characteristic "Night Vision"
 */
var NightVision = /** @class */ (function (_super) {
    tslib_1.__extends(NightVision, _super);
    function NightVision() {
        var _this = _super.call(this, "Night Vision", NightVision.UUID, {
            format: "bool" /* BOOL */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */, "tw" /* TIMED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    NightVision.UUID = "0000011B-0000-1000-8000-0026BB765291";
    return NightVision;
}(Characteristic_1.Characteristic));
exports.NightVision = NightVision;
Characteristic_1.Characteristic.NightVision = NightVision;
/**
 * Characteristic "Nitrogen Dioxide Density"
 */
var NitrogenDioxideDensity = /** @class */ (function (_super) {
    tslib_1.__extends(NitrogenDioxideDensity, _super);
    function NitrogenDioxideDensity() {
        var _this = _super.call(this, "Nitrogen Dioxide Density", NitrogenDioxideDensity.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 1000,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    NitrogenDioxideDensity.UUID = "000000C4-0000-1000-8000-0026BB765291";
    return NitrogenDioxideDensity;
}(Characteristic_1.Characteristic));
exports.NitrogenDioxideDensity = NitrogenDioxideDensity;
Characteristic_1.Characteristic.NitrogenDioxideDensity = NitrogenDioxideDensity;
/**
 * Characteristic "Obstruction Detected"
 */
var ObstructionDetected = /** @class */ (function (_super) {
    tslib_1.__extends(ObstructionDetected, _super);
    function ObstructionDetected() {
        var _this = _super.call(this, "Obstruction Detected", ObstructionDetected.UUID, {
            format: "bool" /* BOOL */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ObstructionDetected.UUID = "00000024-0000-1000-8000-0026BB765291";
    return ObstructionDetected;
}(Characteristic_1.Characteristic));
exports.ObstructionDetected = ObstructionDetected;
Characteristic_1.Characteristic.ObstructionDetected = ObstructionDetected;
/**
 * Characteristic "Occupancy Detected"
 */
var OccupancyDetected = /** @class */ (function (_super) {
    tslib_1.__extends(OccupancyDetected, _super);
    function OccupancyDetected() {
        var _this = _super.call(this, "Occupancy Detected", OccupancyDetected.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    OccupancyDetected.UUID = "00000071-0000-1000-8000-0026BB765291";
    OccupancyDetected.OCCUPANCY_NOT_DETECTED = 0;
    OccupancyDetected.OCCUPANCY_DETECTED = 1;
    return OccupancyDetected;
}(Characteristic_1.Characteristic));
exports.OccupancyDetected = OccupancyDetected;
Characteristic_1.Characteristic.OccupancyDetected = OccupancyDetected;
/**
 * Characteristic "On"
 */
var On = /** @class */ (function (_super) {
    tslib_1.__extends(On, _super);
    function On() {
        var _this = _super.call(this, "On", On.UUID, {
            format: "bool" /* BOOL */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    On.UUID = "00000025-0000-1000-8000-0026BB765291";
    return On;
}(Characteristic_1.Characteristic));
exports.On = On;
Characteristic_1.Characteristic.On = On;
/**
 * Characteristic "Operating State Response"
 * @since iOS 14
 */
var OperatingStateResponse = /** @class */ (function (_super) {
    tslib_1.__extends(OperatingStateResponse, _super);
    function OperatingStateResponse() {
        var _this = _super.call(this, "Operating State Response", OperatingStateResponse.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    OperatingStateResponse.UUID = "00000232-0000-1000-8000-0026BB765291";
    return OperatingStateResponse;
}(Characteristic_1.Characteristic));
exports.OperatingStateResponse = OperatingStateResponse;
Characteristic_1.Characteristic.OperatingStateResponse = OperatingStateResponse;
/**
 * Characteristic "Optical Zoom"
 */
var OpticalZoom = /** @class */ (function (_super) {
    tslib_1.__extends(OpticalZoom, _super);
    function OpticalZoom() {
        var _this = _super.call(this, "Optical Zoom", OpticalZoom.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minStep: 0.1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    OpticalZoom.UUID = "0000011C-0000-1000-8000-0026BB765291";
    return OpticalZoom;
}(Characteristic_1.Characteristic));
exports.OpticalZoom = OpticalZoom;
Characteristic_1.Characteristic.OpticalZoom = OpticalZoom;
/**
 * Characteristic "Outlet In Use"
 */
var OutletInUse = /** @class */ (function (_super) {
    tslib_1.__extends(OutletInUse, _super);
    function OutletInUse() {
        var _this = _super.call(this, "Outlet In Use", OutletInUse.UUID, {
            format: "bool" /* BOOL */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    OutletInUse.UUID = "00000026-0000-1000-8000-0026BB765291";
    return OutletInUse;
}(Characteristic_1.Characteristic));
exports.OutletInUse = OutletInUse;
Characteristic_1.Characteristic.OutletInUse = OutletInUse;
/**
 * Characteristic "Ozone Density"
 */
var OzoneDensity = /** @class */ (function (_super) {
    tslib_1.__extends(OzoneDensity, _super);
    function OzoneDensity() {
        var _this = _super.call(this, "Ozone Density", OzoneDensity.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 1000,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    OzoneDensity.UUID = "000000C3-0000-1000-8000-0026BB765291";
    return OzoneDensity;
}(Characteristic_1.Characteristic));
exports.OzoneDensity = OzoneDensity;
Characteristic_1.Characteristic.OzoneDensity = OzoneDensity;
/**
 * Characteristic "Pairing Features"
 */
var PairingFeatures = /** @class */ (function (_super) {
    tslib_1.__extends(PairingFeatures, _super);
    function PairingFeatures() {
        var _this = _super.call(this, "Pairing Features", PairingFeatures.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    PairingFeatures.UUID = "0000004F-0000-1000-8000-0026BB765291";
    return PairingFeatures;
}(Characteristic_1.Characteristic));
exports.PairingFeatures = PairingFeatures;
Characteristic_1.Characteristic.PairingFeatures = PairingFeatures;
/**
 * Characteristic "Pair Setup"
 */
var PairSetup = /** @class */ (function (_super) {
    tslib_1.__extends(PairSetup, _super);
    function PairSetup() {
        var _this = _super.call(this, "Pair Setup", PairSetup.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    PairSetup.UUID = "0000004C-0000-1000-8000-0026BB765291";
    return PairSetup;
}(Characteristic_1.Characteristic));
exports.PairSetup = PairSetup;
Characteristic_1.Characteristic.PairSetup = PairSetup;
/**
 * Characteristic "Pair Verify"
 */
var PairVerify = /** @class */ (function (_super) {
    tslib_1.__extends(PairVerify, _super);
    function PairVerify() {
        var _this = _super.call(this, "Pair Verify", PairVerify.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    PairVerify.UUID = "0000004E-0000-1000-8000-0026BB765291";
    return PairVerify;
}(Characteristic_1.Characteristic));
exports.PairVerify = PairVerify;
Characteristic_1.Characteristic.PairVerify = PairVerify;
/**
 * Characteristic "Password Setting"
 */
var PasswordSetting = /** @class */ (function (_super) {
    tslib_1.__extends(PasswordSetting, _super);
    function PasswordSetting() {
        var _this = _super.call(this, "Password Setting", PasswordSetting.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    PasswordSetting.UUID = "000000E4-0000-1000-8000-0026BB765291";
    return PasswordSetting;
}(Characteristic_1.Characteristic));
exports.PasswordSetting = PasswordSetting;
Characteristic_1.Characteristic.PasswordSetting = PasswordSetting;
/**
 * Characteristic "Periodic Snapshots Active"
 */
var PeriodicSnapshotsActive = /** @class */ (function (_super) {
    tslib_1.__extends(PeriodicSnapshotsActive, _super);
    function PeriodicSnapshotsActive() {
        var _this = _super.call(this, "Periodic Snapshots Active", PeriodicSnapshotsActive.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    PeriodicSnapshotsActive.UUID = "00000225-0000-1000-8000-0026BB765291";
    PeriodicSnapshotsActive.DISABLE = 0;
    PeriodicSnapshotsActive.ENABLE = 1;
    return PeriodicSnapshotsActive;
}(Characteristic_1.Characteristic));
exports.PeriodicSnapshotsActive = PeriodicSnapshotsActive;
Characteristic_1.Characteristic.PeriodicSnapshotsActive = PeriodicSnapshotsActive;
/**
 * Characteristic "Picture Mode"
 */
var PictureMode = /** @class */ (function (_super) {
    tslib_1.__extends(PictureMode, _super);
    function PictureMode() {
        var _this = _super.call(this, "Picture Mode", PictureMode.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 13,
            minStep: 1,
            validValues: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    PictureMode.UUID = "000000E2-0000-1000-8000-0026BB765291";
    PictureMode.OTHER = 0;
    PictureMode.STANDARD = 1;
    PictureMode.CALIBRATED = 2;
    PictureMode.CALIBRATED_DARK = 3;
    PictureMode.VIVID = 4;
    PictureMode.GAME = 5;
    PictureMode.COMPUTER = 6;
    PictureMode.CUSTOM = 7;
    return PictureMode;
}(Characteristic_1.Characteristic));
exports.PictureMode = PictureMode;
Characteristic_1.Characteristic.PictureMode = PictureMode;
/**
 * Characteristic "Ping"
 * @since iOS 14
 */
var Ping = /** @class */ (function (_super) {
    tslib_1.__extends(Ping, _super);
    function Ping() {
        var _this = _super.call(this, "Ping", Ping.UUID, {
            format: "data" /* DATA */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    Ping.UUID = "0000023C-0000-1000-8000-0026BB765291";
    return Ping;
}(Characteristic_1.Characteristic));
exports.Ping = Ping;
Characteristic_1.Characteristic.Ping = Ping;
/**
 * Characteristic "PM10 Density"
 */
var PM10Density = /** @class */ (function (_super) {
    tslib_1.__extends(PM10Density, _super);
    function PM10Density() {
        var _this = _super.call(this, "PM10 Density", PM10Density.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 1000,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    PM10Density.UUID = "000000C7-0000-1000-8000-0026BB765291";
    return PM10Density;
}(Characteristic_1.Characteristic));
exports.PM10Density = PM10Density;
Characteristic_1.Characteristic.PM10Density = PM10Density;
/**
 * Characteristic "PM2.5 Density"
 */
var PM2_5Density = /** @class */ (function (_super) {
    tslib_1.__extends(PM2_5Density, _super);
    function PM2_5Density() {
        var _this = _super.call(this, "PM2.5 Density", PM2_5Density.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 1000,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    PM2_5Density.UUID = "000000C6-0000-1000-8000-0026BB765291";
    return PM2_5Density;
}(Characteristic_1.Characteristic));
exports.PM2_5Density = PM2_5Density;
Characteristic_1.Characteristic.PM2_5Density = PM2_5Density;
/**
 * Characteristic "Position State"
 */
var PositionState = /** @class */ (function (_super) {
    tslib_1.__extends(PositionState, _super);
    function PositionState() {
        var _this = _super.call(this, "Position State", PositionState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 2,
            minStep: 1,
            validValues: [0, 1, 2],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    PositionState.UUID = "00000072-0000-1000-8000-0026BB765291";
    PositionState.DECREASING = 0;
    PositionState.INCREASING = 1;
    PositionState.STOPPED = 2;
    return PositionState;
}(Characteristic_1.Characteristic));
exports.PositionState = PositionState;
Characteristic_1.Characteristic.PositionState = PositionState;
/**
 * Characteristic "Power Mode Selection"
 */
var PowerModeSelection = /** @class */ (function (_super) {
    tslib_1.__extends(PowerModeSelection, _super);
    function PowerModeSelection() {
        var _this = _super.call(this, "Power Mode Selection", PowerModeSelection.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    PowerModeSelection.UUID = "000000DF-0000-1000-8000-0026BB765291";
    PowerModeSelection.SHOW = 0;
    PowerModeSelection.HIDE = 1;
    return PowerModeSelection;
}(Characteristic_1.Characteristic));
exports.PowerModeSelection = PowerModeSelection;
Characteristic_1.Characteristic.PowerModeSelection = PowerModeSelection;
/**
 * Characteristic "Product Data"
 */
var ProductData = /** @class */ (function (_super) {
    tslib_1.__extends(ProductData, _super);
    function ProductData() {
        var _this = _super.call(this, "Product Data", ProductData.UUID, {
            format: "data" /* DATA */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ProductData.UUID = "00000220-0000-1000-8000-0026BB765291";
    return ProductData;
}(Characteristic_1.Characteristic));
exports.ProductData = ProductData;
Characteristic_1.Characteristic.ProductData = ProductData;
/**
 * Characteristic "Programmable Switch Event"
 */
var ProgrammableSwitchEvent = /** @class */ (function (_super) {
    tslib_1.__extends(ProgrammableSwitchEvent, _super);
    function ProgrammableSwitchEvent() {
        var _this = _super.call(this, "Programmable Switch Event", ProgrammableSwitchEvent.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 2,
            minStep: 1,
            validValues: [0, 1, 2],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ProgrammableSwitchEvent.UUID = "00000073-0000-1000-8000-0026BB765291";
    ProgrammableSwitchEvent.SINGLE_PRESS = 0;
    ProgrammableSwitchEvent.DOUBLE_PRESS = 1;
    ProgrammableSwitchEvent.LONG_PRESS = 2;
    return ProgrammableSwitchEvent;
}(Characteristic_1.Characteristic));
exports.ProgrammableSwitchEvent = ProgrammableSwitchEvent;
Characteristic_1.Characteristic.ProgrammableSwitchEvent = ProgrammableSwitchEvent;
/**
 * Characteristic "Programmable Switch Output State"
 */
var ProgrammableSwitchOutputState = /** @class */ (function (_super) {
    tslib_1.__extends(ProgrammableSwitchOutputState, _super);
    function ProgrammableSwitchOutputState() {
        var _this = _super.call(this, "Programmable Switch Output State", ProgrammableSwitchOutputState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ProgrammableSwitchOutputState.UUID = "00000074-0000-1000-8000-0026BB765291";
    return ProgrammableSwitchOutputState;
}(Characteristic_1.Characteristic));
exports.ProgrammableSwitchOutputState = ProgrammableSwitchOutputState;
Characteristic_1.Characteristic.ProgrammableSwitchOutputState = ProgrammableSwitchOutputState;
/**
 * Characteristic "Program Mode"
 */
var ProgramMode = /** @class */ (function (_super) {
    tslib_1.__extends(ProgramMode, _super);
    function ProgramMode() {
        var _this = _super.call(this, "Program Mode", ProgramMode.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 2,
            minStep: 1,
            validValues: [0, 1, 2],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ProgramMode.UUID = "000000D1-0000-1000-8000-0026BB765291";
    ProgramMode.NO_PROGRAM_SCHEDULED = 0;
    ProgramMode.PROGRAM_SCHEDULED = 1;
    ProgramMode.PROGRAM_SCHEDULED_MANUAL_MODE_ = 2;
    return ProgramMode;
}(Characteristic_1.Characteristic));
exports.ProgramMode = ProgramMode;
Characteristic_1.Characteristic.ProgramMode = ProgramMode;
/**
 * Characteristic "Reachable"
 * @deprecated Removed and not used anymore
 */
var Reachable = /** @class */ (function (_super) {
    tslib_1.__extends(Reachable, _super);
    function Reachable() {
        var _this = _super.call(this, "Reachable", Reachable.UUID, {
            format: "bool" /* BOOL */,
            perms: ["pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    Reachable.UUID = "00000063-0000-1000-8000-0026BB765291";
    return Reachable;
}(Characteristic_1.Characteristic));
exports.Reachable = Reachable;
// noinspection JSDeprecatedSymbols
Characteristic_1.Characteristic.Reachable = Reachable;
/**
 * Characteristic "Received Signal Strength Indication"
 * @since iOS 14
 */
var ReceivedSignalStrengthIndication = /** @class */ (function (_super) {
    tslib_1.__extends(ReceivedSignalStrengthIndication, _super);
    function ReceivedSignalStrengthIndication() {
        var _this = _super.call(this, "Received Signal Strength Indication", ReceivedSignalStrengthIndication.UUID, {
            format: "int" /* INT */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ReceivedSignalStrengthIndication.UUID = "0000023F-0000-1000-8000-0026BB765291";
    return ReceivedSignalStrengthIndication;
}(Characteristic_1.Characteristic));
exports.ReceivedSignalStrengthIndication = ReceivedSignalStrengthIndication;
Characteristic_1.Characteristic.ReceivedSignalStrengthIndication = ReceivedSignalStrengthIndication;
/**
 * Characteristic "Receiver Sensitivity"
 * @since iOS 14
 */
var ReceiverSensitivity = /** @class */ (function (_super) {
    tslib_1.__extends(ReceiverSensitivity, _super);
    function ReceiverSensitivity() {
        var _this = _super.call(this, "Receiver Sensitivity", ReceiverSensitivity.UUID, {
            format: "int" /* INT */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ReceiverSensitivity.UUID = "00000244-0000-1000-8000-0026BB765291";
    return ReceiverSensitivity;
}(Characteristic_1.Characteristic));
exports.ReceiverSensitivity = ReceiverSensitivity;
Characteristic_1.Characteristic.ReceiverSensitivity = ReceiverSensitivity;
/**
 * Characteristic "Recording Audio Active"
 */
var RecordingAudioActive = /** @class */ (function (_super) {
    tslib_1.__extends(RecordingAudioActive, _super);
    function RecordingAudioActive() {
        var _this = _super.call(this, "Recording Audio Active", RecordingAudioActive.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */, "tw" /* TIMED_WRITE */],
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    RecordingAudioActive.UUID = "00000226-0000-1000-8000-0026BB765291";
    RecordingAudioActive.DISABLE = 0;
    RecordingAudioActive.ENABLE = 1;
    return RecordingAudioActive;
}(Characteristic_1.Characteristic));
exports.RecordingAudioActive = RecordingAudioActive;
Characteristic_1.Characteristic.RecordingAudioActive = RecordingAudioActive;
/**
 * Characteristic "Relative Humidity Dehumidifier Threshold"
 */
var RelativeHumidityDehumidifierThreshold = /** @class */ (function (_super) {
    tslib_1.__extends(RelativeHumidityDehumidifierThreshold, _super);
    function RelativeHumidityDehumidifierThreshold() {
        var _this = _super.call(this, "Relative Humidity Dehumidifier Threshold", RelativeHumidityDehumidifierThreshold.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            unit: "percentage" /* PERCENTAGE */,
            minValue: 0,
            maxValue: 100,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    RelativeHumidityDehumidifierThreshold.UUID = "000000C9-0000-1000-8000-0026BB765291";
    return RelativeHumidityDehumidifierThreshold;
}(Characteristic_1.Characteristic));
exports.RelativeHumidityDehumidifierThreshold = RelativeHumidityDehumidifierThreshold;
Characteristic_1.Characteristic.RelativeHumidityDehumidifierThreshold = RelativeHumidityDehumidifierThreshold;
/**
 * Characteristic "Relative Humidity Humidifier Threshold"
 */
var RelativeHumidityHumidifierThreshold = /** @class */ (function (_super) {
    tslib_1.__extends(RelativeHumidityHumidifierThreshold, _super);
    function RelativeHumidityHumidifierThreshold() {
        var _this = _super.call(this, "Relative Humidity Humidifier Threshold", RelativeHumidityHumidifierThreshold.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            unit: "percentage" /* PERCENTAGE */,
            minValue: 0,
            maxValue: 100,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    RelativeHumidityHumidifierThreshold.UUID = "000000CA-0000-1000-8000-0026BB765291";
    return RelativeHumidityHumidifierThreshold;
}(Characteristic_1.Characteristic));
exports.RelativeHumidityHumidifierThreshold = RelativeHumidityHumidifierThreshold;
Characteristic_1.Characteristic.RelativeHumidityHumidifierThreshold = RelativeHumidityHumidifierThreshold;
/**
 * Characteristic "Relay Control Point"
 */
var RelayControlPoint = /** @class */ (function (_super) {
    tslib_1.__extends(RelayControlPoint, _super);
    function RelayControlPoint() {
        var _this = _super.call(this, "Relay Control Point", RelayControlPoint.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    RelayControlPoint.UUID = "0000005E-0000-1000-8000-0026BB765291";
    return RelayControlPoint;
}(Characteristic_1.Characteristic));
exports.RelayControlPoint = RelayControlPoint;
Characteristic_1.Characteristic.RelayControlPoint = RelayControlPoint;
/**
 * Characteristic "Relay Enabled"
 */
var RelayEnabled = /** @class */ (function (_super) {
    tslib_1.__extends(RelayEnabled, _super);
    function RelayEnabled() {
        var _this = _super.call(this, "Relay Enabled", RelayEnabled.UUID, {
            format: "bool" /* BOOL */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    RelayEnabled.UUID = "0000005B-0000-1000-8000-0026BB765291";
    return RelayEnabled;
}(Characteristic_1.Characteristic));
exports.RelayEnabled = RelayEnabled;
Characteristic_1.Characteristic.RelayEnabled = RelayEnabled;
/**
 * Characteristic "Relay State"
 */
var RelayState = /** @class */ (function (_super) {
    tslib_1.__extends(RelayState, _super);
    function RelayState() {
        var _this = _super.call(this, "Relay State", RelayState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 5,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    RelayState.UUID = "0000005C-0000-1000-8000-0026BB765291";
    return RelayState;
}(Characteristic_1.Characteristic));
exports.RelayState = RelayState;
Characteristic_1.Characteristic.RelayState = RelayState;
/**
 * Characteristic "Remaining Duration"
 */
var RemainingDuration = /** @class */ (function (_super) {
    tslib_1.__extends(RemainingDuration, _super);
    function RemainingDuration() {
        var _this = _super.call(this, "Remaining Duration", RemainingDuration.UUID, {
            format: "uint32" /* UINT32 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            unit: "seconds" /* SECONDS */,
            minValue: 0,
            maxValue: 3600,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    RemainingDuration.UUID = "000000D4-0000-1000-8000-0026BB765291";
    return RemainingDuration;
}(Characteristic_1.Characteristic));
exports.RemainingDuration = RemainingDuration;
Characteristic_1.Characteristic.RemainingDuration = RemainingDuration;
/**
 * Characteristic "Remote Key"
 */
var RemoteKey = /** @class */ (function (_super) {
    tslib_1.__extends(RemoteKey, _super);
    function RemoteKey() {
        var _this = _super.call(this, "Remote Key", RemoteKey.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 16,
            minStep: 1,
            validValues: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    RemoteKey.UUID = "000000E1-0000-1000-8000-0026BB765291";
    RemoteKey.REWIND = 0;
    RemoteKey.FAST_FORWARD = 1;
    RemoteKey.NEXT_TRACK = 2;
    RemoteKey.PREVIOUS_TRACK = 3;
    RemoteKey.ARROW_UP = 4;
    RemoteKey.ARROW_DOWN = 5;
    RemoteKey.ARROW_LEFT = 6;
    RemoteKey.ARROW_RIGHT = 7;
    RemoteKey.SELECT = 8;
    RemoteKey.BACK = 9;
    RemoteKey.EXIT = 10;
    RemoteKey.PLAY_PAUSE = 11;
    RemoteKey.INFORMATION = 15;
    return RemoteKey;
}(Characteristic_1.Characteristic));
exports.RemoteKey = RemoteKey;
Characteristic_1.Characteristic.RemoteKey = RemoteKey;
/**
 * Characteristic "Reset Filter Indication"
 */
var ResetFilterIndication = /** @class */ (function (_super) {
    tslib_1.__extends(ResetFilterIndication, _super);
    function ResetFilterIndication() {
        var _this = _super.call(this, "Reset Filter Indication", ResetFilterIndication.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["pw" /* PAIRED_WRITE */],
            minValue: 1,
            maxValue: 1,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ResetFilterIndication.UUID = "000000AD-0000-1000-8000-0026BB765291";
    return ResetFilterIndication;
}(Characteristic_1.Characteristic));
exports.ResetFilterIndication = ResetFilterIndication;
Characteristic_1.Characteristic.ResetFilterIndication = ResetFilterIndication;
/**
 * Characteristic "Rotation Direction"
 */
var RotationDirection = /** @class */ (function (_super) {
    tslib_1.__extends(RotationDirection, _super);
    function RotationDirection() {
        var _this = _super.call(this, "Rotation Direction", RotationDirection.UUID, {
            format: "int" /* INT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    RotationDirection.UUID = "00000028-0000-1000-8000-0026BB765291";
    RotationDirection.CLOCKWISE = 0;
    RotationDirection.COUNTER_CLOCKWISE = 1;
    return RotationDirection;
}(Characteristic_1.Characteristic));
exports.RotationDirection = RotationDirection;
Characteristic_1.Characteristic.RotationDirection = RotationDirection;
/**
 * Characteristic "Rotation Speed"
 */
var RotationSpeed = /** @class */ (function (_super) {
    tslib_1.__extends(RotationSpeed, _super);
    function RotationSpeed() {
        var _this = _super.call(this, "Rotation Speed", RotationSpeed.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            unit: "percentage" /* PERCENTAGE */,
            minValue: 0,
            maxValue: 100,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    RotationSpeed.UUID = "00000029-0000-1000-8000-0026BB765291";
    return RotationSpeed;
}(Characteristic_1.Characteristic));
exports.RotationSpeed = RotationSpeed;
Characteristic_1.Characteristic.RotationSpeed = RotationSpeed;
/**
 * Characteristic "Router Status"
 */
var RouterStatus = /** @class */ (function (_super) {
    tslib_1.__extends(RouterStatus, _super);
    function RouterStatus() {
        var _this = _super.call(this, "Router Status", RouterStatus.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    RouterStatus.UUID = "0000020E-0000-1000-8000-0026BB765291";
    RouterStatus.READY = 0;
    RouterStatus.NOT_READY = 1;
    return RouterStatus;
}(Characteristic_1.Characteristic));
exports.RouterStatus = RouterStatus;
Characteristic_1.Characteristic.RouterStatus = RouterStatus;
/**
 * Characteristic "Saturation"
 */
var Saturation = /** @class */ (function (_super) {
    tslib_1.__extends(Saturation, _super);
    function Saturation() {
        var _this = _super.call(this, "Saturation", Saturation.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            unit: "percentage" /* PERCENTAGE */,
            minValue: 0,
            maxValue: 100,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    Saturation.UUID = "0000002F-0000-1000-8000-0026BB765291";
    return Saturation;
}(Characteristic_1.Characteristic));
exports.Saturation = Saturation;
Characteristic_1.Characteristic.Saturation = Saturation;
/**
 * Characteristic "Security System Alarm Type"
 */
var SecuritySystemAlarmType = /** @class */ (function (_super) {
    tslib_1.__extends(SecuritySystemAlarmType, _super);
    function SecuritySystemAlarmType() {
        var _this = _super.call(this, "Security System Alarm Type", SecuritySystemAlarmType.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SecuritySystemAlarmType.UUID = "0000008E-0000-1000-8000-0026BB765291";
    return SecuritySystemAlarmType;
}(Characteristic_1.Characteristic));
exports.SecuritySystemAlarmType = SecuritySystemAlarmType;
Characteristic_1.Characteristic.SecuritySystemAlarmType = SecuritySystemAlarmType;
/**
 * Characteristic "Security System Current State"
 */
var SecuritySystemCurrentState = /** @class */ (function (_super) {
    tslib_1.__extends(SecuritySystemCurrentState, _super);
    function SecuritySystemCurrentState() {
        var _this = _super.call(this, "Security System Current State", SecuritySystemCurrentState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 4,
            minStep: 1,
            validValues: [0, 1, 2, 3, 4],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SecuritySystemCurrentState.UUID = "00000066-0000-1000-8000-0026BB765291";
    SecuritySystemCurrentState.STAY_ARM = 0;
    SecuritySystemCurrentState.AWAY_ARM = 1;
    SecuritySystemCurrentState.NIGHT_ARM = 2;
    SecuritySystemCurrentState.DISARMED = 3;
    SecuritySystemCurrentState.ALARM_TRIGGERED = 4;
    return SecuritySystemCurrentState;
}(Characteristic_1.Characteristic));
exports.SecuritySystemCurrentState = SecuritySystemCurrentState;
Characteristic_1.Characteristic.SecuritySystemCurrentState = SecuritySystemCurrentState;
/**
 * Characteristic "Security System Target State"
 */
var SecuritySystemTargetState = /** @class */ (function (_super) {
    tslib_1.__extends(SecuritySystemTargetState, _super);
    function SecuritySystemTargetState() {
        var _this = _super.call(this, "Security System Target State", SecuritySystemTargetState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 3,
            minStep: 1,
            validValues: [0, 1, 2, 3],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SecuritySystemTargetState.UUID = "00000067-0000-1000-8000-0026BB765291";
    SecuritySystemTargetState.STAY_ARM = 0;
    SecuritySystemTargetState.AWAY_ARM = 1;
    SecuritySystemTargetState.NIGHT_ARM = 2;
    SecuritySystemTargetState.DISARM = 3;
    return SecuritySystemTargetState;
}(Characteristic_1.Characteristic));
exports.SecuritySystemTargetState = SecuritySystemTargetState;
Characteristic_1.Characteristic.SecuritySystemTargetState = SecuritySystemTargetState;
/**
 * Characteristic "Selected Audio Stream Configuration"
 */
var SelectedAudioStreamConfiguration = /** @class */ (function (_super) {
    tslib_1.__extends(SelectedAudioStreamConfiguration, _super);
    function SelectedAudioStreamConfiguration() {
        var _this = _super.call(this, "Selected Audio Stream Configuration", SelectedAudioStreamConfiguration.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SelectedAudioStreamConfiguration.UUID = "00000128-0000-1000-8000-0026BB765291";
    return SelectedAudioStreamConfiguration;
}(Characteristic_1.Characteristic));
exports.SelectedAudioStreamConfiguration = SelectedAudioStreamConfiguration;
Characteristic_1.Characteristic.SelectedAudioStreamConfiguration = SelectedAudioStreamConfiguration;
/**
 * Characteristic "Selected Camera Recording Configuration"
 */
var SelectedCameraRecordingConfiguration = /** @class */ (function (_super) {
    tslib_1.__extends(SelectedCameraRecordingConfiguration, _super);
    function SelectedCameraRecordingConfiguration() {
        var _this = _super.call(this, "Selected Camera Recording Configuration", SelectedCameraRecordingConfiguration.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SelectedCameraRecordingConfiguration.UUID = "00000209-0000-1000-8000-0026BB765291";
    return SelectedCameraRecordingConfiguration;
}(Characteristic_1.Characteristic));
exports.SelectedCameraRecordingConfiguration = SelectedCameraRecordingConfiguration;
Characteristic_1.Characteristic.SelectedCameraRecordingConfiguration = SelectedCameraRecordingConfiguration;
/**
 * Characteristic "Selected RTP Stream Configuration"
 */
var SelectedRTPStreamConfiguration = /** @class */ (function (_super) {
    tslib_1.__extends(SelectedRTPStreamConfiguration, _super);
    function SelectedRTPStreamConfiguration() {
        var _this = _super.call(this, "Selected RTP Stream Configuration", SelectedRTPStreamConfiguration.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SelectedRTPStreamConfiguration.UUID = "00000117-0000-1000-8000-0026BB765291";
    return SelectedRTPStreamConfiguration;
}(Characteristic_1.Characteristic));
exports.SelectedRTPStreamConfiguration = SelectedRTPStreamConfiguration;
Characteristic_1.Characteristic.SelectedRTPStreamConfiguration = SelectedRTPStreamConfiguration;
/**
 * Characteristic "Serial Number"
 */
var SerialNumber = /** @class */ (function (_super) {
    tslib_1.__extends(SerialNumber, _super);
    function SerialNumber() {
        var _this = _super.call(this, "Serial Number", SerialNumber.UUID, {
            format: "string" /* STRING */,
            perms: ["pr" /* PAIRED_READ */],
            maxLen: 64,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SerialNumber.UUID = "00000030-0000-1000-8000-0026BB765291";
    return SerialNumber;
}(Characteristic_1.Characteristic));
exports.SerialNumber = SerialNumber;
Characteristic_1.Characteristic.SerialNumber = SerialNumber;
/**
 * Characteristic "Service Label Index"
 */
var ServiceLabelIndex = /** @class */ (function (_super) {
    tslib_1.__extends(ServiceLabelIndex, _super);
    function ServiceLabelIndex() {
        var _this = _super.call(this, "Service Label Index", ServiceLabelIndex.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["pr" /* PAIRED_READ */],
            minValue: 1,
            maxValue: 255,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ServiceLabelIndex.UUID = "000000CB-0000-1000-8000-0026BB765291";
    return ServiceLabelIndex;
}(Characteristic_1.Characteristic));
exports.ServiceLabelIndex = ServiceLabelIndex;
Characteristic_1.Characteristic.ServiceLabelIndex = ServiceLabelIndex;
/**
 * Characteristic "Service Label Namespace"
 */
var ServiceLabelNamespace = /** @class */ (function (_super) {
    tslib_1.__extends(ServiceLabelNamespace, _super);
    function ServiceLabelNamespace() {
        var _this = _super.call(this, "Service Label Namespace", ServiceLabelNamespace.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ServiceLabelNamespace.UUID = "000000CD-0000-1000-8000-0026BB765291";
    ServiceLabelNamespace.DOTS = 0;
    ServiceLabelNamespace.ARABIC_NUMERALS = 1;
    return ServiceLabelNamespace;
}(Characteristic_1.Characteristic));
exports.ServiceLabelNamespace = ServiceLabelNamespace;
Characteristic_1.Characteristic.ServiceLabelNamespace = ServiceLabelNamespace;
/**
 * Characteristic "Set Duration"
 */
var SetDuration = /** @class */ (function (_super) {
    tslib_1.__extends(SetDuration, _super);
    function SetDuration() {
        var _this = _super.call(this, "Set Duration", SetDuration.UUID, {
            format: "uint32" /* UINT32 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            unit: "seconds" /* SECONDS */,
            minValue: 0,
            maxValue: 3600,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SetDuration.UUID = "000000D3-0000-1000-8000-0026BB765291";
    return SetDuration;
}(Characteristic_1.Characteristic));
exports.SetDuration = SetDuration;
Characteristic_1.Characteristic.SetDuration = SetDuration;
/**
 * Characteristic "Setup Data Stream Transport"
 */
var SetupDataStreamTransport = /** @class */ (function (_super) {
    tslib_1.__extends(SetupDataStreamTransport, _super);
    function SetupDataStreamTransport() {
        var _this = _super.call(this, "Setup Data Stream Transport", SetupDataStreamTransport.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */, "wr" /* WRITE_RESPONSE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SetupDataStreamTransport.UUID = "00000131-0000-1000-8000-0026BB765291";
    return SetupDataStreamTransport;
}(Characteristic_1.Characteristic));
exports.SetupDataStreamTransport = SetupDataStreamTransport;
Characteristic_1.Characteristic.SetupDataStreamTransport = SetupDataStreamTransport;
/**
 * Characteristic "Setup Endpoints"
 */
var SetupEndpoints = /** @class */ (function (_super) {
    tslib_1.__extends(SetupEndpoints, _super);
    function SetupEndpoints() {
        var _this = _super.call(this, "Setup Endpoints", SetupEndpoints.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SetupEndpoints.UUID = "00000118-0000-1000-8000-0026BB765291";
    return SetupEndpoints;
}(Characteristic_1.Characteristic));
exports.SetupEndpoints = SetupEndpoints;
Characteristic_1.Characteristic.SetupEndpoints = SetupEndpoints;
/**
 * Characteristic "Setup Transfer Transport"
 * @since iOS 13.4
 */
var SetupTransferTransport = /** @class */ (function (_super) {
    tslib_1.__extends(SetupTransferTransport, _super);
    function SetupTransferTransport() {
        var _this = _super.call(this, "Setup Transfer Transport", SetupTransferTransport.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pw" /* PAIRED_WRITE */, "wr" /* WRITE_RESPONSE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SetupTransferTransport.UUID = "00000201-0000-1000-8000-0026BB765291";
    return SetupTransferTransport;
}(Characteristic_1.Characteristic));
exports.SetupTransferTransport = SetupTransferTransport;
Characteristic_1.Characteristic.SetupTransferTransport = SetupTransferTransport;
/**
 * Characteristic "Signal To Noise Ratio"
 * @since iOS 14
 */
var SignalToNoiseRatio = /** @class */ (function (_super) {
    tslib_1.__extends(SignalToNoiseRatio, _super);
    function SignalToNoiseRatio() {
        var _this = _super.call(this, "Signal To Noise Ratio", SignalToNoiseRatio.UUID, {
            format: "int" /* INT */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SignalToNoiseRatio.UUID = "00000241-0000-1000-8000-0026BB765291";
    return SignalToNoiseRatio;
}(Characteristic_1.Characteristic));
exports.SignalToNoiseRatio = SignalToNoiseRatio;
Characteristic_1.Characteristic.SignalToNoiseRatio = SignalToNoiseRatio;
/**
 * Characteristic "Siri Input Type"
 */
var SiriInputType = /** @class */ (function (_super) {
    tslib_1.__extends(SiriInputType, _super);
    function SiriInputType() {
        var _this = _super.call(this, "Siri Input Type", SiriInputType.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 0,
            validValues: [0],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SiriInputType.UUID = "00000132-0000-1000-8000-0026BB765291";
    SiriInputType.PUSH_BUTTON_TRIGGERED_APPLE_TV = 0;
    return SiriInputType;
}(Characteristic_1.Characteristic));
exports.SiriInputType = SiriInputType;
Characteristic_1.Characteristic.SiriInputType = SiriInputType;
/**
 * Characteristic "Slat Type"
 */
var SlatType = /** @class */ (function (_super) {
    tslib_1.__extends(SlatType, _super);
    function SlatType() {
        var _this = _super.call(this, "Slat Type", SlatType.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SlatType.UUID = "000000C0-0000-1000-8000-0026BB765291";
    SlatType.HORIZONTAL = 0;
    SlatType.VERTICAL = 1;
    return SlatType;
}(Characteristic_1.Characteristic));
exports.SlatType = SlatType;
Characteristic_1.Characteristic.SlatType = SlatType;
/**
 * Characteristic "Sleep Discovery Mode"
 */
var SleepDiscoveryMode = /** @class */ (function (_super) {
    tslib_1.__extends(SleepDiscoveryMode, _super);
    function SleepDiscoveryMode() {
        var _this = _super.call(this, "Sleep Discovery Mode", SleepDiscoveryMode.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SleepDiscoveryMode.UUID = "000000E8-0000-1000-8000-0026BB765291";
    SleepDiscoveryMode.NOT_DISCOVERABLE = 0;
    SleepDiscoveryMode.ALWAYS_DISCOVERABLE = 1;
    return SleepDiscoveryMode;
}(Characteristic_1.Characteristic));
exports.SleepDiscoveryMode = SleepDiscoveryMode;
Characteristic_1.Characteristic.SleepDiscoveryMode = SleepDiscoveryMode;
/**
 * Characteristic "Sleep Interval"
 * @since iOS 14
 */
var SleepInterval = /** @class */ (function (_super) {
    tslib_1.__extends(SleepInterval, _super);
    function SleepInterval() {
        var _this = _super.call(this, "Sleep Interval", SleepInterval.UUID, {
            format: "uint32" /* UINT32 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SleepInterval.UUID = "0000023A-0000-1000-8000-0026BB765291";
    return SleepInterval;
}(Characteristic_1.Characteristic));
exports.SleepInterval = SleepInterval;
Characteristic_1.Characteristic.SleepInterval = SleepInterval;
/**
 * Characteristic "Smoke Detected"
 */
var SmokeDetected = /** @class */ (function (_super) {
    tslib_1.__extends(SmokeDetected, _super);
    function SmokeDetected() {
        var _this = _super.call(this, "Smoke Detected", SmokeDetected.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SmokeDetected.UUID = "00000076-0000-1000-8000-0026BB765291";
    SmokeDetected.SMOKE_NOT_DETECTED = 0;
    SmokeDetected.SMOKE_DETECTED = 1;
    return SmokeDetected;
}(Characteristic_1.Characteristic));
exports.SmokeDetected = SmokeDetected;
Characteristic_1.Characteristic.SmokeDetected = SmokeDetected;
/**
 * Characteristic "Software Revision"
 */
var SoftwareRevision = /** @class */ (function (_super) {
    tslib_1.__extends(SoftwareRevision, _super);
    function SoftwareRevision() {
        var _this = _super.call(this, "Software Revision", SoftwareRevision.UUID, {
            format: "string" /* STRING */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SoftwareRevision.UUID = "00000054-0000-1000-8000-0026BB765291";
    return SoftwareRevision;
}(Characteristic_1.Characteristic));
exports.SoftwareRevision = SoftwareRevision;
Characteristic_1.Characteristic.SoftwareRevision = SoftwareRevision;
/**
 * Characteristic "Staged Firmware Version"
 */
var StagedFirmwareVersion = /** @class */ (function (_super) {
    tslib_1.__extends(StagedFirmwareVersion, _super);
    function StagedFirmwareVersion() {
        var _this = _super.call(this, "Staged Firmware Version", StagedFirmwareVersion.UUID, {
            format: "string" /* STRING */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    StagedFirmwareVersion.UUID = "00000249-0000-1000-8000-0026BB765291";
    return StagedFirmwareVersion;
}(Characteristic_1.Characteristic));
exports.StagedFirmwareVersion = StagedFirmwareVersion;
Characteristic_1.Characteristic.StagedFirmwareVersion = StagedFirmwareVersion;
/**
 * Characteristic "Status Active"
 */
var StatusActive = /** @class */ (function (_super) {
    tslib_1.__extends(StatusActive, _super);
    function StatusActive() {
        var _this = _super.call(this, "Status Active", StatusActive.UUID, {
            format: "bool" /* BOOL */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    StatusActive.UUID = "00000075-0000-1000-8000-0026BB765291";
    return StatusActive;
}(Characteristic_1.Characteristic));
exports.StatusActive = StatusActive;
Characteristic_1.Characteristic.StatusActive = StatusActive;
/**
 * Characteristic "Status Fault"
 */
var StatusFault = /** @class */ (function (_super) {
    tslib_1.__extends(StatusFault, _super);
    function StatusFault() {
        var _this = _super.call(this, "Status Fault", StatusFault.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    StatusFault.UUID = "00000077-0000-1000-8000-0026BB765291";
    StatusFault.NO_FAULT = 0;
    StatusFault.GENERAL_FAULT = 1;
    return StatusFault;
}(Characteristic_1.Characteristic));
exports.StatusFault = StatusFault;
Characteristic_1.Characteristic.StatusFault = StatusFault;
/**
 * Characteristic "Status Jammed"
 */
var StatusJammed = /** @class */ (function (_super) {
    tslib_1.__extends(StatusJammed, _super);
    function StatusJammed() {
        var _this = _super.call(this, "Status Jammed", StatusJammed.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    StatusJammed.UUID = "00000078-0000-1000-8000-0026BB765291";
    StatusJammed.NOT_JAMMED = 0;
    StatusJammed.JAMMED = 1;
    return StatusJammed;
}(Characteristic_1.Characteristic));
exports.StatusJammed = StatusJammed;
Characteristic_1.Characteristic.StatusJammed = StatusJammed;
/**
 * Characteristic "Status Low Battery"
 */
var StatusLowBattery = /** @class */ (function (_super) {
    tslib_1.__extends(StatusLowBattery, _super);
    function StatusLowBattery() {
        var _this = _super.call(this, "Status Low Battery", StatusLowBattery.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    StatusLowBattery.UUID = "00000079-0000-1000-8000-0026BB765291";
    StatusLowBattery.BATTERY_LEVEL_NORMAL = 0;
    StatusLowBattery.BATTERY_LEVEL_LOW = 1;
    return StatusLowBattery;
}(Characteristic_1.Characteristic));
exports.StatusLowBattery = StatusLowBattery;
Characteristic_1.Characteristic.StatusLowBattery = StatusLowBattery;
/**
 * Characteristic "Status Tampered"
 */
var StatusTampered = /** @class */ (function (_super) {
    tslib_1.__extends(StatusTampered, _super);
    function StatusTampered() {
        var _this = _super.call(this, "Status Tampered", StatusTampered.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    StatusTampered.UUID = "0000007A-0000-1000-8000-0026BB765291";
    StatusTampered.NOT_TAMPERED = 0;
    StatusTampered.TAMPERED = 1;
    return StatusTampered;
}(Characteristic_1.Characteristic));
exports.StatusTampered = StatusTampered;
Characteristic_1.Characteristic.StatusTampered = StatusTampered;
/**
 * Characteristic "Streaming Status"
 */
var StreamingStatus = /** @class */ (function (_super) {
    tslib_1.__extends(StreamingStatus, _super);
    function StreamingStatus() {
        var _this = _super.call(this, "Streaming Status", StreamingStatus.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    StreamingStatus.UUID = "00000120-0000-1000-8000-0026BB765291";
    return StreamingStatus;
}(Characteristic_1.Characteristic));
exports.StreamingStatus = StreamingStatus;
Characteristic_1.Characteristic.StreamingStatus = StreamingStatus;
/**
 * Characteristic "Sulphur Dioxide Density"
 */
var SulphurDioxideDensity = /** @class */ (function (_super) {
    tslib_1.__extends(SulphurDioxideDensity, _super);
    function SulphurDioxideDensity() {
        var _this = _super.call(this, "Sulphur Dioxide Density", SulphurDioxideDensity.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 1000,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SulphurDioxideDensity.UUID = "000000C5-0000-1000-8000-0026BB765291";
    return SulphurDioxideDensity;
}(Characteristic_1.Characteristic));
exports.SulphurDioxideDensity = SulphurDioxideDensity;
Characteristic_1.Characteristic.SulphurDioxideDensity = SulphurDioxideDensity;
/**
 * Characteristic "Supported Audio Recording Configuration"
 */
var SupportedAudioRecordingConfiguration = /** @class */ (function (_super) {
    tslib_1.__extends(SupportedAudioRecordingConfiguration, _super);
    function SupportedAudioRecordingConfiguration() {
        var _this = _super.call(this, "Supported Audio Recording Configuration", SupportedAudioRecordingConfiguration.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SupportedAudioRecordingConfiguration.UUID = "00000207-0000-1000-8000-0026BB765291";
    return SupportedAudioRecordingConfiguration;
}(Characteristic_1.Characteristic));
exports.SupportedAudioRecordingConfiguration = SupportedAudioRecordingConfiguration;
Characteristic_1.Characteristic.SupportedAudioRecordingConfiguration = SupportedAudioRecordingConfiguration;
/**
 * Characteristic "Supported Audio Stream Configuration"
 */
var SupportedAudioStreamConfiguration = /** @class */ (function (_super) {
    tslib_1.__extends(SupportedAudioStreamConfiguration, _super);
    function SupportedAudioStreamConfiguration() {
        var _this = _super.call(this, "Supported Audio Stream Configuration", SupportedAudioStreamConfiguration.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SupportedAudioStreamConfiguration.UUID = "00000115-0000-1000-8000-0026BB765291";
    return SupportedAudioStreamConfiguration;
}(Characteristic_1.Characteristic));
exports.SupportedAudioStreamConfiguration = SupportedAudioStreamConfiguration;
Characteristic_1.Characteristic.SupportedAudioStreamConfiguration = SupportedAudioStreamConfiguration;
/**
 * Characteristic "Supported Camera Recording Configuration"
 */
var SupportedCameraRecordingConfiguration = /** @class */ (function (_super) {
    tslib_1.__extends(SupportedCameraRecordingConfiguration, _super);
    function SupportedCameraRecordingConfiguration() {
        var _this = _super.call(this, "Supported Camera Recording Configuration", SupportedCameraRecordingConfiguration.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SupportedCameraRecordingConfiguration.UUID = "00000205-0000-1000-8000-0026BB765291";
    return SupportedCameraRecordingConfiguration;
}(Characteristic_1.Characteristic));
exports.SupportedCameraRecordingConfiguration = SupportedCameraRecordingConfiguration;
Characteristic_1.Characteristic.SupportedCameraRecordingConfiguration = SupportedCameraRecordingConfiguration;
/**
 * Characteristic "Supported Characteristic Value Transition Configuration"
 * @since iOS 14
 */
var SupportedCharacteristicValueTransitionConfiguration = /** @class */ (function (_super) {
    tslib_1.__extends(SupportedCharacteristicValueTransitionConfiguration, _super);
    function SupportedCharacteristicValueTransitionConfiguration() {
        var _this = _super.call(this, "Supported Characteristic Value Transition Configuration", SupportedCharacteristicValueTransitionConfiguration.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SupportedCharacteristicValueTransitionConfiguration.UUID = "00000144-0000-1000-8000-0026BB765291";
    return SupportedCharacteristicValueTransitionConfiguration;
}(Characteristic_1.Characteristic));
exports.SupportedCharacteristicValueTransitionConfiguration = SupportedCharacteristicValueTransitionConfiguration;
Characteristic_1.Characteristic.SupportedCharacteristicValueTransitionConfiguration = SupportedCharacteristicValueTransitionConfiguration;
/**
 * Characteristic "Supported Data Stream Transport Configuration"
 */
var SupportedDataStreamTransportConfiguration = /** @class */ (function (_super) {
    tslib_1.__extends(SupportedDataStreamTransportConfiguration, _super);
    function SupportedDataStreamTransportConfiguration() {
        var _this = _super.call(this, "Supported Data Stream Transport Configuration", SupportedDataStreamTransportConfiguration.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SupportedDataStreamTransportConfiguration.UUID = "00000130-0000-1000-8000-0026BB765291";
    return SupportedDataStreamTransportConfiguration;
}(Characteristic_1.Characteristic));
exports.SupportedDataStreamTransportConfiguration = SupportedDataStreamTransportConfiguration;
Characteristic_1.Characteristic.SupportedDataStreamTransportConfiguration = SupportedDataStreamTransportConfiguration;
/**
 * Characteristic "Supported Diagnostics Snapshot"
 * @since iOS 14
 */
var SupportedDiagnosticsSnapshot = /** @class */ (function (_super) {
    tslib_1.__extends(SupportedDiagnosticsSnapshot, _super);
    function SupportedDiagnosticsSnapshot() {
        var _this = _super.call(this, "Supported Diagnostics Snapshot", SupportedDiagnosticsSnapshot.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SupportedDiagnosticsSnapshot.UUID = "00000238-0000-1000-8000-0026BB765291";
    return SupportedDiagnosticsSnapshot;
}(Characteristic_1.Characteristic));
exports.SupportedDiagnosticsSnapshot = SupportedDiagnosticsSnapshot;
Characteristic_1.Characteristic.SupportedDiagnosticsSnapshot = SupportedDiagnosticsSnapshot;
/**
 * Characteristic "Supported Firmware Update Configuration"
 */
var SupportedFirmwareUpdateConfiguration = /** @class */ (function (_super) {
    tslib_1.__extends(SupportedFirmwareUpdateConfiguration, _super);
    function SupportedFirmwareUpdateConfiguration() {
        var _this = _super.call(this, "Supported Firmware Update Configuration", SupportedFirmwareUpdateConfiguration.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SupportedFirmwareUpdateConfiguration.UUID = "00000233-0000-1000-8000-0026BB765291";
    return SupportedFirmwareUpdateConfiguration;
}(Characteristic_1.Characteristic));
exports.SupportedFirmwareUpdateConfiguration = SupportedFirmwareUpdateConfiguration;
Characteristic_1.Characteristic.SupportedFirmwareUpdateConfiguration = SupportedFirmwareUpdateConfiguration;
/**
 * Characteristic "Supported Router Configuration"
 */
var SupportedRouterConfiguration = /** @class */ (function (_super) {
    tslib_1.__extends(SupportedRouterConfiguration, _super);
    function SupportedRouterConfiguration() {
        var _this = _super.call(this, "Supported Router Configuration", SupportedRouterConfiguration.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SupportedRouterConfiguration.UUID = "00000210-0000-1000-8000-0026BB765291";
    return SupportedRouterConfiguration;
}(Characteristic_1.Characteristic));
exports.SupportedRouterConfiguration = SupportedRouterConfiguration;
Characteristic_1.Characteristic.SupportedRouterConfiguration = SupportedRouterConfiguration;
/**
 * Characteristic "Supported RTP Configuration"
 */
var SupportedRTPConfiguration = /** @class */ (function (_super) {
    tslib_1.__extends(SupportedRTPConfiguration, _super);
    function SupportedRTPConfiguration() {
        var _this = _super.call(this, "Supported RTP Configuration", SupportedRTPConfiguration.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SupportedRTPConfiguration.UUID = "00000116-0000-1000-8000-0026BB765291";
    return SupportedRTPConfiguration;
}(Characteristic_1.Characteristic));
exports.SupportedRTPConfiguration = SupportedRTPConfiguration;
Characteristic_1.Characteristic.SupportedRTPConfiguration = SupportedRTPConfiguration;
/**
 * Characteristic "Supported Transfer Transport Configuration"
 * @since iOS 13.4
 */
var SupportedTransferTransportConfiguration = /** @class */ (function (_super) {
    tslib_1.__extends(SupportedTransferTransportConfiguration, _super);
    function SupportedTransferTransportConfiguration() {
        var _this = _super.call(this, "Supported Transfer Transport Configuration", SupportedTransferTransportConfiguration.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SupportedTransferTransportConfiguration.UUID = "00000202-0000-1000-8000-0026BB765291";
    return SupportedTransferTransportConfiguration;
}(Characteristic_1.Characteristic));
exports.SupportedTransferTransportConfiguration = SupportedTransferTransportConfiguration;
Characteristic_1.Characteristic.SupportedTransferTransportConfiguration = SupportedTransferTransportConfiguration;
/**
 * Characteristic "Supported Video Recording Configuration"
 */
var SupportedVideoRecordingConfiguration = /** @class */ (function (_super) {
    tslib_1.__extends(SupportedVideoRecordingConfiguration, _super);
    function SupportedVideoRecordingConfiguration() {
        var _this = _super.call(this, "Supported Video Recording Configuration", SupportedVideoRecordingConfiguration.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SupportedVideoRecordingConfiguration.UUID = "00000206-0000-1000-8000-0026BB765291";
    return SupportedVideoRecordingConfiguration;
}(Characteristic_1.Characteristic));
exports.SupportedVideoRecordingConfiguration = SupportedVideoRecordingConfiguration;
Characteristic_1.Characteristic.SupportedVideoRecordingConfiguration = SupportedVideoRecordingConfiguration;
/**
 * Characteristic "Supported Video Stream Configuration"
 */
var SupportedVideoStreamConfiguration = /** @class */ (function (_super) {
    tslib_1.__extends(SupportedVideoStreamConfiguration, _super);
    function SupportedVideoStreamConfiguration() {
        var _this = _super.call(this, "Supported Video Stream Configuration", SupportedVideoStreamConfiguration.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SupportedVideoStreamConfiguration.UUID = "00000114-0000-1000-8000-0026BB765291";
    return SupportedVideoStreamConfiguration;
}(Characteristic_1.Characteristic));
exports.SupportedVideoStreamConfiguration = SupportedVideoStreamConfiguration;
Characteristic_1.Characteristic.SupportedVideoStreamConfiguration = SupportedVideoStreamConfiguration;
/**
 * Characteristic "Swing Mode"
 */
var SwingMode = /** @class */ (function (_super) {
    tslib_1.__extends(SwingMode, _super);
    function SwingMode() {
        var _this = _super.call(this, "Swing Mode", SwingMode.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    SwingMode.UUID = "000000B6-0000-1000-8000-0026BB765291";
    SwingMode.SWING_DISABLED = 0;
    SwingMode.SWING_ENABLED = 1;
    return SwingMode;
}(Characteristic_1.Characteristic));
exports.SwingMode = SwingMode;
Characteristic_1.Characteristic.SwingMode = SwingMode;
/**
 * Characteristic "Target Air Purifier State"
 */
var TargetAirPurifierState = /** @class */ (function (_super) {
    tslib_1.__extends(TargetAirPurifierState, _super);
    function TargetAirPurifierState() {
        var _this = _super.call(this, "Target Air Purifier State", TargetAirPurifierState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    TargetAirPurifierState.UUID = "000000A8-0000-1000-8000-0026BB765291";
    TargetAirPurifierState.MANUAL = 0;
    TargetAirPurifierState.AUTO = 1;
    return TargetAirPurifierState;
}(Characteristic_1.Characteristic));
exports.TargetAirPurifierState = TargetAirPurifierState;
Characteristic_1.Characteristic.TargetAirPurifierState = TargetAirPurifierState;
/**
 * Characteristic "Target Air Quality"
 * @deprecated Removed and not used anymore
 */
var TargetAirQuality = /** @class */ (function (_super) {
    tslib_1.__extends(TargetAirQuality, _super);
    function TargetAirQuality() {
        var _this = _super.call(this, "Target Air Quality", TargetAirQuality.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 2,
            validValues: [0, 1, 2],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    TargetAirQuality.UUID = "000000AE-0000-1000-8000-0026BB765291";
    TargetAirQuality.EXCELLENT = 0;
    TargetAirQuality.GOOD = 1;
    TargetAirQuality.FAIR = 2;
    return TargetAirQuality;
}(Characteristic_1.Characteristic));
exports.TargetAirQuality = TargetAirQuality;
// noinspection JSDeprecatedSymbols
Characteristic_1.Characteristic.TargetAirQuality = TargetAirQuality;
/**
 * Characteristic "Target Control List"
 */
var TargetControlList = /** @class */ (function (_super) {
    tslib_1.__extends(TargetControlList, _super);
    function TargetControlList() {
        var _this = _super.call(this, "Target Control List", TargetControlList.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */, "wr" /* WRITE_RESPONSE */],
            adminOnlyAccess: [0 /* READ */, 1 /* WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    TargetControlList.UUID = "00000124-0000-1000-8000-0026BB765291";
    return TargetControlList;
}(Characteristic_1.Characteristic));
exports.TargetControlList = TargetControlList;
Characteristic_1.Characteristic.TargetControlList = TargetControlList;
/**
 * Characteristic "Target Control Supported Configuration"
 */
var TargetControlSupportedConfiguration = /** @class */ (function (_super) {
    tslib_1.__extends(TargetControlSupportedConfiguration, _super);
    function TargetControlSupportedConfiguration() {
        var _this = _super.call(this, "Target Control Supported Configuration", TargetControlSupportedConfiguration.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    TargetControlSupportedConfiguration.UUID = "00000123-0000-1000-8000-0026BB765291";
    return TargetControlSupportedConfiguration;
}(Characteristic_1.Characteristic));
exports.TargetControlSupportedConfiguration = TargetControlSupportedConfiguration;
Characteristic_1.Characteristic.TargetControlSupportedConfiguration = TargetControlSupportedConfiguration;
/**
 * Characteristic "Target Door State"
 */
var TargetDoorState = /** @class */ (function (_super) {
    tslib_1.__extends(TargetDoorState, _super);
    function TargetDoorState() {
        var _this = _super.call(this, "Target Door State", TargetDoorState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    TargetDoorState.UUID = "00000032-0000-1000-8000-0026BB765291";
    TargetDoorState.OPEN = 0;
    TargetDoorState.CLOSED = 1;
    return TargetDoorState;
}(Characteristic_1.Characteristic));
exports.TargetDoorState = TargetDoorState;
Characteristic_1.Characteristic.TargetDoorState = TargetDoorState;
/**
 * Characteristic "Target Fan State"
 */
var TargetFanState = /** @class */ (function (_super) {
    tslib_1.__extends(TargetFanState, _super);
    function TargetFanState() {
        var _this = _super.call(this, "Target Fan State", TargetFanState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    TargetFanState.UUID = "000000BF-0000-1000-8000-0026BB765291";
    TargetFanState.MANUAL = 0;
    TargetFanState.AUTO = 1;
    return TargetFanState;
}(Characteristic_1.Characteristic));
exports.TargetFanState = TargetFanState;
Characteristic_1.Characteristic.TargetFanState = TargetFanState;
/**
 * Characteristic "Target Heater-Cooler State"
 */
var TargetHeaterCoolerState = /** @class */ (function (_super) {
    tslib_1.__extends(TargetHeaterCoolerState, _super);
    function TargetHeaterCoolerState() {
        var _this = _super.call(this, "Target Heater-Cooler State", TargetHeaterCoolerState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 2,
            minStep: 1,
            validValues: [0, 1, 2],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    TargetHeaterCoolerState.UUID = "000000B2-0000-1000-8000-0026BB765291";
    TargetHeaterCoolerState.AUTO = 0;
    TargetHeaterCoolerState.HEAT = 1;
    TargetHeaterCoolerState.COOL = 2;
    return TargetHeaterCoolerState;
}(Characteristic_1.Characteristic));
exports.TargetHeaterCoolerState = TargetHeaterCoolerState;
Characteristic_1.Characteristic.TargetHeaterCoolerState = TargetHeaterCoolerState;
/**
 * Characteristic "Target Heating Cooling State"
 */
var TargetHeatingCoolingState = /** @class */ (function (_super) {
    tslib_1.__extends(TargetHeatingCoolingState, _super);
    function TargetHeatingCoolingState() {
        var _this = _super.call(this, "Target Heating Cooling State", TargetHeatingCoolingState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 3,
            minStep: 1,
            validValues: [0, 1, 2, 3],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    TargetHeatingCoolingState.UUID = "00000033-0000-1000-8000-0026BB765291";
    TargetHeatingCoolingState.OFF = 0;
    TargetHeatingCoolingState.HEAT = 1;
    TargetHeatingCoolingState.COOL = 2;
    TargetHeatingCoolingState.AUTO = 3;
    return TargetHeatingCoolingState;
}(Characteristic_1.Characteristic));
exports.TargetHeatingCoolingState = TargetHeatingCoolingState;
Characteristic_1.Characteristic.TargetHeatingCoolingState = TargetHeatingCoolingState;
/**
 * Characteristic "Target Horizontal Tilt Angle"
 */
var TargetHorizontalTiltAngle = /** @class */ (function (_super) {
    tslib_1.__extends(TargetHorizontalTiltAngle, _super);
    function TargetHorizontalTiltAngle() {
        var _this = _super.call(this, "Target Horizontal Tilt Angle", TargetHorizontalTiltAngle.UUID, {
            format: "int" /* INT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            unit: "arcdegrees" /* ARC_DEGREE */,
            minValue: -90,
            maxValue: 90,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    TargetHorizontalTiltAngle.UUID = "0000007B-0000-1000-8000-0026BB765291";
    return TargetHorizontalTiltAngle;
}(Characteristic_1.Characteristic));
exports.TargetHorizontalTiltAngle = TargetHorizontalTiltAngle;
Characteristic_1.Characteristic.TargetHorizontalTiltAngle = TargetHorizontalTiltAngle;
/**
 * Characteristic "Target Humidifier-Dehumidifier State"
 */
var TargetHumidifierDehumidifierState = /** @class */ (function (_super) {
    tslib_1.__extends(TargetHumidifierDehumidifierState, _super);
    function TargetHumidifierDehumidifierState() {
        var _this = _super.call(this, "Target Humidifier-Dehumidifier State", TargetHumidifierDehumidifierState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 2,
            minStep: 1,
            validValues: [0, 1, 2],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    TargetHumidifierDehumidifierState.UUID = "000000B4-0000-1000-8000-0026BB765291";
    /**
     * @deprecated Removed in iOS 11. Use {@link HUMIDIFIER_OR_DEHUMIDIFIER} instead.
     */
    TargetHumidifierDehumidifierState.AUTO = 0;
    TargetHumidifierDehumidifierState.HUMIDIFIER_OR_DEHUMIDIFIER = 0;
    TargetHumidifierDehumidifierState.HUMIDIFIER = 1;
    TargetHumidifierDehumidifierState.DEHUMIDIFIER = 2;
    return TargetHumidifierDehumidifierState;
}(Characteristic_1.Characteristic));
exports.TargetHumidifierDehumidifierState = TargetHumidifierDehumidifierState;
Characteristic_1.Characteristic.TargetHumidifierDehumidifierState = TargetHumidifierDehumidifierState;
/**
 * Characteristic "Target Media State"
 */
var TargetMediaState = /** @class */ (function (_super) {
    tslib_1.__extends(TargetMediaState, _super);
    function TargetMediaState() {
        var _this = _super.call(this, "Target Media State", TargetMediaState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 2,
            minStep: 1,
            validValues: [0, 1, 2],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    TargetMediaState.UUID = "00000137-0000-1000-8000-0026BB765291";
    TargetMediaState.PLAY = 0;
    TargetMediaState.PAUSE = 1;
    TargetMediaState.STOP = 2;
    return TargetMediaState;
}(Characteristic_1.Characteristic));
exports.TargetMediaState = TargetMediaState;
Characteristic_1.Characteristic.TargetMediaState = TargetMediaState;
/**
 * Characteristic "Target Position"
 */
var TargetPosition = /** @class */ (function (_super) {
    tslib_1.__extends(TargetPosition, _super);
    function TargetPosition() {
        var _this = _super.call(this, "Target Position", TargetPosition.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            unit: "percentage" /* PERCENTAGE */,
            minValue: 0,
            maxValue: 100,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    TargetPosition.UUID = "0000007C-0000-1000-8000-0026BB765291";
    return TargetPosition;
}(Characteristic_1.Characteristic));
exports.TargetPosition = TargetPosition;
Characteristic_1.Characteristic.TargetPosition = TargetPosition;
/**
 * Characteristic "Target Relative Humidity"
 */
var TargetRelativeHumidity = /** @class */ (function (_super) {
    tslib_1.__extends(TargetRelativeHumidity, _super);
    function TargetRelativeHumidity() {
        var _this = _super.call(this, "Target Relative Humidity", TargetRelativeHumidity.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            unit: "percentage" /* PERCENTAGE */,
            minValue: 0,
            maxValue: 100,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    TargetRelativeHumidity.UUID = "00000034-0000-1000-8000-0026BB765291";
    return TargetRelativeHumidity;
}(Characteristic_1.Characteristic));
exports.TargetRelativeHumidity = TargetRelativeHumidity;
Characteristic_1.Characteristic.TargetRelativeHumidity = TargetRelativeHumidity;
/**
 * Characteristic "Target Slat State"
 * @deprecated Removed and not used anymore
 */
var TargetSlatState = /** @class */ (function (_super) {
    tslib_1.__extends(TargetSlatState, _super);
    function TargetSlatState() {
        var _this = _super.call(this, "Target Slat State", TargetSlatState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    TargetSlatState.UUID = "000000BE-0000-1000-8000-0026BB765291";
    TargetSlatState.MANUAL = 0;
    TargetSlatState.AUTO = 1;
    return TargetSlatState;
}(Characteristic_1.Characteristic));
exports.TargetSlatState = TargetSlatState;
// noinspection JSDeprecatedSymbols
Characteristic_1.Characteristic.TargetSlatState = TargetSlatState;
/**
 * Characteristic "Target Temperature"
 */
var TargetTemperature = /** @class */ (function (_super) {
    tslib_1.__extends(TargetTemperature, _super);
    function TargetTemperature() {
        var _this = _super.call(this, "Target Temperature", TargetTemperature.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            unit: "celsius" /* CELSIUS */,
            minValue: 10,
            maxValue: 38,
            minStep: 0.1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    TargetTemperature.UUID = "00000035-0000-1000-8000-0026BB765291";
    return TargetTemperature;
}(Characteristic_1.Characteristic));
exports.TargetTemperature = TargetTemperature;
Characteristic_1.Characteristic.TargetTemperature = TargetTemperature;
/**
 * Characteristic "Target Tilt Angle"
 */
var TargetTiltAngle = /** @class */ (function (_super) {
    tslib_1.__extends(TargetTiltAngle, _super);
    function TargetTiltAngle() {
        var _this = _super.call(this, "Target Tilt Angle", TargetTiltAngle.UUID, {
            format: "int" /* INT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            unit: "arcdegrees" /* ARC_DEGREE */,
            minValue: -90,
            maxValue: 90,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    TargetTiltAngle.UUID = "000000C2-0000-1000-8000-0026BB765291";
    return TargetTiltAngle;
}(Characteristic_1.Characteristic));
exports.TargetTiltAngle = TargetTiltAngle;
Characteristic_1.Characteristic.TargetTiltAngle = TargetTiltAngle;
/**
 * Characteristic "Target Vertical Tilt Angle"
 */
var TargetVerticalTiltAngle = /** @class */ (function (_super) {
    tslib_1.__extends(TargetVerticalTiltAngle, _super);
    function TargetVerticalTiltAngle() {
        var _this = _super.call(this, "Target Vertical Tilt Angle", TargetVerticalTiltAngle.UUID, {
            format: "int" /* INT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            unit: "arcdegrees" /* ARC_DEGREE */,
            minValue: -90,
            maxValue: 90,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    TargetVerticalTiltAngle.UUID = "0000007D-0000-1000-8000-0026BB765291";
    return TargetVerticalTiltAngle;
}(Characteristic_1.Characteristic));
exports.TargetVerticalTiltAngle = TargetVerticalTiltAngle;
Characteristic_1.Characteristic.TargetVerticalTiltAngle = TargetVerticalTiltAngle;
/**
 * Characteristic "Target Visibility State"
 */
var TargetVisibilityState = /** @class */ (function (_super) {
    tslib_1.__extends(TargetVisibilityState, _super);
    function TargetVisibilityState() {
        var _this = _super.call(this, "Target Visibility State", TargetVisibilityState.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    TargetVisibilityState.UUID = "00000134-0000-1000-8000-0026BB765291";
    TargetVisibilityState.SHOWN = 0;
    TargetVisibilityState.HIDDEN = 1;
    return TargetVisibilityState;
}(Characteristic_1.Characteristic));
exports.TargetVisibilityState = TargetVisibilityState;
Characteristic_1.Characteristic.TargetVisibilityState = TargetVisibilityState;
/**
 * Characteristic "Temperature Display Units"
 */
var TemperatureDisplayUnits = /** @class */ (function (_super) {
    tslib_1.__extends(TemperatureDisplayUnits, _super);
    function TemperatureDisplayUnits() {
        var _this = _super.call(this, "Temperature Display Units", TemperatureDisplayUnits.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    TemperatureDisplayUnits.UUID = "00000036-0000-1000-8000-0026BB765291";
    TemperatureDisplayUnits.CELSIUS = 0;
    TemperatureDisplayUnits.FAHRENHEIT = 1;
    return TemperatureDisplayUnits;
}(Characteristic_1.Characteristic));
exports.TemperatureDisplayUnits = TemperatureDisplayUnits;
Characteristic_1.Characteristic.TemperatureDisplayUnits = TemperatureDisplayUnits;
/**
 * Characteristic "Third Party Camera Active"
 */
var ThirdPartyCameraActive = /** @class */ (function (_super) {
    tslib_1.__extends(ThirdPartyCameraActive, _super);
    function ThirdPartyCameraActive() {
        var _this = _super.call(this, "Third Party Camera Active", ThirdPartyCameraActive.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ThirdPartyCameraActive.UUID = "0000021C-0000-1000-8000-0026BB765291";
    ThirdPartyCameraActive.OFF = 0;
    ThirdPartyCameraActive.ON = 1;
    return ThirdPartyCameraActive;
}(Characteristic_1.Characteristic));
exports.ThirdPartyCameraActive = ThirdPartyCameraActive;
Characteristic_1.Characteristic.ThirdPartyCameraActive = ThirdPartyCameraActive;
/**
 * Characteristic "Thread Control Point"
 */
var ThreadControlPoint = /** @class */ (function (_super) {
    tslib_1.__extends(ThreadControlPoint, _super);
    function ThreadControlPoint() {
        var _this = _super.call(this, "Thread Control Point", ThreadControlPoint.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ThreadControlPoint.UUID = "00000704-0000-1000-8000-0026BB765291";
    return ThreadControlPoint;
}(Characteristic_1.Characteristic));
exports.ThreadControlPoint = ThreadControlPoint;
Characteristic_1.Characteristic.ThreadControlPoint = ThreadControlPoint;
/**
 * Characteristic "Thread Node Capabilities"
 */
var ThreadNodeCapabilities = /** @class */ (function (_super) {
    tslib_1.__extends(ThreadNodeCapabilities, _super);
    function ThreadNodeCapabilities() {
        var _this = _super.call(this, "Thread Node Capabilities", ThreadNodeCapabilities.UUID, {
            format: "uint16" /* UINT16 */,
            perms: ["pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 31,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ThreadNodeCapabilities.UUID = "00000702-0000-1000-8000-0026BB765291";
    return ThreadNodeCapabilities;
}(Characteristic_1.Characteristic));
exports.ThreadNodeCapabilities = ThreadNodeCapabilities;
Characteristic_1.Characteristic.ThreadNodeCapabilities = ThreadNodeCapabilities;
/**
 * Characteristic "Thread OpenThread Version"
 */
var ThreadOpenThreadVersion = /** @class */ (function (_super) {
    tslib_1.__extends(ThreadOpenThreadVersion, _super);
    function ThreadOpenThreadVersion() {
        var _this = _super.call(this, "Thread OpenThread Version", ThreadOpenThreadVersion.UUID, {
            format: "string" /* STRING */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ThreadOpenThreadVersion.UUID = "00000706-0000-1000-8000-0026BB765291";
    return ThreadOpenThreadVersion;
}(Characteristic_1.Characteristic));
exports.ThreadOpenThreadVersion = ThreadOpenThreadVersion;
Characteristic_1.Characteristic.ThreadOpenThreadVersion = ThreadOpenThreadVersion;
/**
 * Characteristic "Thread Status"
 */
var ThreadStatus = /** @class */ (function (_super) {
    tslib_1.__extends(ThreadStatus, _super);
    function ThreadStatus() {
        var _this = _super.call(this, "Thread Status", ThreadStatus.UUID, {
            format: "uint16" /* UINT16 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 6,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ThreadStatus.UUID = "00000703-0000-1000-8000-0026BB765291";
    return ThreadStatus;
}(Characteristic_1.Characteristic));
exports.ThreadStatus = ThreadStatus;
Characteristic_1.Characteristic.ThreadStatus = ThreadStatus;
/**
 * Characteristic "Time Update"
 * @deprecated Removed and not used anymore
 */
var TimeUpdate = /** @class */ (function (_super) {
    tslib_1.__extends(TimeUpdate, _super);
    function TimeUpdate() {
        var _this = _super.call(this, "Time Update", TimeUpdate.UUID, {
            format: "bool" /* BOOL */,
            perms: ["pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    TimeUpdate.UUID = "0000009A-0000-1000-8000-0026BB765291";
    return TimeUpdate;
}(Characteristic_1.Characteristic));
exports.TimeUpdate = TimeUpdate;
// noinspection JSDeprecatedSymbols
Characteristic_1.Characteristic.TimeUpdate = TimeUpdate;
/**
 * Characteristic "Transmit Power"
 * @since iOS 14
 */
var TransmitPower = /** @class */ (function (_super) {
    tslib_1.__extends(TransmitPower, _super);
    function TransmitPower() {
        var _this = _super.call(this, "Transmit Power", TransmitPower.UUID, {
            format: "int" /* INT */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    TransmitPower.UUID = "00000242-0000-1000-8000-0026BB765291";
    return TransmitPower;
}(Characteristic_1.Characteristic));
exports.TransmitPower = TransmitPower;
Characteristic_1.Characteristic.TransmitPower = TransmitPower;
/**
 * Characteristic "Tunnel Connection Timeout"
 */
var TunnelConnectionTimeout = /** @class */ (function (_super) {
    tslib_1.__extends(TunnelConnectionTimeout, _super);
    function TunnelConnectionTimeout() {
        var _this = _super.call(this, "Tunnel Connection Timeout", TunnelConnectionTimeout.UUID, {
            format: "int" /* INT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    TunnelConnectionTimeout.UUID = "00000061-0000-1000-8000-0026BB765291";
    return TunnelConnectionTimeout;
}(Characteristic_1.Characteristic));
exports.TunnelConnectionTimeout = TunnelConnectionTimeout;
Characteristic_1.Characteristic.TunnelConnectionTimeout = TunnelConnectionTimeout;
/**
 * Characteristic "Tunneled Accessory Advertising"
 */
var TunneledAccessoryAdvertising = /** @class */ (function (_super) {
    tslib_1.__extends(TunneledAccessoryAdvertising, _super);
    function TunneledAccessoryAdvertising() {
        var _this = _super.call(this, "Tunneled Accessory Advertising", TunneledAccessoryAdvertising.UUID, {
            format: "bool" /* BOOL */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    TunneledAccessoryAdvertising.UUID = "00000060-0000-1000-8000-0026BB765291";
    return TunneledAccessoryAdvertising;
}(Characteristic_1.Characteristic));
exports.TunneledAccessoryAdvertising = TunneledAccessoryAdvertising;
Characteristic_1.Characteristic.TunneledAccessoryAdvertising = TunneledAccessoryAdvertising;
/**
 * Characteristic "Tunneled Accessory Connected"
 */
var TunneledAccessoryConnected = /** @class */ (function (_super) {
    tslib_1.__extends(TunneledAccessoryConnected, _super);
    function TunneledAccessoryConnected() {
        var _this = _super.call(this, "Tunneled Accessory Connected", TunneledAccessoryConnected.UUID, {
            format: "bool" /* BOOL */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    TunneledAccessoryConnected.UUID = "00000059-0000-1000-8000-0026BB765291";
    return TunneledAccessoryConnected;
}(Characteristic_1.Characteristic));
exports.TunneledAccessoryConnected = TunneledAccessoryConnected;
Characteristic_1.Characteristic.TunneledAccessoryConnected = TunneledAccessoryConnected;
/**
 * Characteristic "Tunneled Accessory State Number"
 */
var TunneledAccessoryStateNumber = /** @class */ (function (_super) {
    tslib_1.__extends(TunneledAccessoryStateNumber, _super);
    function TunneledAccessoryStateNumber() {
        var _this = _super.call(this, "Tunneled Accessory State Number", TunneledAccessoryStateNumber.UUID, {
            format: "int" /* INT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    TunneledAccessoryStateNumber.UUID = "00000058-0000-1000-8000-0026BB765291";
    return TunneledAccessoryStateNumber;
}(Characteristic_1.Characteristic));
exports.TunneledAccessoryStateNumber = TunneledAccessoryStateNumber;
Characteristic_1.Characteristic.TunneledAccessoryStateNumber = TunneledAccessoryStateNumber;
/**
 * Characteristic "Valve Type"
 */
var ValveType = /** @class */ (function (_super) {
    tslib_1.__extends(ValveType, _super);
    function ValveType() {
        var _this = _super.call(this, "Valve Type", ValveType.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 3,
            minStep: 1,
            validValues: [0, 1, 2, 3],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    ValveType.UUID = "000000D5-0000-1000-8000-0026BB765291";
    ValveType.GENERIC_VALVE = 0;
    ValveType.IRRIGATION = 1;
    ValveType.SHOWER_HEAD = 2;
    ValveType.WATER_FAUCET = 3;
    return ValveType;
}(Characteristic_1.Characteristic));
exports.ValveType = ValveType;
Characteristic_1.Characteristic.ValveType = ValveType;
/**
 * Characteristic "Version"
 */
var Version = /** @class */ (function (_super) {
    tslib_1.__extends(Version, _super);
    function Version() {
        var _this = _super.call(this, "Version", Version.UUID, {
            format: "string" /* STRING */,
            perms: ["pr" /* PAIRED_READ */],
            maxLen: 64,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    Version.UUID = "00000037-0000-1000-8000-0026BB765291";
    return Version;
}(Characteristic_1.Characteristic));
exports.Version = Version;
Characteristic_1.Characteristic.Version = Version;
/**
 * Characteristic "Video Analysis Active"
 * @since iOS 14
 */
var VideoAnalysisActive = /** @class */ (function (_super) {
    tslib_1.__extends(VideoAnalysisActive, _super);
    function VideoAnalysisActive() {
        var _this = _super.call(this, "Video Analysis Active", VideoAnalysisActive.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    VideoAnalysisActive.UUID = "00000229-0000-1000-8000-0026BB765291";
    return VideoAnalysisActive;
}(Characteristic_1.Characteristic));
exports.VideoAnalysisActive = VideoAnalysisActive;
Characteristic_1.Characteristic.VideoAnalysisActive = VideoAnalysisActive;
/**
 * Characteristic "VOC Density"
 */
var VOCDensity = /** @class */ (function (_super) {
    tslib_1.__extends(VOCDensity, _super);
    function VOCDensity() {
        var _this = _super.call(this, "VOC Density", VOCDensity.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 1000,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    VOCDensity.UUID = "000000C8-0000-1000-8000-0026BB765291";
    return VOCDensity;
}(Characteristic_1.Characteristic));
exports.VOCDensity = VOCDensity;
Characteristic_1.Characteristic.VOCDensity = VOCDensity;
/**
 * Characteristic "Volume"
 */
var Volume = /** @class */ (function (_super) {
    tslib_1.__extends(Volume, _super);
    function Volume() {
        var _this = _super.call(this, "Volume", Volume.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */],
            unit: "percentage" /* PERCENTAGE */,
            minValue: 0,
            maxValue: 100,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    Volume.UUID = "00000119-0000-1000-8000-0026BB765291";
    return Volume;
}(Characteristic_1.Characteristic));
exports.Volume = Volume;
Characteristic_1.Characteristic.Volume = Volume;
/**
 * Characteristic "Volume Control Type"
 */
var VolumeControlType = /** @class */ (function (_super) {
    tslib_1.__extends(VolumeControlType, _super);
    function VolumeControlType() {
        var _this = _super.call(this, "Volume Control Type", VolumeControlType.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 3,
            minStep: 1,
            validValues: [0, 1, 2, 3],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    VolumeControlType.UUID = "000000E9-0000-1000-8000-0026BB765291";
    VolumeControlType.NONE = 0;
    VolumeControlType.RELATIVE = 1;
    VolumeControlType.RELATIVE_WITH_CURRENT = 2;
    VolumeControlType.ABSOLUTE = 3;
    return VolumeControlType;
}(Characteristic_1.Characteristic));
exports.VolumeControlType = VolumeControlType;
Characteristic_1.Characteristic.VolumeControlType = VolumeControlType;
/**
 * Characteristic "Volume Selector"
 */
var VolumeSelector = /** @class */ (function (_super) {
    tslib_1.__extends(VolumeSelector, _super);
    function VolumeSelector() {
        var _this = _super.call(this, "Volume Selector", VolumeSelector.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["pw" /* PAIRED_WRITE */],
            minValue: 0,
            maxValue: 1,
            minStep: 1,
            validValues: [0, 1],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    VolumeSelector.UUID = "000000EA-0000-1000-8000-0026BB765291";
    VolumeSelector.INCREMENT = 0;
    VolumeSelector.DECREMENT = 1;
    return VolumeSelector;
}(Characteristic_1.Characteristic));
exports.VolumeSelector = VolumeSelector;
Characteristic_1.Characteristic.VolumeSelector = VolumeSelector;
/**
 * Characteristic "Wake Configuration"
 * @since iOS 13.4
 */
var WakeConfiguration = /** @class */ (function (_super) {
    tslib_1.__extends(WakeConfiguration, _super);
    function WakeConfiguration() {
        var _this = _super.call(this, "Wake Configuration", WakeConfiguration.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    WakeConfiguration.UUID = "00000222-0000-1000-8000-0026BB765291";
    return WakeConfiguration;
}(Characteristic_1.Characteristic));
exports.WakeConfiguration = WakeConfiguration;
Characteristic_1.Characteristic.WakeConfiguration = WakeConfiguration;
/**
 * Characteristic "WAN Configuration List"
 */
var WANConfigurationList = /** @class */ (function (_super) {
    tslib_1.__extends(WANConfigurationList, _super);
    function WANConfigurationList() {
        var _this = _super.call(this, "WAN Configuration List", WANConfigurationList.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    WANConfigurationList.UUID = "00000211-0000-1000-8000-0026BB765291";
    return WANConfigurationList;
}(Characteristic_1.Characteristic));
exports.WANConfigurationList = WANConfigurationList;
Characteristic_1.Characteristic.WANConfigurationList = WANConfigurationList;
/**
 * Characteristic "WAN Status List"
 */
var WANStatusList = /** @class */ (function (_super) {
    tslib_1.__extends(WANStatusList, _super);
    function WANStatusList() {
        var _this = _super.call(this, "WAN Status List", WANStatusList.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    WANStatusList.UUID = "00000212-0000-1000-8000-0026BB765291";
    return WANStatusList;
}(Characteristic_1.Characteristic));
exports.WANStatusList = WANStatusList;
Characteristic_1.Characteristic.WANStatusList = WANStatusList;
/**
 * Characteristic "Water Level"
 */
var WaterLevel = /** @class */ (function (_super) {
    tslib_1.__extends(WaterLevel, _super);
    function WaterLevel() {
        var _this = _super.call(this, "Water Level", WaterLevel.UUID, {
            format: "float" /* FLOAT */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            unit: "percentage" /* PERCENTAGE */,
            minValue: 0,
            maxValue: 100,
            minStep: 1,
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    WaterLevel.UUID = "000000B5-0000-1000-8000-0026BB765291";
    return WaterLevel;
}(Characteristic_1.Characteristic));
exports.WaterLevel = WaterLevel;
Characteristic_1.Characteristic.WaterLevel = WaterLevel;
/**
 * Characteristic "Wi-Fi Capabilities"
 * @since iOS 14
 */
var WiFiCapabilities = /** @class */ (function (_super) {
    tslib_1.__extends(WiFiCapabilities, _super);
    function WiFiCapabilities() {
        var _this = _super.call(this, "Wi-Fi Capabilities", WiFiCapabilities.UUID, {
            format: "uint32" /* UINT32 */,
            perms: ["pr" /* PAIRED_READ */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    WiFiCapabilities.UUID = "0000022C-0000-1000-8000-0026BB765291";
    return WiFiCapabilities;
}(Characteristic_1.Characteristic));
exports.WiFiCapabilities = WiFiCapabilities;
Characteristic_1.Characteristic.WiFiCapabilities = WiFiCapabilities;
/**
 * Characteristic "Wi-Fi Configuration Control"
 * @since iOS 14
 */
var WiFiConfigurationControl = /** @class */ (function (_super) {
    tslib_1.__extends(WiFiConfigurationControl, _super);
    function WiFiConfigurationControl() {
        var _this = _super.call(this, "Wi-Fi Configuration Control", WiFiConfigurationControl.UUID, {
            format: "tlv8" /* TLV8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */, "pw" /* PAIRED_WRITE */, "tw" /* TIMED_WRITE */, "wr" /* WRITE_RESPONSE */],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    WiFiConfigurationControl.UUID = "0000022D-0000-1000-8000-0026BB765291";
    return WiFiConfigurationControl;
}(Characteristic_1.Characteristic));
exports.WiFiConfigurationControl = WiFiConfigurationControl;
Characteristic_1.Characteristic.WiFiConfigurationControl = WiFiConfigurationControl;
/**
 * Characteristic "Wi-Fi Satellite Status"
 */
var WiFiSatelliteStatus = /** @class */ (function (_super) {
    tslib_1.__extends(WiFiSatelliteStatus, _super);
    function WiFiSatelliteStatus() {
        var _this = _super.call(this, "Wi-Fi Satellite Status", WiFiSatelliteStatus.UUID, {
            format: "uint8" /* UINT8 */,
            perms: ["ev" /* NOTIFY */, "pr" /* PAIRED_READ */],
            minValue: 0,
            maxValue: 2,
            validValues: [0, 1, 2],
        }) || this;
        _this.value = _this.getDefaultValue();
        return _this;
    }
    WiFiSatelliteStatus.UUID = "0000021E-0000-1000-8000-0026BB765291";
    WiFiSatelliteStatus.UNKNOWN = 0;
    WiFiSatelliteStatus.CONNECTED = 1;
    WiFiSatelliteStatus.NOT_CONNECTED = 2;
    return WiFiSatelliteStatus;
}(Characteristic_1.Characteristic));
exports.WiFiSatelliteStatus = WiFiSatelliteStatus;
Characteristic_1.Characteristic.WiFiSatelliteStatus = WiFiSatelliteStatus;
//# sourceMappingURL=CharacteristicDefinitions.js.map

/***/ }),

/***/ 3228:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

// THIS FILE IS AUTO-GENERATED - DO NOT MODIFY
// V=860
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Speaker = exports.SmokeSensor = exports.SmartSpeaker = exports.Slats = exports.Siri = exports.ServiceLabel = exports.SecuritySystem = exports.ProtocolInformation = exports.PowerManagement = exports.Pairing = exports.Outlet = exports.OccupancySensor = exports.MotionSensor = exports.Microphone = exports.LockMechanism = exports.LockManagement = exports.LightSensor = exports.Lightbulb = exports.LeakSensor = exports.IrrigationSystem = exports.InputSource = exports.HumiditySensor = exports.HumidifierDehumidifier = exports.HeaterCooler = exports.GarageDoorOpener = exports.FilterMaintenance = exports.Faucet = exports.Fanv2 = exports.Fan = exports.Doorbell = exports.Door = exports.Diagnostics = exports.DataStreamTransportManagement = exports.ContactSensor = exports.CloudRelay = exports.CarbonMonoxideSensor = exports.CarbonDioxideSensor = exports.CameraRTPStreamManagement = exports.CameraRecordingManagement = exports.CameraOperatingMode = exports.CameraControl = exports.BridgingState = exports.BridgeConfiguration = exports.Battery = exports.AudioStreamManagement = exports.AirQualitySensor = exports.AirPurifier = exports.AccessoryRuntimeInformation = exports.AccessoryInformation = exports.AccessControl = void 0;
exports.WindowCovering = exports.Window = exports.WiFiTransport = exports.WiFiSatellite = exports.WiFiRouter = exports.Valve = exports.Tunnel = exports.TransferTransportManagement = exports.TimeInformation = exports.ThreadTransport = exports.Thermostat = exports.TemperatureSensor = exports.TelevisionSpeaker = exports.Television = exports.TargetControlManagement = exports.TargetControl = exports.Switch = exports.StatelessProgrammableSwitch = exports.StatefulProgrammableSwitch = void 0;
var tslib_1 = __nccwpck_require__(4290);
var Characteristic_1 = __nccwpck_require__(3859);
var Service_1 = __nccwpck_require__(7383);
/**
 * Service "Access Control"
 */
var AccessControl = /** @class */ (function (_super) {
    tslib_1.__extends(AccessControl, _super);
    function AccessControl(displayName, subtype) {
        var _this = _super.call(this, displayName, AccessControl.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.AccessControlLevel);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.PasswordSetting);
        return _this;
    }
    AccessControl.UUID = "000000DA-0000-1000-8000-0026BB765291";
    return AccessControl;
}(Service_1.Service));
exports.AccessControl = AccessControl;
Service_1.Service.AccessControl = AccessControl;
/**
 * Service "Accessory Information"
 */
var AccessoryInformation = /** @class */ (function (_super) {
    tslib_1.__extends(AccessoryInformation, _super);
    function AccessoryInformation(displayName, subtype) {
        var _this = _super.call(this, displayName, AccessoryInformation.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.Identify);
        _this.addCharacteristic(Characteristic_1.Characteristic.Manufacturer);
        _this.addCharacteristic(Characteristic_1.Characteristic.Model);
        if (!_this.testCharacteristic(Characteristic_1.Characteristic.Name)) { // workaround for Name characteristic collision in constructor
            _this.addCharacteristic(Characteristic_1.Characteristic.Name).updateValue("Unnamed Service");
        }
        _this.addCharacteristic(Characteristic_1.Characteristic.SerialNumber);
        _this.addCharacteristic(Characteristic_1.Characteristic.FirmwareRevision);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.AccessoryFlags);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.AppMatchingIdentifier);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.ConfiguredName);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.HardwareRevision);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.SoftwareRevision);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.ProductData);
        return _this;
    }
    AccessoryInformation.UUID = "0000003E-0000-1000-8000-0026BB765291";
    return AccessoryInformation;
}(Service_1.Service));
exports.AccessoryInformation = AccessoryInformation;
Service_1.Service.AccessoryInformation = AccessoryInformation;
/**
 * Service "Accessory Runtime Information"
 */
var AccessoryRuntimeInformation = /** @class */ (function (_super) {
    tslib_1.__extends(AccessoryRuntimeInformation, _super);
    function AccessoryRuntimeInformation(displayName, subtype) {
        var _this = _super.call(this, displayName, AccessoryRuntimeInformation.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.Ping);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.ActivityInterval);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.HeartBeat);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.SleepInterval);
        return _this;
    }
    AccessoryRuntimeInformation.UUID = "00000239-0000-1000-8000-0026BB765291";
    return AccessoryRuntimeInformation;
}(Service_1.Service));
exports.AccessoryRuntimeInformation = AccessoryRuntimeInformation;
Service_1.Service.AccessoryRuntimeInformation = AccessoryRuntimeInformation;
/**
 * Service "Air Purifier"
 */
var AirPurifier = /** @class */ (function (_super) {
    tslib_1.__extends(AirPurifier, _super);
    function AirPurifier(displayName, subtype) {
        var _this = _super.call(this, displayName, AirPurifier.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.Active);
        _this.addCharacteristic(Characteristic_1.Characteristic.CurrentAirPurifierState);
        _this.addCharacteristic(Characteristic_1.Characteristic.TargetAirPurifierState);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.LockPhysicalControls);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.RotationSpeed);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.SwingMode);
        return _this;
    }
    AirPurifier.UUID = "000000BB-0000-1000-8000-0026BB765291";
    return AirPurifier;
}(Service_1.Service));
exports.AirPurifier = AirPurifier;
Service_1.Service.AirPurifier = AirPurifier;
/**
 * Service "Air Quality Sensor"
 */
var AirQualitySensor = /** @class */ (function (_super) {
    tslib_1.__extends(AirQualitySensor, _super);
    function AirQualitySensor(displayName, subtype) {
        var _this = _super.call(this, displayName, AirQualitySensor.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.AirQuality);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.NitrogenDioxideDensity);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.OzoneDensity);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.PM10Density);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.PM2_5Density);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.SulphurDioxideDensity);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.VOCDensity);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusActive);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusFault);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusLowBattery);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusTampered);
        return _this;
    }
    AirQualitySensor.UUID = "0000008D-0000-1000-8000-0026BB765291";
    return AirQualitySensor;
}(Service_1.Service));
exports.AirQualitySensor = AirQualitySensor;
Service_1.Service.AirQualitySensor = AirQualitySensor;
/**
 * Service "Audio Stream Management"
 */
var AudioStreamManagement = /** @class */ (function (_super) {
    tslib_1.__extends(AudioStreamManagement, _super);
    function AudioStreamManagement(displayName, subtype) {
        var _this = _super.call(this, displayName, AudioStreamManagement.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.SupportedAudioStreamConfiguration);
        _this.addCharacteristic(Characteristic_1.Characteristic.SelectedAudioStreamConfiguration);
        return _this;
    }
    AudioStreamManagement.UUID = "00000127-0000-1000-8000-0026BB765291";
    return AudioStreamManagement;
}(Service_1.Service));
exports.AudioStreamManagement = AudioStreamManagement;
Service_1.Service.AudioStreamManagement = AudioStreamManagement;
/**
 * Service "Battery"
 */
var Battery = /** @class */ (function (_super) {
    tslib_1.__extends(Battery, _super);
    function Battery(displayName, subtype) {
        var _this = _super.call(this, displayName, Battery.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.StatusLowBattery);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.BatteryLevel);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.ChargingState);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        return _this;
    }
    Battery.UUID = "00000096-0000-1000-8000-0026BB765291";
    return Battery;
}(Service_1.Service));
exports.Battery = Battery;
// noinspection JSDeprecatedSymbols
Service_1.Service.BatteryService = Battery;
Service_1.Service.Battery = Battery;
/**
 * Service "Bridge Configuration"
 * @deprecated Removed and not used anymore
 */
var BridgeConfiguration = /** @class */ (function (_super) {
    tslib_1.__extends(BridgeConfiguration, _super);
    function BridgeConfiguration(displayName, subtype) {
        var _this = _super.call(this, displayName, BridgeConfiguration.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.ConfigureBridgedAccessoryStatus);
        _this.addCharacteristic(Characteristic_1.Characteristic.DiscoverBridgedAccessories);
        _this.addCharacteristic(Characteristic_1.Characteristic.DiscoveredBridgedAccessories);
        _this.addCharacteristic(Characteristic_1.Characteristic.ConfigureBridgedAccessory);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        return _this;
    }
    BridgeConfiguration.UUID = "000000A1-0000-1000-8000-0026BB765291";
    return BridgeConfiguration;
}(Service_1.Service));
exports.BridgeConfiguration = BridgeConfiguration;
// noinspection JSDeprecatedSymbols
Service_1.Service.BridgeConfiguration = BridgeConfiguration;
/**
 * Service "Bridging State"
 * @deprecated Removed and not used anymore
 */
var BridgingState = /** @class */ (function (_super) {
    tslib_1.__extends(BridgingState, _super);
    function BridgingState(displayName, subtype) {
        var _this = _super.call(this, displayName, BridgingState.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.Reachable);
        _this.addCharacteristic(Characteristic_1.Characteristic.LinkQuality);
        _this.addCharacteristic(Characteristic_1.Characteristic.AccessoryIdentifier);
        _this.addCharacteristic(Characteristic_1.Characteristic.Category);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        return _this;
    }
    BridgingState.UUID = "00000062-0000-1000-8000-0026BB765291";
    return BridgingState;
}(Service_1.Service));
exports.BridgingState = BridgingState;
// noinspection JSDeprecatedSymbols
Service_1.Service.BridgingState = BridgingState;
/**
 * Service "Camera Control"
 * @deprecated This service has no usage anymore and will be ignored by iOS
 */
var CameraControl = /** @class */ (function (_super) {
    tslib_1.__extends(CameraControl, _super);
    function CameraControl(displayName, subtype) {
        var _this = _super.call(this, displayName, CameraControl.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.On);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.CurrentHorizontalTiltAngle);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.CurrentVerticalTiltAngle);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.TargetHorizontalTiltAngle);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.TargetVerticalTiltAngle);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.NightVision);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.OpticalZoom);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.DigitalZoom);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.ImageRotation);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.ImageMirroring);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        return _this;
    }
    CameraControl.UUID = "00000111-0000-1000-8000-0026BB765291";
    return CameraControl;
}(Service_1.Service));
exports.CameraControl = CameraControl;
// noinspection JSDeprecatedSymbols
Service_1.Service.CameraControl = CameraControl;
/**
 * Service "Camera Operating Mode"
 */
var CameraOperatingMode = /** @class */ (function (_super) {
    tslib_1.__extends(CameraOperatingMode, _super);
    function CameraOperatingMode(displayName, subtype) {
        var _this = _super.call(this, displayName, CameraOperatingMode.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.EventSnapshotsActive);
        _this.addCharacteristic(Characteristic_1.Characteristic.HomeKitCameraActive);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.CameraOperatingModeIndicator);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.ManuallyDisabled);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.NightVision);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.PeriodicSnapshotsActive);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.ThirdPartyCameraActive);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.DiagonalFieldOfView);
        return _this;
    }
    CameraOperatingMode.UUID = "0000021A-0000-1000-8000-0026BB765291";
    return CameraOperatingMode;
}(Service_1.Service));
exports.CameraOperatingMode = CameraOperatingMode;
Service_1.Service.CameraOperatingMode = CameraOperatingMode;
/**
 * Service "Camera Recording Management"
 */
var CameraRecordingManagement = /** @class */ (function (_super) {
    tslib_1.__extends(CameraRecordingManagement, _super);
    function CameraRecordingManagement(displayName, subtype) {
        var _this = _super.call(this, displayName, CameraRecordingManagement.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.Active);
        _this.addCharacteristic(Characteristic_1.Characteristic.SupportedCameraRecordingConfiguration);
        _this.addCharacteristic(Characteristic_1.Characteristic.SupportedVideoRecordingConfiguration);
        _this.addCharacteristic(Characteristic_1.Characteristic.SupportedAudioRecordingConfiguration);
        _this.addCharacteristic(Characteristic_1.Characteristic.SelectedCameraRecordingConfiguration);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.RecordingAudioActive);
        return _this;
    }
    CameraRecordingManagement.UUID = "00000204-0000-1000-8000-0026BB765291";
    return CameraRecordingManagement;
}(Service_1.Service));
exports.CameraRecordingManagement = CameraRecordingManagement;
// noinspection JSDeprecatedSymbols
Service_1.Service.CameraEventRecordingManagement = CameraRecordingManagement;
Service_1.Service.CameraRecordingManagement = CameraRecordingManagement;
/**
 * Service "Camera RTP Stream Management"
 */
var CameraRTPStreamManagement = /** @class */ (function (_super) {
    tslib_1.__extends(CameraRTPStreamManagement, _super);
    function CameraRTPStreamManagement(displayName, subtype) {
        var _this = _super.call(this, displayName, CameraRTPStreamManagement.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.SelectedRTPStreamConfiguration);
        _this.addCharacteristic(Characteristic_1.Characteristic.SetupEndpoints);
        _this.addCharacteristic(Characteristic_1.Characteristic.StreamingStatus);
        _this.addCharacteristic(Characteristic_1.Characteristic.SupportedAudioStreamConfiguration);
        _this.addCharacteristic(Characteristic_1.Characteristic.SupportedRTPConfiguration);
        _this.addCharacteristic(Characteristic_1.Characteristic.SupportedVideoStreamConfiguration);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Active);
        return _this;
    }
    CameraRTPStreamManagement.UUID = "00000110-0000-1000-8000-0026BB765291";
    return CameraRTPStreamManagement;
}(Service_1.Service));
exports.CameraRTPStreamManagement = CameraRTPStreamManagement;
Service_1.Service.CameraRTPStreamManagement = CameraRTPStreamManagement;
/**
 * Service "Carbon Dioxide Sensor"
 */
var CarbonDioxideSensor = /** @class */ (function (_super) {
    tslib_1.__extends(CarbonDioxideSensor, _super);
    function CarbonDioxideSensor(displayName, subtype) {
        var _this = _super.call(this, displayName, CarbonDioxideSensor.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.CarbonDioxideDetected);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.CarbonDioxideLevel);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.CarbonDioxidePeakLevel);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusActive);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusFault);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusLowBattery);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusTampered);
        return _this;
    }
    CarbonDioxideSensor.UUID = "00000097-0000-1000-8000-0026BB765291";
    return CarbonDioxideSensor;
}(Service_1.Service));
exports.CarbonDioxideSensor = CarbonDioxideSensor;
Service_1.Service.CarbonDioxideSensor = CarbonDioxideSensor;
/**
 * Service "Carbon Monoxide Sensor"
 */
var CarbonMonoxideSensor = /** @class */ (function (_super) {
    tslib_1.__extends(CarbonMonoxideSensor, _super);
    function CarbonMonoxideSensor(displayName, subtype) {
        var _this = _super.call(this, displayName, CarbonMonoxideSensor.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.CarbonMonoxideDetected);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.CarbonMonoxideLevel);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.CarbonMonoxidePeakLevel);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusActive);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusFault);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusLowBattery);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusTampered);
        return _this;
    }
    CarbonMonoxideSensor.UUID = "0000007F-0000-1000-8000-0026BB765291";
    return CarbonMonoxideSensor;
}(Service_1.Service));
exports.CarbonMonoxideSensor = CarbonMonoxideSensor;
Service_1.Service.CarbonMonoxideSensor = CarbonMonoxideSensor;
/**
 * Service "Cloud Relay"
 */
var CloudRelay = /** @class */ (function (_super) {
    tslib_1.__extends(CloudRelay, _super);
    function CloudRelay(displayName, subtype) {
        var _this = _super.call(this, displayName, CloudRelay.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.RelayControlPoint);
        _this.addCharacteristic(Characteristic_1.Characteristic.RelayState);
        _this.addCharacteristic(Characteristic_1.Characteristic.RelayEnabled);
        return _this;
    }
    CloudRelay.UUID = "0000005A-0000-1000-8000-0026BB765291";
    return CloudRelay;
}(Service_1.Service));
exports.CloudRelay = CloudRelay;
// noinspection JSDeprecatedSymbols
Service_1.Service.Relay = CloudRelay;
Service_1.Service.CloudRelay = CloudRelay;
/**
 * Service "Contact Sensor"
 */
var ContactSensor = /** @class */ (function (_super) {
    tslib_1.__extends(ContactSensor, _super);
    function ContactSensor(displayName, subtype) {
        var _this = _super.call(this, displayName, ContactSensor.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.ContactSensorState);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusActive);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusFault);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusLowBattery);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusTampered);
        return _this;
    }
    ContactSensor.UUID = "00000080-0000-1000-8000-0026BB765291";
    return ContactSensor;
}(Service_1.Service));
exports.ContactSensor = ContactSensor;
Service_1.Service.ContactSensor = ContactSensor;
/**
 * Service "Data Stream Transport Management"
 */
var DataStreamTransportManagement = /** @class */ (function (_super) {
    tslib_1.__extends(DataStreamTransportManagement, _super);
    function DataStreamTransportManagement(displayName, subtype) {
        var _this = _super.call(this, displayName, DataStreamTransportManagement.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.SetupDataStreamTransport);
        _this.addCharacteristic(Characteristic_1.Characteristic.SupportedDataStreamTransportConfiguration);
        _this.addCharacteristic(Characteristic_1.Characteristic.Version);
        return _this;
    }
    DataStreamTransportManagement.UUID = "00000129-0000-1000-8000-0026BB765291";
    return DataStreamTransportManagement;
}(Service_1.Service));
exports.DataStreamTransportManagement = DataStreamTransportManagement;
Service_1.Service.DataStreamTransportManagement = DataStreamTransportManagement;
/**
 * Service "Diagnostics"
 */
var Diagnostics = /** @class */ (function (_super) {
    tslib_1.__extends(Diagnostics, _super);
    function Diagnostics(displayName, subtype) {
        var _this = _super.call(this, displayName, Diagnostics.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.SupportedDiagnosticsSnapshot);
        return _this;
    }
    Diagnostics.UUID = "00000237-0000-1000-8000-0026BB765291";
    return Diagnostics;
}(Service_1.Service));
exports.Diagnostics = Diagnostics;
Service_1.Service.Diagnostics = Diagnostics;
/**
 * Service "Door"
 */
var Door = /** @class */ (function (_super) {
    tslib_1.__extends(Door, _super);
    function Door(displayName, subtype) {
        var _this = _super.call(this, displayName, Door.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.CurrentPosition);
        _this.addCharacteristic(Characteristic_1.Characteristic.PositionState);
        _this.addCharacteristic(Characteristic_1.Characteristic.TargetPosition);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.ObstructionDetected);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.HoldPosition);
        return _this;
    }
    Door.UUID = "00000081-0000-1000-8000-0026BB765291";
    return Door;
}(Service_1.Service));
exports.Door = Door;
Service_1.Service.Door = Door;
/**
 * Service "Doorbell"
 */
var Doorbell = /** @class */ (function (_super) {
    tslib_1.__extends(Doorbell, _super);
    function Doorbell(displayName, subtype) {
        var _this = _super.call(this, displayName, Doorbell.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.ProgrammableSwitchEvent);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Brightness);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Mute);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.OperatingStateResponse);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Volume);
        return _this;
    }
    Doorbell.UUID = "00000121-0000-1000-8000-0026BB765291";
    return Doorbell;
}(Service_1.Service));
exports.Doorbell = Doorbell;
Service_1.Service.Doorbell = Doorbell;
/**
 * Service "Fan"
 */
var Fan = /** @class */ (function (_super) {
    tslib_1.__extends(Fan, _super);
    function Fan(displayName, subtype) {
        var _this = _super.call(this, displayName, Fan.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.On);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.RotationDirection);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.RotationSpeed);
        return _this;
    }
    Fan.UUID = "00000040-0000-1000-8000-0026BB765291";
    return Fan;
}(Service_1.Service));
exports.Fan = Fan;
Service_1.Service.Fan = Fan;
/**
 * Service "Fanv2"
 */
var Fanv2 = /** @class */ (function (_super) {
    tslib_1.__extends(Fanv2, _super);
    function Fanv2(displayName, subtype) {
        var _this = _super.call(this, displayName, Fanv2.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.Active);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.CurrentFanState);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.TargetFanState);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.LockPhysicalControls);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.RotationDirection);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.RotationSpeed);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.SwingMode);
        return _this;
    }
    Fanv2.UUID = "000000B7-0000-1000-8000-0026BB765291";
    return Fanv2;
}(Service_1.Service));
exports.Fanv2 = Fanv2;
Service_1.Service.Fanv2 = Fanv2;
/**
 * Service "Faucet"
 */
var Faucet = /** @class */ (function (_super) {
    tslib_1.__extends(Faucet, _super);
    function Faucet(displayName, subtype) {
        var _this = _super.call(this, displayName, Faucet.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.Active);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusFault);
        return _this;
    }
    Faucet.UUID = "000000D7-0000-1000-8000-0026BB765291";
    return Faucet;
}(Service_1.Service));
exports.Faucet = Faucet;
Service_1.Service.Faucet = Faucet;
/**
 * Service "Filter Maintenance"
 */
var FilterMaintenance = /** @class */ (function (_super) {
    tslib_1.__extends(FilterMaintenance, _super);
    function FilterMaintenance(displayName, subtype) {
        var _this = _super.call(this, displayName, FilterMaintenance.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.FilterChangeIndication);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.FilterLifeLevel);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.ResetFilterIndication);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        return _this;
    }
    FilterMaintenance.UUID = "000000BA-0000-1000-8000-0026BB765291";
    return FilterMaintenance;
}(Service_1.Service));
exports.FilterMaintenance = FilterMaintenance;
Service_1.Service.FilterMaintenance = FilterMaintenance;
/**
 * Service "Garage Door Opener"
 */
var GarageDoorOpener = /** @class */ (function (_super) {
    tslib_1.__extends(GarageDoorOpener, _super);
    function GarageDoorOpener(displayName, subtype) {
        var _this = _super.call(this, displayName, GarageDoorOpener.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.CurrentDoorState);
        _this.addCharacteristic(Characteristic_1.Characteristic.TargetDoorState);
        _this.addCharacteristic(Characteristic_1.Characteristic.ObstructionDetected);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.LockCurrentState);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.LockTargetState);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        return _this;
    }
    GarageDoorOpener.UUID = "00000041-0000-1000-8000-0026BB765291";
    return GarageDoorOpener;
}(Service_1.Service));
exports.GarageDoorOpener = GarageDoorOpener;
Service_1.Service.GarageDoorOpener = GarageDoorOpener;
/**
 * Service "Heater-Cooler"
 */
var HeaterCooler = /** @class */ (function (_super) {
    tslib_1.__extends(HeaterCooler, _super);
    function HeaterCooler(displayName, subtype) {
        var _this = _super.call(this, displayName, HeaterCooler.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.Active);
        _this.addCharacteristic(Characteristic_1.Characteristic.CurrentHeaterCoolerState);
        _this.addCharacteristic(Characteristic_1.Characteristic.TargetHeaterCoolerState);
        _this.addCharacteristic(Characteristic_1.Characteristic.CurrentTemperature);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.LockPhysicalControls);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.RotationSpeed);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.SwingMode);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.CoolingThresholdTemperature);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.HeatingThresholdTemperature);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.TemperatureDisplayUnits);
        return _this;
    }
    HeaterCooler.UUID = "000000BC-0000-1000-8000-0026BB765291";
    return HeaterCooler;
}(Service_1.Service));
exports.HeaterCooler = HeaterCooler;
Service_1.Service.HeaterCooler = HeaterCooler;
/**
 * Service "Humidifier-Dehumidifier"
 */
var HumidifierDehumidifier = /** @class */ (function (_super) {
    tslib_1.__extends(HumidifierDehumidifier, _super);
    function HumidifierDehumidifier(displayName, subtype) {
        var _this = _super.call(this, displayName, HumidifierDehumidifier.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.Active);
        _this.addCharacteristic(Characteristic_1.Characteristic.CurrentHumidifierDehumidifierState);
        _this.addCharacteristic(Characteristic_1.Characteristic.TargetHumidifierDehumidifierState);
        _this.addCharacteristic(Characteristic_1.Characteristic.CurrentRelativeHumidity);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.LockPhysicalControls);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.RelativeHumidityDehumidifierThreshold);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.RelativeHumidityHumidifierThreshold);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.RotationSpeed);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.SwingMode);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.WaterLevel);
        return _this;
    }
    HumidifierDehumidifier.UUID = "000000BD-0000-1000-8000-0026BB765291";
    return HumidifierDehumidifier;
}(Service_1.Service));
exports.HumidifierDehumidifier = HumidifierDehumidifier;
Service_1.Service.HumidifierDehumidifier = HumidifierDehumidifier;
/**
 * Service "Humidity Sensor"
 */
var HumiditySensor = /** @class */ (function (_super) {
    tslib_1.__extends(HumiditySensor, _super);
    function HumiditySensor(displayName, subtype) {
        var _this = _super.call(this, displayName, HumiditySensor.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.CurrentRelativeHumidity);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusActive);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusFault);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusLowBattery);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusTampered);
        return _this;
    }
    HumiditySensor.UUID = "00000082-0000-1000-8000-0026BB765291";
    return HumiditySensor;
}(Service_1.Service));
exports.HumiditySensor = HumiditySensor;
Service_1.Service.HumiditySensor = HumiditySensor;
/**
 * Service "Input Source"
 */
var InputSource = /** @class */ (function (_super) {
    tslib_1.__extends(InputSource, _super);
    function InputSource(displayName, subtype) {
        var _this = _super.call(this, displayName, InputSource.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.ConfiguredName);
        _this.addCharacteristic(Characteristic_1.Characteristic.InputSourceType);
        _this.addCharacteristic(Characteristic_1.Characteristic.IsConfigured);
        if (!_this.testCharacteristic(Characteristic_1.Characteristic.Name)) { // workaround for Name characteristic collision in constructor
            _this.addCharacteristic(Characteristic_1.Characteristic.Name).updateValue("Unnamed Service");
        }
        _this.addCharacteristic(Characteristic_1.Characteristic.CurrentVisibilityState);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Identifier);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.InputDeviceType);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.TargetVisibilityState);
        return _this;
    }
    InputSource.UUID = "000000D9-0000-1000-8000-0026BB765291";
    return InputSource;
}(Service_1.Service));
exports.InputSource = InputSource;
Service_1.Service.InputSource = InputSource;
/**
 * Service "Irrigation-System"
 */
var IrrigationSystem = /** @class */ (function (_super) {
    tslib_1.__extends(IrrigationSystem, _super);
    function IrrigationSystem(displayName, subtype) {
        var _this = _super.call(this, displayName, IrrigationSystem.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.Active);
        _this.addCharacteristic(Characteristic_1.Characteristic.ProgramMode);
        _this.addCharacteristic(Characteristic_1.Characteristic.InUse);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.RemainingDuration);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusFault);
        return _this;
    }
    IrrigationSystem.UUID = "000000CF-0000-1000-8000-0026BB765291";
    return IrrigationSystem;
}(Service_1.Service));
exports.IrrigationSystem = IrrigationSystem;
Service_1.Service.IrrigationSystem = IrrigationSystem;
/**
 * Service "Leak Sensor"
 */
var LeakSensor = /** @class */ (function (_super) {
    tslib_1.__extends(LeakSensor, _super);
    function LeakSensor(displayName, subtype) {
        var _this = _super.call(this, displayName, LeakSensor.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.LeakDetected);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusActive);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusFault);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusLowBattery);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusTampered);
        return _this;
    }
    LeakSensor.UUID = "00000083-0000-1000-8000-0026BB765291";
    return LeakSensor;
}(Service_1.Service));
exports.LeakSensor = LeakSensor;
Service_1.Service.LeakSensor = LeakSensor;
/**
 * Service "Lightbulb"
 */
var Lightbulb = /** @class */ (function (_super) {
    tslib_1.__extends(Lightbulb, _super);
    function Lightbulb(displayName, subtype) {
        var _this = _super.call(this, displayName, Lightbulb.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.On);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Brightness);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.CharacteristicValueActiveTransitionCount);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.CharacteristicValueTransitionControl);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.ColorTemperature);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Hue);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Saturation);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.SupportedCharacteristicValueTransitionConfiguration);
        return _this;
    }
    Lightbulb.UUID = "00000043-0000-1000-8000-0026BB765291";
    return Lightbulb;
}(Service_1.Service));
exports.Lightbulb = Lightbulb;
Service_1.Service.Lightbulb = Lightbulb;
/**
 * Service "Light Sensor"
 */
var LightSensor = /** @class */ (function (_super) {
    tslib_1.__extends(LightSensor, _super);
    function LightSensor(displayName, subtype) {
        var _this = _super.call(this, displayName, LightSensor.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.CurrentAmbientLightLevel);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusActive);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusFault);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusLowBattery);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusTampered);
        return _this;
    }
    LightSensor.UUID = "00000084-0000-1000-8000-0026BB765291";
    return LightSensor;
}(Service_1.Service));
exports.LightSensor = LightSensor;
Service_1.Service.LightSensor = LightSensor;
/**
 * Service "Lock Management"
 */
var LockManagement = /** @class */ (function (_super) {
    tslib_1.__extends(LockManagement, _super);
    function LockManagement(displayName, subtype) {
        var _this = _super.call(this, displayName, LockManagement.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.LockControlPoint);
        _this.addCharacteristic(Characteristic_1.Characteristic.Version);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.AdministratorOnlyAccess);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.AudioFeedback);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.CurrentDoorState);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.LockManagementAutoSecurityTimeout);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.LockLastKnownAction);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Logs);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.MotionDetected);
        return _this;
    }
    LockManagement.UUID = "00000044-0000-1000-8000-0026BB765291";
    return LockManagement;
}(Service_1.Service));
exports.LockManagement = LockManagement;
Service_1.Service.LockManagement = LockManagement;
/**
 * Service "Lock Mechanism"
 */
var LockMechanism = /** @class */ (function (_super) {
    tslib_1.__extends(LockMechanism, _super);
    function LockMechanism(displayName, subtype) {
        var _this = _super.call(this, displayName, LockMechanism.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.LockCurrentState);
        _this.addCharacteristic(Characteristic_1.Characteristic.LockTargetState);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        return _this;
    }
    LockMechanism.UUID = "00000045-0000-1000-8000-0026BB765291";
    return LockMechanism;
}(Service_1.Service));
exports.LockMechanism = LockMechanism;
Service_1.Service.LockMechanism = LockMechanism;
/**
 * Service "Microphone"
 */
var Microphone = /** @class */ (function (_super) {
    tslib_1.__extends(Microphone, _super);
    function Microphone(displayName, subtype) {
        var _this = _super.call(this, displayName, Microphone.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.Mute);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Volume);
        return _this;
    }
    Microphone.UUID = "00000112-0000-1000-8000-0026BB765291";
    return Microphone;
}(Service_1.Service));
exports.Microphone = Microphone;
Service_1.Service.Microphone = Microphone;
/**
 * Service "Motion Sensor"
 */
var MotionSensor = /** @class */ (function (_super) {
    tslib_1.__extends(MotionSensor, _super);
    function MotionSensor(displayName, subtype) {
        var _this = _super.call(this, displayName, MotionSensor.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.MotionDetected);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusActive);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusFault);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusLowBattery);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusTampered);
        return _this;
    }
    MotionSensor.UUID = "00000085-0000-1000-8000-0026BB765291";
    return MotionSensor;
}(Service_1.Service));
exports.MotionSensor = MotionSensor;
Service_1.Service.MotionSensor = MotionSensor;
/**
 * Service "Occupancy Sensor"
 */
var OccupancySensor = /** @class */ (function (_super) {
    tslib_1.__extends(OccupancySensor, _super);
    function OccupancySensor(displayName, subtype) {
        var _this = _super.call(this, displayName, OccupancySensor.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.OccupancyDetected);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusActive);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusFault);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusLowBattery);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusTampered);
        return _this;
    }
    OccupancySensor.UUID = "00000086-0000-1000-8000-0026BB765291";
    return OccupancySensor;
}(Service_1.Service));
exports.OccupancySensor = OccupancySensor;
Service_1.Service.OccupancySensor = OccupancySensor;
/**
 * Service "Outlet"
 * @since iOS 13
 */
var Outlet = /** @class */ (function (_super) {
    tslib_1.__extends(Outlet, _super);
    function Outlet(displayName, subtype) {
        var _this = _super.call(this, displayName, Outlet.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.On);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.OutletInUse);
        return _this;
    }
    Outlet.UUID = "00000047-0000-1000-8000-0026BB765291";
    return Outlet;
}(Service_1.Service));
exports.Outlet = Outlet;
Service_1.Service.Outlet = Outlet;
/**
 * Service "Pairing"
 */
var Pairing = /** @class */ (function (_super) {
    tslib_1.__extends(Pairing, _super);
    function Pairing(displayName, subtype) {
        var _this = _super.call(this, displayName, Pairing.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.ListPairings);
        _this.addCharacteristic(Characteristic_1.Characteristic.PairSetup);
        _this.addCharacteristic(Characteristic_1.Characteristic.PairVerify);
        _this.addCharacteristic(Characteristic_1.Characteristic.PairingFeatures);
        return _this;
    }
    Pairing.UUID = "00000055-0000-1000-8000-0026BB765291";
    return Pairing;
}(Service_1.Service));
exports.Pairing = Pairing;
Service_1.Service.Pairing = Pairing;
/**
 * Service "Power Management"
 */
var PowerManagement = /** @class */ (function (_super) {
    tslib_1.__extends(PowerManagement, _super);
    function PowerManagement(displayName, subtype) {
        var _this = _super.call(this, displayName, PowerManagement.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.WakeConfiguration);
        return _this;
    }
    PowerManagement.UUID = "00000221-0000-1000-8000-0026BB765291";
    return PowerManagement;
}(Service_1.Service));
exports.PowerManagement = PowerManagement;
Service_1.Service.PowerManagement = PowerManagement;
/**
 * Service "Protocol Information"
 */
var ProtocolInformation = /** @class */ (function (_super) {
    tslib_1.__extends(ProtocolInformation, _super);
    function ProtocolInformation(displayName, subtype) {
        var _this = _super.call(this, displayName, ProtocolInformation.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.Version);
        return _this;
    }
    ProtocolInformation.UUID = "000000A2-0000-1000-8000-0026BB765291";
    return ProtocolInformation;
}(Service_1.Service));
exports.ProtocolInformation = ProtocolInformation;
Service_1.Service.ProtocolInformation = ProtocolInformation;
/**
 * Service "Security System"
 */
var SecuritySystem = /** @class */ (function (_super) {
    tslib_1.__extends(SecuritySystem, _super);
    function SecuritySystem(displayName, subtype) {
        var _this = _super.call(this, displayName, SecuritySystem.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.SecuritySystemCurrentState);
        _this.addCharacteristic(Characteristic_1.Characteristic.SecuritySystemTargetState);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.SecuritySystemAlarmType);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusFault);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusTampered);
        return _this;
    }
    SecuritySystem.UUID = "0000007E-0000-1000-8000-0026BB765291";
    return SecuritySystem;
}(Service_1.Service));
exports.SecuritySystem = SecuritySystem;
Service_1.Service.SecuritySystem = SecuritySystem;
/**
 * Service "Service Label"
 */
var ServiceLabel = /** @class */ (function (_super) {
    tslib_1.__extends(ServiceLabel, _super);
    function ServiceLabel(displayName, subtype) {
        var _this = _super.call(this, displayName, ServiceLabel.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.ServiceLabelNamespace);
        return _this;
    }
    ServiceLabel.UUID = "000000CC-0000-1000-8000-0026BB765291";
    return ServiceLabel;
}(Service_1.Service));
exports.ServiceLabel = ServiceLabel;
Service_1.Service.ServiceLabel = ServiceLabel;
/**
 * Service "Siri"
 */
var Siri = /** @class */ (function (_super) {
    tslib_1.__extends(Siri, _super);
    function Siri(displayName, subtype) {
        var _this = _super.call(this, displayName, Siri.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.SiriInputType);
        return _this;
    }
    Siri.UUID = "00000133-0000-1000-8000-0026BB765291";
    return Siri;
}(Service_1.Service));
exports.Siri = Siri;
Service_1.Service.Siri = Siri;
/**
 * Service "Slats"
 */
var Slats = /** @class */ (function (_super) {
    tslib_1.__extends(Slats, _super);
    function Slats(displayName, subtype) {
        var _this = _super.call(this, displayName, Slats.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.CurrentSlatState);
        _this.addCharacteristic(Characteristic_1.Characteristic.SlatType);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.SwingMode);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.CurrentTiltAngle);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.TargetTiltAngle);
        return _this;
    }
    Slats.UUID = "000000B9-0000-1000-8000-0026BB765291";
    return Slats;
}(Service_1.Service));
exports.Slats = Slats;
// noinspection JSDeprecatedSymbols
Service_1.Service.Slat = Slats;
Service_1.Service.Slats = Slats;
/**
 * Service "Smart Speaker"
 */
var SmartSpeaker = /** @class */ (function (_super) {
    tslib_1.__extends(SmartSpeaker, _super);
    function SmartSpeaker(displayName, subtype) {
        var _this = _super.call(this, displayName, SmartSpeaker.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.CurrentMediaState);
        _this.addCharacteristic(Characteristic_1.Characteristic.TargetMediaState);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.ConfiguredName);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Mute);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Volume);
        return _this;
    }
    SmartSpeaker.UUID = "00000228-0000-1000-8000-0026BB765291";
    return SmartSpeaker;
}(Service_1.Service));
exports.SmartSpeaker = SmartSpeaker;
Service_1.Service.SmartSpeaker = SmartSpeaker;
/**
 * Service "Smoke Sensor"
 */
var SmokeSensor = /** @class */ (function (_super) {
    tslib_1.__extends(SmokeSensor, _super);
    function SmokeSensor(displayName, subtype) {
        var _this = _super.call(this, displayName, SmokeSensor.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.SmokeDetected);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusActive);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusFault);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusLowBattery);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusTampered);
        return _this;
    }
    SmokeSensor.UUID = "00000087-0000-1000-8000-0026BB765291";
    return SmokeSensor;
}(Service_1.Service));
exports.SmokeSensor = SmokeSensor;
Service_1.Service.SmokeSensor = SmokeSensor;
/**
 * Service "Speaker"
 * @since iOS 10
 */
var Speaker = /** @class */ (function (_super) {
    tslib_1.__extends(Speaker, _super);
    function Speaker(displayName, subtype) {
        var _this = _super.call(this, displayName, Speaker.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.Mute);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Active);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Volume);
        return _this;
    }
    Speaker.UUID = "00000113-0000-1000-8000-0026BB765291";
    return Speaker;
}(Service_1.Service));
exports.Speaker = Speaker;
Service_1.Service.Speaker = Speaker;
/**
 * Service "Stateful Programmable Switch"
 */
var StatefulProgrammableSwitch = /** @class */ (function (_super) {
    tslib_1.__extends(StatefulProgrammableSwitch, _super);
    function StatefulProgrammableSwitch(displayName, subtype) {
        var _this = _super.call(this, displayName, StatefulProgrammableSwitch.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.ProgrammableSwitchEvent);
        _this.addCharacteristic(Characteristic_1.Characteristic.ProgrammableSwitchOutputState);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        return _this;
    }
    StatefulProgrammableSwitch.UUID = "00000088-0000-1000-8000-0026BB765291";
    return StatefulProgrammableSwitch;
}(Service_1.Service));
exports.StatefulProgrammableSwitch = StatefulProgrammableSwitch;
Service_1.Service.StatefulProgrammableSwitch = StatefulProgrammableSwitch;
/**
 * Service "Stateless Programmable Switch"
 */
var StatelessProgrammableSwitch = /** @class */ (function (_super) {
    tslib_1.__extends(StatelessProgrammableSwitch, _super);
    function StatelessProgrammableSwitch(displayName, subtype) {
        var _this = _super.call(this, displayName, StatelessProgrammableSwitch.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.ProgrammableSwitchEvent);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.ServiceLabelIndex);
        return _this;
    }
    StatelessProgrammableSwitch.UUID = "00000089-0000-1000-8000-0026BB765291";
    return StatelessProgrammableSwitch;
}(Service_1.Service));
exports.StatelessProgrammableSwitch = StatelessProgrammableSwitch;
Service_1.Service.StatelessProgrammableSwitch = StatelessProgrammableSwitch;
/**
 * Service "Switch"
 */
var Switch = /** @class */ (function (_super) {
    tslib_1.__extends(Switch, _super);
    function Switch(displayName, subtype) {
        var _this = _super.call(this, displayName, Switch.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.On);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        return _this;
    }
    Switch.UUID = "00000049-0000-1000-8000-0026BB765291";
    return Switch;
}(Service_1.Service));
exports.Switch = Switch;
Service_1.Service.Switch = Switch;
/**
 * Service "Target Control"
 */
var TargetControl = /** @class */ (function (_super) {
    tslib_1.__extends(TargetControl, _super);
    function TargetControl(displayName, subtype) {
        var _this = _super.call(this, displayName, TargetControl.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.Active);
        _this.addCharacteristic(Characteristic_1.Characteristic.ActiveIdentifier);
        _this.addCharacteristic(Characteristic_1.Characteristic.ButtonEvent);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        return _this;
    }
    TargetControl.UUID = "00000125-0000-1000-8000-0026BB765291";
    return TargetControl;
}(Service_1.Service));
exports.TargetControl = TargetControl;
Service_1.Service.TargetControl = TargetControl;
/**
 * Service "Target Control Management"
 */
var TargetControlManagement = /** @class */ (function (_super) {
    tslib_1.__extends(TargetControlManagement, _super);
    function TargetControlManagement(displayName, subtype) {
        var _this = _super.call(this, displayName, TargetControlManagement.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.TargetControlSupportedConfiguration);
        _this.addCharacteristic(Characteristic_1.Characteristic.TargetControlList);
        return _this;
    }
    TargetControlManagement.UUID = "00000122-0000-1000-8000-0026BB765291";
    return TargetControlManagement;
}(Service_1.Service));
exports.TargetControlManagement = TargetControlManagement;
Service_1.Service.TargetControlManagement = TargetControlManagement;
/**
 * Service "Television"
 */
var Television = /** @class */ (function (_super) {
    tslib_1.__extends(Television, _super);
    function Television(displayName, subtype) {
        var _this = _super.call(this, displayName, Television.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.Active);
        _this.addCharacteristic(Characteristic_1.Characteristic.ActiveIdentifier);
        _this.addCharacteristic(Characteristic_1.Characteristic.ConfiguredName);
        _this.addCharacteristic(Characteristic_1.Characteristic.RemoteKey);
        _this.addCharacteristic(Characteristic_1.Characteristic.SleepDiscoveryMode);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Brightness);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.ClosedCaptions);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.DisplayOrder);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.CurrentMediaState);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.TargetMediaState);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.PictureMode);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.PowerModeSelection);
        return _this;
    }
    Television.UUID = "000000D8-0000-1000-8000-0026BB765291";
    return Television;
}(Service_1.Service));
exports.Television = Television;
Service_1.Service.Television = Television;
/**
 * Service "Television Speaker"
 */
var TelevisionSpeaker = /** @class */ (function (_super) {
    tslib_1.__extends(TelevisionSpeaker, _super);
    function TelevisionSpeaker(displayName, subtype) {
        var _this = _super.call(this, displayName, TelevisionSpeaker.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.Mute);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Active);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Volume);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.VolumeControlType);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.VolumeSelector);
        return _this;
    }
    TelevisionSpeaker.UUID = "00000113-0000-1000-8000-0026BB765291";
    return TelevisionSpeaker;
}(Service_1.Service));
exports.TelevisionSpeaker = TelevisionSpeaker;
Service_1.Service.TelevisionSpeaker = TelevisionSpeaker;
/**
 * Service "Temperature Sensor"
 */
var TemperatureSensor = /** @class */ (function (_super) {
    tslib_1.__extends(TemperatureSensor, _super);
    function TemperatureSensor(displayName, subtype) {
        var _this = _super.call(this, displayName, TemperatureSensor.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.CurrentTemperature);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusActive);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusFault);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusLowBattery);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusTampered);
        return _this;
    }
    TemperatureSensor.UUID = "0000008A-0000-1000-8000-0026BB765291";
    return TemperatureSensor;
}(Service_1.Service));
exports.TemperatureSensor = TemperatureSensor;
Service_1.Service.TemperatureSensor = TemperatureSensor;
/**
 * Service "Thermostat"
 */
var Thermostat = /** @class */ (function (_super) {
    tslib_1.__extends(Thermostat, _super);
    function Thermostat(displayName, subtype) {
        var _this = _super.call(this, displayName, Thermostat.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.CurrentHeatingCoolingState);
        _this.addCharacteristic(Characteristic_1.Characteristic.TargetHeatingCoolingState);
        _this.addCharacteristic(Characteristic_1.Characteristic.CurrentTemperature);
        _this.addCharacteristic(Characteristic_1.Characteristic.TargetTemperature);
        _this.addCharacteristic(Characteristic_1.Characteristic.TemperatureDisplayUnits);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.CurrentRelativeHumidity);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.TargetRelativeHumidity);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.CoolingThresholdTemperature);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.HeatingThresholdTemperature);
        return _this;
    }
    Thermostat.UUID = "0000004A-0000-1000-8000-0026BB765291";
    return Thermostat;
}(Service_1.Service));
exports.Thermostat = Thermostat;
Service_1.Service.Thermostat = Thermostat;
/**
 * Service "Thread Transport"
 */
var ThreadTransport = /** @class */ (function (_super) {
    tslib_1.__extends(ThreadTransport, _super);
    function ThreadTransport(displayName, subtype) {
        var _this = _super.call(this, displayName, ThreadTransport.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.CurrentTransport);
        _this.addCharacteristic(Characteristic_1.Characteristic.ThreadControlPoint);
        _this.addCharacteristic(Characteristic_1.Characteristic.ThreadNodeCapabilities);
        _this.addCharacteristic(Characteristic_1.Characteristic.ThreadStatus);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.CCAEnergyDetectThreshold);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.CCASignalDetectThreshold);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.EventRetransmissionMaximum);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.EventTransmissionCounters);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.MACRetransmissionMaximum);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.MACTransmissionCounters);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.ReceiverSensitivity);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.ReceivedSignalStrengthIndication);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.SignalToNoiseRatio);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.ThreadOpenThreadVersion);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.TransmitPower);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.MaximumTransmitPower);
        return _this;
    }
    ThreadTransport.UUID = "00000701-0000-1000-8000-0026BB765291";
    return ThreadTransport;
}(Service_1.Service));
exports.ThreadTransport = ThreadTransport;
Service_1.Service.ThreadTransport = ThreadTransport;
/**
 * Service "Time Information"
 * @deprecated Removed and not used anymore
 */
var TimeInformation = /** @class */ (function (_super) {
    tslib_1.__extends(TimeInformation, _super);
    function TimeInformation(displayName, subtype) {
        var _this = _super.call(this, displayName, TimeInformation.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.CurrentTime);
        _this.addCharacteristic(Characteristic_1.Characteristic.DayoftheWeek);
        _this.addCharacteristic(Characteristic_1.Characteristic.TimeUpdate);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        return _this;
    }
    TimeInformation.UUID = "00000099-0000-1000-8000-0026BB765291";
    return TimeInformation;
}(Service_1.Service));
exports.TimeInformation = TimeInformation;
// noinspection JSDeprecatedSymbols
Service_1.Service.TimeInformation = TimeInformation;
/**
 * Service "Transfer Transport Management"
 */
var TransferTransportManagement = /** @class */ (function (_super) {
    tslib_1.__extends(TransferTransportManagement, _super);
    function TransferTransportManagement(displayName, subtype) {
        var _this = _super.call(this, displayName, TransferTransportManagement.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.SupportedTransferTransportConfiguration);
        _this.addCharacteristic(Characteristic_1.Characteristic.SetupTransferTransport);
        return _this;
    }
    TransferTransportManagement.UUID = "00000203-0000-1000-8000-0026BB765291";
    return TransferTransportManagement;
}(Service_1.Service));
exports.TransferTransportManagement = TransferTransportManagement;
Service_1.Service.TransferTransportManagement = TransferTransportManagement;
/**
 * Service "Tunnel"
 */
var Tunnel = /** @class */ (function (_super) {
    tslib_1.__extends(Tunnel, _super);
    function Tunnel(displayName, subtype) {
        var _this = _super.call(this, displayName, Tunnel.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.AccessoryIdentifier);
        _this.addCharacteristic(Characteristic_1.Characteristic.TunnelConnectionTimeout);
        _this.addCharacteristic(Characteristic_1.Characteristic.TunneledAccessoryAdvertising);
        _this.addCharacteristic(Characteristic_1.Characteristic.TunneledAccessoryConnected);
        _this.addCharacteristic(Characteristic_1.Characteristic.TunneledAccessoryStateNumber);
        return _this;
    }
    Tunnel.UUID = "00000056-0000-1000-8000-0026BB765291";
    return Tunnel;
}(Service_1.Service));
exports.Tunnel = Tunnel;
// noinspection JSDeprecatedSymbols
Service_1.Service.TunneledBTLEAccessoryService = Tunnel;
Service_1.Service.Tunnel = Tunnel;
/**
 * Service "Valve"
 */
var Valve = /** @class */ (function (_super) {
    tslib_1.__extends(Valve, _super);
    function Valve(displayName, subtype) {
        var _this = _super.call(this, displayName, Valve.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.Active);
        _this.addCharacteristic(Characteristic_1.Characteristic.InUse);
        _this.addCharacteristic(Characteristic_1.Characteristic.ValveType);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.IsConfigured);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.RemainingDuration);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.ServiceLabelIndex);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.SetDuration);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.StatusFault);
        return _this;
    }
    Valve.UUID = "000000D0-0000-1000-8000-0026BB765291";
    return Valve;
}(Service_1.Service));
exports.Valve = Valve;
Service_1.Service.Valve = Valve;
/**
 * Service "Wi-Fi Router"
 */
var WiFiRouter = /** @class */ (function (_super) {
    tslib_1.__extends(WiFiRouter, _super);
    function WiFiRouter(displayName, subtype) {
        var _this = _super.call(this, displayName, WiFiRouter.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.ConfiguredName);
        _this.addCharacteristic(Characteristic_1.Characteristic.ManagedNetworkEnable);
        _this.addCharacteristic(Characteristic_1.Characteristic.NetworkAccessViolationControl);
        _this.addCharacteristic(Characteristic_1.Characteristic.NetworkClientProfileControl);
        _this.addCharacteristic(Characteristic_1.Characteristic.NetworkClientStatusControl);
        _this.addCharacteristic(Characteristic_1.Characteristic.RouterStatus);
        _this.addCharacteristic(Characteristic_1.Characteristic.SupportedRouterConfiguration);
        _this.addCharacteristic(Characteristic_1.Characteristic.WANConfigurationList);
        _this.addCharacteristic(Characteristic_1.Characteristic.WANStatusList);
        return _this;
    }
    WiFiRouter.UUID = "0000020A-0000-1000-8000-0026BB765291";
    return WiFiRouter;
}(Service_1.Service));
exports.WiFiRouter = WiFiRouter;
Service_1.Service.WiFiRouter = WiFiRouter;
/**
 * Service "Wi-Fi Satellite"
 */
var WiFiSatellite = /** @class */ (function (_super) {
    tslib_1.__extends(WiFiSatellite, _super);
    function WiFiSatellite(displayName, subtype) {
        var _this = _super.call(this, displayName, WiFiSatellite.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.WiFiSatelliteStatus);
        return _this;
    }
    WiFiSatellite.UUID = "0000020F-0000-1000-8000-0026BB765291";
    return WiFiSatellite;
}(Service_1.Service));
exports.WiFiSatellite = WiFiSatellite;
Service_1.Service.WiFiSatellite = WiFiSatellite;
/**
 * Service "Wi-Fi Transport"
 */
var WiFiTransport = /** @class */ (function (_super) {
    tslib_1.__extends(WiFiTransport, _super);
    function WiFiTransport(displayName, subtype) {
        var _this = _super.call(this, displayName, WiFiTransport.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.CurrentTransport);
        _this.addCharacteristic(Characteristic_1.Characteristic.WiFiCapabilities);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.WiFiConfigurationControl);
        return _this;
    }
    WiFiTransport.UUID = "0000022A-0000-1000-8000-0026BB765291";
    return WiFiTransport;
}(Service_1.Service));
exports.WiFiTransport = WiFiTransport;
Service_1.Service.WiFiTransport = WiFiTransport;
/**
 * Service "Window"
 */
var Window = /** @class */ (function (_super) {
    tslib_1.__extends(Window, _super);
    function Window(displayName, subtype) {
        var _this = _super.call(this, displayName, Window.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.CurrentPosition);
        _this.addCharacteristic(Characteristic_1.Characteristic.PositionState);
        _this.addCharacteristic(Characteristic_1.Characteristic.TargetPosition);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.ObstructionDetected);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.HoldPosition);
        return _this;
    }
    Window.UUID = "0000008B-0000-1000-8000-0026BB765291";
    return Window;
}(Service_1.Service));
exports.Window = Window;
Service_1.Service.Window = Window;
/**
 * Service "Window Covering"
 */
var WindowCovering = /** @class */ (function (_super) {
    tslib_1.__extends(WindowCovering, _super);
    function WindowCovering(displayName, subtype) {
        var _this = _super.call(this, displayName, WindowCovering.UUID, subtype) || this;
        // Required Characteristics
        _this.addCharacteristic(Characteristic_1.Characteristic.CurrentPosition);
        _this.addCharacteristic(Characteristic_1.Characteristic.PositionState);
        _this.addCharacteristic(Characteristic_1.Characteristic.TargetPosition);
        // Optional Characteristics
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.CurrentHorizontalTiltAngle);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.TargetHorizontalTiltAngle);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.Name);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.ObstructionDetected);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.HoldPosition);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.CurrentVerticalTiltAngle);
        _this.addOptionalCharacteristic(Characteristic_1.Characteristic.TargetVerticalTiltAngle);
        return _this;
    }
    WindowCovering.UUID = "0000008C-0000-1000-8000-0026BB765291";
    return WindowCovering;
}(Service_1.Service));
exports.WindowCovering = WindowCovering;
Service_1.Service.WindowCovering = WindowCovering;
//# sourceMappingURL=ServiceDefinitions.js.map

/***/ }),

/***/ 3476:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __nccwpck_require__(4290);
tslib_1.__exportStar(__nccwpck_require__(1969), exports);
tslib_1.__exportStar(__nccwpck_require__(3228), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 3623:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AccessoryInfo = exports.PermissionTypes = void 0;
var tslib_1 = __nccwpck_require__(4290);
var assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
var crypto_1 = tslib_1.__importDefault(__nccwpck_require__(6417));
var tweetnacl_1 = tslib_1.__importDefault(__nccwpck_require__(9920));
var util_1 = tslib_1.__importDefault(__nccwpck_require__(1669));
var eventedhttp_1 = __nccwpck_require__(1561);
var HAPStorage_1 = __nccwpck_require__(7617);
var packageJson = __nccwpck_require__(7308);
var PermissionTypes;
(function (PermissionTypes) {
    // noinspection JSUnusedGlobalSymbols
    PermissionTypes[PermissionTypes["USER"] = 0] = "USER";
    PermissionTypes[PermissionTypes["ADMIN"] = 1] = "ADMIN";
})(PermissionTypes = exports.PermissionTypes || (exports.PermissionTypes = {}));
/**
 * AccessoryInfo is a model class containing a subset of Accessory data relevant to the internal HAP server,
 * such as encryption keys and username. It is persisted to disk.
 */
var AccessoryInfo = /** @class */ (function () {
    function AccessoryInfo(username) {
        var _this = this;
        this.configVersion = 1;
        this.lastFirmwareVersion = "";
        // Returns a boolean indicating whether this accessory has been paired with a client.
        this.paired = function () {
            return Object.keys(_this.pairedClients).length > 0; // if we have any paired clients, we're paired.
        };
        this.save = function () {
            var e_1, _a;
            var saved = {
                displayName: _this.displayName,
                category: _this.category,
                pincode: _this.pincode,
                signSk: _this.signSk.toString('hex'),
                signPk: _this.signPk.toString('hex'),
                pairedClients: {},
                // moving permissions into an extra object, so there is nothing to migrate from old files.
                // if the legacy node-persist storage should be upgraded some time, it would be reasonable to combine the storage
                // of public keys (pairedClients object) and permissions.
                pairedClientsPermission: {},
                configVersion: _this.configVersion,
                configHash: _this.configHash,
                setupID: _this.setupID,
                lastFirmwareVersion: _this.lastFirmwareVersion,
            };
            try {
                for (var _b = tslib_1.__values(Object.entries(_this.pairedClients)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = tslib_1.__read(_c.value, 2), username = _d[0], pairingInformation = _d[1];
                    //@ts-ignore
                    saved.pairedClients[username] = pairingInformation.publicKey.toString("hex");
                    // @ts-ignore
                    saved.pairedClientsPermission[username] = pairingInformation.permission;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            var key = AccessoryInfo.persistKey(_this.username);
            HAPStorage_1.HAPStorage.storage().setItemSync(key, saved);
        };
        this.username = username;
        this.displayName = "";
        this.model = "";
        // @ts-ignore
        this.category = "";
        this.pincode = "";
        this.signSk = Buffer.alloc(0);
        this.signPk = Buffer.alloc(0);
        this.pairedClients = {};
        this.pairedAdminClients = 0;
        this.configHash = "";
        this.setupID = "";
    }
    /**
     * Add a paired client to memory.
     * @param {HAPUsername} username
     * @param {Buffer} publicKey
     * @param {PermissionTypes} permission
     */
    AccessoryInfo.prototype.addPairedClient = function (username, publicKey, permission) {
        this.pairedClients[username] = {
            username: username,
            publicKey: publicKey,
            permission: permission
        };
        if (permission === 1 /* ADMIN */) {
            this.pairedAdminClients++;
        }
    };
    AccessoryInfo.prototype.updatePermission = function (username, permission) {
        var pairingInformation = this.pairedClients[username];
        if (pairingInformation) {
            var oldPermission = pairingInformation.permission;
            pairingInformation.permission = permission;
            if (oldPermission === 1 /* ADMIN */ && permission !== 1 /* ADMIN */) {
                this.pairedAdminClients--;
            }
            else if (oldPermission !== 1 /* ADMIN */ && permission === 1 /* ADMIN */) {
                this.pairedAdminClients++;
            }
        }
    };
    AccessoryInfo.prototype.listPairings = function () {
        var e_2, _a;
        var array = [];
        try {
            for (var _b = tslib_1.__values(Object.values(this.pairedClients)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var pairingInformation = _c.value;
                array.push(pairingInformation);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return array;
    };
    /**
     * Remove a paired client from memory.
     * @param connection - the session of the connection initiated the removal of the pairing
     * @param {string} username
     */
    AccessoryInfo.prototype.removePairedClient = function (connection, username) {
        var e_3, _a;
        this._removePairedClient0(connection, username);
        if (this.pairedAdminClients === 0) { // if we don't have any admin clients left paired it is required to kill all normal clients
            try {
                for (var _b = tslib_1.__values(Object.keys(this.pairedClients)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var username0 = _c.value;
                    this._removePairedClient0(connection, username0);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
    };
    AccessoryInfo.prototype._removePairedClient0 = function (connection, username) {
        if (this.pairedClients[username] && this.pairedClients[username].permission === 1 /* ADMIN */)
            this.pairedAdminClients--;
        delete this.pairedClients[username];
        eventedhttp_1.EventedHTTPServer.destroyExistingConnectionsAfterUnpair(connection, username);
    };
    /**
     * Check if username is paired
     * @param username
     */
    AccessoryInfo.prototype.isPaired = function (username) {
        return !!this.pairedClients[username];
    };
    AccessoryInfo.prototype.hasAdminPermissions = function (username) {
        if (!username)
            return false;
        var pairingInformation = this.pairedClients[username];
        return !!pairingInformation && pairingInformation.permission === 1 /* ADMIN */;
    };
    // Gets the public key for a paired client as a Buffer, or falsy value if not paired.
    AccessoryInfo.prototype.getClientPublicKey = function (username) {
        var pairingInformation = this.pairedClients[username];
        if (pairingInformation) {
            return pairingInformation.publicKey;
        }
        else {
            return undefined;
        }
    };
    /**
     * Checks based on the current accessory configuration if the current configuration number needs to be incremented.
     * Additionally, if desired, it checks if the firmware version was incremented (aka the HAP-NodeJS) version did grow.
     *
     * @param configuration - The current accessory configuration.
     * @param checkFirmwareIncrement
     * @returns True if the current configuration number was incremented and thus a new TXT must be advertised.
     */
    AccessoryInfo.prototype.checkForCurrentConfigurationNumberIncrement = function (configuration, checkFirmwareIncrement) {
        var shasum = crypto_1.default.createHash('sha1');
        shasum.update(JSON.stringify(configuration));
        var configHash = shasum.digest('hex');
        var changed = false;
        if (configHash !== this.configHash) {
            this.configVersion++;
            this.configHash = configHash;
            this.ensureConfigVersionBounds();
            changed = true;
        }
        if (this.lastFirmwareVersion !== packageJson.version) {
            // we only check if it is different and not only if it is incremented
            // HomeKit spec prohibits firmware downgrades, but with hap-nodejs it's possible lol
            this.lastFirmwareVersion = packageJson.version;
            changed = true;
        }
        if (changed) {
            this.save();
        }
        return changed;
    };
    AccessoryInfo.prototype.getConfigVersion = function () {
        return this.configVersion;
    };
    AccessoryInfo.prototype.ensureConfigVersionBounds = function () {
        // current configuration number must be in the range of 1-65535 and wrap to 1 when it overflows
        this.configVersion = this.configVersion % (0xFFFF + 1);
        if (this.configVersion === 0) {
            this.configVersion = 1;
        }
    };
    AccessoryInfo.remove = function (username) {
        var key = AccessoryInfo.persistKey(username);
        HAPStorage_1.HAPStorage.storage().removeItemSync(key);
    };
    AccessoryInfo.deviceIdPattern = /^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/;
    // Gets a key for storing this AccessoryInfo in the filesystem, like "AccessoryInfo.CC223DE3CEF3.json"
    AccessoryInfo.persistKey = function (username) {
        return util_1.default.format("AccessoryInfo.%s.json", username.replace(/:/g, "").toUpperCase());
    };
    AccessoryInfo.create = function (username) {
        AccessoryInfo.assertValidUsername(username);
        var accessoryInfo = new AccessoryInfo(username);
        accessoryInfo.lastFirmwareVersion = packageJson.version;
        // Create a new unique key pair for this accessory.
        var keyPair = tweetnacl_1.default.sign.keyPair();
        accessoryInfo.signSk = Buffer.from(keyPair.secretKey);
        accessoryInfo.signPk = Buffer.from(keyPair.publicKey);
        return accessoryInfo;
    };
    AccessoryInfo.load = function (username) {
        var e_4, _a;
        AccessoryInfo.assertValidUsername(username);
        var key = AccessoryInfo.persistKey(username);
        var saved = HAPStorage_1.HAPStorage.storage().getItem(key);
        if (saved) {
            var info = new AccessoryInfo(username);
            info.displayName = saved.displayName || "";
            info.category = saved.category || "";
            info.pincode = saved.pincode || "";
            info.signSk = Buffer.from(saved.signSk || '', 'hex');
            info.signPk = Buffer.from(saved.signPk || '', 'hex');
            info.pairedClients = {};
            try {
                for (var _b = tslib_1.__values(Object.keys(saved.pairedClients || {})), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var username_1 = _c.value;
                    var publicKey = saved.pairedClients[username_1];
                    var permission = saved.pairedClientsPermission ? saved.pairedClientsPermission[username_1] : undefined;
                    if (permission === undefined)
                        permission = 1 /* ADMIN */; // defaulting to admin permissions is the only suitable solution, there is no way to recover permissions
                    info.pairedClients[username_1] = {
                        username: username_1,
                        publicKey: Buffer.from(publicKey, 'hex'),
                        permission: permission
                    };
                    if (permission === 1 /* ADMIN */)
                        info.pairedAdminClients++;
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_4) throw e_4.error; }
            }
            info.configVersion = saved.configVersion || 1;
            info.configHash = saved.configHash || "";
            info.setupID = saved.setupID || "";
            info.lastFirmwareVersion = saved.lastFirmwareVersion || packageJson.version;
            info.ensureConfigVersionBounds();
            return info;
        }
        else {
            return null;
        }
    };
    AccessoryInfo.assertValidUsername = function (username) {
        assert_1.default.ok(AccessoryInfo.deviceIdPattern.test(username), "The supplied username (" + username + ") is not valid " +
            "(expected a format like 'XX:XX:XX:XX:XX:XX' with XX being a valid hexadecimal string). " +
            "Note that, if you had this accessory already paired with the invalid username, you will need to repair " +
            "the accessory and reconfigure your services in the Home app. " +
            "Using an invalid username will lead to unexpected behaviour.");
    };
    return AccessoryInfo;
}());
exports.AccessoryInfo = AccessoryInfo;
//# sourceMappingURL=AccessoryInfo.js.map

/***/ }),

/***/ 548:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ControllerStorage = void 0;
var tslib_1 = __nccwpck_require__(4290);
var util_1 = tslib_1.__importDefault(__nccwpck_require__(1669));
var debug_1 = tslib_1.__importDefault(__nccwpck_require__(7984));
var HAPStorage_1 = __nccwpck_require__(7617);
var debug = debug_1.default("HAP-NodeJS:ControllerStorage");
var ControllerStorage = /** @class */ (function () {
    function ControllerStorage(accessory) {
        this.initialized = false;
        this.fileCreated = false;
        this.purgeUnidentifiedAccessoryData = true;
        // ---------------------------------------------------------
        this.trackedControllers = []; // used to track controllers before data was loaded from disk
        this.controllerData = {};
        this.accessoryUUID = accessory.UUID;
    }
    ControllerStorage.prototype.enqueueSaveRequest = function (timeout) {
        var _this = this;
        var _a;
        if (timeout === void 0) { timeout = 0; }
        if (this.parent) {
            this.parent.enqueueSaveRequest(timeout);
            return;
        }
        var plannedTime = Date.now() + timeout;
        if (this.queuedSaveTimeout) {
            if (plannedTime <= ((_a = this.queuedSaveTime) !== null && _a !== void 0 ? _a : 0)) {
                return;
            }
            clearTimeout(this.queuedSaveTimeout);
        }
        this.queuedSaveTimeout = setTimeout(function () {
            _this.queuedSaveTimeout = _this.queuedSaveTime = undefined;
            _this.save();
        }, timeout).unref();
        this.queuedSaveTime = Date.now() + timeout;
    };
    /**
     * Links a bridged accessory to the ControllerStorage of the bridge accessory.
     *
     * @param accessory
     */
    ControllerStorage.prototype.linkAccessory = function (accessory) {
        if (!this.linkedAccessories) {
            this.linkedAccessories = [];
        }
        var storage = accessory.controllerStorage;
        this.linkedAccessories.push(storage);
        storage.parent = this;
        var saved = this.restoredAccessories && this.restoredAccessories[accessory.UUID];
        if (this.initialized) {
            storage.init(saved);
        }
    };
    ControllerStorage.prototype.trackController = function (controller) {
        controller.setupStateChangeDelegate(this.handleStateChange.bind(this, controller)); // setup delegate
        if (!this.initialized) { // track controller if data isn't loaded yet
            this.trackedControllers.push(controller);
        }
        else {
            this.restoreController(controller);
        }
    };
    ControllerStorage.prototype.untrackController = function (controller) {
        var index = this.trackedControllers.indexOf(controller);
        if (index !== -1) { // remove from trackedControllers if storage wasn't initialized yet
            this.trackedControllers.splice(index, 1);
        }
        controller.setupStateChangeDelegate(undefined); // remove associating with this storage object
        this.purgeControllerData(controller);
    };
    ControllerStorage.prototype.purgeControllerData = function (controller) {
        delete this.controllerData[controller.controllerId()];
        if (this.initialized) {
            this.enqueueSaveRequest(100);
        }
    };
    ControllerStorage.prototype.handleStateChange = function (controller) {
        var id = controller.controllerId();
        var serialized = controller.serialize();
        if (!serialized) { // can be undefined when controller wishes to delete data
            delete this.controllerData[id];
        }
        else {
            var controllerData = this.controllerData[id];
            if (!controllerData) {
                this.controllerData[id] = {
                    data: serialized,
                };
            }
            else {
                controllerData.data = serialized;
            }
        }
        if (this.initialized) { // only save if data was loaded
            // run save data "async", as handleStateChange call will probably always be caused by a http request
            // this should improve our response time
            this.enqueueSaveRequest(100);
        }
    };
    ControllerStorage.prototype.restoreController = function (controller) {
        if (!this.initialized) {
            throw new Error("Illegal state. Controller data wasn't loaded yet!");
        }
        var controllerData = this.controllerData[controller.controllerId()];
        if (controllerData) {
            try {
                controller.deserialize(controllerData.data);
            }
            catch (error) {
                console.warn("Could not initialize controller of type '" + controller.controllerId() + "' from data stored on disk. Resetting to default: " + error.stack);
                controller.handleFactoryReset();
            }
            controllerData.purgeOnNextLoad = undefined;
        }
    };
    /**
     * Called when this particular Storage object is feed with data loaded from disk.
     * This method is only called once.
     *
     * @param data - array of {@link StoredControllerData}. undefined if nothing was stored on disk for this particular storage object
     */
    ControllerStorage.prototype.init = function (data) {
        var _this = this;
        if (this.initialized) {
            throw new Error("ControllerStorage for accessory " + this.accessoryUUID + " was already initialized!");
        }
        this.initialized = true;
        // storing data into our local controllerData Record
        data && data.forEach(function (saved) { return _this.controllerData[saved.type] = saved.controllerData; });
        var restoredControllers = [];
        this.trackedControllers.forEach(function (controller) {
            _this.restoreController(controller);
            restoredControllers.push(controller.controllerId());
        });
        this.trackedControllers.splice(0, this.trackedControllers.length); // clear tracking list
        var purgedData = false;
        Object.entries(this.controllerData).forEach(function (_a) {
            var _b = tslib_1.__read(_a, 2), id = _b[0], data = _b[1];
            if (data.purgeOnNextLoad) {
                delete _this.controllerData[id];
                purgedData = true;
                return;
            }
            if (!restoredControllers.includes(id)) {
                data.purgeOnNextLoad = true;
            }
        });
        if (purgedData) {
            this.enqueueSaveRequest(500);
        }
    };
    ControllerStorage.prototype.load = function (username) {
        if (this.username) {
            throw new Error("ControllerStorage was already loaded!");
        }
        this.username = username;
        var key = ControllerStorage.persistKey(username);
        var saved = HAPStorage_1.HAPStorage.storage().getItem(key);
        var ownData;
        if (saved) {
            this.fileCreated = true;
            ownData = saved.accessories[this.accessoryUUID];
            delete saved.accessories[this.accessoryUUID];
        }
        this.init(ownData);
        if (this.linkedAccessories) {
            this.linkedAccessories.forEach(function (linkedStorage) {
                var savedData = saved && saved.accessories[linkedStorage.accessoryUUID];
                linkedStorage.init(savedData);
                if (saved) {
                    delete saved.accessories[linkedStorage.accessoryUUID];
                }
            });
        }
        if (saved && Object.keys(saved.accessories).length > 0) {
            if (!this.purgeUnidentifiedAccessoryData) {
                this.restoredAccessories = saved.accessories; // save data for controllers which aren't linked yet
            }
            else {
                debug("Purging unidentified controller data for bridge %s", username);
            }
        }
    };
    ControllerStorage.prototype.save = function () {
        var _a;
        if (this.parent) {
            this.parent.save();
            return;
        }
        if (!this.initialized) {
            throw new Error("ControllerStorage has not yet been loaded!");
        }
        if (!this.username) {
            throw new Error("Cannot save controllerData for a storage without a username!");
        }
        var accessories = (_a = {},
            _a[this.accessoryUUID] = this.controllerData,
            _a);
        if (this.linkedAccessories) { // grab data from all linked storage objects
            this.linkedAccessories.forEach(function (accessory) { return accessories[accessory.accessoryUUID] = accessory.controllerData; });
        }
        // TODO removed accessories won't ever be deleted?
        var accessoryData = this.restoredAccessories || {};
        Object.entries(accessories).forEach(function (_a) {
            var _b = tslib_1.__read(_a, 2), uuid = _b[0], controllerData = _b[1];
            var entries = Object.entries(controllerData);
            if (entries.length > 0) {
                accessoryData[uuid] = entries.map(function (_a) {
                    var _b = tslib_1.__read(_a, 2), id = _b[0], data = _b[1];
                    return ({
                        type: id,
                        controllerData: data,
                    });
                });
            }
        });
        var key = ControllerStorage.persistKey(this.username);
        if (Object.keys(accessoryData).length > 0) {
            var saved = {
                accessories: accessoryData,
            };
            this.fileCreated = true;
            HAPStorage_1.HAPStorage.storage().setItemSync(key, saved);
        }
        else if (this.fileCreated) {
            this.fileCreated = false;
            HAPStorage_1.HAPStorage.storage().removeItemSync(key);
        }
    };
    ControllerStorage.persistKey = function (username) {
        return util_1.default.format("ControllerStorage.%s.json", username.replace(/:/g, "").toUpperCase());
    };
    ControllerStorage.remove = function (username) {
        var key = ControllerStorage.persistKey(username);
        HAPStorage_1.HAPStorage.storage().removeItemSync(key);
    };
    return ControllerStorage;
}());
exports.ControllerStorage = ControllerStorage;
//# sourceMappingURL=ControllerStorage.js.map

/***/ }),

/***/ 7617:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HAPStorage = void 0;
var tslib_1 = __nccwpck_require__(4290);
// @ts-ignore
var node_persist_1 = tslib_1.__importDefault(__nccwpck_require__(9923));
var HAPStorage = /** @class */ (function () {
    function HAPStorage() {
    }
    HAPStorage.storage = function () {
        return this.INSTANCE.storage();
    };
    HAPStorage.setCustomStoragePath = function (path) {
        this.INSTANCE.setCustomStoragePath(path);
    };
    HAPStorage.prototype.storage = function () {
        if (!this.localStore) {
            this.localStore = node_persist_1.default.create();
            if (this.customStoragePath) {
                this.localStore.initSync({
                    dir: this.customStoragePath,
                });
            }
            else {
                this.localStore.initSync();
            }
        }
        return this.localStore;
    };
    HAPStorage.prototype.setCustomStoragePath = function (path) {
        if (this.localStore) {
            throw new Error("Cannot change storage path after it has already been initialized!");
        }
        this.customStoragePath = path;
    };
    HAPStorage.INSTANCE = new HAPStorage();
    return HAPStorage;
}());
exports.HAPStorage = HAPStorage;
//# sourceMappingURL=HAPStorage.js.map

/***/ }),

/***/ 996:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IdentifierCache = void 0;
var tslib_1 = __nccwpck_require__(4290);
var crypto_1 = tslib_1.__importDefault(__nccwpck_require__(6417));
var util_1 = tslib_1.__importDefault(__nccwpck_require__(1669));
var HAPStorage_1 = __nccwpck_require__(7617);
/**
 * IdentifierCache is a model class that manages a system of associating HAP "Accessory IDs" and "Instance IDs"
 * with other values that don't usually change. HomeKit Clients use Accessory/Instance IDs as a primary key of
 * sorts, so the IDs need to remain "stable". For instance, if you create a HomeKit "Scene" called "Leaving Home"
 * that sets your Alarm System's "Target Alarm State" Characteristic to "Arm Away", that Scene will store whatever
 * "Instance ID" it was given for the "Target Alarm State" Characteristic. If the ID changes later on this server,
 * the scene will stop working.
 */
var IdentifierCache = /** @class */ (function () {
    function IdentifierCache(username) {
        var _this = this;
        this.username = username;
        this._cache = {}; // cache[key:string] = id:number
        this._usedCache = null; // for usage tracking and expiring old keys
        this._savedCacheHash = ""; // for checking if new cache need to be saved
        this.startTrackingUsage = function () {
            _this._usedCache = {};
        };
        this.stopTrackingUsageAndExpireUnused = function () {
            // simply rotate in the new cache that was built during our normal getXYZ() calls.
            _this._cache = _this._usedCache || _this._cache;
            _this._usedCache = null;
        };
        this.getCache = function (key) {
            var value = _this._cache[key];
            // track this cache item if needed
            if (_this._usedCache && typeof value !== 'undefined')
                _this._usedCache[key] = value;
            return value;
        };
        this.setCache = function (key, value) {
            _this._cache[key] = value;
            // track this cache item if needed
            if (_this._usedCache)
                _this._usedCache[key] = value;
            return value;
        };
        this.getAID = function (accessoryUUID) {
            var key = accessoryUUID;
            // ensure that our "next AID" field is not expired
            _this.getCache('|nextAID');
            return _this.getCache(key) || _this.setCache(key, _this.getNextAID());
        };
        this.getIID = function (accessoryUUID, serviceUUID, serviceSubtype, characteristicUUID) {
            var key = accessoryUUID
                + '|' + serviceUUID
                + (serviceSubtype ? '|' + serviceSubtype : '')
                + (characteristicUUID ? '|' + characteristicUUID : '');
            // ensure that our "next IID" field for this accessory is not expired
            _this.getCache(accessoryUUID + '|nextIID');
            return _this.getCache(key) || _this.setCache(key, _this.getNextIID(accessoryUUID));
        };
        this.getNextAID = function () {
            var key = '|nextAID';
            var nextAID = _this.getCache(key) || 2; // start at 2 because the root Accessory or Bridge must be 1
            _this.setCache(key, nextAID + 1); // increment
            return nextAID;
        };
        this.getNextIID = function (accessoryUUID) {
            var key = accessoryUUID + '|nextIID';
            var nextIID = _this.getCache(key) || 2; // iid 1 is reserved for the Accessory Information service
            _this.setCache(key, nextIID + 1); // increment
            return nextIID;
        };
        this.save = function () {
            var newCacheHash = crypto_1.default.createHash('sha1').update(JSON.stringify(_this._cache)).digest('hex'); //calculate hash of new cache
            if (newCacheHash != _this._savedCacheHash) { //check if cache need to be saved and proceed accordingly
                var saved = {
                    cache: _this._cache
                };
                var key = IdentifierCache.persistKey(_this.username);
                HAPStorage_1.HAPStorage.storage().setItemSync(key, saved);
                _this._savedCacheHash = newCacheHash; //update hash of saved cache for future use
            }
        };
    }
    IdentifierCache.remove = function (username) {
        var key = this.persistKey(username);
        HAPStorage_1.HAPStorage.storage().removeItemSync(key);
    };
    /**
     * Persisting to File System
     */
    // Gets a key for storing this IdentifierCache in the filesystem, like "IdentifierCache.CC223DE3CEF3.json"
    IdentifierCache.persistKey = function (username) {
        return util_1.default.format("IdentifierCache.%s.json", username.replace(/:/g, "").toUpperCase());
    };
    IdentifierCache.load = function (username) {
        var key = IdentifierCache.persistKey(username);
        var saved = HAPStorage_1.HAPStorage.storage().getItem(key);
        if (saved) {
            var info = new IdentifierCache(username);
            info._cache = saved.cache;
            info._savedCacheHash = crypto_1.default.createHash('sha1').update(JSON.stringify(info._cache)).digest('hex'); //calculate hash of the saved hash to decide in future if saving of new cache is needed
            return info;
        }
        else {
            return null;
        }
    };
    return IdentifierCache;
}());
exports.IdentifierCache = IdentifierCache;
//# sourceMappingURL=IdentifierCache.js.map

/***/ }),

/***/ 8545:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AccessControlManagement = exports.AccessControlEvent = exports.AccessLevel = void 0;
var tslib_1 = __nccwpck_require__(4290);
var events_1 = __nccwpck_require__(8614);
var Characteristic_1 = __nccwpck_require__(3859);
var Service_1 = __nccwpck_require__(7383);
var tlv = tslib_1.__importStar(__nccwpck_require__(4041));
var AccessControlTypes;
(function (AccessControlTypes) {
    AccessControlTypes[AccessControlTypes["PASSWORD"] = 1] = "PASSWORD";
    AccessControlTypes[AccessControlTypes["PASSWORD_REQUIRED"] = 2] = "PASSWORD_REQUIRED";
})(AccessControlTypes || (AccessControlTypes = {}));
/**
 * This defines the Access Level for TVs and Speakers. It is pretty much only used for the AirPlay 2 protocol
 * so this information is not really useful.
 */
var AccessLevel;
(function (AccessLevel) {
    // noinspection JSUnusedGlobalSymbols
    /**
     * This access level is set when the users selects "Anyone" or "Anyone On The Same Network"
     * in the Access Control settings.
     */
    AccessLevel[AccessLevel["ANYONE"] = 0] = "ANYONE";
    /**
     * This access level is set when the users selects "Only People Sharing this Home" in the
     * Access Control settings.
     * On this level password setting is ignored.
     * Requests to the HAPServer can only come from Home members anyways, so there is no real use to it.
     * This is pretty much only used for the AirPlay 2 protocol.
     */
    AccessLevel[AccessLevel["HOME_MEMBERS_ONLY"] = 1] = "HOME_MEMBERS_ONLY";
    // 2 seems to be also a valid value in the range, but never encountered it.
    // so don't know what's the use of it.
})(AccessLevel = exports.AccessLevel || (exports.AccessLevel = {}));
var AccessControlEvent;
(function (AccessControlEvent) {
    AccessControlEvent["ACCESS_LEVEL_UPDATED"] = "update-control-level";
    AccessControlEvent["PASSWORD_SETTING_UPDATED"] = "update-password";
})(AccessControlEvent = exports.AccessControlEvent || (exports.AccessControlEvent = {}));
var AccessControlManagement = /** @class */ (function (_super) {
    tslib_1.__extends(AccessControlManagement, _super);
    function AccessControlManagement(password, service) {
        var _this = _super.call(this) || this;
        /**
         * The current access level set for the Home
         */
        _this.accessLevel = 0;
        _this.passwordRequired = false;
        _this.accessControlService = service || new Service_1.Service.AccessControl();
        _this.setupServiceHandlers(password);
        return _this;
    }
    /**
     * @returns the AccessControl service
     */
    AccessControlManagement.prototype.getService = function () {
        return this.accessControlService;
    };
    /**
     * @returns the current {@link AccessLevel} configured for the Home
     */
    AccessControlManagement.prototype.getAccessLevel = function () {
        return this.accessLevel;
    };
    /**
     * @returns the current password configured for the Home or `undefined` if no password is required.
     */
    AccessControlManagement.prototype.getPassword = function () {
        return this.passwordRequired ? this.password : undefined;
    };
    /**
     * This destroys the AccessControlManagement.
     * It unregisters all GET or SET handler it has associated with the given AccessControl service.
     * It removes all event handlers which were registered to this object.
     */
    AccessControlManagement.prototype.destroy = function () {
        this.removeAllListeners();
        this.accessControlService.getCharacteristic(Characteristic_1.Characteristic.AccessControlLevel).removeOnSet();
        if (this.accessControlService.testCharacteristic(Characteristic_1.Characteristic.PasswordSetting)) {
            this.accessControlService.getCharacteristic(Characteristic_1.Characteristic.PasswordSetting).removeOnSet();
        }
    };
    AccessControlManagement.prototype.handleAccessLevelChange = function (value) {
        var _this = this;
        this.accessLevel = value;
        setTimeout(function () {
            _this.emit("update-control-level" /* ACCESS_LEVEL_UPDATED */, _this.accessLevel);
        }, 0).unref();
    };
    AccessControlManagement.prototype.handlePasswordChange = function (value) {
        var _this = this;
        var data = Buffer.from(value, "base64");
        var objects = tlv.decode(data);
        if (objects[1 /* PASSWORD */]) {
            this.password = objects[1 /* PASSWORD */].toString("utf8");
        }
        else {
            this.password = undefined;
        }
        this.passwordRequired = !!objects[2 /* PASSWORD_REQUIRED */][0];
        setTimeout(function () {
            _this.emit("update-password" /* PASSWORD_SETTING_UPDATED */, _this.password, _this.passwordRequired);
        }, 0).unref();
    };
    AccessControlManagement.prototype.setupServiceHandlers = function (enabledPasswordCharacteristics) {
        // perms: [Perms.NOTIFY, Perms.PAIRED_READ, Perms.PAIRED_WRITE],
        var _this = this;
        this.accessControlService.getCharacteristic(Characteristic_1.Characteristic.AccessControlLevel)
            .onSet(function (value) { return _this.handleAccessLevelChange(value); })
            .updateValue(0);
        if (enabledPasswordCharacteristics) {
            this.accessControlService.getCharacteristic(Characteristic_1.Characteristic.PasswordSetting)
                .onSet(function (value) { return _this.handlePasswordChange(value); })
                .updateValue("");
        }
    };
    return AccessControlManagement;
}(events_1.EventEmitter));
exports.AccessControlManagement = AccessControlManagement;
//# sourceMappingURL=AccessControlManagement.js.map

/***/ }),

/***/ 9885:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.clone = void 0;
var tslib_1 = __nccwpck_require__(4290);
/**
 * A simple clone function that also allows you to pass an "extend" object whose properties will be
 * added to the cloned copy of the original object passed.
 */
function clone(object, extend) {
    var e_1, _a, e_2, _b;
    var cloned = {};
    try {
        for (var _c = tslib_1.__values(Object.entries(object)), _d = _c.next(); !_d.done; _d = _c.next()) {
            var _e = tslib_1.__read(_d.value, 2), key = _e[0], value = _e[1];
            cloned[key] = value;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (extend) {
        try {
            for (var _f = tslib_1.__values(Object.entries(extend)), _g = _f.next(); !_g.done; _g = _f.next()) {
                var _h = tslib_1.__read(_g.value, 2), key = _h[0], value = _h[1];
                cloned[key] = value;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    return cloned;
}
exports.clone = clone;
//# sourceMappingURL=clone.js.map

/***/ }),

/***/ 1814:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorUtils = void 0;
var tslib_1 = __nccwpck_require__(4290);
var assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
var lookupTable = new Map([
    [100, [19, 222.1]],
    [101, [18.7, 222.2]],
    [102, [18.4, 222.3]],
    [103, [18.2, 222.3]],
    [104, [17.9, 222.4]],
    [105, [17.6, 222.5]],
    [106, [17.3, 222.7]],
    [107, [17, 222.8]],
    [108, [16.7, 222.9]],
    [109, [16.4, 223]],
    [110, [16.1, 223.2]],
    [111, [15.8, 223.3]],
    [112, [15.4, 223.4]],
    [113, [15.2, 223.6]],
    [114, [14.9, 223.8]],
    [115, [14.7, 223.9]],
    [116, [14.3, 224.1]],
    [117, [14.1, 224.2]],
    [118, [13.8, 224.4]],
    [119, [13.5, 224.6]],
    [120, [13.2, 224.8]],
    [121, [12.9, 225]],
    [122, [12.5, 225.3]],
    [123, [12.2, 225.6]],
    [124, [11.8, 225.9]],
    [125, [11.4, 226.3]],
    [126, [11.1, 226.7]],
    [127, [10.7, 227.1]],
    [128, [10.3, 227.6]],
    [129, [9.9, 228]],
    [130, [9.6, 228.5]],
    [131, [9.3, 229.1]],
    [132, [8.9, 229.6]],
    [133, [8.5, 230.2]],
    [134, [8.2, 230.9]],
    [135, [7.8, 231.6]],
    [136, [7.5, 232.5]],
    [137, [7.1, 233.5]],
    [138, [6.7, 234.6]],
    [139, [6.3, 235.8]],
    [140, [6, 237.1]],
    [141, [5.6, 238.9]],
    [142, [5.2, 240.9]],
    [143, [5, 242.9]],
    [144, [4.8, 244.9]],
    [145, [4.6, 246.9]],
    [146, [4.4, 249.3]],
    [147, [4.3, 251.9]],
    [148, [4.1, 254.9]],
    [149, [3.9, 258]],
    [150, [3.7, 261.8]],
    [151, [3.4, 265.9]],
    [152, [3.2, 271]],
    [153, [3, 276.4]],
    [154, [2.8, 283.6]],
    [155, [2.6, 290.4]],
    [156, [2.3, 295.3]],
    [157, [2.1, 300]],
    [158, [1.9, 300]],
    [159, [1.6, 300]],
    [160, [1.4, 195.8]],
    [161, [1.2, 84.3]],
    [162, [1.3, 58.2]],
    [163, [1.5, 55.9]],
    [164, [1.7, 53.2]],
    [165, [1.9, 50.2]],
    [166, [2.1, 47.1]],
    [167, [2.4, 44.5]],
    [168, [2.6, 42.6]],
    [169, [2.9, 40.9]],
    [170, [3.1, 39.5]],
    [171, [3.4, 38.3]],
    [172, [3.7, 37.3]],
    [173, [3.9, 36.5]],
    [174, [4.2, 35.7]],
    [175, [4.4, 35.1]],
    [176, [4.6, 34.5]],
    [177, [4.9, 34]],
    [178, [5.1, 33.5]],
    [179, [5.3, 33]],
    [180, [5.6, 32.7]],
    [181, [5.8, 32.3]],
    [182, [6, 32]],
    [183, [6.3, 31.7]],
    [184, [6.5, 31.4]],
    [185, [6.7, 31.2]],
    [186, [7, 30.9]],
    [187, [7.2, 30.7]],
    [188, [7.4, 30.5]],
    [189, [7.6, 30.3]],
    [190, [7.9, 30.1]],
    [191, [8.1, 29.9]],
    [192, [8.4, 29.7]],
    [193, [8.6, 29.6]],
    [194, [8.9, 29.5]],
    [195, [9.1, 29.3]],
    [196, [9.4, 29.2]],
    [197, [9.6, 29.1]],
    [198, [9.8, 29]],
    [199, [10, 28.9]],
    [200, [10.2, 28.7]],
    [201, [10.5, 28.7]],
    [202, [10.7, 28.6]],
    [203, [11, 28.5]],
    [204, [11.2, 28.4]],
    [205, [11.4, 28.3]],
    [206, [11.6, 28.3]],
    [207, [11.8, 28.2]],
    [208, [12.1, 28.1]],
    [209, [12.3, 28.1]],
    [210, [12.5, 28]],
    [211, [12.7, 28]],
    [212, [12.9, 27.9]],
    [213, [13.2, 27.8]],
    [214, [13.4, 27.8]],
    [215, [13.6, 27.7]],
    [216, [13.8, 27.7]],
    [217, [14, 27.7]],
    [218, [14.3, 27.6]],
    [219, [14.5, 27.6]],
    [220, [14.7, 27.5]],
    [221, [14.9, 27.5]],
    [222, [15.1, 27.5]],
    [223, [15.3, 27.4]],
    [224, [15.5, 27.4]],
    [225, [15.8, 27.4]],
    [226, [16, 27.3]],
    [227, [16.2, 27.3]],
    [228, [16.4, 27.3]],
    [229, [16.6, 27.3]],
    [230, [16.8, 27.2]],
    [231, [17, 27.2]],
    [232, [17.2, 27.2]],
    [233, [17.4, 27.2]],
    [234, [17.6, 27.2]],
    [235, [17.8, 27.1]],
    [236, [18, 27.1]],
    [237, [18.2, 27.1]],
    [238, [18.4, 27.1]],
    [239, [18.7, 27.1]],
    [240, [18.8, 27]],
    [241, [19, 27]],
    [242, [19.2, 27]],
    [243, [19.4, 27]],
    [244, [19.6, 27]],
    [245, [19.8, 27]],
    [246, [20, 27]],
    [247, [20.3, 26.9]],
    [248, [20.5, 26.9]],
    [249, [20.6, 26.9]],
    [250, [20.8, 26.9]],
    [251, [21, 26.9]],
    [252, [21.3, 26.9]],
    [253, [21.5, 26.9]],
    [254, [21.6, 26.9]],
    [255, [21.8, 26.8]],
    [256, [22, 26.8]],
    [257, [22.2, 26.8]],
    [258, [22.4, 26.8]],
    [259, [22.6, 26.8]],
    [260, [22.8, 26.8]],
    [261, [23, 26.8]],
    [262, [23.2, 26.8]],
    [263, [23.4, 26.8]],
    [264, [23.6, 26.8]],
    [265, [23.8, 26.8]],
    [266, [24, 26.8]],
    [267, [24.1, 26.8]],
    [268, [24.3, 26.8]],
    [269, [24.5, 26.8]],
    [270, [24.7, 26.8]],
    [271, [24.8, 26.8]],
    [272, [25.1, 26.7]],
    [273, [25.3, 26.7]],
    [274, [25.4, 26.7]],
    [275, [25.6, 26.7]],
    [276, [25.8, 26.7]],
    [277, [26, 26.7]],
    [278, [26.1, 26.7]],
    [279, [26.3, 26.7]],
    [280, [26.5, 26.7]],
    [281, [26.7, 26.7]],
    [282, [26.9, 26.7]],
    [283, [27.1, 26.7]],
    [284, [27.3, 26.7]],
    [285, [27.5, 26.7]],
    [286, [27.7, 26.7]],
    [287, [27.8, 26.7]],
    [288, [28, 26.7]],
    [289, [28.2, 26.7]],
    [290, [28.4, 26.7]],
    [291, [28.6, 26.7]],
    [292, [28.8, 26.7]],
    [293, [28.9, 26.7]],
    [294, [29.1, 26.7]],
    [295, [29.3, 26.7]],
    [296, [29.5, 26.7]],
    [297, [29.6, 26.7]],
    [298, [29.8, 26.7]],
    [299, [30, 26.7]],
    [300, [30.2, 26.7]],
    [301, [30.4, 26.7]],
    [302, [30.5, 26.7]],
    [303, [30.7, 26.7]],
    [304, [30.9, 26.7]],
    [305, [31.1, 26.7]],
    [306, [31.2, 26.7]],
    [307, [31.4, 26.7]],
    [308, [31.6, 26.7]],
    [309, [31.8, 26.8]],
    [310, [31.9, 26.8]],
    [311, [32.1, 26.8]],
    [312, [32.3, 26.8]],
    [313, [32.5, 26.8]],
    [314, [32.6, 26.8]],
    [315, [32.8, 26.8]],
    [316, [33, 26.8]],
    [317, [33.2, 26.8]],
    [318, [33.3, 26.8]],
    [319, [33.5, 26.8]],
    [320, [33.7, 26.8]],
    [321, [33.8, 26.8]],
    [322, [34, 26.8]],
    [323, [34.2, 26.8]],
    [324, [34.4, 26.8]],
    [325, [34.5, 26.8]],
    [326, [34.7, 26.8]],
    [327, [34.9, 26.8]],
    [328, [35.1, 26.8]],
    [329, [35.2, 26.8]],
    [330, [35.4, 26.8]],
    [331, [35.5, 26.8]],
    [332, [35.7, 26.8]],
    [333, [35.9, 26.8]],
    [334, [36.1, 26.8]],
    [335, [36.3, 26.9]],
    [336, [36.5, 26.9]],
    [337, [36.7, 26.9]],
    [338, [36.9, 26.9]],
    [339, [37.1, 26.9]],
    [340, [37.2, 26.9]],
    [341, [37.4, 26.9]],
    [342, [37.5, 26.9]],
    [343, [37.7, 26.9]],
    [344, [37.9, 26.9]],
    [345, [38.1, 26.9]],
    [346, [38.3, 26.9]],
    [347, [38.5, 26.9]],
    [348, [38.7, 26.9]],
    [349, [38.9, 26.9]],
    [350, [39, 26.9]],
    [351, [39.2, 26.9]],
    [352, [39.3, 27]],
    [353, [39.5, 27]],
    [354, [39.7, 27]],
    [355, [39.9, 27]],
    [356, [40.1, 27]],
    [357, [40.2, 27]],
    [358, [40.4, 27]],
    [359, [40.6, 27]],
    [360, [40.8, 27]],
    [361, [40.9, 27]],
    [362, [41.1, 27]],
    [363, [41.2, 27]],
    [364, [41.4, 27]],
    [365, [41.6, 27]],
    [366, [41.8, 27]],
    [367, [42, 27]],
    [368, [42.1, 27.1]],
    [369, [42.3, 27.1]],
    [370, [42.4, 27.1]],
    [371, [42.6, 27.1]],
    [372, [42.8, 27.1]],
    [373, [43, 27.1]],
    [374, [43.1, 27.1]],
    [375, [43.2, 27.1]],
    [376, [43.4, 27.1]],
    [377, [43.6, 27.1]],
    [378, [43.8, 27.1]],
    [379, [43.9, 27.1]],
    [380, [44.1, 27.1]],
    [381, [44.3, 27.2]],
    [382, [44.4, 27.2]],
    [383, [44.6, 27.2]],
    [384, [44.7, 27.2]],
    [385, [44.9, 27.2]],
    [386, [45.1, 27.2]],
    [387, [45.3, 27.2]],
    [388, [45.5, 27.2]],
    [389, [45.6, 27.2]],
    [390, [45.8, 27.2]],
    [391, [46, 27.2]],
    [392, [46.2, 27.2]],
    [393, [46.4, 27.3]],
    [394, [46.5, 27.3]],
    [395, [46.7, 27.3]],
    [396, [46.9, 27.3]],
    [397, [47.1, 27.3]],
    [398, [47.2, 27.3]],
    [399, [47.4, 27.3]],
    [400, [47.6, 27.3]],
    [401, [47.7, 27.3]],
    [402, [47.9, 27.3]],
    [403, [48.1, 27.3]],
    [404, [48.3, 27.3]],
    [405, [48.5, 27.4]],
    [406, [48.7, 27.4]],
    [407, [48.8, 27.4]],
    [408, [49, 27.4]],
    [409, [49.2, 27.4]],
    [410, [49.4, 27.4]],
    [411, [49.6, 27.4]],
    [412, [49.7, 27.4]],
    [413, [49.9, 27.4]],
    [414, [50.1, 27.4]],
    [415, [50.2, 27.4]],
    [416, [50.4, 27.4]],
    [417, [50.6, 27.5]],
    [418, [50.7, 27.5]],
    [419, [50.9, 27.5]],
    [420, [51.1, 27.5]],
    [421, [51.2, 27.5]],
    [422, [51.4, 27.5]],
    [423, [51.6, 27.5]],
    [424, [51.7, 27.5]],
    [425, [51.9, 27.5]],
    [426, [52.1, 27.5]],
    [427, [51.2, 27.6]],
    [428, [52.4, 27.6]],
    [429, [52.5, 27.6]],
    [430, [52.7, 27.6]],
    [431, [52.9, 27.6]],
    [432, [53.1, 27.6]],
    [433, [53.2, 27.6]],
    [434, [53.4, 27.6]],
    [435, [53.6, 27.6]],
    [436, [53.7, 27.6]],
    [437, [53.9, 27.6]],
    [438, [54.1, 27.7]],
    [439, [54.2, 27.7]],
    [440, [54.3, 27.7]],
    [441, [54.5, 27.7]],
    [442, [54.7, 27.7]],
    [443, [54.8, 27.7]],
    [444, [55, 27.7]],
    [445, [55.2, 27.7]],
    [446, [55.3, 27.7]],
    [447, [55.5, 27.7]],
    [448, [55.7, 27.7]],
    [449, [55.8, 27.8]],
    [450, [56, 27.8]],
    [451, [56.2, 27.8]],
    [452, [56.3, 27.8]],
    [453, [56.5, 27.8]],
    [454, [56.7, 27.8]],
    [455, [56.8, 27.8]],
    [456, [57, 27.8]],
    [457, [57.2, 27.8]],
    [458, [57.3, 27.9]],
    [459, [57.4, 27.9]],
    [460, [57.6, 27.9]],
    [461, [57.8, 27.9]],
    [462, [57.9, 27.9]],
    [463, [58.1, 27.9]],
    [464, [58.3, 27.9]],
    [465, [58.4, 27.9]],
    [466, [58.6, 27.9]],
    [467, [58.8, 27.9]],
    [468, [59, 28]],
    [469, [59.1, 28]],
    [470, [59.2, 28]],
    [471, [59.4, 28]],
    [472, [59.6, 28]],
    [473, [59.7, 28]],
    [474, [60, 28]],
    [475, [60.1, 28]],
    [476, [60.2, 28]],
    [477, [60.4, 28]],
    [478, [60.6, 28.1]],
    [479, [60.7, 28.1]],
    [480, [60.9, 28.1]],
    [481, [60.1, 28.1]],
    [482, [60.3, 28.1]],
    [483, [61.4, 28.1]],
    [484, [61.5, 28.1]],
    [485, [61.7, 28.1]],
    [486, [61.9, 28.1]],
    [487, [62, 28.2]],
    [488, [62.2, 28.2]],
    [489, [62.3, 28.2]],
    [490, [62.5, 28.2]],
    [491, [62.7, 28.2]],
    [492, [62.8, 28.2]],
    [493, [63, 28.2]],
    [494, [63.2, 28.2]],
    [495, [63.3, 28.2]],
    [496, [63.4, 28.2]],
    [497, [63.6, 28.2]],
    [498, [63.8, 28.3]],
    [499, [63.9, 28.3]],
    [500, [64.1, 28.3]],
]);
var ColorUtils = /** @class */ (function () {
    function ColorUtils() {
    }
    /**
     * Returns the Hue and Saturation representation of the given color temperature in mired.
     *
     * @param colorTemperature - The color temperature in mired.
     * @param roundResults - The lookup table has a precision of .1 decimal places. The given characteristics only have a step value of 1.
     *  Thus the method will round the results by default to an integer value. This can be turned of using this option.
     * @returns An number array of length 2 with the first element being the saturation and the second argument being the hue.
     */
    ColorUtils.colorTemperatureToHueAndSaturation = function (colorTemperature, roundResults) {
        if (roundResults === void 0) { roundResults = true; }
        if (colorTemperature > 500) {
            colorTemperature = 500;
        }
        else if (colorTemperature < 100) {
            colorTemperature = 100;
        }
        colorTemperature = Math.round(colorTemperature); // ensure integer
        var hueAndTemperature = lookupTable.get(colorTemperature);
        assert_1.default(colorTemperature != undefined, "lookup for temperature " + colorTemperature + " did not yield any results");
        if (roundResults) {
            hueAndTemperature[0] = Math.round(hueAndTemperature[0]);
            hueAndTemperature[1] = Math.round(hueAndTemperature[1]);
        }
        return {
            saturation: hueAndTemperature[0],
            hue: hueAndTemperature[1],
        };
    };
    return ColorUtils;
}());
exports.ColorUtils = ColorUtils;
//# sourceMappingURL=color-utils.js.map

/***/ }),

/***/ 1561:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HAPConnection = exports.HAPConnectionEvent = exports.HAPConnectionState = exports.EventedHTTPServer = exports.EventedHTTPServerEvent = exports.HAPEncryption = void 0;
var tslib_1 = __nccwpck_require__(4290);
var domain_formatter_1 = __nccwpck_require__(9783);
var assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
var debug_1 = tslib_1.__importDefault(__nccwpck_require__(7984));
var events_1 = __nccwpck_require__(8614);
var http_1 = tslib_1.__importDefault(__nccwpck_require__(8605));
var net_1 = tslib_1.__importDefault(__nccwpck_require__(1631));
var os_1 = tslib_1.__importDefault(__nccwpck_require__(2087));
var hapCrypto = tslib_1.__importStar(__nccwpck_require__(6272));
var net_utils_1 = __nccwpck_require__(3984);
var uuid = tslib_1.__importStar(__nccwpck_require__(6814));
var debug = debug_1.default('HAP-NodeJS:EventedHTTPServer');
var debugCon = debug_1.default("HAP-NodeJS:EventedHTTPServer:Connection");
/**
 * Simple struct to hold vars needed to support HAP encryption.
 */
var HAPEncryption = /** @class */ (function () {
    function HAPEncryption(clientPublicKey, secretKey, publicKey, sharedSecret, hkdfPairEncryptionKey) {
        this.accessoryToControllerCount = 0;
        this.controllerToAccessoryCount = 0;
        this.clientPublicKey = clientPublicKey;
        this.secretKey = secretKey;
        this.publicKey = publicKey;
        this.sharedSecret = sharedSecret;
        this.hkdfPairEncryptionKey = hkdfPairEncryptionKey;
        this.accessoryToControllerKey = Buffer.alloc(0);
        this.controllerToAccessoryKey = Buffer.alloc(0);
    }
    return HAPEncryption;
}());
exports.HAPEncryption = HAPEncryption;
var EventedHTTPServerEvent;
(function (EventedHTTPServerEvent) {
    EventedHTTPServerEvent["LISTENING"] = "listening";
    EventedHTTPServerEvent["CONNECTION_OPENED"] = "connection-opened";
    EventedHTTPServerEvent["REQUEST"] = "request";
    EventedHTTPServerEvent["CONNECTION_CLOSED"] = "connection-closed";
})(EventedHTTPServerEvent = exports.EventedHTTPServerEvent || (exports.EventedHTTPServerEvent = {}));
/**
 * EventedHTTPServer provides an HTTP-like server that supports HAP "extensions" for security and events.
 *
 * Implementation
 * --------------
 * In order to implement the "custom HTTP" server required by the HAP protocol (see HAPServer.js) without completely
 * reinventing the wheel, we create both a generic TCP socket server as well as a standard Node HTTP server.
 * The TCP socket server acts as a proxy, allowing users of this class to transform data (for encryption) as necessary
 * and passing through bytes directly to the HTTP server for processing. This way we get Node to do all
 * the "heavy lifting" of HTTP like parsing headers and formatting responses.
 *
 * Events are sent by simply waiting for current HTTP traffic to subside and then sending a custom response packet
 * directly down the wire via the socket.
 *
 * Each connection to the main TCP server gets its own internal HTTP server, so we can track ongoing requests/responses
 * for safe event insertion.
 */
var EventedHTTPServer = /** @class */ (function (_super) {
    tslib_1.__extends(EventedHTTPServer, _super);
    function EventedHTTPServer() {
        var _this = _super.call(this) || this;
        /**
         * Set of all currently connected HAP connections.
         */
        _this.connections = new Set();
        /**
         * Session dictionary indexed by username/identifier. The username uniquely identifies every person added to the home.
         * So there can be multiple sessions open for a single username (multiple devices connected to the same Apple ID).
         */
        _this.connectionsByUsername = new Map();
        _this.tcpServer = net_1.default.createServer();
        var interval = setInterval(function () {
            var e_1, _a;
            var connectionString = "";
            try {
                for (var _b = tslib_1.__values(_this.connections), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var connection = _c.value;
                    if (connectionString) {
                        connectionString += ", ";
                    }
                    connectionString += connection.remoteAddress + ":" + connection.remotePort;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            debug("Currently " + _this.connections.size + " hap connections open: " + connectionString);
        }, 60000);
        interval.unref();
        return _this;
    }
    EventedHTTPServer.prototype.scheduleNextConnectionIdleTimeout = function () {
        var e_2, _a;
        this.connectionIdleTimeout = undefined;
        if (!this.tcpServer.listening) {
            return;
        }
        debug("Running idle timeout timer...");
        var currentTime = new Date().getTime();
        var nextTimeout = -1;
        try {
            for (var _b = tslib_1.__values(this.connections), _c = _b.next(); !_c.done; _c = _b.next()) {
                var connection = _c.value;
                var timeDelta = currentTime - connection.lastSocketOperation;
                if (timeDelta >= EventedHTTPServer.MAX_CONNECTION_IDLE_TIME) {
                    debug("[%s] Closing connection as it was inactive for " + timeDelta + "ms");
                    connection.close();
                }
                else {
                    nextTimeout = Math.max(nextTimeout, EventedHTTPServer.MAX_CONNECTION_IDLE_TIME - timeDelta);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        if (this.connections.size >= EventedHTTPServer.CONNECTION_TIMEOUT_LIMIT) {
            this.connectionIdleTimeout = setTimeout(this.scheduleNextConnectionIdleTimeout.bind(this), nextTimeout);
        }
    };
    EventedHTTPServer.prototype.listen = function (targetPort, hostname) {
        var _this = this;
        this.tcpServer.listen(targetPort, hostname, function () {
            var address = _this.tcpServer.address(); // address() is only a string when listening to unix domain sockets
            debug("Server listening on %s:%s", address.family === "IPv6" ? "[" + address.address + "]" : address.address, address.port);
            _this.emit("listening" /* LISTENING */, address.port, address.address);
        });
        this.tcpServer.on("connection", this.onConnection.bind(this));
    };
    EventedHTTPServer.prototype.stop = function () {
        var e_3, _a;
        this.tcpServer.close();
        try {
            for (var _b = tslib_1.__values(this.connections), _c = _b.next(); !_c.done; _c = _b.next()) {
                var connection = _c.value;
                connection.close();
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    EventedHTTPServer.prototype.destroy = function () {
        this.stop();
        this.removeAllListeners();
    };
    /**
     * Send a even notification for given characteristic and changed value to all connected clients.
     * If {@param originator} is specified, the given {@link HAPConnection} will be excluded from the broadcast.
     *
     * @param aid - The accessory id of the updated characteristic.
     * @param iid - The instance id of the updated characteristic.
     * @param value - The newly set value of the characteristic.
     * @param originator - If specified, the connection will not get a event message.
     * @param immediateDelivery - The HAP spec requires some characteristics to be delivery immediately.
     *   Namely for the {@link ButtonEvent} and the {@link ProgrammableSwitchEvent} characteristics.
     */
    EventedHTTPServer.prototype.broadcastEvent = function (aid, iid, value, originator, immediateDelivery) {
        var e_4, _a;
        try {
            for (var _b = tslib_1.__values(this.connections), _c = _b.next(); !_c.done; _c = _b.next()) {
                var connection = _c.value;
                if (connection === originator) {
                    debug("[%s] Muting event '%s' notification for this connection since it originated here.", connection.remoteAddress, aid + "." + iid);
                    continue;
                }
                connection.sendEvent(aid, iid, value, immediateDelivery);
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
    };
    EventedHTTPServer.prototype.onConnection = function (socket) {
        var _this = this;
        var connection = new HAPConnection(this, socket);
        connection.on("request" /* REQUEST */, function (request, response) {
            _this.emit("request" /* REQUEST */, connection, request, response);
        });
        connection.on("authenticated" /* AUTHENTICATED */, this.handleConnectionAuthenticated.bind(this, connection));
        connection.on("closed" /* CLOSED */, this.handleConnectionClose.bind(this, connection));
        this.connections.add(connection);
        debug("[%s] New connection from client on interface %s (%s)", connection.remoteAddress, connection.networkInterface, connection.localAddress);
        this.emit("connection-opened" /* CONNECTION_OPENED */, connection);
        if (this.connections.size >= EventedHTTPServer.CONNECTION_TIMEOUT_LIMIT && !this.connectionIdleTimeout) {
            this.scheduleNextConnectionIdleTimeout();
        }
    };
    EventedHTTPServer.prototype.handleConnectionAuthenticated = function (connection, username) {
        var connections = this.connectionsByUsername.get(username);
        if (!connections) {
            this.connectionsByUsername.set(username, [connection]);
        }
        else if (!connections.includes(connection)) { // ensure this doesn't get added more than one time
            connections.push(connection);
        }
    };
    EventedHTTPServer.prototype.handleConnectionClose = function (connection) {
        this.emit("connection-closed" /* CONNECTION_CLOSED */, connection);
        this.connections.delete(connection);
        if (connection.username) { // aka connection was authenticated
            var connections = this.connectionsByUsername.get(connection.username);
            if (connections) {
                var index = connections.indexOf(connection);
                if (index !== -1) {
                    connections.splice(index, 1);
                }
                if (connections.length === 0) {
                    this.connectionsByUsername.delete(connection.username);
                }
            }
        }
    };
    EventedHTTPServer.destroyExistingConnectionsAfterUnpair = function (initiator, username) {
        var e_5, _a;
        var connections = initiator.server.connectionsByUsername.get(username);
        if (connections) {
            try {
                for (var connections_1 = tslib_1.__values(connections), connections_1_1 = connections_1.next(); !connections_1_1.done; connections_1_1 = connections_1.next()) {
                    var connection = connections_1_1.value;
                    connection.closeConnectionAsOfUnpair(initiator);
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (connections_1_1 && !connections_1_1.done && (_a = connections_1.return)) _a.call(connections_1);
                }
                finally { if (e_5) throw e_5.error; }
            }
        }
    };
    EventedHTTPServer.CONNECTION_TIMEOUT_LIMIT = 16; // if we have more (or equal) # connections we start the timeout
    EventedHTTPServer.MAX_CONNECTION_IDLE_TIME = 60 * 60 * 1000; // 1h
    return EventedHTTPServer;
}(events_1.EventEmitter));
exports.EventedHTTPServer = EventedHTTPServer;
/**
 * @private
 */
var HAPConnectionState;
(function (HAPConnectionState) {
    HAPConnectionState[HAPConnectionState["CONNECTING"] = 0] = "CONNECTING";
    HAPConnectionState[HAPConnectionState["FULLY_SET_UP"] = 1] = "FULLY_SET_UP";
    HAPConnectionState[HAPConnectionState["AUTHENTICATED"] = 2] = "AUTHENTICATED";
    // above signals are represent a alive connection
    // below states are considered "closed or soon closed"
    HAPConnectionState[HAPConnectionState["TO_BE_TEARED_DOWN"] = 3] = "TO_BE_TEARED_DOWN";
    HAPConnectionState[HAPConnectionState["CLOSING"] = 4] = "CLOSING";
    HAPConnectionState[HAPConnectionState["CLOSED"] = 5] = "CLOSED";
})(HAPConnectionState = exports.HAPConnectionState || (exports.HAPConnectionState = {}));
var HAPConnectionEvent;
(function (HAPConnectionEvent) {
    HAPConnectionEvent["REQUEST"] = "request";
    HAPConnectionEvent["AUTHENTICATED"] = "authenticated";
    HAPConnectionEvent["CLOSED"] = "closed";
})(HAPConnectionEvent = exports.HAPConnectionEvent || (exports.HAPConnectionEvent = {}));
/**
 * Manages a single iOS-initiated HTTP connection during its lifetime.
 * @private
 */
var HAPConnection = /** @class */ (function (_super) {
    tslib_1.__extends(HAPConnection, _super);
    function HAPConnection(server, clientSocket) {
        var _this = _super.call(this) || this;
        _this.state = 0 /* CONNECTING */;
        _this.lastSocketOperation = new Date().getTime();
        _this.pendingClientSocketData = Buffer.alloc(0); // data received from client before HTTP proxy is fully setup
        _this.handlingRequest = false; // true while we are composing an HTTP response (so events can wait)
        _this.registeredEvents = new Set();
        _this.queuedEvents = new Map();
        _this.pendingEventData = []; // queue of unencrypted event data waiting to be sent until after an in-progress HTTP response is being written
        _this.server = server;
        _this.sessionID = uuid.generate(clientSocket.remoteAddress + ':' + clientSocket.remotePort);
        _this.localAddress = clientSocket.localAddress;
        _this.remoteAddress = clientSocket.remoteAddress; // cache because it becomes undefined in 'onClientSocketClose'
        _this.remotePort = clientSocket.remotePort;
        _this.networkInterface = HAPConnection.getLocalNetworkInterface(clientSocket);
        // clientSocket is the socket connected to the actual iOS device
        _this.tcpSocket = clientSocket;
        _this.tcpSocket.on('data', _this.onTCPSocketData.bind(_this));
        _this.tcpSocket.on('close', _this.onTCPSocketClose.bind(_this));
        _this.tcpSocket.on('error', _this.onTCPSocketError.bind(_this)); // we MUST register for this event, otherwise the error will bubble up to the top and crash the node process entirely.
        _this.tcpSocket.setNoDelay(true); // disable Nagle algorithm
        // "HAP accessory servers must not use keepalive messages, which periodically wake up iOS devices".
        // Thus we don't configure any tcp keepalive
        // create our internal HTTP server for this connection that we will proxy data to and from
        _this.internalHttpServer = http_1.default.createServer();
        _this.internalHttpServer.timeout = 0; // clients expect to hold connections open as long as they want
        _this.internalHttpServer.keepAliveTimeout = 0; // workaround for https://github.com/nodejs/node/issues/13391
        _this.internalHttpServer.on("listening", _this.onHttpServerListening.bind(_this));
        _this.internalHttpServer.on('request', _this.handleHttpServerRequest.bind(_this));
        _this.internalHttpServer.on('error', _this.onHttpServerError.bind(_this));
        // close event is added later on the "connect" event as possible listen retries would throw unnecessary close events
        _this.internalHttpServer.listen(0, _this.internalHttpServerAddress = net_utils_1.getOSLoopbackAddressIfAvailable());
        return _this;
    }
    /**
     * This method is called once the connection has gone through pair-verify.
     * As any HomeKit controller will initiate a pair-verify after the pair-setup procedure, this method gets
     * not called on the initial pair-setup.
     *
     * Once this method has been called, the connection is authenticated and encryption is turned on.
     */
    HAPConnection.prototype.connectionAuthenticated = function (username) {
        this.state = 2 /* AUTHENTICATED */;
        this.username = username;
        this.emit("authenticated" /* AUTHENTICATED */, username);
    };
    HAPConnection.prototype.isAuthenticated = function () {
        return this.state === 2 /* AUTHENTICATED */;
    };
    HAPConnection.prototype.close = function () {
        if (this.state >= 4 /* CLOSING */) {
            return; // already closed/closing
        }
        this.state = 4 /* CLOSING */;
        this.tcpSocket.destroy();
    };
    HAPConnection.prototype.closeConnectionAsOfUnpair = function (initiator) {
        if (this === initiator) {
            // the initiator of the unpair request is this connection, meaning it unpaired itself.
            // we still need to send the response packet to the unpair request.
            this.state = 3 /* TO_BE_TEARED_DOWN */;
        }
        else {
            // as HomeKit requires it, destroy any active session which got unpaired
            this.close();
        }
    };
    HAPConnection.prototype.sendEvent = function (aid, iid, value, immediateDelivery) {
        assert_1.default(aid != undefined, "HAPConnection.sendEvent: aid must be defined!");
        assert_1.default(iid != undefined, "HAPConnection.sendEvent: iid must be defined!");
        var eventName = aid + "." + iid;
        if (!this.registeredEvents.has(eventName)) {
            return;
        }
        if (immediateDelivery) {
            // some characteristics are required to deliver notifications immediately
            this.writeEventNotification({
                characteristics: [{
                        aid: aid,
                        iid: iid,
                        value: value,
                    }],
            });
        }
        else {
            // TODO should a new event not remove a previous event (to support censor open -> censor closed :thinking:)
            //   any only remove previous events if the same value was set?
            this.queuedEvents.set(eventName, {
                aid: aid,
                iid: iid,
                value: value,
            });
            if (!this.handlingRequest && !this.eventsTimer) { // if we are handling a request or there is already a timer running we just add it in the queue
                this.eventsTimer = setTimeout(this.handleEventsTimeout.bind(this), 250);
                this.eventsTimer.unref();
            }
        }
    };
    HAPConnection.prototype.handleEventsTimeout = function () {
        this.eventsTimer = undefined;
        if (this.state > 2 /* AUTHENTICATED */ || this.handlingRequest) {
            // connection is closed or about to be closed. no need to send any further events
            // OR we are currently sending a response
            return;
        }
        this.writeQueuedEventNotifications();
    };
    HAPConnection.prototype.writePendingEventNotifications = function () {
        var e_6, _a;
        try {
            for (var _b = tslib_1.__values(this.pendingEventData), _c = _b.next(); !_c.done; _c = _b.next()) {
                var buffer = _c.value;
                this.tcpSocket.write(this.encrypt(buffer));
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_6) throw e_6.error; }
        }
        this.pendingEventData.splice(0, this.pendingEventData.length);
    };
    HAPConnection.prototype.writeQueuedEventNotifications = function () {
        var e_7, _a;
        if (this.queuedEvents.size === 0 || this.eventsTimer) {
            return; // don't send empty event notifications or if there is a timeout running
        }
        var eventData = { characteristics: [] };
        try {
            for (var _b = tslib_1.__values(this.queuedEvents), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = tslib_1.__read(_c.value, 2), eventName = _d[0], characteristic = _d[1];
                if (!this.registeredEvents.has(eventName)) { // client unregistered events in the mean time
                    continue;
                }
                eventData.characteristics.push(characteristic);
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_7) throw e_7.error; }
        }
        this.queuedEvents.clear();
        this.writeEventNotification(eventData);
    };
    /**
     * This will create an EVENT/1.0 notification header with the provided event notification.
     * If currently a HTTP request is in progress the assembled packet will be
     * added to the pending events list.
     *
     * @param notification - The event which should be sent out
     */
    HAPConnection.prototype.writeEventNotification = function (notification) {
        debugCon("[%s] Sending HAP event notifications %o", this.remoteAddress, notification.characteristics);
        var dataBuffer = Buffer.from(JSON.stringify(notification), "utf8");
        var header = Buffer.from("EVENT/1.0 200 OK\r\n" +
            "Content-Type: application/hap+json\r\n" +
            "Content-Length: " + dataBuffer.length + "\r\n" +
            "\r\n", "utf8" // buffer encoding
        );
        var buffer = Buffer.concat([header, dataBuffer]);
        if (this.handlingRequest) {
            // it is important that we not encrypt the pending event data. This would increment the nonce used in encryption
            this.pendingEventData.push(buffer);
        }
        else {
            this.tcpSocket.write(this.encrypt(buffer), this.handleTCPSocketWriteFulfilled.bind(this));
        }
    };
    HAPConnection.prototype.enableEventNotifications = function (aid, iid) {
        this.registeredEvents.add(aid + "." + iid);
    };
    HAPConnection.prototype.disableEventNotifications = function (aid, iid) {
        this.registeredEvents.delete(aid + "." + iid);
    };
    HAPConnection.prototype.hasEventNotifications = function (aid, iid) {
        return this.registeredEvents.has(aid + "." + iid);
    };
    HAPConnection.prototype.getRegisteredEvents = function () {
        return this.registeredEvents;
    };
    HAPConnection.prototype.clearRegisteredEvents = function () {
        this.registeredEvents.clear();
    };
    HAPConnection.prototype.encrypt = function (data) {
        // if accessoryToControllerKey is not empty, then encryption is enabled for this connection. However, we'll
        // need to be careful to ensure that we don't encrypt the last few bytes of the response from handlePairVerifyStepTwo.
        // Since all communication calls are asynchronous, we could easily receive this 'encrypt' event for those bytes.
        // So we want to make sure that we aren't encrypting data until we have *received* some encrypted data from the client first.
        if (this.encryption && this.encryption.accessoryToControllerKey.length > 0 && this.encryption.controllerToAccessoryCount > 0) {
            return hapCrypto.layerEncrypt(data, this.encryption);
        }
        return data; // otherwise we don't encrypt and return plaintext
    };
    HAPConnection.prototype.decrypt = function (data) {
        if (this.encryption && this.encryption.controllerToAccessoryKey.length > 0) {
            // below call may throw an error if decryption failed
            return hapCrypto.layerDecrypt(data, this.encryption);
        }
        return data; // otherwise we don't decrypt and return plaintext
    };
    HAPConnection.prototype.onHttpServerListening = function () {
        var _this = this;
        var addressInfo = this.internalHttpServer.address(); // address() is only a string when listening to unix domain sockets
        var addressString = addressInfo.family === "IPv6" ? "[" + addressInfo.address + "]" : addressInfo.address;
        this.internalHttpServerPort = addressInfo.port;
        debugCon("[%s] Internal HTTP server listening on %s:%s", this.remoteAddress, addressString, addressInfo.port);
        this.internalHttpServer.on('close', this.onHttpServerClose.bind(this));
        // now we can establish a connection to this running HTTP server for proxying data
        this.httpSocket = net_1.default.createConnection(this.internalHttpServerPort, this.internalHttpServerAddress); // previously we used addressInfo.address
        this.httpSocket.setNoDelay(true); // disable Nagle algorithm
        this.httpSocket.on('data', this.handleHttpServerResponse.bind(this));
        this.httpSocket.on('error', this.onHttpSocketError.bind(this)); // we MUST register for this event, otherwise the error will bubble up to the top and crash the node process entirely.
        this.httpSocket.on('close', this.onHttpSocketClose.bind(this));
        this.httpSocket.on('connect', function () {
            // we are now fully set up:
            //  - clientSocket is connected to the iOS device
            //  - serverSocket is connected to the httpServer
            //  - ready to proxy data!
            _this.state = 1 /* FULLY_SET_UP */;
            debugCon("[%s] Internal HTTP socket connected. HAPConnection now fully set up!", _this.remoteAddress);
            // start by flushing any pending buffered data received from the client while we were setting up
            if (_this.pendingClientSocketData && _this.pendingClientSocketData.length > 0) {
                _this.httpSocket.write(_this.pendingClientSocketData);
            }
            _this.pendingClientSocketData = undefined;
        });
    };
    /**
     * This event handler is called when we receive data from a HomeKit controller on our tcp socket.
     * We store the data if the internal http server is not read yet, or forward it to the http server.
     */
    HAPConnection.prototype.onTCPSocketData = function (data) {
        if (this.state > 2 /* AUTHENTICATED */) {
            // don't accept data of a connection which is about to be closed or already closed
            return;
        }
        this.handlingRequest = true; // reverted to false once response was sent out
        this.lastSocketOperation = new Date().getTime();
        try {
            data = this.decrypt(data);
        }
        catch (error) { // decryption and/or verification failed, disconnect the client
            debugCon("[%s] Error occurred trying to decrypt incoming packet: %s", this.remoteAddress, error.message);
            this.close();
            return;
        }
        if (this.state < 1 /* FULLY_SET_UP */) { // we're not setup yet, so add this data to our intermediate buffer
            this.pendingClientSocketData = Buffer.concat([this.pendingClientSocketData, data]);
        }
        else {
            this.httpSocket.write(data); // proxy it along to the HTTP server
        }
    };
    /**
     * This event handler is called when the internal http server receives a request.
     * Meaning we received data from the HomeKit controller in {@link onTCPSocketData}, which then send the
     * data unencrypted to the internal http server. And now it landed here, fully parsed as a http request.
     */
    HAPConnection.prototype.handleHttpServerRequest = function (request, response) {
        if (this.state > 2 /* AUTHENTICATED */) {
            // don't accept data of a connection which is about to be closed or already closed
            return;
        }
        request.socket.setNoDelay(true);
        response.connection.setNoDelay(true); // deprecated since 13.0.0
        debugCon("[%s] HTTP request: %s", this.remoteAddress, request.url);
        this.emit("request" /* REQUEST */, request, response);
    };
    /**
     * This event handler is called by the socket which is connected to our internal http server.
     * It is called with the response returned from the http server.
     * In this method we have to encrypt and forward the message back to the HomeKit controller.
     */
    HAPConnection.prototype.handleHttpServerResponse = function (data) {
        var _this = this;
        data = this.encrypt(data);
        this.tcpSocket.write(data, this.handleTCPSocketWriteFulfilled.bind(this));
        debugCon("[%s] HTTP Response is finished", this.remoteAddress);
        this.handlingRequest = false;
        if (this.state === 3 /* TO_BE_TEARED_DOWN */) {
            setTimeout(function () { return _this.close(); }, 10);
        }
        else if (this.state < 3 /* TO_BE_TEARED_DOWN */) {
            this.writePendingEventNotifications();
            this.writeQueuedEventNotifications();
        }
    };
    HAPConnection.prototype.handleTCPSocketWriteFulfilled = function () {
        this.lastSocketOperation = new Date().getTime();
    };
    HAPConnection.prototype.onTCPSocketError = function (err) {
        debugCon("[%s] Client connection error: %s", this.remoteAddress, err.message);
        // onTCPSocketClose will be called next
    };
    HAPConnection.prototype.onTCPSocketClose = function () {
        this.state = 5 /* CLOSED */;
        debugCon("[%s] Client connection closed", this.remoteAddress);
        if (this.httpSocket) {
            this.httpSocket.destroy();
        }
        this.internalHttpServer.close();
        this.emit("closed" /* CLOSED */); // sending final closed event
        this.removeAllListeners(); // cleanup listeners, we are officially dead now
    };
    HAPConnection.prototype.onHttpServerError = function (err) {
        debugCon("[%s] HTTP server error: %s", this.remoteAddress, err.message);
        if (err.code === 'EADDRINUSE') {
            this.internalHttpServerPort = undefined;
            this.internalHttpServer.close();
            this.internalHttpServer.listen(0, this.internalHttpServerAddress = net_utils_1.getOSLoopbackAddressIfAvailable());
        }
    };
    HAPConnection.prototype.onHttpServerClose = function () {
        debugCon("[%s] HTTP server was closed", this.remoteAddress);
        // make sure the iOS side is closed as well
        this.close();
    };
    HAPConnection.prototype.onHttpSocketError = function (err) {
        debugCon("[%s] HTTP connection error: ", this.remoteAddress, err.message);
        // onHttpSocketClose will be called next
    };
    HAPConnection.prototype.onHttpSocketClose = function () {
        debugCon("[%s] HTTP connection was closed", this.remoteAddress);
        // we only support a single long-lived connection to our internal HTTP server. Since it's closed,
        // we'll need to shut it down entirely.
        this.internalHttpServer.close();
    };
    HAPConnection.prototype.getLocalAddress = function (ipVersion) {
        var e_8, _a, e_9, _b;
        var infos = os_1.default.networkInterfaces()[this.networkInterface];
        if (ipVersion === "ipv4") {
            try {
                for (var infos_1 = tslib_1.__values(infos), infos_1_1 = infos_1.next(); !infos_1_1.done; infos_1_1 = infos_1.next()) {
                    var info = infos_1_1.value;
                    if (info.family === "IPv4") {
                        return info.address;
                    }
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (infos_1_1 && !infos_1_1.done && (_a = infos_1.return)) _a.call(infos_1);
                }
                finally { if (e_8) throw e_8.error; }
            }
            throw new Error("Could not find " + ipVersion + " address for interface " + this.networkInterface);
        }
        else {
            var localUniqueAddress = undefined;
            try {
                for (var infos_2 = tslib_1.__values(infos), infos_2_1 = infos_2.next(); !infos_2_1.done; infos_2_1 = infos_2.next()) {
                    var info = infos_2_1.value;
                    if (info.family === "IPv6") {
                        if (!info.scopeid) {
                            return info.address;
                        }
                        else if (!localUniqueAddress) {
                            localUniqueAddress = info.address;
                        }
                    }
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (infos_2_1 && !infos_2_1.done && (_b = infos_2.return)) _b.call(infos_2);
                }
                finally { if (e_9) throw e_9.error; }
            }
            if (!localUniqueAddress) {
                throw new Error("Could not find " + ipVersion + " address for interface " + this.networkInterface);
            }
            return localUniqueAddress;
        }
    };
    HAPConnection.getLocalNetworkInterface = function (socket) {
        var e_10, _a, e_11, _b, e_12, _c, e_13, _d;
        var localAddress = socket.localAddress;
        if (localAddress.startsWith("::ffff:")) { // IPv4-Mapped IPv6 Address https://tools.ietf.org/html/rfc4291#section-2.5.5.2
            localAddress = localAddress.substring(7);
        }
        else {
            var index = localAddress.indexOf("%");
            if (index !== -1) { // link-local ipv6
                localAddress = localAddress.substring(0, index);
            }
        }
        var interfaces = os_1.default.networkInterfaces();
        try {
            for (var _e = tslib_1.__values(Object.entries(interfaces)), _f = _e.next(); !_f.done; _f = _e.next()) {
                var _g = tslib_1.__read(_f.value, 2), name = _g[0], infos = _g[1];
                try {
                    for (var infos_3 = (e_11 = void 0, tslib_1.__values(infos)), infos_3_1 = infos_3.next(); !infos_3_1.done; infos_3_1 = infos_3.next()) {
                        var info = infos_3_1.value;
                        if (info.address === localAddress) {
                            return name;
                        }
                    }
                }
                catch (e_11_1) { e_11 = { error: e_11_1 }; }
                finally {
                    try {
                        if (infos_3_1 && !infos_3_1.done && (_b = infos_3.return)) _b.call(infos_3);
                    }
                    finally { if (e_11) throw e_11.error; }
                }
            }
        }
        catch (e_10_1) { e_10 = { error: e_10_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
            }
            finally { if (e_10) throw e_10.error; }
        }
        // we couldn't map the address from above, we try now to match subnets (see https://github.com/homebridge/HAP-NodeJS/issues/847)
        var family = net_1.default.isIPv4(localAddress) ? "IPv4" : "IPv6";
        try {
            for (var _h = tslib_1.__values(Object.entries(interfaces)), _j = _h.next(); !_j.done; _j = _h.next()) {
                var _k = tslib_1.__read(_j.value, 2), name = _k[0], infos = _k[1];
                try {
                    for (var infos_4 = (e_13 = void 0, tslib_1.__values(infos)), infos_4_1 = infos_4.next(); !infos_4_1.done; infos_4_1 = infos_4.next()) {
                        var info = infos_4_1.value;
                        if (info.family !== family) {
                            continue;
                        }
                        // check if the localAddress is in the same subnet
                        if (domain_formatter_1.getNetAddress(localAddress, info.netmask) === domain_formatter_1.getNetAddress(info.address, info.netmask)) {
                            return name;
                        }
                    }
                }
                catch (e_13_1) { e_13 = { error: e_13_1 }; }
                finally {
                    try {
                        if (infos_4_1 && !infos_4_1.done && (_d = infos_4.return)) _d.call(infos_4);
                    }
                    finally { if (e_13) throw e_13.error; }
                }
            }
        }
        catch (e_12_1) { e_12 = { error: e_12_1 }; }
        finally {
            try {
                if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
            }
            finally { if (e_12) throw e_12.error; }
        }
        console.log("WARNING couldn't map socket coming from remote address " + socket.remoteAddress + ":" + socket.remotePort + " at local address " + socket.localAddress + " to a interface!");
        return Object.keys(interfaces)[1]; // just use the first interface after the loopback interface as fallback
    };
    return HAPConnection;
}(events_1.EventEmitter));
exports.HAPConnection = HAPConnection;
//# sourceMappingURL=eventedhttp.js.map

/***/ }),

/***/ 6272:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.writeUInt64LE = exports.chacha20_poly1305_encryptAndSeal = exports.chacha20_poly1305_decryptAndVerify = exports.layerDecrypt = exports.layerEncrypt = exports.HKDF = exports.generateCurve25519SharedSecKey = exports.generateCurve25519KeyPair = void 0;
var tslib_1 = __nccwpck_require__(4290);
var assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
var crypto_1 = tslib_1.__importDefault(__nccwpck_require__(6417));
var futoin_hkdf_1 = tslib_1.__importDefault(__nccwpck_require__(247));
var tweetnacl_1 = tslib_1.__importDefault(__nccwpck_require__(9920));
if (!crypto_1.default.getCiphers().includes("chacha20-poly1305")) {
    assert_1.default.fail("The cipher 'chacha20-poly1305' is not supported with your current running nodejs version v" + process.version + ". " +
        "At least a nodejs version of v10.17.0 (excluding v11.0 and v11.1) is required!");
}
function generateCurve25519KeyPair() {
    return tweetnacl_1.default.box.keyPair();
}
exports.generateCurve25519KeyPair = generateCurve25519KeyPair;
function generateCurve25519SharedSecKey(priKey, pubKey) {
    return tweetnacl_1.default.scalarMult(priKey, pubKey);
}
exports.generateCurve25519SharedSecKey = generateCurve25519SharedSecKey;
function HKDF(hashAlg, salt, ikm, info, size) {
    return futoin_hkdf_1.default(ikm, size, { hash: hashAlg, salt: salt, info: info });
}
exports.HKDF = HKDF;
function layerEncrypt(data, encryption) {
    var result = Buffer.alloc(0);
    var total = data.length;
    for (var offset = 0; offset < total;) {
        var length = Math.min(total - offset, 0x400);
        var leLength = Buffer.alloc(2);
        leLength.writeUInt16LE(length, 0);
        var nonce = Buffer.alloc(8);
        writeUInt64LE(encryption.accessoryToControllerCount++, nonce, 0);
        var encrypted = chacha20_poly1305_encryptAndSeal(encryption.accessoryToControllerKey, nonce, leLength, data.slice(offset, offset + length));
        offset += length;
        result = Buffer.concat([result, leLength, encrypted.ciphertext, encrypted.authTag]);
    }
    return result;
}
exports.layerEncrypt = layerEncrypt;
function layerDecrypt(packet, encryption) {
    if (encryption.incompleteFrame) {
        packet = Buffer.concat([encryption.incompleteFrame, packet]);
        encryption.incompleteFrame = undefined;
    }
    var result = Buffer.alloc(0);
    var total = packet.length;
    for (var offset = 0; offset < total;) {
        var realDataLength = packet.slice(offset, offset + 2).readUInt16LE(0);
        var availableDataLength = total - offset - 2 - 16;
        if (realDataLength > availableDataLength) { // Fragmented packet
            encryption.incompleteFrame = packet.slice(offset);
            break;
        }
        var nonce = Buffer.alloc(8);
        writeUInt64LE(encryption.controllerToAccessoryCount++, nonce, 0);
        var plaintext = chacha20_poly1305_decryptAndVerify(encryption.controllerToAccessoryKey, nonce, packet.slice(offset, offset + 2), packet.slice(offset + 2, offset + 2 + realDataLength), packet.slice(offset + 2 + realDataLength, offset + 2 + realDataLength + 16));
        result = Buffer.concat([result, plaintext]);
        offset += (18 + realDataLength);
    }
    return result;
}
exports.layerDecrypt = layerDecrypt;
function chacha20_poly1305_decryptAndVerify(key, nonce, aad, ciphertext, authTag) {
    // @ts-ignore types for this a really broken
    var decipher = crypto_1.default.createDecipheriv("chacha20-poly1305", key, nonce, { authTagLength: 16 });
    if (aad) {
        decipher.setAAD(aad);
    }
    decipher.setAuthTag(authTag);
    var plaintext = decipher.update(ciphertext);
    decipher.final(); // final call verifies integrity using the auth tag. Throws error if something was manipulated!
    return plaintext;
}
exports.chacha20_poly1305_decryptAndVerify = chacha20_poly1305_decryptAndVerify;
function chacha20_poly1305_encryptAndSeal(key, nonce, aad, plaintext) {
    // @ts-ignore types for this a really broken
    var cipher = crypto_1.default.createCipheriv("chacha20-poly1305", key, nonce, { authTagLength: 16 });
    if (aad) {
        cipher.setAAD(aad);
    }
    var ciphertext = cipher.update(plaintext);
    cipher.final(); // final call creates the auth tag
    var authTag = cipher.getAuthTag();
    return {
        ciphertext: ciphertext,
        authTag: authTag,
    };
}
exports.chacha20_poly1305_encryptAndSeal = chacha20_poly1305_encryptAndSeal;
var MAX_UINT32 = 0x00000000FFFFFFFF;
var MAX_INT53 = 0x001FFFFFFFFFFFFF;
function onesComplement(number) {
    number = ~number;
    if (number < 0) {
        number = (number & 0x7FFFFFFF) + 0x80000000;
    }
    return number;
}
function uintHighLow(number) {
    assert_1.default(number > -1 && number <= MAX_INT53, "number out of range");
    assert_1.default(Math.floor(number) === number, "number must be an integer");
    var high = 0;
    var signbit = number & 0xFFFFFFFF;
    var low = signbit < 0 ? (number & 0x7FFFFFFF) + 0x80000000 : signbit;
    if (number > MAX_UINT32) {
        high = (number - low) / (MAX_UINT32 + 1);
    }
    return [high, low];
}
function intHighLow(number) {
    if (number > -1) {
        return uintHighLow(number);
    }
    var hl = uintHighLow(-number);
    var high = onesComplement(hl[0]);
    var low = onesComplement(hl[1]);
    if (low === MAX_UINT32) {
        high += 1;
        low = 0;
    }
    else {
        low += 1;
    }
    return [high, low];
}
function writeUInt64BE(number, buffer, offset) {
    if (offset === void 0) { offset = 0; }
    var hl = uintHighLow(number);
    buffer.writeUInt32BE(hl[0], offset);
    buffer.writeUInt32BE(hl[1], offset + 4);
}
function writeUInt64LE(number, buffer, offset) {
    if (offset === void 0) { offset = 0; }
    var hl = uintHighLow(number);
    buffer.writeUInt32LE(hl[1], offset);
    buffer.writeUInt32LE(hl[0], offset + 4);
}
exports.writeUInt64LE = writeUInt64LE;
//# sourceMappingURL=hapCrypto.js.map

/***/ }),

/***/ 9495:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HapStatusError = void 0;
var tslib_1 = __nccwpck_require__(4290);
var HAPServer_1 = __nccwpck_require__(7551);
/**
 * Throws a HAP status error that is sent back to HomeKit.
 *
 * @example
 * ```ts
 * throw new HapStatusError(HAPStatus.OPERATION_TIMED_OUT);
 * ```
 */
var HapStatusError = /** @class */ (function (_super) {
    tslib_1.__extends(HapStatusError, _super);
    function HapStatusError(status) {
        var _this = _super.call(this, 'HAP Status Error: ' + status) || this;
        Object.setPrototypeOf(_this, HapStatusError.prototype);
        if (HAPServer_1.IsKnownHAPStatusError(status)) {
            _this.hapStatus = status;
        }
        else {
            _this.hapStatus = -70402 /* SERVICE_COMMUNICATION_FAILURE */;
        }
        return _this;
    }
    return HapStatusError;
}(Error));
exports.HapStatusError = HapStatusError;
//# sourceMappingURL=hapStatusError.js.map

/***/ }),

/***/ 3984:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOSLoopbackAddressIfAvailable = exports.getOSLoopbackAddress = exports.findLoopbackAddress = void 0;
var tslib_1 = __nccwpck_require__(4290);
var os_1 = tslib_1.__importDefault(__nccwpck_require__(2087));
var debug_1 = tslib_1.__importDefault(__nccwpck_require__(7984));
var debug = debug_1.default("HAP-NodeJS:net-utils");
function findLoopbackAddress() {
    var e_1, _a, e_2, _b;
    var ipv6 = undefined; // ::1/128
    var ipv6LinkLocal = undefined; // fe80::/10
    var ipv4 = undefined; // 127.0.0.1/8
    try {
        for (var _c = tslib_1.__values(Object.entries(os_1.default.networkInterfaces())), _d = _c.next(); !_d.done; _d = _c.next()) {
            var _e = tslib_1.__read(_d.value, 2), name = _e[0], infos = _e[1];
            var internal = false;
            try {
                for (var infos_1 = (e_2 = void 0, tslib_1.__values(infos)), infos_1_1 = infos_1.next(); !infos_1_1.done; infos_1_1 = infos_1.next()) {
                    var info = infos_1_1.value;
                    if (!info.internal) {
                        continue;
                    }
                    internal = true;
                    if (info.family === "IPv4") {
                        if (!ipv4) {
                            ipv4 = info.address;
                        }
                    }
                    else if (info.family === "IPv6") {
                        if (info.scopeid) {
                            if (!ipv6LinkLocal) {
                                ipv6LinkLocal = info.address + "%" + name; // ipv6 link local addresses are only valid with a scope
                            }
                        }
                        else if (!ipv6) {
                            ipv6 = info.address;
                        }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (infos_1_1 && !infos_1_1.done && (_b = infos_1.return)) _b.call(infos_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            if (internal) {
                break;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var address = ipv4 || ipv6 || ipv6LinkLocal;
    if (!address) {
        throw new Error("Could not find a valid loopback address on the platform!");
    }
    return address;
}
exports.findLoopbackAddress = findLoopbackAddress;
var loopbackAddress = undefined; // loopback addressed used for the internal http server (::1 or 127.0.0.1)
/**
 * Returns the loopback address for the machine.
 * Uses IPV4 loopback address by default and falls back to global unique IPv6 loopback and then
 * link local IPv6 loopback address.
 * If no loopback interface could be found a error is thrown.
 */
function getOSLoopbackAddress() {
    return loopbackAddress !== null && loopbackAddress !== void 0 ? loopbackAddress : (loopbackAddress = findLoopbackAddress());
}
exports.getOSLoopbackAddress = getOSLoopbackAddress;
/**
 * Refer to {@link getOSLoopbackAddress}.
 * Instead of throwing an error, undefined is returned if loopback interface couldn't be detected.
 */
function getOSLoopbackAddressIfAvailable() {
    try {
        return loopbackAddress !== null && loopbackAddress !== void 0 ? loopbackAddress : (loopbackAddress = findLoopbackAddress());
    }
    catch (error) {
        console.log(error.stack);
        return undefined;
    }
}
exports.getOSLoopbackAddressIfAvailable = getOSLoopbackAddressIfAvailable;
//# sourceMappingURL=net-utils.js.map

/***/ }),

/***/ 8597:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.once = void 0;
var tslib_1 = __nccwpck_require__(4290);
function once(func) {
    var called = false;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (called) {
            throw new Error("This callback function has already been called by someone else; it can only be called one time.");
        }
        else {
            called = true;
            return func.apply(void 0, tslib_1.__spread(args));
        }
    };
}
exports.once = once;
//# sourceMappingURL=once.js.map

/***/ }),

/***/ 8131:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.numericUpperBound = exports.numericLowerBound = exports.isIntegerNumericFormat = exports.isUnsignedNumericFormat = exports.isNumericFormat = exports.formatOutgoingCharacteristicValue = void 0;
function formatOutgoingCharacteristicValue(value, props) {
    var _a;
    if (typeof value === "boolean") {
        return value ? 1 : 0;
    }
    else if (typeof value === "number") {
        if (!props.minStep || props.minStep >= 1) {
            return value;
        }
        var base = (_a = props.minValue) !== null && _a !== void 0 ? _a : 0;
        var inverse = 1 / props.minStep;
        return Math.round(((Math.round((value - base) * inverse) / inverse) + base) * 10000) / 10000;
    }
    return value;
}
exports.formatOutgoingCharacteristicValue = formatOutgoingCharacteristicValue;
function isNumericFormat(format) {
    switch (format) {
        case "int" /* INT */:
        case "float" /* FLOAT */:
        case "uint8" /* UINT8 */:
        case "uint16" /* UINT16 */:
        case "uint32" /* UINT32 */:
        case "uint64" /* UINT64 */:
            return true;
        default:
            return false;
    }
}
exports.isNumericFormat = isNumericFormat;
function isUnsignedNumericFormat(format) {
    switch (format) {
        case "uint8" /* UINT8 */:
        case "uint16" /* UINT16 */:
        case "uint32" /* UINT32 */:
        case "uint64" /* UINT64 */:
            return true;
        default:
            return false;
    }
}
exports.isUnsignedNumericFormat = isUnsignedNumericFormat;
function isIntegerNumericFormat(format) {
    switch (format) {
        case "int" /* INT */:
        case "uint8" /* UINT8 */:
        case "uint16" /* UINT16 */:
        case "uint32" /* UINT32 */:
        case "uint64" /* UINT64 */:
            return true;
        default:
            return false;
    }
}
exports.isIntegerNumericFormat = isIntegerNumericFormat;
function numericLowerBound(format) {
    switch (format) {
        case "int" /* INT */:
            return -2147483648;
        case "uint8" /* UINT8 */:
        case "uint16" /* UINT16 */:
        case "uint32" /* UINT32 */:
        case "uint64" /* UINT64 */:
            return 0;
        default:
            throw new Error("Unable to determine numeric lower bound for " + format);
    }
}
exports.numericLowerBound = numericLowerBound;
function numericUpperBound(format) {
    switch (format) {
        case "int" /* INT */:
            return 2147483647;
        case "uint8" /* UINT8 */:
            return 255;
        case "uint16" /* UINT16 */:
            return 65535;
        case "uint32" /* UINT32 */:
            return 4294967295;
        case "uint64" /* UINT64 */:
            return 18446744073709551615; // don't get fooled, javascript uses 18446744073709552000 here
        default:
            throw new Error("Unable to determine numeric lower bound for " + format);
    }
}
exports.numericUpperBound = numericUpperBound;
//# sourceMappingURL=request-util.js.map

/***/ }),

/***/ 1637:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.epochMillisFromMillisSince2001_01_01 = exports.epochMillisFromMillisSince2001_01_01Buffer = void 0;
var tslib_1 = __nccwpck_require__(4290);
var assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
var tlv_1 = __nccwpck_require__(4041);
var EPOCH_MILLIS_2001_01_01 = Date.UTC(2001, 0, 1, 0, 0, 0, 0);
function epochMillisFromMillisSince2001_01_01Buffer(millis) {
    assert_1.default(millis.length === 8, "can only parse 64 bit buffers!");
    var millisSince2001 = tlv_1.readUInt64BE(millis);
    return epochMillisFromMillisSince2001_01_01(millisSince2001);
}
exports.epochMillisFromMillisSince2001_01_01Buffer = epochMillisFromMillisSince2001_01_01Buffer;
function epochMillisFromMillisSince2001_01_01(millis) {
    return EPOCH_MILLIS_2001_01_01 + millis;
}
exports.epochMillisFromMillisSince2001_01_01 = epochMillisFromMillisSince2001_01_01;
//# sourceMappingURL=time.js.map

/***/ }),

/***/ 4041:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.writeVariableUIntLE = exports.readVariableUIntLE = exports.readUInt16 = exports.writeUInt16 = exports.writeFloat32LE = exports.readUInt32 = exports.writeUInt32 = exports.readUInt64BE = exports.readUInt64 = exports.writeUInt64 = exports.decodeList = exports.decodeWithLists = exports.decode = exports.encode = void 0;
var tslib_1 = __nccwpck_require__(4290);
var assert_1 = tslib_1.__importDefault(__nccwpck_require__(2357));
var hapCrypto = tslib_1.__importStar(__nccwpck_require__(6272));
/**
 * Type Length Value encoding/decoding, used by HAP as a wire format.
 * https://en.wikipedia.org/wiki/Type-length-value
 */
var EMPTY_TLV_TYPE = 0x00; // and empty tlv with id 0 is usually used as delimiter for tlv lists
function encode(type, data) {
    var e_1, _a;
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    var encodedTLVBuffers = [];
    // coerce data to Buffer if needed
    if (typeof data === 'number') {
        data = Buffer.from([data]);
    }
    else if (typeof data === 'string') {
        data = Buffer.from(data);
    }
    if (Array.isArray(data)) {
        var first = true;
        try {
            for (var data_1 = tslib_1.__values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
                var entry = data_1_1.value;
                if (!first) {
                    encodedTLVBuffers.push(Buffer.from([EMPTY_TLV_TYPE, 0])); // push delimiter
                }
                else {
                    first = false;
                }
                encodedTLVBuffers.push(encode(type, entry));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    else if (data.length <= 255) {
        encodedTLVBuffers.push(Buffer.concat([Buffer.from([type, data.length]), data]));
    }
    else { // otherwise it doesn't fit into one tlv entry, thus we push multiple
        var leftBytes = data.length;
        var currentIndex = 0;
        for (; leftBytes > 0;) {
            if (leftBytes >= 255) {
                encodedTLVBuffers.push(Buffer.concat([Buffer.from([type, 0xFF]), data.slice(currentIndex, currentIndex + 255)]));
                leftBytes -= 255;
                currentIndex += 255;
            }
            else {
                encodedTLVBuffers.push(Buffer.concat([Buffer.from([type, leftBytes]), data.slice(currentIndex)]));
                leftBytes -= leftBytes;
            }
        }
    }
    // do we have more arguments to encode?
    if (args.length >= 2) {
        // chop off the first two arguments which we already processed, and process the rest recursively
        var _b = tslib_1.__read(args), nextType = _b[0], nextData = _b[1], nextArgs = _b.slice(2);
        var remainingTLVBuffer = encode.apply(void 0, tslib_1.__spread([nextType, nextData], nextArgs));
        // append the remaining encoded arguments directly to the buffer
        encodedTLVBuffers.push(remainingTLVBuffer);
    }
    return Buffer.concat(encodedTLVBuffers);
}
exports.encode = encode;
/**
 * This method is the legacy way of decoding tlv data.
 * It will not properly decode multiple list of the same id.
 * Should the decoder encounter multiple instances of the same id, it will just concatenate the buffer data.
 *
 * @param buffer - TLV8 data
 */
function decode(buffer) {
    var objects = {};
    var leftLength = buffer.length;
    var currentIndex = 0;
    for (; leftLength > 0;) {
        var type = buffer[currentIndex];
        var length = buffer[currentIndex + 1];
        currentIndex += 2;
        leftLength -= 2;
        var data = buffer.slice(currentIndex, currentIndex + length);
        if (objects[type]) {
            objects[type] = Buffer.concat([objects[type], data]);
        }
        else {
            objects[type] = data;
        }
        currentIndex += length;
        leftLength -= length;
    }
    return objects;
}
exports.decode = decode;
function decodeWithLists(buffer) {
    var result = {};
    var leftBytes = buffer.length;
    var readIndex = 0;
    var lastType = -1;
    var lastLength = -1;
    var lastItemWasDelimiter = false;
    for (; leftBytes > 0;) {
        var type = buffer.readUInt8(readIndex++);
        var length = buffer.readUInt8(readIndex++);
        leftBytes -= 2;
        var data = buffer.slice(readIndex, readIndex + length);
        readIndex += length;
        leftBytes -= length;
        if (type === 0 && length === 0) {
            lastItemWasDelimiter = true;
            continue;
        }
        var existing = result[type];
        if (existing) { // there is already an item with the same type
            if (lastItemWasDelimiter && lastType === type) { // list of tlv types
                if (Array.isArray(existing)) {
                    existing.push(data);
                }
                else {
                    result[type] = [existing, data];
                }
            }
            else if (lastType === type && lastLength === 255) { // tlv data got split into multiple entries as length exceeded 255
                if (Array.isArray(existing)) {
                    // append to the last data blob in the array
                    var last = existing[existing.length - 1];
                    existing[existing.length - 1] = Buffer.concat([last, data]);
                }
                else {
                    result[type] = Buffer.concat([existing, data]);
                }
            }
            else {
                throw new Error("Found duplicated tlv entry with type " + type + " and length " + length + " (lastItemWasDelimiter: " + lastItemWasDelimiter + ", lastType: " + lastType + ", lastLength: " + lastLength + ")");
            }
        }
        else {
            result[type] = data;
        }
        lastType = type;
        lastLength = length;
        lastItemWasDelimiter = false;
    }
    return result;
}
exports.decodeWithLists = decodeWithLists;
function decodeList(data, entryStartId) {
    var objectsList = [];
    var leftLength = data.length;
    var currentIndex = 0;
    var objects = undefined;
    for (; leftLength > 0;) {
        var type = data[currentIndex]; // T
        var length = data[currentIndex + 1]; // L
        var value = data.slice(currentIndex + 2, currentIndex + 2 + length); // V
        if (type === entryStartId) { // we got the start of a new entry
            if (objects !== undefined) { // save the previous entry
                objectsList.push(objects);
            }
            objects = {};
        }
        if (objects === undefined)
            throw new Error("Error parsing tlv list: Encountered uninitialized storage object");
        if (objects[type]) { // append to buffer if we have an already data for this type
            objects[type] = Buffer.concat([value, objects[type]]);
        }
        else {
            objects[type] = value;
        }
        currentIndex += 2 + length;
        leftLength -= 2 + length;
    }
    if (objects !== undefined)
        objectsList.push(objects); // push last entry
    return objectsList;
}
exports.decodeList = decodeList;
function writeUInt64(value) {
    var float64 = new Float64Array(1);
    float64[0] = value;
    var buffer = Buffer.alloc(float64.buffer.byteLength);
    var view = new Uint8Array(float64.buffer);
    for (var i = 0; i < buffer.length; i++) {
        buffer[i] = view[i];
    }
    return buffer;
}
exports.writeUInt64 = writeUInt64;
// noinspection JSUnusedGlobalSymbols
/**
 * @param buffer
 * @deprecated This is pretty much broken
 */
function readUInt64(buffer) {
    var float64 = new Float64Array(buffer);
    return float64[0];
}
exports.readUInt64 = readUInt64;
function readUInt64BE(buffer, offset) {
    if (offset === void 0) { offset = 0; }
    var low = buffer.readUInt32LE(offset);
    return buffer.readUInt32LE(offset + 4) * 0x100000000 + low;
}
exports.readUInt64BE = readUInt64BE;
function writeUInt32(value) {
    var buffer = Buffer.alloc(4);
    buffer.writeUInt32LE(value, 0);
    return buffer;
}
exports.writeUInt32 = writeUInt32;
function readUInt32(buffer) {
    return buffer.readUInt32LE(0);
}
exports.readUInt32 = readUInt32;
function writeFloat32LE(value) {
    var buffer = Buffer.alloc(4);
    buffer.writeFloatLE(value, 0);
    return buffer;
}
exports.writeFloat32LE = writeFloat32LE;
function writeUInt16(value) {
    var buffer = Buffer.alloc(2);
    buffer.writeUInt16LE(value, 0);
    return buffer;
}
exports.writeUInt16 = writeUInt16;
function readUInt16(buffer) {
    return buffer.readUInt16LE(0);
}
exports.readUInt16 = readUInt16;
function readVariableUIntLE(buffer, offset) {
    if (offset === void 0) { offset = 0; }
    switch (buffer.length) {
        case 1:
            return buffer.readUInt8(offset);
        case 2:
            return buffer.readUInt16LE(offset);
        case 4:
            return buffer.readUInt32LE(offset);
        case 8:
            return readUInt64BE(buffer, offset);
        default:
            throw new Error("Can't read uint LE with length " + buffer.length);
    }
}
exports.readVariableUIntLE = readVariableUIntLE;
function writeVariableUIntLE(number, offset) {
    if (offset === void 0) { offset = 0; }
    assert_1.default(number >= 0, "Can't encode a negative integer as unsigned integer");
    if (number <= 255) {
        var buffer = Buffer.alloc(1);
        buffer.writeUInt8(number, offset);
        return buffer;
    }
    else if (number <= 65535) {
        var buffer = Buffer.alloc(2);
        buffer.writeUInt16LE(number, offset);
        return buffer;
    }
    else if (number <= 4294967295) {
        var buffer = Buffer.alloc(4);
        buffer.writeUInt32LE(number, offset);
        return buffer;
    }
    else {
        var buffer = Buffer.alloc(8);
        hapCrypto.writeUInt64LE(number, buffer, offset);
        return buffer;
    }
}
exports.writeVariableUIntLE = writeVariableUIntLE;
//# sourceMappingURL=tlv.js.map

/***/ }),

/***/ 6814:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toLongForm = exports.toShortForm = exports.write = exports.unparse = exports.isValid = exports.generate = exports.BASE_UUID = void 0;
var tslib_1 = __nccwpck_require__(4290);
var crypto_1 = tslib_1.__importDefault(__nccwpck_require__(6417));
exports.BASE_UUID = '-0000-1000-8000-0026BB765291';
// http://stackoverflow.com/a/25951500/66673
function generate(data) {
    var sha1sum = crypto_1.default.createHash('sha1');
    sha1sum.update(data);
    var s = sha1sum.digest('hex');
    var i = -1;
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        i += 1;
        switch (c) {
            case 'y':
                return ((parseInt('0x' + s[i], 16) & 0x3) | 0x8).toString(16);
            case 'x':
            default:
                return s[i];
        }
    });
}
exports.generate = generate;
var VALID_UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function isValid(UUID) {
    return VALID_UUID_REGEX.test(UUID);
}
exports.isValid = isValid;
function unparse(buf, offset) {
    if (offset === void 0) { offset = 0; }
    if (typeof buf === "string" && isValid(buf)) {
        /*
          This check was added to fix backwards compatibility with the old style CameraSource API.
          The old StreamController implementation would not unparse the HAP provided sessionId for the current streaming session.
          This was changed when the new Controller API was introduced, which now turns the sessionId Buffer into a string
          and passes it to the implementor of the Camera.
          Old style CameraSource implementations would use this unparse function to turn the Buffer into a string.
          As the sessionId is already a string we just return it here.
    
          The buf attribute being a also type of "string" as actually an error. Also I don't know who decided to
          not unparse the sessionId. I'm only here to fix things.
         */
        return buf;
    }
    var i = offset;
    return buf.toString("hex", i, (i += 4)) + "-" +
        buf.toString("hex", i, (i += 2)) + "-" +
        buf.toString("hex", i, (i += 2)) + "-" +
        buf.toString("hex", i, (i += 2)) + "-" +
        buf.toString("hex", i, i + 6);
}
exports.unparse = unparse;
function write(uuid, buf, offset) {
    if (offset === void 0) { offset = 0; }
    var buffer = Buffer.from(uuid.replace(/-/g, ""), "hex");
    if (buf) {
        buffer.copy(buf, offset);
        return buf;
    }
    else {
        return buffer;
    }
}
exports.write = write;
var SHORT_FORM_REGEX = /^0*([0-9a-f]{1,8})-([0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
function toShortForm(uuid, base) {
    if (base === void 0) { base = exports.BASE_UUID; }
    if (!isValid(uuid))
        throw new TypeError('uuid was not a valid UUID or short form UUID');
    if (base && !isValid('00000000' + base))
        throw new TypeError('base was not a valid base UUID');
    if (base && !uuid.endsWith(base))
        return uuid.toUpperCase();
    return uuid.replace(SHORT_FORM_REGEX, '$1').toUpperCase();
}
exports.toShortForm = toShortForm;
var VALID_SHORT_REGEX = /^[0-9a-f]{1,8}$/i;
function toLongForm(uuid, base) {
    if (base === void 0) { base = exports.BASE_UUID; }
    if (isValid(uuid))
        return uuid.toUpperCase();
    if (!VALID_SHORT_REGEX.test(uuid))
        throw new TypeError('uuid was not a valid UUID or short form UUID');
    if (!isValid('00000000' + base))
        throw new TypeError('base was not a valid base UUID');
    return (('00000000' + uuid).substr(-8) + base).toUpperCase();
}
exports.toLongForm = toLongForm;
//# sourceMappingURL=uuid.js.map

/***/ }),

/***/ 4128:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 9920:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

(function(nacl) {
'use strict';

// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
//
// Implementation derived from TweetNaCl version 20140427.
// See for details: http://tweetnacl.cr.yp.to/

var gf = function(init) {
  var i, r = new Float64Array(16);
  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
  return r;
};

//  Pluggable, initialized in high-level API below.
var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };

var _0 = new Uint8Array(16);
var _9 = new Uint8Array(32); _9[0] = 9;

var gf0 = gf(),
    gf1 = gf([1]),
    _121665 = gf([0xdb41, 1]),
    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

function ts64(x, i, h, l) {
  x[i]   = (h >> 24) & 0xff;
  x[i+1] = (h >> 16) & 0xff;
  x[i+2] = (h >>  8) & 0xff;
  x[i+3] = h & 0xff;
  x[i+4] = (l >> 24)  & 0xff;
  x[i+5] = (l >> 16)  & 0xff;
  x[i+6] = (l >>  8)  & 0xff;
  x[i+7] = l & 0xff;
}

function vn(x, xi, y, yi, n) {
  var i,d = 0;
  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
  return (1 & ((d - 1) >>> 8)) - 1;
}

function crypto_verify_16(x, xi, y, yi) {
  return vn(x,xi,y,yi,16);
}

function crypto_verify_32(x, xi, y, yi) {
  return vn(x,xi,y,yi,32);
}

function core_salsa20(o, p, k, c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }
   x0 =  x0 +  j0 | 0;
   x1 =  x1 +  j1 | 0;
   x2 =  x2 +  j2 | 0;
   x3 =  x3 +  j3 | 0;
   x4 =  x4 +  j4 | 0;
   x5 =  x5 +  j5 | 0;
   x6 =  x6 +  j6 | 0;
   x7 =  x7 +  j7 | 0;
   x8 =  x8 +  j8 | 0;
   x9 =  x9 +  j9 | 0;
  x10 = x10 + j10 | 0;
  x11 = x11 + j11 | 0;
  x12 = x12 + j12 | 0;
  x13 = x13 + j13 | 0;
  x14 = x14 + j14 | 0;
  x15 = x15 + j15 | 0;

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x1 >>>  0 & 0xff;
  o[ 5] = x1 >>>  8 & 0xff;
  o[ 6] = x1 >>> 16 & 0xff;
  o[ 7] = x1 >>> 24 & 0xff;

  o[ 8] = x2 >>>  0 & 0xff;
  o[ 9] = x2 >>>  8 & 0xff;
  o[10] = x2 >>> 16 & 0xff;
  o[11] = x2 >>> 24 & 0xff;

  o[12] = x3 >>>  0 & 0xff;
  o[13] = x3 >>>  8 & 0xff;
  o[14] = x3 >>> 16 & 0xff;
  o[15] = x3 >>> 24 & 0xff;

  o[16] = x4 >>>  0 & 0xff;
  o[17] = x4 >>>  8 & 0xff;
  o[18] = x4 >>> 16 & 0xff;
  o[19] = x4 >>> 24 & 0xff;

  o[20] = x5 >>>  0 & 0xff;
  o[21] = x5 >>>  8 & 0xff;
  o[22] = x5 >>> 16 & 0xff;
  o[23] = x5 >>> 24 & 0xff;

  o[24] = x6 >>>  0 & 0xff;
  o[25] = x6 >>>  8 & 0xff;
  o[26] = x6 >>> 16 & 0xff;
  o[27] = x6 >>> 24 & 0xff;

  o[28] = x7 >>>  0 & 0xff;
  o[29] = x7 >>>  8 & 0xff;
  o[30] = x7 >>> 16 & 0xff;
  o[31] = x7 >>> 24 & 0xff;

  o[32] = x8 >>>  0 & 0xff;
  o[33] = x8 >>>  8 & 0xff;
  o[34] = x8 >>> 16 & 0xff;
  o[35] = x8 >>> 24 & 0xff;

  o[36] = x9 >>>  0 & 0xff;
  o[37] = x9 >>>  8 & 0xff;
  o[38] = x9 >>> 16 & 0xff;
  o[39] = x9 >>> 24 & 0xff;

  o[40] = x10 >>>  0 & 0xff;
  o[41] = x10 >>>  8 & 0xff;
  o[42] = x10 >>> 16 & 0xff;
  o[43] = x10 >>> 24 & 0xff;

  o[44] = x11 >>>  0 & 0xff;
  o[45] = x11 >>>  8 & 0xff;
  o[46] = x11 >>> 16 & 0xff;
  o[47] = x11 >>> 24 & 0xff;

  o[48] = x12 >>>  0 & 0xff;
  o[49] = x12 >>>  8 & 0xff;
  o[50] = x12 >>> 16 & 0xff;
  o[51] = x12 >>> 24 & 0xff;

  o[52] = x13 >>>  0 & 0xff;
  o[53] = x13 >>>  8 & 0xff;
  o[54] = x13 >>> 16 & 0xff;
  o[55] = x13 >>> 24 & 0xff;

  o[56] = x14 >>>  0 & 0xff;
  o[57] = x14 >>>  8 & 0xff;
  o[58] = x14 >>> 16 & 0xff;
  o[59] = x14 >>> 24 & 0xff;

  o[60] = x15 >>>  0 & 0xff;
  o[61] = x15 >>>  8 & 0xff;
  o[62] = x15 >>> 16 & 0xff;
  o[63] = x15 >>> 24 & 0xff;
}

function core_hsalsa20(o,p,k,c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x5 >>>  0 & 0xff;
  o[ 5] = x5 >>>  8 & 0xff;
  o[ 6] = x5 >>> 16 & 0xff;
  o[ 7] = x5 >>> 24 & 0xff;

  o[ 8] = x10 >>>  0 & 0xff;
  o[ 9] = x10 >>>  8 & 0xff;
  o[10] = x10 >>> 16 & 0xff;
  o[11] = x10 >>> 24 & 0xff;

  o[12] = x15 >>>  0 & 0xff;
  o[13] = x15 >>>  8 & 0xff;
  o[14] = x15 >>> 16 & 0xff;
  o[15] = x15 >>> 24 & 0xff;

  o[16] = x6 >>>  0 & 0xff;
  o[17] = x6 >>>  8 & 0xff;
  o[18] = x6 >>> 16 & 0xff;
  o[19] = x6 >>> 24 & 0xff;

  o[20] = x7 >>>  0 & 0xff;
  o[21] = x7 >>>  8 & 0xff;
  o[22] = x7 >>> 16 & 0xff;
  o[23] = x7 >>> 24 & 0xff;

  o[24] = x8 >>>  0 & 0xff;
  o[25] = x8 >>>  8 & 0xff;
  o[26] = x8 >>> 16 & 0xff;
  o[27] = x8 >>> 24 & 0xff;

  o[28] = x9 >>>  0 & 0xff;
  o[29] = x9 >>>  8 & 0xff;
  o[30] = x9 >>> 16 & 0xff;
  o[31] = x9 >>> 24 & 0xff;
}

function crypto_core_salsa20(out,inp,k,c) {
  core_salsa20(out,inp,k,c);
}

function crypto_core_hsalsa20(out,inp,k,c) {
  core_hsalsa20(out,inp,k,c);
}

var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
            // "expand 32-byte k"

function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
    mpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
  }
  return 0;
}

function crypto_stream_salsa20(c,cpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = x[i];
  }
  return 0;
}

function crypto_stream(c,cpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20(c,cpos,d,sn,s);
}

function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
}

/*
* Port of Andrew Moon's Poly1305-donna-16. Public domain.
* https://github.com/floodyberry/poly1305-donna
*/

var poly1305 = function(key) {
  this.buffer = new Uint8Array(16);
  this.r = new Uint16Array(10);
  this.h = new Uint16Array(10);
  this.pad = new Uint16Array(8);
  this.leftover = 0;
  this.fin = 0;

  var t0, t1, t2, t3, t4, t5, t6, t7;

  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
  this.r[5] = ((t4 >>>  1)) & 0x1ffe;
  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
  this.r[9] = ((t7 >>>  5)) & 0x007f;

  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
};

poly1305.prototype.blocks = function(m, mpos, bytes) {
  var hibit = this.fin ? 0 : (1 << 11);
  var t0, t1, t2, t3, t4, t5, t6, t7, c;
  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;

  var h0 = this.h[0],
      h1 = this.h[1],
      h2 = this.h[2],
      h3 = this.h[3],
      h4 = this.h[4],
      h5 = this.h[5],
      h6 = this.h[6],
      h7 = this.h[7],
      h8 = this.h[8],
      h9 = this.h[9];

  var r0 = this.r[0],
      r1 = this.r[1],
      r2 = this.r[2],
      r3 = this.r[3],
      r4 = this.r[4],
      r5 = this.r[5],
      r6 = this.r[6],
      r7 = this.r[7],
      r8 = this.r[8],
      r9 = this.r[9];

  while (bytes >= 16) {
    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
    h5 += ((t4 >>>  1)) & 0x1fff;
    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
    h9 += ((t7 >>> 5)) | hibit;

    c = 0;

    d0 = c;
    d0 += h0 * r0;
    d0 += h1 * (5 * r9);
    d0 += h2 * (5 * r8);
    d0 += h3 * (5 * r7);
    d0 += h4 * (5 * r6);
    c = (d0 >>> 13); d0 &= 0x1fff;
    d0 += h5 * (5 * r5);
    d0 += h6 * (5 * r4);
    d0 += h7 * (5 * r3);
    d0 += h8 * (5 * r2);
    d0 += h9 * (5 * r1);
    c += (d0 >>> 13); d0 &= 0x1fff;

    d1 = c;
    d1 += h0 * r1;
    d1 += h1 * r0;
    d1 += h2 * (5 * r9);
    d1 += h3 * (5 * r8);
    d1 += h4 * (5 * r7);
    c = (d1 >>> 13); d1 &= 0x1fff;
    d1 += h5 * (5 * r6);
    d1 += h6 * (5 * r5);
    d1 += h7 * (5 * r4);
    d1 += h8 * (5 * r3);
    d1 += h9 * (5 * r2);
    c += (d1 >>> 13); d1 &= 0x1fff;

    d2 = c;
    d2 += h0 * r2;
    d2 += h1 * r1;
    d2 += h2 * r0;
    d2 += h3 * (5 * r9);
    d2 += h4 * (5 * r8);
    c = (d2 >>> 13); d2 &= 0x1fff;
    d2 += h5 * (5 * r7);
    d2 += h6 * (5 * r6);
    d2 += h7 * (5 * r5);
    d2 += h8 * (5 * r4);
    d2 += h9 * (5 * r3);
    c += (d2 >>> 13); d2 &= 0x1fff;

    d3 = c;
    d3 += h0 * r3;
    d3 += h1 * r2;
    d3 += h2 * r1;
    d3 += h3 * r0;
    d3 += h4 * (5 * r9);
    c = (d3 >>> 13); d3 &= 0x1fff;
    d3 += h5 * (5 * r8);
    d3 += h6 * (5 * r7);
    d3 += h7 * (5 * r6);
    d3 += h8 * (5 * r5);
    d3 += h9 * (5 * r4);
    c += (d3 >>> 13); d3 &= 0x1fff;

    d4 = c;
    d4 += h0 * r4;
    d4 += h1 * r3;
    d4 += h2 * r2;
    d4 += h3 * r1;
    d4 += h4 * r0;
    c = (d4 >>> 13); d4 &= 0x1fff;
    d4 += h5 * (5 * r9);
    d4 += h6 * (5 * r8);
    d4 += h7 * (5 * r7);
    d4 += h8 * (5 * r6);
    d4 += h9 * (5 * r5);
    c += (d4 >>> 13); d4 &= 0x1fff;

    d5 = c;
    d5 += h0 * r5;
    d5 += h1 * r4;
    d5 += h2 * r3;
    d5 += h3 * r2;
    d5 += h4 * r1;
    c = (d5 >>> 13); d5 &= 0x1fff;
    d5 += h5 * r0;
    d5 += h6 * (5 * r9);
    d5 += h7 * (5 * r8);
    d5 += h8 * (5 * r7);
    d5 += h9 * (5 * r6);
    c += (d5 >>> 13); d5 &= 0x1fff;

    d6 = c;
    d6 += h0 * r6;
    d6 += h1 * r5;
    d6 += h2 * r4;
    d6 += h3 * r3;
    d6 += h4 * r2;
    c = (d6 >>> 13); d6 &= 0x1fff;
    d6 += h5 * r1;
    d6 += h6 * r0;
    d6 += h7 * (5 * r9);
    d6 += h8 * (5 * r8);
    d6 += h9 * (5 * r7);
    c += (d6 >>> 13); d6 &= 0x1fff;

    d7 = c;
    d7 += h0 * r7;
    d7 += h1 * r6;
    d7 += h2 * r5;
    d7 += h3 * r4;
    d7 += h4 * r3;
    c = (d7 >>> 13); d7 &= 0x1fff;
    d7 += h5 * r2;
    d7 += h6 * r1;
    d7 += h7 * r0;
    d7 += h8 * (5 * r9);
    d7 += h9 * (5 * r8);
    c += (d7 >>> 13); d7 &= 0x1fff;

    d8 = c;
    d8 += h0 * r8;
    d8 += h1 * r7;
    d8 += h2 * r6;
    d8 += h3 * r5;
    d8 += h4 * r4;
    c = (d8 >>> 13); d8 &= 0x1fff;
    d8 += h5 * r3;
    d8 += h6 * r2;
    d8 += h7 * r1;
    d8 += h8 * r0;
    d8 += h9 * (5 * r9);
    c += (d8 >>> 13); d8 &= 0x1fff;

    d9 = c;
    d9 += h0 * r9;
    d9 += h1 * r8;
    d9 += h2 * r7;
    d9 += h3 * r6;
    d9 += h4 * r5;
    c = (d9 >>> 13); d9 &= 0x1fff;
    d9 += h5 * r4;
    d9 += h6 * r3;
    d9 += h7 * r2;
    d9 += h8 * r1;
    d9 += h9 * r0;
    c += (d9 >>> 13); d9 &= 0x1fff;

    c = (((c << 2) + c)) | 0;
    c = (c + d0) | 0;
    d0 = c & 0x1fff;
    c = (c >>> 13);
    d1 += c;

    h0 = d0;
    h1 = d1;
    h2 = d2;
    h3 = d3;
    h4 = d4;
    h5 = d5;
    h6 = d6;
    h7 = d7;
    h8 = d8;
    h9 = d9;

    mpos += 16;
    bytes -= 16;
  }
  this.h[0] = h0;
  this.h[1] = h1;
  this.h[2] = h2;
  this.h[3] = h3;
  this.h[4] = h4;
  this.h[5] = h5;
  this.h[6] = h6;
  this.h[7] = h7;
  this.h[8] = h8;
  this.h[9] = h9;
};

poly1305.prototype.finish = function(mac, macpos) {
  var g = new Uint16Array(10);
  var c, mask, f, i;

  if (this.leftover) {
    i = this.leftover;
    this.buffer[i++] = 1;
    for (; i < 16; i++) this.buffer[i] = 0;
    this.fin = 1;
    this.blocks(this.buffer, 0, 16);
  }

  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  for (i = 2; i < 10; i++) {
    this.h[i] += c;
    c = this.h[i] >>> 13;
    this.h[i] &= 0x1fff;
  }
  this.h[0] += (c * 5);
  c = this.h[0] >>> 13;
  this.h[0] &= 0x1fff;
  this.h[1] += c;
  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  this.h[2] += c;

  g[0] = this.h[0] + 5;
  c = g[0] >>> 13;
  g[0] &= 0x1fff;
  for (i = 1; i < 10; i++) {
    g[i] = this.h[i] + c;
    c = g[i] >>> 13;
    g[i] &= 0x1fff;
  }
  g[9] -= (1 << 13);

  mask = (c ^ 1) - 1;
  for (i = 0; i < 10; i++) g[i] &= mask;
  mask = ~mask;
  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];

  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;

  f = this.h[0] + this.pad[0];
  this.h[0] = f & 0xffff;
  for (i = 1; i < 8; i++) {
    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
    this.h[i] = f & 0xffff;
  }

  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
};

poly1305.prototype.update = function(m, mpos, bytes) {
  var i, want;

  if (this.leftover) {
    want = (16 - this.leftover);
    if (want > bytes)
      want = bytes;
    for (i = 0; i < want; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    bytes -= want;
    mpos += want;
    this.leftover += want;
    if (this.leftover < 16)
      return;
    this.blocks(this.buffer, 0, 16);
    this.leftover = 0;
  }

  if (bytes >= 16) {
    want = bytes - (bytes % 16);
    this.blocks(m, mpos, want);
    mpos += want;
    bytes -= want;
  }

  if (bytes) {
    for (i = 0; i < bytes; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    this.leftover += bytes;
  }
};

function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
  var s = new poly1305(k);
  s.update(m, mpos, n);
  s.finish(out, outpos);
  return 0;
}

function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
  var x = new Uint8Array(16);
  crypto_onetimeauth(x,0,m,mpos,n,k);
  return crypto_verify_16(h,hpos,x,0);
}

function crypto_secretbox(c,m,d,n,k) {
  var i;
  if (d < 32) return -1;
  crypto_stream_xor(c,0,m,0,d,n,k);
  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
  for (i = 0; i < 16; i++) c[i] = 0;
  return 0;
}

function crypto_secretbox_open(m,c,d,n,k) {
  var i;
  var x = new Uint8Array(32);
  if (d < 32) return -1;
  crypto_stream(x,0,32,n,k);
  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
  crypto_stream_xor(m,0,c,0,d,n,k);
  for (i = 0; i < 32; i++) m[i] = 0;
  return 0;
}

function set25519(r, a) {
  var i;
  for (i = 0; i < 16; i++) r[i] = a[i]|0;
}

function car25519(o) {
  var i, v, c = 1;
  for (i = 0; i < 16; i++) {
    v = o[i] + c + 65535;
    c = Math.floor(v / 65536);
    o[i] = v - c * 65536;
  }
  o[0] += c-1 + 37 * (c-1);
}

function sel25519(p, q, b) {
  var t, c = ~(b-1);
  for (var i = 0; i < 16; i++) {
    t = c & (p[i] ^ q[i]);
    p[i] ^= t;
    q[i] ^= t;
  }
}

function pack25519(o, n) {
  var i, j, b;
  var m = gf(), t = gf();
  for (i = 0; i < 16; i++) t[i] = n[i];
  car25519(t);
  car25519(t);
  car25519(t);
  for (j = 0; j < 2; j++) {
    m[0] = t[0] - 0xffed;
    for (i = 1; i < 15; i++) {
      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
      m[i-1] &= 0xffff;
    }
    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
    b = (m[15]>>16) & 1;
    m[14] &= 0xffff;
    sel25519(t, m, 1-b);
  }
  for (i = 0; i < 16; i++) {
    o[2*i] = t[i] & 0xff;
    o[2*i+1] = t[i]>>8;
  }
}

function neq25519(a, b) {
  var c = new Uint8Array(32), d = new Uint8Array(32);
  pack25519(c, a);
  pack25519(d, b);
  return crypto_verify_32(c, 0, d, 0);
}

function par25519(a) {
  var d = new Uint8Array(32);
  pack25519(d, a);
  return d[0] & 1;
}

function unpack25519(o, n) {
  var i;
  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
  o[15] &= 0x7fff;
}

function A(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
}

function Z(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
}

function M(o, a, b) {
  var v, c,
     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
    b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7],
    b8 = b[8],
    b9 = b[9],
    b10 = b[10],
    b11 = b[11],
    b12 = b[12],
    b13 = b[13],
    b14 = b[14],
    b15 = b[15];

  v = a[0];
  t0 += v * b0;
  t1 += v * b1;
  t2 += v * b2;
  t3 += v * b3;
  t4 += v * b4;
  t5 += v * b5;
  t6 += v * b6;
  t7 += v * b7;
  t8 += v * b8;
  t9 += v * b9;
  t10 += v * b10;
  t11 += v * b11;
  t12 += v * b12;
  t13 += v * b13;
  t14 += v * b14;
  t15 += v * b15;
  v = a[1];
  t1 += v * b0;
  t2 += v * b1;
  t3 += v * b2;
  t4 += v * b3;
  t5 += v * b4;
  t6 += v * b5;
  t7 += v * b6;
  t8 += v * b7;
  t9 += v * b8;
  t10 += v * b9;
  t11 += v * b10;
  t12 += v * b11;
  t13 += v * b12;
  t14 += v * b13;
  t15 += v * b14;
  t16 += v * b15;
  v = a[2];
  t2 += v * b0;
  t3 += v * b1;
  t4 += v * b2;
  t5 += v * b3;
  t6 += v * b4;
  t7 += v * b5;
  t8 += v * b6;
  t9 += v * b7;
  t10 += v * b8;
  t11 += v * b9;
  t12 += v * b10;
  t13 += v * b11;
  t14 += v * b12;
  t15 += v * b13;
  t16 += v * b14;
  t17 += v * b15;
  v = a[3];
  t3 += v * b0;
  t4 += v * b1;
  t5 += v * b2;
  t6 += v * b3;
  t7 += v * b4;
  t8 += v * b5;
  t9 += v * b6;
  t10 += v * b7;
  t11 += v * b8;
  t12 += v * b9;
  t13 += v * b10;
  t14 += v * b11;
  t15 += v * b12;
  t16 += v * b13;
  t17 += v * b14;
  t18 += v * b15;
  v = a[4];
  t4 += v * b0;
  t5 += v * b1;
  t6 += v * b2;
  t7 += v * b3;
  t8 += v * b4;
  t9 += v * b5;
  t10 += v * b6;
  t11 += v * b7;
  t12 += v * b8;
  t13 += v * b9;
  t14 += v * b10;
  t15 += v * b11;
  t16 += v * b12;
  t17 += v * b13;
  t18 += v * b14;
  t19 += v * b15;
  v = a[5];
  t5 += v * b0;
  t6 += v * b1;
  t7 += v * b2;
  t8 += v * b3;
  t9 += v * b4;
  t10 += v * b5;
  t11 += v * b6;
  t12 += v * b7;
  t13 += v * b8;
  t14 += v * b9;
  t15 += v * b10;
  t16 += v * b11;
  t17 += v * b12;
  t18 += v * b13;
  t19 += v * b14;
  t20 += v * b15;
  v = a[6];
  t6 += v * b0;
  t7 += v * b1;
  t8 += v * b2;
  t9 += v * b3;
  t10 += v * b4;
  t11 += v * b5;
  t12 += v * b6;
  t13 += v * b7;
  t14 += v * b8;
  t15 += v * b9;
  t16 += v * b10;
  t17 += v * b11;
  t18 += v * b12;
  t19 += v * b13;
  t20 += v * b14;
  t21 += v * b15;
  v = a[7];
  t7 += v * b0;
  t8 += v * b1;
  t9 += v * b2;
  t10 += v * b3;
  t11 += v * b4;
  t12 += v * b5;
  t13 += v * b6;
  t14 += v * b7;
  t15 += v * b8;
  t16 += v * b9;
  t17 += v * b10;
  t18 += v * b11;
  t19 += v * b12;
  t20 += v * b13;
  t21 += v * b14;
  t22 += v * b15;
  v = a[8];
  t8 += v * b0;
  t9 += v * b1;
  t10 += v * b2;
  t11 += v * b3;
  t12 += v * b4;
  t13 += v * b5;
  t14 += v * b6;
  t15 += v * b7;
  t16 += v * b8;
  t17 += v * b9;
  t18 += v * b10;
  t19 += v * b11;
  t20 += v * b12;
  t21 += v * b13;
  t22 += v * b14;
  t23 += v * b15;
  v = a[9];
  t9 += v * b0;
  t10 += v * b1;
  t11 += v * b2;
  t12 += v * b3;
  t13 += v * b4;
  t14 += v * b5;
  t15 += v * b6;
  t16 += v * b7;
  t17 += v * b8;
  t18 += v * b9;
  t19 += v * b10;
  t20 += v * b11;
  t21 += v * b12;
  t22 += v * b13;
  t23 += v * b14;
  t24 += v * b15;
  v = a[10];
  t10 += v * b0;
  t11 += v * b1;
  t12 += v * b2;
  t13 += v * b3;
  t14 += v * b4;
  t15 += v * b5;
  t16 += v * b6;
  t17 += v * b7;
  t18 += v * b8;
  t19 += v * b9;
  t20 += v * b10;
  t21 += v * b11;
  t22 += v * b12;
  t23 += v * b13;
  t24 += v * b14;
  t25 += v * b15;
  v = a[11];
  t11 += v * b0;
  t12 += v * b1;
  t13 += v * b2;
  t14 += v * b3;
  t15 += v * b4;
  t16 += v * b5;
  t17 += v * b6;
  t18 += v * b7;
  t19 += v * b8;
  t20 += v * b9;
  t21 += v * b10;
  t22 += v * b11;
  t23 += v * b12;
  t24 += v * b13;
  t25 += v * b14;
  t26 += v * b15;
  v = a[12];
  t12 += v * b0;
  t13 += v * b1;
  t14 += v * b2;
  t15 += v * b3;
  t16 += v * b4;
  t17 += v * b5;
  t18 += v * b6;
  t19 += v * b7;
  t20 += v * b8;
  t21 += v * b9;
  t22 += v * b10;
  t23 += v * b11;
  t24 += v * b12;
  t25 += v * b13;
  t26 += v * b14;
  t27 += v * b15;
  v = a[13];
  t13 += v * b0;
  t14 += v * b1;
  t15 += v * b2;
  t16 += v * b3;
  t17 += v * b4;
  t18 += v * b5;
  t19 += v * b6;
  t20 += v * b7;
  t21 += v * b8;
  t22 += v * b9;
  t23 += v * b10;
  t24 += v * b11;
  t25 += v * b12;
  t26 += v * b13;
  t27 += v * b14;
  t28 += v * b15;
  v = a[14];
  t14 += v * b0;
  t15 += v * b1;
  t16 += v * b2;
  t17 += v * b3;
  t18 += v * b4;
  t19 += v * b5;
  t20 += v * b6;
  t21 += v * b7;
  t22 += v * b8;
  t23 += v * b9;
  t24 += v * b10;
  t25 += v * b11;
  t26 += v * b12;
  t27 += v * b13;
  t28 += v * b14;
  t29 += v * b15;
  v = a[15];
  t15 += v * b0;
  t16 += v * b1;
  t17 += v * b2;
  t18 += v * b3;
  t19 += v * b4;
  t20 += v * b5;
  t21 += v * b6;
  t22 += v * b7;
  t23 += v * b8;
  t24 += v * b9;
  t25 += v * b10;
  t26 += v * b11;
  t27 += v * b12;
  t28 += v * b13;
  t29 += v * b14;
  t30 += v * b15;

  t0  += 38 * t16;
  t1  += 38 * t17;
  t2  += 38 * t18;
  t3  += 38 * t19;
  t4  += 38 * t20;
  t5  += 38 * t21;
  t6  += 38 * t22;
  t7  += 38 * t23;
  t8  += 38 * t24;
  t9  += 38 * t25;
  t10 += 38 * t26;
  t11 += 38 * t27;
  t12 += 38 * t28;
  t13 += 38 * t29;
  t14 += 38 * t30;
  // t15 left as is

  // first car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  // second car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  o[ 0] = t0;
  o[ 1] = t1;
  o[ 2] = t2;
  o[ 3] = t3;
  o[ 4] = t4;
  o[ 5] = t5;
  o[ 6] = t6;
  o[ 7] = t7;
  o[ 8] = t8;
  o[ 9] = t9;
  o[10] = t10;
  o[11] = t11;
  o[12] = t12;
  o[13] = t13;
  o[14] = t14;
  o[15] = t15;
}

function S(o, a) {
  M(o, a, a);
}

function inv25519(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 253; a >= 0; a--) {
    S(c, c);
    if(a !== 2 && a !== 4) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function pow2523(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 250; a >= 0; a--) {
      S(c, c);
      if(a !== 1) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function crypto_scalarmult(q, n, p) {
  var z = new Uint8Array(32);
  var x = new Float64Array(80), r, i;
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf();
  for (i = 0; i < 31; i++) z[i] = n[i];
  z[31]=(n[31]&127)|64;
  z[0]&=248;
  unpack25519(x,p);
  for (i = 0; i < 16; i++) {
    b[i]=x[i];
    d[i]=a[i]=c[i]=0;
  }
  a[0]=d[0]=1;
  for (i=254; i>=0; --i) {
    r=(z[i>>>3]>>>(i&7))&1;
    sel25519(a,b,r);
    sel25519(c,d,r);
    A(e,a,c);
    Z(a,a,c);
    A(c,b,d);
    Z(b,b,d);
    S(d,e);
    S(f,a);
    M(a,c,a);
    M(c,b,e);
    A(e,a,c);
    Z(a,a,c);
    S(b,a);
    Z(c,d,f);
    M(a,c,_121665);
    A(a,a,d);
    M(c,c,a);
    M(a,d,f);
    M(d,b,x);
    S(b,e);
    sel25519(a,b,r);
    sel25519(c,d,r);
  }
  for (i = 0; i < 16; i++) {
    x[i+16]=a[i];
    x[i+32]=c[i];
    x[i+48]=b[i];
    x[i+64]=d[i];
  }
  var x32 = x.subarray(32);
  var x16 = x.subarray(16);
  inv25519(x32,x32);
  M(x16,x16,x32);
  pack25519(q,x16);
  return 0;
}

function crypto_scalarmult_base(q, n) {
  return crypto_scalarmult(q, n, _9);
}

function crypto_box_keypair(y, x) {
  randombytes(x, 32);
  return crypto_scalarmult_base(y, x);
}

function crypto_box_beforenm(k, y, x) {
  var s = new Uint8Array(32);
  crypto_scalarmult(s, x, y);
  return crypto_core_hsalsa20(k, _0, s, sigma);
}

var crypto_box_afternm = crypto_secretbox;
var crypto_box_open_afternm = crypto_secretbox_open;

function crypto_box(c, m, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_afternm(c, m, d, n, k);
}

function crypto_box_open(m, c, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_open_afternm(m, c, d, n, k);
}

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function crypto_hashblocks_hl(hh, hl, m, n) {
  var wh = new Int32Array(16), wl = new Int32Array(16),
      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
      th, tl, i, j, h, l, a, b, c, d;

  var ah0 = hh[0],
      ah1 = hh[1],
      ah2 = hh[2],
      ah3 = hh[3],
      ah4 = hh[4],
      ah5 = hh[5],
      ah6 = hh[6],
      ah7 = hh[7],

      al0 = hl[0],
      al1 = hl[1],
      al2 = hl[2],
      al3 = hl[3],
      al4 = hl[4],
      al5 = hl[5],
      al6 = hl[6],
      al7 = hl[7];

  var pos = 0;
  while (n >= 128) {
    for (i = 0; i < 16; i++) {
      j = 8 * i + pos;
      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
    }
    for (i = 0; i < 80; i++) {
      bh0 = ah0;
      bh1 = ah1;
      bh2 = ah2;
      bh3 = ah3;
      bh4 = ah4;
      bh5 = ah5;
      bh6 = ah6;
      bh7 = ah7;

      bl0 = al0;
      bl1 = al1;
      bl2 = al2;
      bl3 = al3;
      bl4 = al4;
      bl5 = al5;
      bl6 = al6;
      bl7 = al7;

      // add
      h = ah7;
      l = al7;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma1
      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Ch
      h = (ah4 & ah5) ^ (~ah4 & ah6);
      l = (al4 & al5) ^ (~al4 & al6);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // K
      h = K[i*2];
      l = K[i*2+1];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // w
      h = wh[i%16];
      l = wl[i%16];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      th = c & 0xffff | d << 16;
      tl = a & 0xffff | b << 16;

      // add
      h = th;
      l = tl;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma0
      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Maj
      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh7 = (c & 0xffff) | (d << 16);
      bl7 = (a & 0xffff) | (b << 16);

      // add
      h = bh3;
      l = bl3;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      h = th;
      l = tl;

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh3 = (c & 0xffff) | (d << 16);
      bl3 = (a & 0xffff) | (b << 16);

      ah1 = bh0;
      ah2 = bh1;
      ah3 = bh2;
      ah4 = bh3;
      ah5 = bh4;
      ah6 = bh5;
      ah7 = bh6;
      ah0 = bh7;

      al1 = bl0;
      al2 = bl1;
      al3 = bl2;
      al4 = bl3;
      al5 = bl4;
      al6 = bl5;
      al7 = bl6;
      al0 = bl7;

      if (i%16 === 15) {
        for (j = 0; j < 16; j++) {
          // add
          h = wh[j];
          l = wl[j];

          a = l & 0xffff; b = l >>> 16;
          c = h & 0xffff; d = h >>> 16;

          h = wh[(j+9)%16];
          l = wl[(j+9)%16];

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma0
          th = wh[(j+1)%16];
          tl = wl[(j+1)%16];
          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma1
          th = wh[(j+14)%16];
          tl = wl[(j+14)%16];
          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;

          wh[j] = (c & 0xffff) | (d << 16);
          wl[j] = (a & 0xffff) | (b << 16);
        }
      }
    }

    // add
    h = ah0;
    l = al0;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[0];
    l = hl[0];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[0] = ah0 = (c & 0xffff) | (d << 16);
    hl[0] = al0 = (a & 0xffff) | (b << 16);

    h = ah1;
    l = al1;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[1];
    l = hl[1];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[1] = ah1 = (c & 0xffff) | (d << 16);
    hl[1] = al1 = (a & 0xffff) | (b << 16);

    h = ah2;
    l = al2;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[2];
    l = hl[2];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[2] = ah2 = (c & 0xffff) | (d << 16);
    hl[2] = al2 = (a & 0xffff) | (b << 16);

    h = ah3;
    l = al3;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[3];
    l = hl[3];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[3] = ah3 = (c & 0xffff) | (d << 16);
    hl[3] = al3 = (a & 0xffff) | (b << 16);

    h = ah4;
    l = al4;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[4];
    l = hl[4];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[4] = ah4 = (c & 0xffff) | (d << 16);
    hl[4] = al4 = (a & 0xffff) | (b << 16);

    h = ah5;
    l = al5;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[5];
    l = hl[5];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[5] = ah5 = (c & 0xffff) | (d << 16);
    hl[5] = al5 = (a & 0xffff) | (b << 16);

    h = ah6;
    l = al6;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[6];
    l = hl[6];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[6] = ah6 = (c & 0xffff) | (d << 16);
    hl[6] = al6 = (a & 0xffff) | (b << 16);

    h = ah7;
    l = al7;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[7];
    l = hl[7];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[7] = ah7 = (c & 0xffff) | (d << 16);
    hl[7] = al7 = (a & 0xffff) | (b << 16);

    pos += 128;
    n -= 128;
  }

  return n;
}

function crypto_hash(out, m, n) {
  var hh = new Int32Array(8),
      hl = new Int32Array(8),
      x = new Uint8Array(256),
      i, b = n;

  hh[0] = 0x6a09e667;
  hh[1] = 0xbb67ae85;
  hh[2] = 0x3c6ef372;
  hh[3] = 0xa54ff53a;
  hh[4] = 0x510e527f;
  hh[5] = 0x9b05688c;
  hh[6] = 0x1f83d9ab;
  hh[7] = 0x5be0cd19;

  hl[0] = 0xf3bcc908;
  hl[1] = 0x84caa73b;
  hl[2] = 0xfe94f82b;
  hl[3] = 0x5f1d36f1;
  hl[4] = 0xade682d1;
  hl[5] = 0x2b3e6c1f;
  hl[6] = 0xfb41bd6b;
  hl[7] = 0x137e2179;

  crypto_hashblocks_hl(hh, hl, m, n);
  n %= 128;

  for (i = 0; i < n; i++) x[i] = m[b-n+i];
  x[n] = 128;

  n = 256-128*(n<112?1:0);
  x[n-9] = 0;
  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
  crypto_hashblocks_hl(hh, hl, x, n);

  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);

  return 0;
}

function add(p, q) {
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf(),
      g = gf(), h = gf(), t = gf();

  Z(a, p[1], p[0]);
  Z(t, q[1], q[0]);
  M(a, a, t);
  A(b, p[0], p[1]);
  A(t, q[0], q[1]);
  M(b, b, t);
  M(c, p[3], q[3]);
  M(c, c, D2);
  M(d, p[2], q[2]);
  A(d, d, d);
  Z(e, b, a);
  Z(f, d, c);
  A(g, d, c);
  A(h, b, a);

  M(p[0], e, f);
  M(p[1], h, g);
  M(p[2], g, f);
  M(p[3], e, h);
}

function cswap(p, q, b) {
  var i;
  for (i = 0; i < 4; i++) {
    sel25519(p[i], q[i], b);
  }
}

function pack(r, p) {
  var tx = gf(), ty = gf(), zi = gf();
  inv25519(zi, p[2]);
  M(tx, p[0], zi);
  M(ty, p[1], zi);
  pack25519(r, ty);
  r[31] ^= par25519(tx) << 7;
}

function scalarmult(p, q, s) {
  var b, i;
  set25519(p[0], gf0);
  set25519(p[1], gf1);
  set25519(p[2], gf1);
  set25519(p[3], gf0);
  for (i = 255; i >= 0; --i) {
    b = (s[(i/8)|0] >> (i&7)) & 1;
    cswap(p, q, b);
    add(q, p);
    add(p, p);
    cswap(p, q, b);
  }
}

function scalarbase(p, s) {
  var q = [gf(), gf(), gf(), gf()];
  set25519(q[0], X);
  set25519(q[1], Y);
  set25519(q[2], gf1);
  M(q[3], X, Y);
  scalarmult(p, q, s);
}

function crypto_sign_keypair(pk, sk, seeded) {
  var d = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()];
  var i;

  if (!seeded) randombytes(sk, 32);
  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  scalarbase(p, d);
  pack(pk, p);

  for (i = 0; i < 32; i++) sk[i+32] = pk[i];
  return 0;
}

var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

function modL(r, x) {
  var carry, i, j, k;
  for (i = 63; i >= 32; --i) {
    carry = 0;
    for (j = i - 32, k = i - 12; j < k; ++j) {
      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
      carry = Math.floor((x[j] + 128) / 256);
      x[j] -= carry * 256;
    }
    x[j] += carry;
    x[i] = 0;
  }
  carry = 0;
  for (j = 0; j < 32; j++) {
    x[j] += carry - (x[31] >> 4) * L[j];
    carry = x[j] >> 8;
    x[j] &= 255;
  }
  for (j = 0; j < 32; j++) x[j] -= carry * L[j];
  for (i = 0; i < 32; i++) {
    x[i+1] += x[i] >> 8;
    r[i] = x[i] & 255;
  }
}

function reduce(r) {
  var x = new Float64Array(64), i;
  for (i = 0; i < 64; i++) x[i] = r[i];
  for (i = 0; i < 64; i++) r[i] = 0;
  modL(r, x);
}

// Note: difference from C - smlen returned, not passed as argument.
function crypto_sign(sm, m, n, sk) {
  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
  var i, j, x = new Float64Array(64);
  var p = [gf(), gf(), gf(), gf()];

  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  var smlen = n + 64;
  for (i = 0; i < n; i++) sm[64 + i] = m[i];
  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

  crypto_hash(r, sm.subarray(32), n+32);
  reduce(r);
  scalarbase(p, r);
  pack(sm, p);

  for (i = 32; i < 64; i++) sm[i] = sk[i];
  crypto_hash(h, sm, n + 64);
  reduce(h);

  for (i = 0; i < 64; i++) x[i] = 0;
  for (i = 0; i < 32; i++) x[i] = r[i];
  for (i = 0; i < 32; i++) {
    for (j = 0; j < 32; j++) {
      x[i+j] += h[i] * d[j];
    }
  }

  modL(sm.subarray(32), x);
  return smlen;
}

function unpackneg(r, p) {
  var t = gf(), chk = gf(), num = gf(),
      den = gf(), den2 = gf(), den4 = gf(),
      den6 = gf();

  set25519(r[2], gf1);
  unpack25519(r[1], p);
  S(num, r[1]);
  M(den, num, D);
  Z(num, num, r[2]);
  A(den, r[2], den);

  S(den2, den);
  S(den4, den2);
  M(den6, den4, den2);
  M(t, den6, num);
  M(t, t, den);

  pow2523(t, t);
  M(t, t, num);
  M(t, t, den);
  M(t, t, den);
  M(r[0], t, den);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) M(r[0], r[0], I);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) return -1;

  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

  M(r[3], r[0], r[1]);
  return 0;
}

function crypto_sign_open(m, sm, n, pk) {
  var i;
  var t = new Uint8Array(32), h = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()],
      q = [gf(), gf(), gf(), gf()];

  if (n < 64) return -1;

  if (unpackneg(q, pk)) return -1;

  for (i = 0; i < n; i++) m[i] = sm[i];
  for (i = 0; i < 32; i++) m[i+32] = pk[i];
  crypto_hash(h, m, n);
  reduce(h);
  scalarmult(p, q, h);

  scalarbase(q, sm.subarray(32));
  add(p, q);
  pack(t, p);

  n -= 64;
  if (crypto_verify_32(sm, 0, t, 0)) {
    for (i = 0; i < n; i++) m[i] = 0;
    return -1;
  }

  for (i = 0; i < n; i++) m[i] = sm[i + 64];
  return n;
}

var crypto_secretbox_KEYBYTES = 32,
    crypto_secretbox_NONCEBYTES = 24,
    crypto_secretbox_ZEROBYTES = 32,
    crypto_secretbox_BOXZEROBYTES = 16,
    crypto_scalarmult_BYTES = 32,
    crypto_scalarmult_SCALARBYTES = 32,
    crypto_box_PUBLICKEYBYTES = 32,
    crypto_box_SECRETKEYBYTES = 32,
    crypto_box_BEFORENMBYTES = 32,
    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
    crypto_sign_BYTES = 64,
    crypto_sign_PUBLICKEYBYTES = 32,
    crypto_sign_SECRETKEYBYTES = 64,
    crypto_sign_SEEDBYTES = 32,
    crypto_hash_BYTES = 64;

nacl.lowlevel = {
  crypto_core_hsalsa20: crypto_core_hsalsa20,
  crypto_stream_xor: crypto_stream_xor,
  crypto_stream: crypto_stream,
  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
  crypto_stream_salsa20: crypto_stream_salsa20,
  crypto_onetimeauth: crypto_onetimeauth,
  crypto_onetimeauth_verify: crypto_onetimeauth_verify,
  crypto_verify_16: crypto_verify_16,
  crypto_verify_32: crypto_verify_32,
  crypto_secretbox: crypto_secretbox,
  crypto_secretbox_open: crypto_secretbox_open,
  crypto_scalarmult: crypto_scalarmult,
  crypto_scalarmult_base: crypto_scalarmult_base,
  crypto_box_beforenm: crypto_box_beforenm,
  crypto_box_afternm: crypto_box_afternm,
  crypto_box: crypto_box,
  crypto_box_open: crypto_box_open,
  crypto_box_keypair: crypto_box_keypair,
  crypto_hash: crypto_hash,
  crypto_sign: crypto_sign,
  crypto_sign_keypair: crypto_sign_keypair,
  crypto_sign_open: crypto_sign_open,

  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
  crypto_sign_BYTES: crypto_sign_BYTES,
  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
  crypto_hash_BYTES: crypto_hash_BYTES,

  gf: gf,
  D: D,
  L: L,
  pack25519: pack25519,
  unpack25519: unpack25519,
  M: M,
  A: A,
  S: S,
  Z: Z,
  pow2523: pow2523,
  add: add,
  set25519: set25519,
  modL: modL,
  scalarmult: scalarmult,
  scalarbase: scalarbase,
};

/* High-level API */

function checkLengths(k, n) {
  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
}

function checkBoxLengths(pk, sk) {
  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
}

function checkArrayTypes() {
  for (var i = 0; i < arguments.length; i++) {
    if (!(arguments[i] instanceof Uint8Array))
      throw new TypeError('unexpected type, use Uint8Array');
  }
}

function cleanup(arr) {
  for (var i = 0; i < arr.length; i++) arr[i] = 0;
}

nacl.randomBytes = function(n) {
  var b = new Uint8Array(n);
  randombytes(b, n);
  return b;
};

nacl.secretbox = function(msg, nonce, key) {
  checkArrayTypes(msg, nonce, key);
  checkLengths(key, nonce);
  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
  var c = new Uint8Array(m.length);
  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
  crypto_secretbox(c, m, m.length, nonce, key);
  return c.subarray(crypto_secretbox_BOXZEROBYTES);
};

nacl.secretbox.open = function(box, nonce, key) {
  checkArrayTypes(box, nonce, key);
  checkLengths(key, nonce);
  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
  var m = new Uint8Array(c.length);
  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
  if (c.length < 32) return null;
  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
  return m.subarray(crypto_secretbox_ZEROBYTES);
};

nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

nacl.scalarMult = function(n, p) {
  checkArrayTypes(n, p);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult(q, n, p);
  return q;
};

nacl.scalarMult.base = function(n) {
  checkArrayTypes(n);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult_base(q, n);
  return q;
};

nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

nacl.box = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox(msg, nonce, k);
};

nacl.box.before = function(publicKey, secretKey) {
  checkArrayTypes(publicKey, secretKey);
  checkBoxLengths(publicKey, secretKey);
  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
  crypto_box_beforenm(k, publicKey, secretKey);
  return k;
};

nacl.box.after = nacl.secretbox;

nacl.box.open = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox.open(msg, nonce, k);
};

nacl.box.open.after = nacl.secretbox.open;

nacl.box.keyPair = function() {
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
  crypto_box_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.box.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_box_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  crypto_scalarmult_base(pk, secretKey);
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
nacl.box.nonceLength = crypto_box_NONCEBYTES;
nacl.box.overheadLength = nacl.secretbox.overheadLength;

nacl.sign = function(msg, secretKey) {
  checkArrayTypes(msg, secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
  crypto_sign(signedMsg, msg, msg.length, secretKey);
  return signedMsg;
};

nacl.sign.open = function(signedMsg, publicKey) {
  checkArrayTypes(signedMsg, publicKey);
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var tmp = new Uint8Array(signedMsg.length);
  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
  if (mlen < 0) return null;
  var m = new Uint8Array(mlen);
  for (var i = 0; i < m.length; i++) m[i] = tmp[i];
  return m;
};

nacl.sign.detached = function(msg, secretKey) {
  var signedMsg = nacl.sign(msg, secretKey);
  var sig = new Uint8Array(crypto_sign_BYTES);
  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
  return sig;
};

nacl.sign.detached.verify = function(msg, sig, publicKey) {
  checkArrayTypes(msg, sig, publicKey);
  if (sig.length !== crypto_sign_BYTES)
    throw new Error('bad signature size');
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
  var m = new Uint8Array(crypto_sign_BYTES + msg.length);
  var i;
  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
};

nacl.sign.keyPair = function() {
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  crypto_sign_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.sign.keyPair.fromSeed = function(seed) {
  checkArrayTypes(seed);
  if (seed.length !== crypto_sign_SEEDBYTES)
    throw new Error('bad seed size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  for (var i = 0; i < 32; i++) sk[i] = seed[i];
  crypto_sign_keypair(pk, sk, true);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
nacl.sign.seedLength = crypto_sign_SEEDBYTES;
nacl.sign.signatureLength = crypto_sign_BYTES;

nacl.hash = function(msg) {
  checkArrayTypes(msg);
  var h = new Uint8Array(crypto_hash_BYTES);
  crypto_hash(h, msg, msg.length);
  return h;
};

nacl.hash.hashLength = crypto_hash_BYTES;

nacl.verify = function(x, y) {
  checkArrayTypes(x, y);
  // Zero length arguments are considered not equal.
  if (x.length === 0 || y.length === 0) return false;
  if (x.length !== y.length) return false;
  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
};

nacl.setPRNG = function(fn) {
  randombytes = fn;
};

(function() {
  // Initialize PRNG if environment provides CSPRNG.
  // If not, methods calling randombytes will throw.
  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
  if (crypto && crypto.getRandomValues) {
    // Browsers.
    var QUOTA = 65536;
    nacl.setPRNG(function(x, n) {
      var i, v = new Uint8Array(n);
      for (i = 0; i < n; i += QUOTA) {
        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
      }
      for (i = 0; i < n; i++) x[i] = v[i];
      cleanup(v);
    });
  } else if (true) {
    // Node.js.
    crypto = __nccwpck_require__(6417);
    if (crypto && crypto.randomBytes) {
      nacl.setPRNG(function(x, n) {
        var i, v = crypto.randomBytes(n);
        for (i = 0; i < n; i++) x[i] = v[i];
        cleanup(v);
      });
    }
  }
})();

})( true && module.exports ? module.exports : (self.nacl = self.nacl || {}));


/***/ }),

/***/ 4250:
/***/ ((module) => {

"use strict";


module.exports = (flag, argv = process.argv) => {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};


/***/ }),

/***/ 3805:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __nccwpck_require__(2545);

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ 2545:
/***/ ((module) => {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ 9930:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var bind = __nccwpck_require__(4517);

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


/***/ }),

/***/ 6919:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

try {
  var util = __nccwpck_require__(1669);
  /* istanbul ignore next */
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = __nccwpck_require__(7526);
}


/***/ }),

/***/ 7526:
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ 3434:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var ip = exports;
var Buffer = __nccwpck_require__(4293).Buffer;
var os = __nccwpck_require__(2087);

ip.toBuffer = function(ip, buff, offset) {
  offset = ~~offset;

  var result;

  if (this.isV4Format(ip)) {
    result = buff || new Buffer(offset + 4);
    ip.split(/\./g).map(function(byte) {
      result[offset++] = parseInt(byte, 10) & 0xff;
    });
  } else if (this.isV6Format(ip)) {
    var sections = ip.split(':', 8);

    var i;
    for (i = 0; i < sections.length; i++) {
      var isv4 = this.isV4Format(sections[i]);
      var v4Buffer;

      if (isv4) {
        v4Buffer = this.toBuffer(sections[i]);
        sections[i] = v4Buffer.slice(0, 2).toString('hex');
      }

      if (v4Buffer && ++i < 8) {
        sections.splice(i, 0, v4Buffer.slice(2, 4).toString('hex'));
      }
    }

    if (sections[0] === '') {
      while (sections.length < 8) sections.unshift('0');
    } else if (sections[sections.length - 1] === '') {
      while (sections.length < 8) sections.push('0');
    } else if (sections.length < 8) {
      for (i = 0; i < sections.length && sections[i] !== ''; i++);
      var argv = [ i, 1 ];
      for (i = 9 - sections.length; i > 0; i--) {
        argv.push('0');
      }
      sections.splice.apply(sections, argv);
    }

    result = buff || new Buffer(offset + 16);
    for (i = 0; i < sections.length; i++) {
      var word = parseInt(sections[i], 16);
      result[offset++] = (word >> 8) & 0xff;
      result[offset++] = word & 0xff;
    }
  }

  if (!result) {
    throw Error('Invalid ip address: ' + ip);
  }

  return result;
};

ip.toString = function(buff, offset, length) {
  offset = ~~offset;
  length = length || (buff.length - offset);

  var result = [];
  if (length === 4) {
    // IPv4
    for (var i = 0; i < length; i++) {
      result.push(buff[offset + i]);
    }
    result = result.join('.');
  } else if (length === 16) {
    // IPv6
    for (var i = 0; i < length; i += 2) {
      result.push(buff.readUInt16BE(offset + i).toString(16));
    }
    result = result.join(':');
    result = result.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3');
    result = result.replace(/:{3,4}/, '::');
  }

  return result;
};

var ipv4Regex = /^(\d{1,3}\.){3,3}\d{1,3}$/;
var ipv6Regex =
    /^(::)?(((\d{1,3}\.){3}(\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;

ip.isV4Format = function(ip) {
  return ipv4Regex.test(ip);
};

ip.isV6Format = function(ip) {
  return ipv6Regex.test(ip);
};
function _normalizeFamily(family) {
  return family ? family.toLowerCase() : 'ipv4';
}

ip.fromPrefixLen = function(prefixlen, family) {
  if (prefixlen > 32) {
    family = 'ipv6';
  } else {
    family = _normalizeFamily(family);
  }

  var len = 4;
  if (family === 'ipv6') {
    len = 16;
  }
  var buff = new Buffer(len);

  for (var i = 0, n = buff.length; i < n; ++i) {
    var bits = 8;
    if (prefixlen < 8) {
      bits = prefixlen;
    }
    prefixlen -= bits;

    buff[i] = ~(0xff >> bits) & 0xff;
  }

  return ip.toString(buff);
};

ip.mask = function(addr, mask) {
  addr = ip.toBuffer(addr);
  mask = ip.toBuffer(mask);

  var result = new Buffer(Math.max(addr.length, mask.length));

  var i = 0;
  // Same protocol - do bitwise and
  if (addr.length === mask.length) {
    for (i = 0; i < addr.length; i++) {
      result[i] = addr[i] & mask[i];
    }
  } else if (mask.length === 4) {
    // IPv6 address and IPv4 mask
    // (Mask low bits)
    for (i = 0; i < mask.length; i++) {
      result[i] = addr[addr.length - 4  + i] & mask[i];
    }
  } else {
    // IPv6 mask and IPv4 addr
    for (var i = 0; i < result.length - 6; i++) {
      result[i] = 0;
    }

    // ::ffff:ipv4
    result[10] = 0xff;
    result[11] = 0xff;
    for (i = 0; i < addr.length; i++) {
      result[i + 12] = addr[i] & mask[i + 12];
    }
    i = i + 12;
  }
  for (; i < result.length; i++)
    result[i] = 0;

  return ip.toString(result);
};

ip.cidr = function(cidrString) {
  var cidrParts = cidrString.split('/');

  var addr = cidrParts[0];
  if (cidrParts.length !== 2)
    throw new Error('invalid CIDR subnet: ' + addr);

  var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));

  return ip.mask(addr, mask);
};

ip.subnet = function(addr, mask) {
  var networkAddress = ip.toLong(ip.mask(addr, mask));

  // Calculate the mask's length.
  var maskBuffer = ip.toBuffer(mask);
  var maskLength = 0;

  for (var i = 0; i < maskBuffer.length; i++) {
    if (maskBuffer[i] === 0xff) {
      maskLength += 8;
    } else {
      var octet = maskBuffer[i] & 0xff;
      while (octet) {
        octet = (octet << 1) & 0xff;
        maskLength++;
      }
    }
  }

  var numberOfAddresses = Math.pow(2, 32 - maskLength);

  return {
    networkAddress: ip.fromLong(networkAddress),
    firstAddress: numberOfAddresses <= 2 ?
                    ip.fromLong(networkAddress) :
                    ip.fromLong(networkAddress + 1),
    lastAddress: numberOfAddresses <= 2 ?
                    ip.fromLong(networkAddress + numberOfAddresses - 1) :
                    ip.fromLong(networkAddress + numberOfAddresses - 2),
    broadcastAddress: ip.fromLong(networkAddress + numberOfAddresses - 1),
    subnetMask: mask,
    subnetMaskLength: maskLength,
    numHosts: numberOfAddresses <= 2 ?
                numberOfAddresses : numberOfAddresses - 2,
    length: numberOfAddresses,
    contains: function(other) {
      return networkAddress === ip.toLong(ip.mask(other, mask));
    }
  };
};

ip.cidrSubnet = function(cidrString) {
  var cidrParts = cidrString.split('/');

  var addr = cidrParts[0];
  if (cidrParts.length !== 2)
    throw new Error('invalid CIDR subnet: ' + addr);

  var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));

  return ip.subnet(addr, mask);
};

ip.not = function(addr) {
  var buff = ip.toBuffer(addr);
  for (var i = 0; i < buff.length; i++) {
    buff[i] = 0xff ^ buff[i];
  }
  return ip.toString(buff);
};

ip.or = function(a, b) {
  a = ip.toBuffer(a);
  b = ip.toBuffer(b);

  // same protocol
  if (a.length === b.length) {
    for (var i = 0; i < a.length; ++i) {
      a[i] |= b[i];
    }
    return ip.toString(a);

  // mixed protocols
  } else {
    var buff = a;
    var other = b;
    if (b.length > a.length) {
      buff = b;
      other = a;
    }

    var offset = buff.length - other.length;
    for (var i = offset; i < buff.length; ++i) {
      buff[i] |= other[i - offset];
    }

    return ip.toString(buff);
  }
};

ip.isEqual = function(a, b) {
  a = ip.toBuffer(a);
  b = ip.toBuffer(b);

  // Same protocol
  if (a.length === b.length) {
    for (var i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }

  // Swap
  if (b.length === 4) {
    var t = b;
    b = a;
    a = t;
  }

  // a - IPv4, b - IPv6
  for (var i = 0; i < 10; i++) {
    if (b[i] !== 0) return false;
  }

  var word = b.readUInt16BE(10);
  if (word !== 0 && word !== 0xffff) return false;

  for (var i = 0; i < 4; i++) {
    if (a[i] !== b[i + 12]) return false;
  }

  return true;
};

ip.isPrivate = function(addr) {
  return /^(::f{4}:)?10\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i
      .test(addr) ||
    /^(::f{4}:)?192\.168\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) ||
    /^(::f{4}:)?172\.(1[6-9]|2\d|30|31)\.([0-9]{1,3})\.([0-9]{1,3})$/i
      .test(addr) ||
    /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) ||
    /^(::f{4}:)?169\.254\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) ||
    /^f[cd][0-9a-f]{2}:/i.test(addr) ||
    /^fe80:/i.test(addr) ||
    /^::1$/.test(addr) ||
    /^::$/.test(addr);
};

ip.isPublic = function(addr) {
  return !ip.isPrivate(addr);
};

ip.isLoopback = function(addr) {
  return /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})/
      .test(addr) ||
    /^fe80::1$/.test(addr) ||
    /^::1$/.test(addr) ||
    /^::$/.test(addr);
};

ip.loopback = function(family) {
  //
  // Default to `ipv4`
  //
  family = _normalizeFamily(family);

  if (family !== 'ipv4' && family !== 'ipv6') {
    throw new Error('family must be ipv4 or ipv6');
  }

  return family === 'ipv4' ? '127.0.0.1' : 'fe80::1';
};

//
// ### function address (name, family)
// #### @name {string|'public'|'private'} **Optional** Name or security
//      of the network interface.
// #### @family {ipv4|ipv6} **Optional** IP family of the address (defaults
//      to ipv4).
//
// Returns the address for the network interface on the current system with
// the specified `name`:
//   * String: First `family` address of the interface.
//             If not found see `undefined`.
//   * 'public': the first public ip address of family.
//   * 'private': the first private ip address of family.
//   * undefined: First address with `ipv4` or loopback address `127.0.0.1`.
//
ip.address = function(name, family) {
  var interfaces = os.networkInterfaces();
  var all;

  //
  // Default to `ipv4`
  //
  family = _normalizeFamily(family);

  //
  // If a specific network interface has been named,
  // return the address.
  //
  if (name && name !== 'private' && name !== 'public') {
    var res = interfaces[name].filter(function(details) {
      var itemFamily = details.family.toLowerCase();
      return itemFamily === family;
    });
    if (res.length === 0)
      return undefined;
    return res[0].address;
  }

  var all = Object.keys(interfaces).map(function (nic) {
    //
    // Note: name will only be `public` or `private`
    // when this is called.
    //
    var addresses = interfaces[nic].filter(function (details) {
      details.family = details.family.toLowerCase();
      if (details.family !== family || ip.isLoopback(details.address)) {
        return false;
      } else if (!name) {
        return true;
      }

      return name === 'public' ? ip.isPrivate(details.address) :
          ip.isPublic(details.address);
    });

    return addresses.length ? addresses[0].address : undefined;
  }).filter(Boolean);

  return !all.length ? ip.loopback(family) : all[0];
};

ip.toLong = function(ip) {
  var ipl = 0;
  ip.split('.').forEach(function(octet) {
    ipl <<= 8;
    ipl += parseInt(octet);
  });
  return(ipl >>> 0);
};

ip.fromLong = function(ipl) {
  return ((ipl >>> 24) + '.' +
      (ipl >> 16 & 255) + '.' +
      (ipl >> 8 & 255) + '.' +
      (ipl & 255) );
};


/***/ }),

/***/ 6312:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
var callBound = __nccwpck_require__(8749);

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;


/***/ }),

/***/ 5454:
/***/ ((module) => {

"use strict";


if (typeof BigInt === 'function') {
	var bigIntValueOf = BigInt.prototype.valueOf;
	var tryBigInt = function tryBigIntObject(value) {
		try {
			bigIntValueOf.call(value);
			return true;
		} catch (e) {
		}
		return false;
	};

	module.exports = function isBigInt(value) {
		if (
			value === null
			|| typeof value === 'undefined'
			|| typeof value === 'boolean'
			|| typeof value === 'string'
			|| typeof value === 'number'
			|| typeof value === 'symbol'
			|| typeof value === 'function'
		) {
			return false;
		}
		if (typeof value === 'bigint') {
			return true;
		}

		return tryBigInt(value);
	};
} else {
	module.exports = function isBigInt(value) {
		return  false && 0;
	};
}


/***/ }),

/***/ 3428:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var callBound = __nccwpck_require__(8749);
var $boolToStr = callBound('Boolean.prototype.toString');
var $toString = callBound('Object.prototype.toString');

var tryBooleanObject = function booleanBrandCheck(value) {
	try {
		$boolToStr(value);
		return true;
	} catch (e) {
		return false;
	}
};
var boolClass = '[object Boolean]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isBoolean(value) {
	if (typeof value === 'boolean') {
		return true;
	}
	if (value === null || typeof value !== 'object') {
		return false;
	}
	return hasToStringTag && Symbol.toStringTag in value ? tryBooleanObject(value) : $toString(value) === boolClass;
};


/***/ }),

/***/ 4044:
/***/ ((module) => {

"use strict";


var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateGetDayCall(value) {
	try {
		getDay.call(value);
		return true;
	} catch (e) {
		return false;
	}
};

var toStr = Object.prototype.toString;
var dateClass = '[object Date]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isDateObject(value) {
	if (typeof value !== 'object' || value === null) {
		return false;
	}
	return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
};


/***/ }),

/***/ 8120:
/***/ ((module) => {

"use strict";


var $Map = typeof Map === 'function' && Map.prototype ? Map : null;
var $Set = typeof Set === 'function' && Set.prototype ? Set : null;

var exported;

if (!$Map) {
	// eslint-disable-next-line no-unused-vars
	exported = function isMap(x) {
		// `Map` is not present in this environment.
		return false;
	};
}

var $mapHas = $Map ? Map.prototype.has : null;
var $setHas = $Set ? Set.prototype.has : null;
if (!exported && !$mapHas) {
	// eslint-disable-next-line no-unused-vars
	exported = function isMap(x) {
		// `Map` does not have a `has` method
		return false;
	};
}

module.exports = exported || function isMap(x) {
	if (!x || typeof x !== 'object') {
		return false;
	}
	try {
		$mapHas.call(x);
		if ($setHas) {
			try {
				$setHas.call(x);
			} catch (e) {
				return true;
			}
		}
		return x instanceof $Map; // core-js workaround, pre-v2.5.0
	} catch (e) {}
	return false;
};


/***/ }),

/***/ 6671:
/***/ ((module) => {

"use strict";


var numToStr = Number.prototype.toString;
var tryNumberObject = function tryNumberObject(value) {
	try {
		numToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var numClass = '[object Number]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isNumberObject(value) {
	if (typeof value === 'number') {
		return true;
	}
	if (typeof value !== 'object') {
		return false;
	}
	return hasToStringTag ? tryNumberObject(value) : toStr.call(value) === numClass;
};


/***/ }),

/***/ 7239:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var callBound = __nccwpck_require__(8749);
var hasSymbols = __nccwpck_require__(3805)();
var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === 'symbol';
var has;
var $exec;
var isRegexMarker;
var badStringifier;

if (hasToStringTag) {
	has = callBound('Object.prototype.hasOwnProperty');
	$exec = callBound('RegExp.prototype.exec');
	isRegexMarker = {};

	var throwRegexMarker = function () {
		throw isRegexMarker;
	};
	badStringifier = {
		toString: throwRegexMarker,
		valueOf: throwRegexMarker
	};

	if (typeof Symbol.toPrimitive === 'symbol') {
		badStringifier[Symbol.toPrimitive] = throwRegexMarker;
	}
}

var $toString = callBound('Object.prototype.toString');
var gOPD = Object.getOwnPropertyDescriptor;
var regexClass = '[object RegExp]';

module.exports = hasToStringTag
	// eslint-disable-next-line consistent-return
	? function isRegex(value) {
		if (!value || typeof value !== 'object') {
			return false;
		}

		var descriptor = gOPD(value, 'lastIndex');
		var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
		if (!hasLastIndexDataProperty) {
			return false;
		}

		try {
			$exec(value, badStringifier);
		} catch (e) {
			return e === isRegexMarker;
		}
	}
	: function isRegex(value) {
		// In older browsers, typeof regex incorrectly returns 'function'
		if (!value || (typeof value !== 'object' && typeof value !== 'function')) {
			return false;
		}

		return $toString(value) === regexClass;
	};


/***/ }),

/***/ 7936:
/***/ ((module) => {

"use strict";


var $Map = typeof Map === 'function' && Map.prototype ? Map : null;
var $Set = typeof Set === 'function' && Set.prototype ? Set : null;

var exported;

if (!$Set) {
	// eslint-disable-next-line no-unused-vars
	exported = function isSet(x) {
		// `Set` is not present in this environment.
		return false;
	};
}

var $mapHas = $Map ? Map.prototype.has : null;
var $setHas = $Set ? Set.prototype.has : null;
if (!exported && !$setHas) {
	// eslint-disable-next-line no-unused-vars
	exported = function isSet(x) {
		// `Set` does not have a `has` method
		return false;
	};
}

module.exports = exported || function isSet(x) {
	if (!x || typeof x !== 'object') {
		return false;
	}
	try {
		$setHas.call(x);
		if ($mapHas) {
			try {
				$mapHas.call(x);
			} catch (e) {
				return true;
			}
		}
		return x instanceof $Set; // core-js workaround, pre-v2.5.0
	} catch (e) {}
	return false;
};


/***/ }),

/***/ 3482:
/***/ ((module) => {

"use strict";


var strValue = String.prototype.valueOf;
var tryStringObject = function tryStringObject(value) {
	try {
		strValue.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var strClass = '[object String]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isString(value) {
	if (typeof value === 'string') {
		return true;
	}
	if (typeof value !== 'object') {
		return false;
	}
	return hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;
};


/***/ }),

/***/ 7992:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var toStr = Object.prototype.toString;
var hasSymbols = __nccwpck_require__(3805)();

if (hasSymbols) {
	var symToStr = Symbol.prototype.toString;
	var symStringRegex = /^Symbol\(.*\)$/;
	var isSymbolObject = function isRealSymbolObject(value) {
		if (typeof value.valueOf() !== 'symbol') {
			return false;
		}
		return symStringRegex.test(symToStr.call(value));
	};

	module.exports = function isSymbol(value) {
		if (typeof value === 'symbol') {
			return true;
		}
		if (toStr.call(value) !== '[object Symbol]') {
			return false;
		}
		try {
			return isSymbolObject(value);
		} catch (e) {
			return false;
		}
	};
} else {

	module.exports = function isSymbol(value) {
		// this environment does not support Symbols.
		return  false && 0;
	};
}


/***/ }),

/***/ 8234:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var forEach = __nccwpck_require__(3219);
var availableTypedArrays = __nccwpck_require__(3308);
var callBound = __nccwpck_require__(8749);

var $toString = callBound('Object.prototype.toString');
var hasSymbols = __nccwpck_require__(3805)();
var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === 'symbol';

var typedArrays = availableTypedArrays();

var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};
var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = __nccwpck_require__(6649);
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		var arr = new global[typedArray]();
		if (!(Symbol.toStringTag in arr)) {
			throw new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');
		}
		var proto = getPrototypeOf(arr);
		var descriptor = gOPD(proto, Symbol.toStringTag);
		if (!descriptor) {
			var superProto = getPrototypeOf(proto);
			descriptor = gOPD(superProto, Symbol.toStringTag);
		}
		toStrTags[typedArray] = descriptor.get;
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var anyTrue = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!anyTrue) {
			try {
				anyTrue = getter.call(value) === typedArray;
			} catch (e) { /**/ }
		}
	});
	return anyTrue;
};

module.exports = function isTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag) {
		var tag = $slice($toString(value), 8, -1);
		return $indexOf(typedArrays, tag) > -1;
	}
	if (!gOPD) { return false; }
	return tryTypedArrays(value);
};


/***/ }),

/***/ 4010:
/***/ ((module) => {

"use strict";


var $WeakMap = typeof WeakMap === 'function' && WeakMap.prototype ? WeakMap : null;
var $WeakSet = typeof WeakSet === 'function' && WeakSet.prototype ? WeakSet : null;

var exported;

if (!$WeakMap) {
	// eslint-disable-next-line no-unused-vars
	exported = function isWeakMap(x) {
		// `WeakMap` is not present in this environment.
		return false;
	};
}

var $mapHas = $WeakMap ? $WeakMap.prototype.has : null;
var $setHas = $WeakSet ? $WeakSet.prototype.has : null;
if (!exported && !$mapHas) {
	// eslint-disable-next-line no-unused-vars
	exported = function isWeakMap(x) {
		// `WeakMap` does not have a `has` method
		return false;
	};
}

module.exports = exported || function isWeakMap(x) {
	if (!x || typeof x !== 'object') {
		return false;
	}
	try {
		$mapHas.call(x, $mapHas);
		if ($setHas) {
			try {
				$setHas.call(x, $setHas);
			} catch (e) {
				return true;
			}
		}
		return x instanceof $WeakMap; // core-js workaround, pre-v3
	} catch (e) {}
	return false;
};


/***/ }),

/***/ 4689:
/***/ ((module) => {

"use strict";


var $WeakMap = typeof WeakMap === 'function' && WeakMap.prototype ? WeakMap : null;
var $WeakSet = typeof WeakSet === 'function' && WeakSet.prototype ? WeakSet : null;

var exported;

if (!$WeakMap) {
	// eslint-disable-next-line no-unused-vars
	exported = function isWeakSet(x) {
		// `WeakSet` is not present in this environment.
		return false;
	};
}

var $mapHas = $WeakMap ? $WeakMap.prototype.has : null;
var $setHas = $WeakSet ? $WeakSet.prototype.has : null;
if (!exported && !$setHas) {
	// eslint-disable-next-line no-unused-vars
	module.exports = function isWeakSet(x) {
		// `WeakSet` does not have a `has` method
		return false;
	};
}

module.exports = exported || function isWeakSet(x) {
	if (!x || typeof x !== 'object') {
		return false;
	}
	try {
		$setHas.call(x, $setHas);
		if ($mapHas) {
			try {
				$mapHas.call(x, $mapHas);
			} catch (e) {
				return true;
			}
		}
		return x instanceof $WeakSet; // core-js workaround, pre-v3
	} catch (e) {}
	return false;
};


/***/ }),

/***/ 9842:
/***/ ((module) => {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ 3392:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var dmp = _interopDefault(__nccwpck_require__(4355));
var chalk = _interopDefault(__nccwpck_require__(137));

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};





var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var Processor = function () {
  function Processor(options) {
    classCallCheck(this, Processor);

    this.selfOptions = options || {};
    this.pipes = {};
  }

  createClass(Processor, [{
    key: 'options',
    value: function options(_options) {
      if (_options) {
        this.selfOptions = _options;
      }
      return this.selfOptions;
    }
  }, {
    key: 'pipe',
    value: function pipe(name, pipeArg) {
      var pipe = pipeArg;
      if (typeof name === 'string') {
        if (typeof pipe === 'undefined') {
          return this.pipes[name];
        } else {
          this.pipes[name] = pipe;
        }
      }
      if (name && name.name) {
        pipe = name;
        if (pipe.processor === this) {
          return pipe;
        }
        this.pipes[pipe.name] = pipe;
      }
      pipe.processor = this;
      return pipe;
    }
  }, {
    key: 'process',
    value: function process(input, pipe) {
      var context = input;
      context.options = this.options();
      var nextPipe = pipe || input.pipe || 'default';
      var lastPipe = void 0;
      var lastContext = void 0;
      while (nextPipe) {
        if (typeof context.nextAfterChildren !== 'undefined') {
          // children processed and coming back to parent
          context.next = context.nextAfterChildren;
          context.nextAfterChildren = null;
        }

        if (typeof nextPipe === 'string') {
          nextPipe = this.pipe(nextPipe);
        }
        nextPipe.process(context);
        lastContext = context;
        lastPipe = nextPipe;
        nextPipe = null;
        if (context) {
          if (context.next) {
            context = context.next;
            nextPipe = lastContext.nextPipe || context.pipe || lastPipe;
          }
        }
      }
      return context.hasResult ? context.result : undefined;
    }
  }]);
  return Processor;
}();

var Pipe = function () {
  function Pipe(name) {
    classCallCheck(this, Pipe);

    this.name = name;
    this.filters = [];
  }

  createClass(Pipe, [{
    key: 'process',
    value: function process(input) {
      if (!this.processor) {
        throw new Error('add this pipe to a processor before using it');
      }
      var debug = this.debug;
      var length = this.filters.length;
      var context = input;
      for (var index = 0; index < length; index++) {
        var filter = this.filters[index];
        if (debug) {
          this.log('filter: ' + filter.filterName);
        }
        filter(context);
        if ((typeof context === 'undefined' ? 'undefined' : _typeof(context)) === 'object' && context.exiting) {
          context.exiting = false;
          break;
        }
      }
      if (!context.next && this.resultCheck) {
        this.resultCheck(context);
      }
    }
  }, {
    key: 'log',
    value: function log(msg) {
      console.log('[jsondiffpatch] ' + this.name + ' pipe, ' + msg);
    }
  }, {
    key: 'append',
    value: function append() {
      var _filters;

      (_filters = this.filters).push.apply(_filters, arguments);
      return this;
    }
  }, {
    key: 'prepend',
    value: function prepend() {
      var _filters2;

      (_filters2 = this.filters).unshift.apply(_filters2, arguments);
      return this;
    }
  }, {
    key: 'indexOf',
    value: function indexOf(filterName) {
      if (!filterName) {
        throw new Error('a filter name is required');
      }
      for (var index = 0; index < this.filters.length; index++) {
        var filter = this.filters[index];
        if (filter.filterName === filterName) {
          return index;
        }
      }
      throw new Error('filter not found: ' + filterName);
    }
  }, {
    key: 'list',
    value: function list() {
      return this.filters.map(function (f) {
        return f.filterName;
      });
    }
  }, {
    key: 'after',
    value: function after(filterName) {
      var index = this.indexOf(filterName);
      var params = Array.prototype.slice.call(arguments, 1);
      if (!params.length) {
        throw new Error('a filter is required');
      }
      params.unshift(index + 1, 0);
      Array.prototype.splice.apply(this.filters, params);
      return this;
    }
  }, {
    key: 'before',
    value: function before(filterName) {
      var index = this.indexOf(filterName);
      var params = Array.prototype.slice.call(arguments, 1);
      if (!params.length) {
        throw new Error('a filter is required');
      }
      params.unshift(index, 0);
      Array.prototype.splice.apply(this.filters, params);
      return this;
    }
  }, {
    key: 'replace',
    value: function replace(filterName) {
      var index = this.indexOf(filterName);
      var params = Array.prototype.slice.call(arguments, 1);
      if (!params.length) {
        throw new Error('a filter is required');
      }
      params.unshift(index, 1);
      Array.prototype.splice.apply(this.filters, params);
      return this;
    }
  }, {
    key: 'remove',
    value: function remove(filterName) {
      var index = this.indexOf(filterName);
      this.filters.splice(index, 1);
      return this;
    }
  }, {
    key: 'clear',
    value: function clear() {
      this.filters.length = 0;
      return this;
    }
  }, {
    key: 'shouldHaveResult',
    value: function shouldHaveResult(should) {
      if (should === false) {
        this.resultCheck = null;
        return;
      }
      if (this.resultCheck) {
        return;
      }
      var pipe = this;
      this.resultCheck = function (context) {
        if (!context.hasResult) {
          console.log(context);
          var error = new Error(pipe.name + ' failed');
          error.noResult = true;
          throw error;
        }
      };
      return this;
    }
  }]);
  return Pipe;
}();

var Context = function () {
  function Context() {
    classCallCheck(this, Context);
  }

  createClass(Context, [{
    key: 'setResult',
    value: function setResult(result) {
      this.result = result;
      this.hasResult = true;
      return this;
    }
  }, {
    key: 'exit',
    value: function exit() {
      this.exiting = true;
      return this;
    }
  }, {
    key: 'switchTo',
    value: function switchTo(next, pipe) {
      if (typeof next === 'string' || next instanceof Pipe) {
        this.nextPipe = next;
      } else {
        this.next = next;
        if (pipe) {
          this.nextPipe = pipe;
        }
      }
      return this;
    }
  }, {
    key: 'push',
    value: function push(child, name) {
      child.parent = this;
      if (typeof name !== 'undefined') {
        child.childName = name;
      }
      child.root = this.root || this;
      child.options = child.options || this.options;
      if (!this.children) {
        this.children = [child];
        this.nextAfterChildren = this.next || null;
        this.next = child;
      } else {
        this.children[this.children.length - 1].next = child;
        this.children.push(child);
      }
      child.next = this;
      return this;
    }
  }]);
  return Context;
}();

var isArray = typeof Array.isArray === 'function' ? Array.isArray : function (a) {
  return a instanceof Array;
};

function cloneRegExp(re) {
  var regexMatch = /^\/(.*)\/([gimyu]*)$/.exec(re.toString());
  return new RegExp(regexMatch[1], regexMatch[2]);
}

function clone(arg) {
  if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) !== 'object') {
    return arg;
  }
  if (arg === null) {
    return null;
  }
  if (isArray(arg)) {
    return arg.map(clone);
  }
  if (arg instanceof Date) {
    return new Date(arg.getTime());
  }
  if (arg instanceof RegExp) {
    return cloneRegExp(arg);
  }
  var cloned = {};
  for (var name in arg) {
    if (Object.prototype.hasOwnProperty.call(arg, name)) {
      cloned[name] = clone(arg[name]);
    }
  }
  return cloned;
}

var DiffContext = function (_Context) {
  inherits(DiffContext, _Context);

  function DiffContext(left, right) {
    classCallCheck(this, DiffContext);

    var _this = possibleConstructorReturn(this, (DiffContext.__proto__ || Object.getPrototypeOf(DiffContext)).call(this));

    _this.left = left;
    _this.right = right;
    _this.pipe = 'diff';
    return _this;
  }

  createClass(DiffContext, [{
    key: 'setResult',
    value: function setResult(result) {
      if (this.options.cloneDiffValues && (typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object') {
        var clone$$1 = typeof this.options.cloneDiffValues === 'function' ? this.options.cloneDiffValues : clone;
        if (_typeof(result[0]) === 'object') {
          result[0] = clone$$1(result[0]);
        }
        if (_typeof(result[1]) === 'object') {
          result[1] = clone$$1(result[1]);
        }
      }
      return Context.prototype.setResult.apply(this, arguments);
    }
  }]);
  return DiffContext;
}(Context);

var PatchContext = function (_Context) {
  inherits(PatchContext, _Context);

  function PatchContext(left, delta) {
    classCallCheck(this, PatchContext);

    var _this = possibleConstructorReturn(this, (PatchContext.__proto__ || Object.getPrototypeOf(PatchContext)).call(this));

    _this.left = left;
    _this.delta = delta;
    _this.pipe = 'patch';
    return _this;
  }

  return PatchContext;
}(Context);

var ReverseContext = function (_Context) {
  inherits(ReverseContext, _Context);

  function ReverseContext(delta) {
    classCallCheck(this, ReverseContext);

    var _this = possibleConstructorReturn(this, (ReverseContext.__proto__ || Object.getPrototypeOf(ReverseContext)).call(this));

    _this.delta = delta;
    _this.pipe = 'reverse';
    return _this;
  }

  return ReverseContext;
}(Context);

var isArray$1 = typeof Array.isArray === 'function' ? Array.isArray : function (a) {
  return a instanceof Array;
};

var diffFilter = function trivialMatchesDiffFilter(context) {
  if (context.left === context.right) {
    context.setResult(undefined).exit();
    return;
  }
  if (typeof context.left === 'undefined') {
    if (typeof context.right === 'function') {
      throw new Error('functions are not supported');
    }
    context.setResult([context.right]).exit();
    return;
  }
  if (typeof context.right === 'undefined') {
    context.setResult([context.left, 0, 0]).exit();
    return;
  }
  if (typeof context.left === 'function' || typeof context.right === 'function') {
    throw new Error('functions are not supported');
  }
  context.leftType = context.left === null ? 'null' : _typeof(context.left);
  context.rightType = context.right === null ? 'null' : _typeof(context.right);
  if (context.leftType !== context.rightType) {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  if (context.leftType === 'boolean' || context.leftType === 'number') {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  if (context.leftType === 'object') {
    context.leftIsArray = isArray$1(context.left);
  }
  if (context.rightType === 'object') {
    context.rightIsArray = isArray$1(context.right);
  }
  if (context.leftIsArray !== context.rightIsArray) {
    context.setResult([context.left, context.right]).exit();
    return;
  }

  if (context.left instanceof RegExp) {
    if (context.right instanceof RegExp) {
      context.setResult([context.left.toString(), context.right.toString()]).exit();
    } else {
      context.setResult([context.left, context.right]).exit();
    }
  }
};
diffFilter.filterName = 'trivial';

var patchFilter = function trivialMatchesPatchFilter(context) {
  if (typeof context.delta === 'undefined') {
    context.setResult(context.left).exit();
    return;
  }
  context.nested = !isArray$1(context.delta);
  if (context.nested) {
    return;
  }
  if (context.delta.length === 1) {
    context.setResult(context.delta[0]).exit();
    return;
  }
  if (context.delta.length === 2) {
    if (context.left instanceof RegExp) {
      var regexArgs = /^\/(.*)\/([gimyu]+)$/.exec(context.delta[1]);
      if (regexArgs) {
        context.setResult(new RegExp(regexArgs[1], regexArgs[2])).exit();
        return;
      }
    }
    context.setResult(context.delta[1]).exit();
    return;
  }
  if (context.delta.length === 3 && context.delta[2] === 0) {
    context.setResult(undefined).exit();
  }
};
patchFilter.filterName = 'trivial';

var reverseFilter = function trivialReferseFilter(context) {
  if (typeof context.delta === 'undefined') {
    context.setResult(context.delta).exit();
    return;
  }
  context.nested = !isArray$1(context.delta);
  if (context.nested) {
    return;
  }
  if (context.delta.length === 1) {
    context.setResult([context.delta[0], 0, 0]).exit();
    return;
  }
  if (context.delta.length === 2) {
    context.setResult([context.delta[1], context.delta[0]]).exit();
    return;
  }
  if (context.delta.length === 3 && context.delta[2] === 0) {
    context.setResult([context.delta[0]]).exit();
  }
};
reverseFilter.filterName = 'trivial';

function collectChildrenDiffFilter(context) {
  if (!context || !context.children) {
    return;
  }
  var length = context.children.length;
  var child = void 0;
  var result = context.result;
  for (var index = 0; index < length; index++) {
    child = context.children[index];
    if (typeof child.result === 'undefined') {
      continue;
    }
    result = result || {};
    result[child.childName] = child.result;
  }
  if (result && context.leftIsArray) {
    result._t = 'a';
  }
  context.setResult(result).exit();
}
collectChildrenDiffFilter.filterName = 'collectChildren';

function objectsDiffFilter(context) {
  if (context.leftIsArray || context.leftType !== 'object') {
    return;
  }

  var name = void 0;
  var child = void 0;
  var propertyFilter = context.options.propertyFilter;
  for (name in context.left) {
    if (!Object.prototype.hasOwnProperty.call(context.left, name)) {
      continue;
    }
    if (propertyFilter && !propertyFilter(name, context)) {
      continue;
    }
    child = new DiffContext(context.left[name], context.right[name]);
    context.push(child, name);
  }
  for (name in context.right) {
    if (!Object.prototype.hasOwnProperty.call(context.right, name)) {
      continue;
    }
    if (propertyFilter && !propertyFilter(name, context)) {
      continue;
    }
    if (typeof context.left[name] === 'undefined') {
      child = new DiffContext(undefined, context.right[name]);
      context.push(child, name);
    }
  }

  if (!context.children || context.children.length === 0) {
    context.setResult(undefined).exit();
    return;
  }
  context.exit();
}
objectsDiffFilter.filterName = 'objects';

var patchFilter$1 = function nestedPatchFilter(context) {
  if (!context.nested) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  var name = void 0;
  var child = void 0;
  for (name in context.delta) {
    child = new PatchContext(context.left[name], context.delta[name]);
    context.push(child, name);
  }
  context.exit();
};
patchFilter$1.filterName = 'objects';

var collectChildrenPatchFilter = function collectChildrenPatchFilter(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  var length = context.children.length;
  var child = void 0;
  for (var index = 0; index < length; index++) {
    child = context.children[index];
    if (Object.prototype.hasOwnProperty.call(context.left, child.childName) && child.result === undefined) {
      delete context.left[child.childName];
    } else if (context.left[child.childName] !== child.result) {
      context.left[child.childName] = child.result;
    }
  }
  context.setResult(context.left).exit();
};
collectChildrenPatchFilter.filterName = 'collectChildren';

var reverseFilter$1 = function nestedReverseFilter(context) {
  if (!context.nested) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  var name = void 0;
  var child = void 0;
  for (name in context.delta) {
    child = new ReverseContext(context.delta[name]);
    context.push(child, name);
  }
  context.exit();
};
reverseFilter$1.filterName = 'objects';

function collectChildrenReverseFilter(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  var length = context.children.length;
  var child = void 0;
  var delta = {};
  for (var index = 0; index < length; index++) {
    child = context.children[index];
    if (delta[child.childName] !== child.result) {
      delta[child.childName] = child.result;
    }
  }
  context.setResult(delta).exit();
}
collectChildrenReverseFilter.filterName = 'collectChildren';

/*

LCS implementation that supports arrays or strings

reference: http://en.wikipedia.org/wiki/Longest_common_subsequence_problem

*/

var defaultMatch = function defaultMatch(array1, array2, index1, index2) {
  return array1[index1] === array2[index2];
};

var lengthMatrix = function lengthMatrix(array1, array2, match, context) {
  var len1 = array1.length;
  var len2 = array2.length;
  var x = void 0,
      y = void 0;

  // initialize empty matrix of len1+1 x len2+1
  var matrix = [len1 + 1];
  for (x = 0; x < len1 + 1; x++) {
    matrix[x] = [len2 + 1];
    for (y = 0; y < len2 + 1; y++) {
      matrix[x][y] = 0;
    }
  }
  matrix.match = match;
  // save sequence lengths for each coordinate
  for (x = 1; x < len1 + 1; x++) {
    for (y = 1; y < len2 + 1; y++) {
      if (match(array1, array2, x - 1, y - 1, context)) {
        matrix[x][y] = matrix[x - 1][y - 1] + 1;
      } else {
        matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1]);
      }
    }
  }
  return matrix;
};

var backtrack = function backtrack(matrix, array1, array2, context) {
  var index1 = array1.length;
  var index2 = array2.length;
  var subsequence = {
    sequence: [],
    indices1: [],
    indices2: []
  };

  while (index1 !== 0 && index2 !== 0) {
    var sameLetter = matrix.match(array1, array2, index1 - 1, index2 - 1, context);
    if (sameLetter) {
      subsequence.sequence.unshift(array1[index1 - 1]);
      subsequence.indices1.unshift(index1 - 1);
      subsequence.indices2.unshift(index2 - 1);
      --index1;
      --index2;
    } else {
      var valueAtMatrixAbove = matrix[index1][index2 - 1];
      var valueAtMatrixLeft = matrix[index1 - 1][index2];
      if (valueAtMatrixAbove > valueAtMatrixLeft) {
        --index2;
      } else {
        --index1;
      }
    }
  }
  return subsequence;
};

var get$1 = function get(array1, array2, match, context) {
  var innerContext = context || {};
  var matrix = lengthMatrix(array1, array2, match || defaultMatch, innerContext);
  var result = backtrack(matrix, array1, array2, innerContext);
  if (typeof array1 === 'string' && typeof array2 === 'string') {
    result.sequence = result.sequence.join('');
  }
  return result;
};

var lcs = {
  get: get$1
};

var ARRAY_MOVE = 3;

var isArray$2 = typeof Array.isArray === 'function' ? Array.isArray : function (a) {
  return a instanceof Array;
};

var arrayIndexOf = typeof Array.prototype.indexOf === 'function' ? function (array, item) {
  return array.indexOf(item);
} : function (array, item) {
  var length = array.length;
  for (var i = 0; i < length; i++) {
    if (array[i] === item) {
      return i;
    }
  }
  return -1;
};

function arraysHaveMatchByRef(array1, array2, len1, len2) {
  for (var index1 = 0; index1 < len1; index1++) {
    var val1 = array1[index1];
    for (var index2 = 0; index2 < len2; index2++) {
      var val2 = array2[index2];
      if (index1 !== index2 && val1 === val2) {
        return true;
      }
    }
  }
}

function matchItems(array1, array2, index1, index2, context) {
  var value1 = array1[index1];
  var value2 = array2[index2];
  if (value1 === value2) {
    return true;
  }
  if ((typeof value1 === 'undefined' ? 'undefined' : _typeof(value1)) !== 'object' || (typeof value2 === 'undefined' ? 'undefined' : _typeof(value2)) !== 'object') {
    return false;
  }
  var objectHash = context.objectHash;
  if (!objectHash) {
    // no way to match objects was provided, try match by position
    return context.matchByPosition && index1 === index2;
  }
  var hash1 = void 0;
  var hash2 = void 0;
  if (typeof index1 === 'number') {
    context.hashCache1 = context.hashCache1 || [];
    hash1 = context.hashCache1[index1];
    if (typeof hash1 === 'undefined') {
      context.hashCache1[index1] = hash1 = objectHash(value1, index1);
    }
  } else {
    hash1 = objectHash(value1);
  }
  if (typeof hash1 === 'undefined') {
    return false;
  }
  if (typeof index2 === 'number') {
    context.hashCache2 = context.hashCache2 || [];
    hash2 = context.hashCache2[index2];
    if (typeof hash2 === 'undefined') {
      context.hashCache2[index2] = hash2 = objectHash(value2, index2);
    }
  } else {
    hash2 = objectHash(value2);
  }
  if (typeof hash2 === 'undefined') {
    return false;
  }
  return hash1 === hash2;
}

var diffFilter$1 = function arraysDiffFilter(context) {
  if (!context.leftIsArray) {
    return;
  }

  var matchContext = {
    objectHash: context.options && context.options.objectHash,
    matchByPosition: context.options && context.options.matchByPosition
  };
  var commonHead = 0;
  var commonTail = 0;
  var index = void 0;
  var index1 = void 0;
  var index2 = void 0;
  var array1 = context.left;
  var array2 = context.right;
  var len1 = array1.length;
  var len2 = array2.length;

  var child = void 0;

  if (len1 > 0 && len2 > 0 && !matchContext.objectHash && typeof matchContext.matchByPosition !== 'boolean') {
    matchContext.matchByPosition = !arraysHaveMatchByRef(array1, array2, len1, len2);
  }

  // separate common head
  while (commonHead < len1 && commonHead < len2 && matchItems(array1, array2, commonHead, commonHead, matchContext)) {
    index = commonHead;
    child = new DiffContext(context.left[index], context.right[index]);
    context.push(child, index);
    commonHead++;
  }
  // separate common tail
  while (commonTail + commonHead < len1 && commonTail + commonHead < len2 && matchItems(array1, array2, len1 - 1 - commonTail, len2 - 1 - commonTail, matchContext)) {
    index1 = len1 - 1 - commonTail;
    index2 = len2 - 1 - commonTail;
    child = new DiffContext(context.left[index1], context.right[index2]);
    context.push(child, index2);
    commonTail++;
  }
  var result = void 0;
  if (commonHead + commonTail === len1) {
    if (len1 === len2) {
      // arrays are identical
      context.setResult(undefined).exit();
      return;
    }
    // trivial case, a block (1 or more consecutive items) was added
    result = result || {
      _t: 'a'
    };
    for (index = commonHead; index < len2 - commonTail; index++) {
      result[index] = [array2[index]];
    }
    context.setResult(result).exit();
    return;
  }
  if (commonHead + commonTail === len2) {
    // trivial case, a block (1 or more consecutive items) was removed
    result = result || {
      _t: 'a'
    };
    for (index = commonHead; index < len1 - commonTail; index++) {
      result['_' + index] = [array1[index], 0, 0];
    }
    context.setResult(result).exit();
    return;
  }
  // reset hash cache
  delete matchContext.hashCache1;
  delete matchContext.hashCache2;

  // diff is not trivial, find the LCS (Longest Common Subsequence)
  var trimmed1 = array1.slice(commonHead, len1 - commonTail);
  var trimmed2 = array2.slice(commonHead, len2 - commonTail);
  var seq = lcs.get(trimmed1, trimmed2, matchItems, matchContext);
  var removedItems = [];
  result = result || {
    _t: 'a'
  };
  for (index = commonHead; index < len1 - commonTail; index++) {
    if (arrayIndexOf(seq.indices1, index - commonHead) < 0) {
      // removed
      result['_' + index] = [array1[index], 0, 0];
      removedItems.push(index);
    }
  }

  var detectMove = true;
  if (context.options && context.options.arrays && context.options.arrays.detectMove === false) {
    detectMove = false;
  }
  var includeValueOnMove = false;
  if (context.options && context.options.arrays && context.options.arrays.includeValueOnMove) {
    includeValueOnMove = true;
  }

  var removedItemsLength = removedItems.length;
  for (index = commonHead; index < len2 - commonTail; index++) {
    var indexOnArray2 = arrayIndexOf(seq.indices2, index - commonHead);
    if (indexOnArray2 < 0) {
      // added, try to match with a removed item and register as position move
      var isMove = false;
      if (detectMove && removedItemsLength > 0) {
        for (var removeItemIndex1 = 0; removeItemIndex1 < removedItemsLength; removeItemIndex1++) {
          index1 = removedItems[removeItemIndex1];
          if (matchItems(trimmed1, trimmed2, index1 - commonHead, index - commonHead, matchContext)) {
            // store position move as: [originalValue, newPosition, ARRAY_MOVE]
            result['_' + index1].splice(1, 2, index, ARRAY_MOVE);
            if (!includeValueOnMove) {
              // don't include moved value on diff, to save bytes
              result['_' + index1][0] = '';
            }

            index2 = index;
            child = new DiffContext(context.left[index1], context.right[index2]);
            context.push(child, index2);
            removedItems.splice(removeItemIndex1, 1);
            isMove = true;
            break;
          }
        }
      }
      if (!isMove) {
        // added
        result[index] = [array2[index]];
      }
    } else {
      // match, do inner diff
      index1 = seq.indices1[indexOnArray2] + commonHead;
      index2 = seq.indices2[indexOnArray2] + commonHead;
      child = new DiffContext(context.left[index1], context.right[index2]);
      context.push(child, index2);
    }
  }

  context.setResult(result).exit();
};
diffFilter$1.filterName = 'arrays';

var compare = {
  numerically: function numerically(a, b) {
    return a - b;
  },
  numericallyBy: function numericallyBy(name) {
    return function (a, b) {
      return a[name] - b[name];
    };
  }
};

var patchFilter$2 = function nestedPatchFilter(context) {
  if (!context.nested) {
    return;
  }
  if (context.delta._t !== 'a') {
    return;
  }
  var index = void 0;
  var index1 = void 0;

  var delta = context.delta;
  var array = context.left;

  // first, separate removals, insertions and modifications
  var toRemove = [];
  var toInsert = [];
  var toModify = [];
  for (index in delta) {
    if (index !== '_t') {
      if (index[0] === '_') {
        // removed item from original array
        if (delta[index][2] === 0 || delta[index][2] === ARRAY_MOVE) {
          toRemove.push(parseInt(index.slice(1), 10));
        } else {
          throw new Error('only removal or move can be applied at original array indices,' + (' invalid diff type: ' + delta[index][2]));
        }
      } else {
        if (delta[index].length === 1) {
          // added item at new array
          toInsert.push({
            index: parseInt(index, 10),
            value: delta[index][0]
          });
        } else {
          // modified item at new array
          toModify.push({
            index: parseInt(index, 10),
            delta: delta[index]
          });
        }
      }
    }
  }

  // remove items, in reverse order to avoid sawing our own floor
  toRemove = toRemove.sort(compare.numerically);
  for (index = toRemove.length - 1; index >= 0; index--) {
    index1 = toRemove[index];
    var indexDiff = delta['_' + index1];
    var removedValue = array.splice(index1, 1)[0];
    if (indexDiff[2] === ARRAY_MOVE) {
      // reinsert later
      toInsert.push({
        index: indexDiff[1],
        value: removedValue
      });
    }
  }

  // insert items, in reverse order to avoid moving our own floor
  toInsert = toInsert.sort(compare.numericallyBy('index'));
  var toInsertLength = toInsert.length;
  for (index = 0; index < toInsertLength; index++) {
    var insertion = toInsert[index];
    array.splice(insertion.index, 0, insertion.value);
  }

  // apply modifications
  var toModifyLength = toModify.length;
  var child = void 0;
  if (toModifyLength > 0) {
    for (index = 0; index < toModifyLength; index++) {
      var modification = toModify[index];
      child = new PatchContext(context.left[modification.index], modification.delta);
      context.push(child, modification.index);
    }
  }

  if (!context.children) {
    context.setResult(context.left).exit();
    return;
  }
  context.exit();
};
patchFilter$2.filterName = 'arrays';

var collectChildrenPatchFilter$1 = function collectChildrenPatchFilter(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t !== 'a') {
    return;
  }
  var length = context.children.length;
  var child = void 0;
  for (var index = 0; index < length; index++) {
    child = context.children[index];
    context.left[child.childName] = child.result;
  }
  context.setResult(context.left).exit();
};
collectChildrenPatchFilter$1.filterName = 'arraysCollectChildren';

var reverseFilter$2 = function arraysReverseFilter(context) {
  if (!context.nested) {
    if (context.delta[2] === ARRAY_MOVE) {
      context.newName = '_' + context.delta[1];
      context.setResult([context.delta[0], parseInt(context.childName.substr(1), 10), ARRAY_MOVE]).exit();
    }
    return;
  }
  if (context.delta._t !== 'a') {
    return;
  }
  var name = void 0;
  var child = void 0;
  for (name in context.delta) {
    if (name === '_t') {
      continue;
    }
    child = new ReverseContext(context.delta[name]);
    context.push(child, name);
  }
  context.exit();
};
reverseFilter$2.filterName = 'arrays';

var reverseArrayDeltaIndex = function reverseArrayDeltaIndex(delta, index, itemDelta) {
  if (typeof index === 'string' && index[0] === '_') {
    return parseInt(index.substr(1), 10);
  } else if (isArray$2(itemDelta) && itemDelta[2] === 0) {
    return '_' + index;
  }

  var reverseIndex = +index;
  for (var deltaIndex in delta) {
    var deltaItem = delta[deltaIndex];
    if (isArray$2(deltaItem)) {
      if (deltaItem[2] === ARRAY_MOVE) {
        var moveFromIndex = parseInt(deltaIndex.substr(1), 10);
        var moveToIndex = deltaItem[1];
        if (moveToIndex === +index) {
          return moveFromIndex;
        }
        if (moveFromIndex <= reverseIndex && moveToIndex > reverseIndex) {
          reverseIndex++;
        } else if (moveFromIndex >= reverseIndex && moveToIndex < reverseIndex) {
          reverseIndex--;
        }
      } else if (deltaItem[2] === 0) {
        var deleteIndex = parseInt(deltaIndex.substr(1), 10);
        if (deleteIndex <= reverseIndex) {
          reverseIndex++;
        }
      } else if (deltaItem.length === 1 && deltaIndex <= reverseIndex) {
        reverseIndex--;
      }
    }
  }

  return reverseIndex;
};

function collectChildrenReverseFilter$1(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t !== 'a') {
    return;
  }
  var length = context.children.length;
  var child = void 0;
  var delta = {
    _t: 'a'
  };

  for (var index = 0; index < length; index++) {
    child = context.children[index];
    var name = child.newName;
    if (typeof name === 'undefined') {
      name = reverseArrayDeltaIndex(context.delta, child.childName, child.result);
    }
    if (delta[name] !== child.result) {
      delta[name] = child.result;
    }
  }
  context.setResult(delta).exit();
}
collectChildrenReverseFilter$1.filterName = 'arraysCollectChildren';

var diffFilter$2 = function datesDiffFilter(context) {
  if (context.left instanceof Date) {
    if (context.right instanceof Date) {
      if (context.left.getTime() !== context.right.getTime()) {
        context.setResult([context.left, context.right]);
      } else {
        context.setResult(undefined);
      }
    } else {
      context.setResult([context.left, context.right]);
    }
    context.exit();
  } else if (context.right instanceof Date) {
    context.setResult([context.left, context.right]).exit();
  }
};
diffFilter$2.filterName = 'dates';

/* global diff_match_patch */
var TEXT_DIFF = 2;
var DEFAULT_MIN_LENGTH = 60;
var cachedDiffPatch = null;

var getDiffMatchPatch = function getDiffMatchPatch(required) {
  /* jshint camelcase: false */

  if (!cachedDiffPatch) {
    var instance = void 0;
    /* eslint-disable camelcase, new-cap */
    if (typeof diff_match_patch !== 'undefined') {
      // already loaded, probably a browser
      instance = typeof diff_match_patch === 'function' ? new diff_match_patch() : new diff_match_patch.diff_match_patch();
    } else if (dmp) {
      try {
        instance = dmp && new dmp();
      } catch (err) {
        instance = null;
      }
    }
    /* eslint-enable camelcase, new-cap */
    if (!instance) {
      if (!required) {
        return null;
      }
      var error = new Error('text diff_match_patch library not found');
      // eslint-disable-next-line camelcase
      error.diff_match_patch_not_found = true;
      throw error;
    }
    cachedDiffPatch = {
      diff: function diff(txt1, txt2) {
        return instance.patch_toText(instance.patch_make(txt1, txt2));
      },
      patch: function patch(txt1, _patch) {
        var results = instance.patch_apply(instance.patch_fromText(_patch), txt1);
        for (var i = 0; i < results[1].length; i++) {
          if (!results[1][i]) {
            var _error = new Error('text patch failed');
            _error.textPatchFailed = true;
          }
        }
        return results[0];
      }
    };
  }
  return cachedDiffPatch;
};

var diffFilter$3 = function textsDiffFilter(context) {
  if (context.leftType !== 'string') {
    return;
  }
  var minLength = context.options && context.options.textDiff && context.options.textDiff.minLength || DEFAULT_MIN_LENGTH;
  if (context.left.length < minLength || context.right.length < minLength) {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  // large text, try to use a text-diff algorithm
  var diffMatchPatch = getDiffMatchPatch();
  if (!diffMatchPatch) {
    // diff-match-patch library not available,
    // fallback to regular string replace
    context.setResult([context.left, context.right]).exit();
    return;
  }
  var diff = diffMatchPatch.diff;
  context.setResult([diff(context.left, context.right), 0, TEXT_DIFF]).exit();
};
diffFilter$3.filterName = 'texts';

var patchFilter$3 = function textsPatchFilter(context) {
  if (context.nested) {
    return;
  }
  if (context.delta[2] !== TEXT_DIFF) {
    return;
  }

  // text-diff, use a text-patch algorithm
  var patch = getDiffMatchPatch(true).patch;
  context.setResult(patch(context.left, context.delta[0])).exit();
};
patchFilter$3.filterName = 'texts';

var textDeltaReverse = function textDeltaReverse(delta) {
  var i = void 0;
  var l = void 0;
  var lines = void 0;
  var line = void 0;
  var lineTmp = void 0;
  var header = null;
  var headerRegex = /^@@ +-(\d+),(\d+) +\+(\d+),(\d+) +@@$/;
  var lineHeader = void 0;
  lines = delta.split('\n');
  for (i = 0, l = lines.length; i < l; i++) {
    line = lines[i];
    var lineStart = line.slice(0, 1);
    if (lineStart === '@') {
      header = headerRegex.exec(line);
      lineHeader = i;

      // fix header
      lines[lineHeader] = '@@ -' + header[3] + ',' + header[4] + ' +' + header[1] + ',' + header[2] + ' @@';
    } else if (lineStart === '+') {
      lines[i] = '-' + lines[i].slice(1);
      if (lines[i - 1].slice(0, 1) === '+') {
        // swap lines to keep default order (-+)
        lineTmp = lines[i];
        lines[i] = lines[i - 1];
        lines[i - 1] = lineTmp;
      }
    } else if (lineStart === '-') {
      lines[i] = '+' + lines[i].slice(1);
    }
  }
  return lines.join('\n');
};

var reverseFilter$3 = function textsReverseFilter(context) {
  if (context.nested) {
    return;
  }
  if (context.delta[2] !== TEXT_DIFF) {
    return;
  }

  // text-diff, use a text-diff algorithm
  context.setResult([textDeltaReverse(context.delta[0]), 0, TEXT_DIFF]).exit();
};
reverseFilter$3.filterName = 'texts';

var DiffPatcher = function () {
  function DiffPatcher(options) {
    classCallCheck(this, DiffPatcher);

    this.processor = new Processor(options);
    this.processor.pipe(new Pipe('diff').append(collectChildrenDiffFilter, diffFilter, diffFilter$2, diffFilter$3, objectsDiffFilter, diffFilter$1).shouldHaveResult());
    this.processor.pipe(new Pipe('patch').append(collectChildrenPatchFilter, collectChildrenPatchFilter$1, patchFilter, patchFilter$3, patchFilter$1, patchFilter$2).shouldHaveResult());
    this.processor.pipe(new Pipe('reverse').append(collectChildrenReverseFilter, collectChildrenReverseFilter$1, reverseFilter, reverseFilter$3, reverseFilter$1, reverseFilter$2).shouldHaveResult());
  }

  createClass(DiffPatcher, [{
    key: 'options',
    value: function options() {
      var _processor;

      return (_processor = this.processor).options.apply(_processor, arguments);
    }
  }, {
    key: 'diff',
    value: function diff(left, right) {
      return this.processor.process(new DiffContext(left, right));
    }
  }, {
    key: 'patch',
    value: function patch(left, delta) {
      return this.processor.process(new PatchContext(left, delta));
    }
  }, {
    key: 'reverse',
    value: function reverse(delta) {
      return this.processor.process(new ReverseContext(delta));
    }
  }, {
    key: 'unpatch',
    value: function unpatch(right, delta) {
      return this.patch(right, this.reverse(delta));
    }
  }, {
    key: 'clone',
    value: function clone$$1(value) {
      return clone(value);
    }
  }]);
  return DiffPatcher;
}();

var isArray$3 = typeof Array.isArray === 'function' ? Array.isArray : function (a) {
  return a instanceof Array;
};

var getObjectKeys = typeof Object.keys === 'function' ? function (obj) {
  return Object.keys(obj);
} : function (obj) {
  var names = [];
  for (var property in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, property)) {
      names.push(property);
    }
  }
  return names;
};

var trimUnderscore = function trimUnderscore(str) {
  if (str.substr(0, 1) === '_') {
    return str.slice(1);
  }
  return str;
};

var arrayKeyToSortNumber = function arrayKeyToSortNumber(key) {
  if (key === '_t') {
    return -1;
  } else {
    if (key.substr(0, 1) === '_') {
      return parseInt(key.slice(1), 10);
    } else {
      return parseInt(key, 10) + 0.1;
    }
  }
};

var arrayKeyComparer = function arrayKeyComparer(key1, key2) {
  return arrayKeyToSortNumber(key1) - arrayKeyToSortNumber(key2);
};

var BaseFormatter = function () {
  function BaseFormatter() {
    classCallCheck(this, BaseFormatter);
  }

  createClass(BaseFormatter, [{
    key: 'format',
    value: function format(delta, left) {
      var context = {};
      this.prepareContext(context);
      this.recurse(context, delta, left);
      return this.finalize(context);
    }
  }, {
    key: 'prepareContext',
    value: function prepareContext(context) {
      context.buffer = [];
      context.out = function () {
        var _buffer;

        (_buffer = this.buffer).push.apply(_buffer, arguments);
      };
    }
  }, {
    key: 'typeFormattterNotFound',
    value: function typeFormattterNotFound(context, deltaType) {
      throw new Error('cannot format delta type: ' + deltaType);
    }
  }, {
    key: 'typeFormattterErrorFormatter',
    value: function typeFormattterErrorFormatter(context, err) {
      return err.toString();
    }
  }, {
    key: 'finalize',
    value: function finalize(_ref) {
      var buffer = _ref.buffer;

      if (isArray$3(buffer)) {
        return buffer.join('');
      }
    }
  }, {
    key: 'recurse',
    value: function recurse(context, delta, left, key, leftKey, movedFrom, isLast) {
      var useMoveOriginHere = delta && movedFrom;
      var leftValue = useMoveOriginHere ? movedFrom.value : left;

      if (typeof delta === 'undefined' && typeof key === 'undefined') {
        return undefined;
      }

      var type = this.getDeltaType(delta, movedFrom);
      var nodeType = type === 'node' ? delta._t === 'a' ? 'array' : 'object' : '';

      if (typeof key !== 'undefined') {
        this.nodeBegin(context, key, leftKey, type, nodeType, isLast);
      } else {
        this.rootBegin(context, type, nodeType);
      }

      var typeFormattter = void 0;
      try {
        typeFormattter = this['format_' + type] || this.typeFormattterNotFound(context, type);
        typeFormattter.call(this, context, delta, leftValue, key, leftKey, movedFrom);
      } catch (err) {
        this.typeFormattterErrorFormatter(context, err, delta, leftValue, key, leftKey, movedFrom);
        if (typeof console !== 'undefined' && console.error) {
          console.error(err.stack);
        }
      }

      if (typeof key !== 'undefined') {
        this.nodeEnd(context, key, leftKey, type, nodeType, isLast);
      } else {
        this.rootEnd(context, type, nodeType);
      }
    }
  }, {
    key: 'formatDeltaChildren',
    value: function formatDeltaChildren(context, delta, left) {
      var self = this;
      this.forEachDeltaKey(delta, left, function (key, leftKey, movedFrom, isLast) {
        self.recurse(context, delta[key], left ? left[leftKey] : undefined, key, leftKey, movedFrom, isLast);
      });
    }
  }, {
    key: 'forEachDeltaKey',
    value: function forEachDeltaKey(delta, left, fn) {
      var keys = getObjectKeys(delta);
      var arrayKeys = delta._t === 'a';
      var moveDestinations = {};
      var name = void 0;
      if (typeof left !== 'undefined') {
        for (name in left) {
          if (Object.prototype.hasOwnProperty.call(left, name)) {
            if (typeof delta[name] === 'undefined' && (!arrayKeys || typeof delta['_' + name] === 'undefined')) {
              keys.push(name);
            }
          }
        }
      }
      // look for move destinations
      for (name in delta) {
        if (Object.prototype.hasOwnProperty.call(delta, name)) {
          var value = delta[name];
          if (isArray$3(value) && value[2] === 3) {
            moveDestinations[value[1].toString()] = {
              key: name,
              value: left && left[parseInt(name.substr(1))]
            };
            if (this.includeMoveDestinations !== false) {
              if (typeof left === 'undefined' && typeof delta[value[1]] === 'undefined') {
                keys.push(value[1].toString());
              }
            }
          }
        }
      }
      if (arrayKeys) {
        keys.sort(arrayKeyComparer);
      } else {
        keys.sort();
      }
      for (var index = 0, length = keys.length; index < length; index++) {
        var key = keys[index];
        if (arrayKeys && key === '_t') {
          continue;
        }
        var leftKey = arrayKeys ? typeof key === 'number' ? key : parseInt(trimUnderscore(key), 10) : key;
        var isLast = index === length - 1;
        fn(key, leftKey, moveDestinations[leftKey], isLast);
      }
    }
  }, {
    key: 'getDeltaType',
    value: function getDeltaType(delta, movedFrom) {
      if (typeof delta === 'undefined') {
        if (typeof movedFrom !== 'undefined') {
          return 'movedestination';
        }
        return 'unchanged';
      }
      if (isArray$3(delta)) {
        if (delta.length === 1) {
          return 'added';
        }
        if (delta.length === 2) {
          return 'modified';
        }
        if (delta.length === 3 && delta[2] === 0) {
          return 'deleted';
        }
        if (delta.length === 3 && delta[2] === 2) {
          return 'textdiff';
        }
        if (delta.length === 3 && delta[2] === 3) {
          return 'moved';
        }
      } else if ((typeof delta === 'undefined' ? 'undefined' : _typeof(delta)) === 'object') {
        return 'node';
      }
      return 'unknown';
    }
  }, {
    key: 'parseTextDiff',
    value: function parseTextDiff(value) {
      var output = [];
      var lines = value.split('\n@@ ');
      for (var i = 0, l = lines.length; i < l; i++) {
        var line = lines[i];
        var lineOutput = {
          pieces: []
        };
        var location = /^(?:@@ )?[-+]?(\d+),(\d+)/.exec(line).slice(1);
        lineOutput.location = {
          line: location[0],
          chr: location[1]
        };
        var pieces = line.split('\n').slice(1);
        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
          var piece = pieces[pieceIndex];
          if (!piece.length) {
            continue;
          }
          var pieceOutput = {
            type: 'context'
          };
          if (piece.substr(0, 1) === '+') {
            pieceOutput.type = 'added';
          } else if (piece.substr(0, 1) === '-') {
            pieceOutput.type = 'deleted';
          }
          pieceOutput.text = piece.slice(1);
          lineOutput.pieces.push(pieceOutput);
        }
        output.push(lineOutput);
      }
      return output;
    }
  }]);
  return BaseFormatter;
}();



var base = Object.freeze({
	default: BaseFormatter
});

var HtmlFormatter = function (_BaseFormatter) {
  inherits(HtmlFormatter, _BaseFormatter);

  function HtmlFormatter() {
    classCallCheck(this, HtmlFormatter);
    return possibleConstructorReturn(this, (HtmlFormatter.__proto__ || Object.getPrototypeOf(HtmlFormatter)).apply(this, arguments));
  }

  createClass(HtmlFormatter, [{
    key: 'typeFormattterErrorFormatter',
    value: function typeFormattterErrorFormatter(context, err) {
      context.out('<pre class="jsondiffpatch-error">' + err + '</pre>');
    }
  }, {
    key: 'formatValue',
    value: function formatValue(context, value) {
      context.out('<pre>' + htmlEscape(JSON.stringify(value, null, 2)) + '</pre>');
    }
  }, {
    key: 'formatTextDiffString',
    value: function formatTextDiffString(context, value) {
      var lines = this.parseTextDiff(value);
      context.out('<ul class="jsondiffpatch-textdiff">');
      for (var i = 0, l = lines.length; i < l; i++) {
        var line = lines[i];
        context.out('<li><div class="jsondiffpatch-textdiff-location">' + ('<span class="jsondiffpatch-textdiff-line-number">' + line.location.line + '</span><span class="jsondiffpatch-textdiff-char">' + line.location.chr + '</span></div><div class="jsondiffpatch-textdiff-line">'));
        var pieces = line.pieces;
        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
          /* global decodeURI */
          var piece = pieces[pieceIndex];
          context.out('<span class="jsondiffpatch-textdiff-' + piece.type + '">' + htmlEscape(decodeURI(piece.text)) + '</span>');
        }
        context.out('</div></li>');
      }
      context.out('</ul>');
    }
  }, {
    key: 'rootBegin',
    value: function rootBegin(context, type, nodeType) {
      var nodeClass = 'jsondiffpatch-' + type + (nodeType ? ' jsondiffpatch-child-node-type-' + nodeType : '');
      context.out('<div class="jsondiffpatch-delta ' + nodeClass + '">');
    }
  }, {
    key: 'rootEnd',
    value: function rootEnd(context) {
      context.out('</div>' + (context.hasArrows ? '<script type="text/javascript">setTimeout(' + (adjustArrows.toString() + ',10);</script>') : ''));
    }
  }, {
    key: 'nodeBegin',
    value: function nodeBegin(context, key, leftKey, type, nodeType) {
      var nodeClass = 'jsondiffpatch-' + type + (nodeType ? ' jsondiffpatch-child-node-type-' + nodeType : '');
      context.out('<li class="' + nodeClass + '" data-key="' + leftKey + '">' + ('<div class="jsondiffpatch-property-name">' + leftKey + '</div>'));
    }
  }, {
    key: 'nodeEnd',
    value: function nodeEnd(context) {
      context.out('</li>');
    }

    /* jshint camelcase: false */
    /* eslint-disable camelcase */

  }, {
    key: 'format_unchanged',
    value: function format_unchanged(context, delta, left) {
      if (typeof left === 'undefined') {
        return;
      }
      context.out('<div class="jsondiffpatch-value">');
      this.formatValue(context, left);
      context.out('</div>');
    }
  }, {
    key: 'format_movedestination',
    value: function format_movedestination(context, delta, left) {
      if (typeof left === 'undefined') {
        return;
      }
      context.out('<div class="jsondiffpatch-value">');
      this.formatValue(context, left);
      context.out('</div>');
    }
  }, {
    key: 'format_node',
    value: function format_node(context, delta, left) {
      // recurse
      var nodeType = delta._t === 'a' ? 'array' : 'object';
      context.out('<ul class="jsondiffpatch-node jsondiffpatch-node-type-' + nodeType + '">');
      this.formatDeltaChildren(context, delta, left);
      context.out('</ul>');
    }
  }, {
    key: 'format_added',
    value: function format_added(context, delta) {
      context.out('<div class="jsondiffpatch-value">');
      this.formatValue(context, delta[0]);
      context.out('</div>');
    }
  }, {
    key: 'format_modified',
    value: function format_modified(context, delta) {
      context.out('<div class="jsondiffpatch-value jsondiffpatch-left-value">');
      this.formatValue(context, delta[0]);
      context.out('</div>' + '<div class="jsondiffpatch-value jsondiffpatch-right-value">');
      this.formatValue(context, delta[1]);
      context.out('</div>');
    }
  }, {
    key: 'format_deleted',
    value: function format_deleted(context, delta) {
      context.out('<div class="jsondiffpatch-value">');
      this.formatValue(context, delta[0]);
      context.out('</div>');
    }
  }, {
    key: 'format_moved',
    value: function format_moved(context, delta) {
      context.out('<div class="jsondiffpatch-value">');
      this.formatValue(context, delta[0]);
      context.out('</div><div class="jsondiffpatch-moved-destination">' + delta[1] + '</div>');

      // draw an SVG arrow from here to move destination
      context.out(
      /* jshint multistr: true */
      '<div class="jsondiffpatch-arrow" ' + 'style="position: relative; left: -34px;">\n          <svg width="30" height="60" ' + 'style="position: absolute; display: none;">\n          <defs>\n              <marker id="markerArrow" markerWidth="8" markerHeight="8"\n                 refx="2" refy="4"\n                     orient="auto" markerUnits="userSpaceOnUse">\n                  <path d="M1,1 L1,7 L7,4 L1,1" style="fill: #339;" />\n              </marker>\n          </defs>\n          <path d="M30,0 Q-10,25 26,50"\n            style="stroke: #88f; stroke-width: 2px; fill: none; ' + 'stroke-opacity: 0.5; marker-end: url(#markerArrow);"\n          ></path>\n          </svg>\n      </div>');
      context.hasArrows = true;
    }
  }, {
    key: 'format_textdiff',
    value: function format_textdiff(context, delta) {
      context.out('<div class="jsondiffpatch-value">');
      this.formatTextDiffString(context, delta[0]);
      context.out('</div>');
    }
  }]);
  return HtmlFormatter;
}(BaseFormatter);

function htmlEscape(text) {
  var html = text;
  var replacements = [[/&/g, '&amp;'], [/</g, '&lt;'], [/>/g, '&gt;'], [/'/g, '&apos;'], [/"/g, '&quot;']];
  for (var i = 0; i < replacements.length; i++) {
    html = html.replace(replacements[i][0], replacements[i][1]);
  }
  return html;
}

var adjustArrows = function jsondiffpatchHtmlFormatterAdjustArrows(nodeArg) {
  var node = nodeArg || document;
  var getElementText = function getElementText(_ref) {
    var textContent = _ref.textContent,
        innerText = _ref.innerText;
    return textContent || innerText;
  };
  var eachByQuery = function eachByQuery(el, query, fn) {
    var elems = el.querySelectorAll(query);
    for (var i = 0, l = elems.length; i < l; i++) {
      fn(elems[i]);
    }
  };
  var eachChildren = function eachChildren(_ref2, fn) {
    var children = _ref2.children;

    for (var i = 0, l = children.length; i < l; i++) {
      fn(children[i], i);
    }
  };
  eachByQuery(node, '.jsondiffpatch-arrow', function (_ref3) {
    var parentNode = _ref3.parentNode,
        children = _ref3.children,
        style = _ref3.style;

    var arrowParent = parentNode;
    var svg = children[0];
    var path = svg.children[1];
    svg.style.display = 'none';
    var destination = getElementText(arrowParent.querySelector('.jsondiffpatch-moved-destination'));
    var container = arrowParent.parentNode;
    var destinationElem = void 0;
    eachChildren(container, function (child) {
      if (child.getAttribute('data-key') === destination) {
        destinationElem = child;
      }
    });
    if (!destinationElem) {
      return;
    }
    try {
      var distance = destinationElem.offsetTop - arrowParent.offsetTop;
      svg.setAttribute('height', Math.abs(distance) + 6);
      style.top = -8 + (distance > 0 ? 0 : distance) + 'px';
      var curve = distance > 0 ? 'M30,0 Q-10,' + Math.round(distance / 2) + ' 26,' + (distance - 4) : 'M30,' + -distance + ' Q-10,' + Math.round(-distance / 2) + ' 26,4';
      path.setAttribute('d', curve);
      svg.style.display = '';
    } catch (err) {}
  });
};

/* jshint camelcase: true */
/* eslint-enable camelcase */

var showUnchanged = function showUnchanged(show, node, delay) {
  var el = node || document.body;
  var prefix = 'jsondiffpatch-unchanged-';
  var classes = {
    showing: prefix + 'showing',
    hiding: prefix + 'hiding',
    visible: prefix + 'visible',
    hidden: prefix + 'hidden'
  };
  var list = el.classList;
  if (!list) {
    return;
  }
  if (!delay) {
    list.remove(classes.showing);
    list.remove(classes.hiding);
    list.remove(classes.visible);
    list.remove(classes.hidden);
    if (show === false) {
      list.add(classes.hidden);
    }
    return;
  }
  if (show === false) {
    list.remove(classes.showing);
    list.add(classes.visible);
    setTimeout(function () {
      list.add(classes.hiding);
    }, 10);
  } else {
    list.remove(classes.hiding);
    list.add(classes.showing);
    list.remove(classes.hidden);
  }
  var intervalId = setInterval(function () {
    adjustArrows(el);
  }, 100);
  setTimeout(function () {
    list.remove(classes.showing);
    list.remove(classes.hiding);
    if (show === false) {
      list.add(classes.hidden);
      list.remove(classes.visible);
    } else {
      list.add(classes.visible);
      list.remove(classes.hidden);
    }
    setTimeout(function () {
      list.remove(classes.visible);
      clearInterval(intervalId);
    }, delay + 400);
  }, delay);
};

var hideUnchanged = function hideUnchanged(node, delay) {
  return showUnchanged(false, node, delay);
};

var defaultInstance = void 0;

function format(delta, left) {
  if (!defaultInstance) {
    defaultInstance = new HtmlFormatter();
  }
  return defaultInstance.format(delta, left);
}



var html = Object.freeze({
	showUnchanged: showUnchanged,
	hideUnchanged: hideUnchanged,
	default: HtmlFormatter,
	format: format
});

var AnnotatedFormatter = function (_BaseFormatter) {
  inherits(AnnotatedFormatter, _BaseFormatter);

  function AnnotatedFormatter() {
    classCallCheck(this, AnnotatedFormatter);

    var _this = possibleConstructorReturn(this, (AnnotatedFormatter.__proto__ || Object.getPrototypeOf(AnnotatedFormatter)).call(this));

    _this.includeMoveDestinations = false;
    return _this;
  }

  createClass(AnnotatedFormatter, [{
    key: 'prepareContext',
    value: function prepareContext(context) {
      get(AnnotatedFormatter.prototype.__proto__ || Object.getPrototypeOf(AnnotatedFormatter.prototype), 'prepareContext', this).call(this, context);
      context.indent = function (levels) {
        this.indentLevel = (this.indentLevel || 0) + (typeof levels === 'undefined' ? 1 : levels);
        this.indentPad = new Array(this.indentLevel + 1).join('&nbsp;&nbsp;');
      };
      context.row = function (json, htmlNote) {
        context.out('<tr><td style="white-space: nowrap;">' + '<pre class="jsondiffpatch-annotated-indent"' + ' style="display: inline-block">');
        context.out(context.indentPad);
        context.out('</pre><pre style="display: inline-block">');
        context.out(json);
        context.out('</pre></td><td class="jsondiffpatch-delta-note"><div>');
        context.out(htmlNote);
        context.out('</div></td></tr>');
      };
    }
  }, {
    key: 'typeFormattterErrorFormatter',
    value: function typeFormattterErrorFormatter(context, err) {
      context.row('', '<pre class="jsondiffpatch-error">' + err + '</pre>');
    }
  }, {
    key: 'formatTextDiffString',
    value: function formatTextDiffString(context, value) {
      var lines = this.parseTextDiff(value);
      context.out('<ul class="jsondiffpatch-textdiff">');
      for (var i = 0, l = lines.length; i < l; i++) {
        var line = lines[i];
        context.out('<li><div class="jsondiffpatch-textdiff-location">' + ('<span class="jsondiffpatch-textdiff-line-number">' + line.location.line + '</span><span class="jsondiffpatch-textdiff-char">' + line.location.chr + '</span></div><div class="jsondiffpatch-textdiff-line">'));
        var pieces = line.pieces;
        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
          var piece = pieces[pieceIndex];
          context.out('<span class="jsondiffpatch-textdiff-' + piece.type + '">' + piece.text + '</span>');
        }
        context.out('</div></li>');
      }
      context.out('</ul>');
    }
  }, {
    key: 'rootBegin',
    value: function rootBegin(context, type, nodeType) {
      context.out('<table class="jsondiffpatch-annotated-delta">');
      if (type === 'node') {
        context.row('{');
        context.indent();
      }
      if (nodeType === 'array') {
        context.row('"_t": "a",', 'Array delta (member names indicate array indices)');
      }
    }
  }, {
    key: 'rootEnd',
    value: function rootEnd(context, type) {
      if (type === 'node') {
        context.indent(-1);
        context.row('}');
      }
      context.out('</table>');
    }
  }, {
    key: 'nodeBegin',
    value: function nodeBegin(context, key, leftKey, type, nodeType) {
      context.row('&quot;' + key + '&quot;: {');
      if (type === 'node') {
        context.indent();
      }
      if (nodeType === 'array') {
        context.row('"_t": "a",', 'Array delta (member names indicate array indices)');
      }
    }
  }, {
    key: 'nodeEnd',
    value: function nodeEnd(context, key, leftKey, type, nodeType, isLast) {
      if (type === 'node') {
        context.indent(-1);
      }
      context.row('}' + (isLast ? '' : ','));
    }

    /* jshint camelcase: false */

    /* eslint-disable camelcase */

  }, {
    key: 'format_unchanged',
    value: function format_unchanged() {}
  }, {
    key: 'format_movedestination',
    value: function format_movedestination() {}
  }, {
    key: 'format_node',
    value: function format_node(context, delta, left) {
      // recurse
      this.formatDeltaChildren(context, delta, left);
    }
  }]);
  return AnnotatedFormatter;
}(BaseFormatter);

/* eslint-enable camelcase */

var wrapPropertyName = function wrapPropertyName(name) {
  return '<pre style="display:inline-block">&quot;' + name + '&quot;</pre>';
};

var deltaAnnotations = {
  added: function added(delta, left, key, leftKey) {
    var formatLegend = ' <pre>([newValue])</pre>';
    if (typeof leftKey === 'undefined') {
      return 'new value' + formatLegend;
    }
    if (typeof leftKey === 'number') {
      return 'insert at index ' + leftKey + formatLegend;
    }
    return 'add property ' + wrapPropertyName(leftKey) + formatLegend;
  },
  modified: function modified(delta, left, key, leftKey) {
    var formatLegend = ' <pre>([previousValue, newValue])</pre>';
    if (typeof leftKey === 'undefined') {
      return 'modify value' + formatLegend;
    }
    if (typeof leftKey === 'number') {
      return 'modify at index ' + leftKey + formatLegend;
    }
    return 'modify property ' + wrapPropertyName(leftKey) + formatLegend;
  },
  deleted: function deleted(delta, left, key, leftKey) {
    var formatLegend = ' <pre>([previousValue, 0, 0])</pre>';
    if (typeof leftKey === 'undefined') {
      return 'delete value' + formatLegend;
    }
    if (typeof leftKey === 'number') {
      return 'remove index ' + leftKey + formatLegend;
    }
    return 'delete property ' + wrapPropertyName(leftKey) + formatLegend;
  },
  moved: function moved(delta, left, key, leftKey) {
    return 'move from <span title="(position to remove at original state)">' + ('index ' + leftKey + '</span> to <span title="(position to insert at final') + (' state)">index ' + delta[1] + '</span>');
  },
  textdiff: function textdiff(delta, left, key, leftKey) {
    var location = typeof leftKey === 'undefined' ? '' : typeof leftKey === 'number' ? ' at index ' + leftKey : ' at property ' + wrapPropertyName(leftKey);
    return 'text diff' + location + ', format is <a href="https://code.google.com/' + 'p/google-diff-match-patch/wiki/Unidiff">a variation of Unidiff</a>';
  }
};

var formatAnyChange = function formatAnyChange(context, delta) {
  var deltaType = this.getDeltaType(delta);
  var annotator = deltaAnnotations[deltaType];
  var htmlNote = annotator && annotator.apply(annotator, Array.prototype.slice.call(arguments, 1));
  var json = JSON.stringify(delta, null, 2);
  if (deltaType === 'textdiff') {
    // split text diffs lines
    json = json.split('\\n').join('\\n"+\n   "');
  }
  context.indent();
  context.row(json, htmlNote);
  context.indent(-1);
};

/* eslint-disable camelcase */
AnnotatedFormatter.prototype.format_added = formatAnyChange;
AnnotatedFormatter.prototype.format_modified = formatAnyChange;
AnnotatedFormatter.prototype.format_deleted = formatAnyChange;
AnnotatedFormatter.prototype.format_moved = formatAnyChange;
AnnotatedFormatter.prototype.format_textdiff = formatAnyChange;
var defaultInstance$1 = void 0;

function format$1(delta, left) {
  if (!defaultInstance$1) {
    defaultInstance$1 = new AnnotatedFormatter();
  }
  return defaultInstance$1.format(delta, left);
}



var annotated = Object.freeze({
	default: AnnotatedFormatter,
	format: format$1
});

var OPERATIONS = {
  add: 'add',
  remove: 'remove',
  replace: 'replace',
  move: 'move'
};

var JSONFormatter = function (_BaseFormatter) {
  inherits(JSONFormatter, _BaseFormatter);

  function JSONFormatter() {
    classCallCheck(this, JSONFormatter);

    var _this = possibleConstructorReturn(this, (JSONFormatter.__proto__ || Object.getPrototypeOf(JSONFormatter)).call(this));

    _this.includeMoveDestinations = true;
    return _this;
  }

  createClass(JSONFormatter, [{
    key: 'prepareContext',
    value: function prepareContext(context) {
      get(JSONFormatter.prototype.__proto__ || Object.getPrototypeOf(JSONFormatter.prototype), 'prepareContext', this).call(this, context);
      context.result = [];
      context.path = [];
      context.pushCurrentOp = function (obj) {
        var op = obj.op,
            value = obj.value;

        var val = {
          op: op,
          path: this.currentPath()
        };
        if (typeof value !== 'undefined') {
          val.value = value;
        }
        this.result.push(val);
      };

      context.pushMoveOp = function (to) {
        var from = this.currentPath();
        this.result.push({
          op: OPERATIONS.move,
          from: from,
          path: this.toPath(to)
        });
      };

      context.currentPath = function () {
        return '/' + this.path.join('/');
      };

      context.toPath = function (toPath) {
        var to = this.path.slice();
        to[to.length - 1] = toPath;
        return '/' + to.join('/');
      };
    }
  }, {
    key: 'typeFormattterErrorFormatter',
    value: function typeFormattterErrorFormatter(context, err) {
      context.out('[ERROR] ' + err);
    }
  }, {
    key: 'rootBegin',
    value: function rootBegin() {}
  }, {
    key: 'rootEnd',
    value: function rootEnd() {}
  }, {
    key: 'nodeBegin',
    value: function nodeBegin(_ref, key, leftKey) {
      var path = _ref.path;

      path.push(leftKey);
    }
  }, {
    key: 'nodeEnd',
    value: function nodeEnd(_ref2) {
      var path = _ref2.path;

      path.pop();
    }

    /* jshint camelcase: false */
    /* eslint-disable camelcase */

  }, {
    key: 'format_unchanged',
    value: function format_unchanged() {}
  }, {
    key: 'format_movedestination',
    value: function format_movedestination() {}
  }, {
    key: 'format_node',
    value: function format_node(context, delta, left) {
      this.formatDeltaChildren(context, delta, left);
    }
  }, {
    key: 'format_added',
    value: function format_added(context, delta) {
      context.pushCurrentOp({ op: OPERATIONS.add, value: delta[0] });
    }
  }, {
    key: 'format_modified',
    value: function format_modified(context, delta) {
      context.pushCurrentOp({ op: OPERATIONS.replace, value: delta[1] });
    }
  }, {
    key: 'format_deleted',
    value: function format_deleted(context) {
      context.pushCurrentOp({ op: OPERATIONS.remove });
    }
  }, {
    key: 'format_moved',
    value: function format_moved(context, delta) {
      var to = delta[1];
      context.pushMoveOp(to);
    }
  }, {
    key: 'format_textdiff',
    value: function format_textdiff() {
      throw new Error('Not implemented');
    }
  }, {
    key: 'format',
    value: function format(delta, left) {
      var context = {};
      this.prepareContext(context);
      this.recurse(context, delta, left);
      return context.result;
    }
  }]);
  return JSONFormatter;
}(BaseFormatter);

var last = function last(arr) {
  return arr[arr.length - 1];
};

var sortBy = function sortBy(arr, pred) {
  arr.sort(pred);
  return arr;
};

var compareByIndexDesc = function compareByIndexDesc(indexA, indexB) {
  var lastA = parseInt(indexA, 10);
  var lastB = parseInt(indexB, 10);
  if (!(isNaN(lastA) || isNaN(lastB))) {
    return lastB - lastA;
  } else {
    return 0;
  }
};

var opsByDescendingOrder = function opsByDescendingOrder(removeOps) {
  return sortBy(removeOps, function (a, b) {
    var splitA = a.path.split('/');
    var splitB = b.path.split('/');
    if (splitA.length !== splitB.length) {
      return splitA.length - splitB.length;
    } else {
      return compareByIndexDesc(last(splitA), last(splitB));
    }
  });
};

var partitionOps = function partitionOps(arr, fns) {
  var initArr = Array(fns.length + 1).fill().map(function () {
    return [];
  });
  return arr.map(function (item) {
    var position = fns.map(function (fn) {
      return fn(item);
    }).indexOf(true);
    if (position < 0) {
      position = fns.length;
    }
    return { item: item, position: position };
  }).reduce(function (acc, item) {
    acc[item.position].push(item.item);
    return acc;
  }, initArr);
};
var isMoveOp = function isMoveOp(_ref3) {
  var op = _ref3.op;
  return op === 'move';
};
var isRemoveOp = function isRemoveOp(_ref4) {
  var op = _ref4.op;
  return op === 'remove';
};

var reorderOps = function reorderOps(diff) {
  var _partitionOps = partitionOps(diff, [isMoveOp, isRemoveOp]),
      _partitionOps2 = slicedToArray(_partitionOps, 3),
      moveOps = _partitionOps2[0],
      removedOps = _partitionOps2[1],
      restOps = _partitionOps2[2];

  var removeOpsReverse = opsByDescendingOrder(removedOps);
  return [].concat(toConsumableArray(removeOpsReverse), toConsumableArray(moveOps), toConsumableArray(restOps));
};

var defaultInstance$2 = void 0;

var format$2 = function format(delta, left) {
  if (!defaultInstance$2) {
    defaultInstance$2 = new JSONFormatter();
  }
  return reorderOps(defaultInstance$2.format(delta, left));
};

var log = function log(delta, left) {
  console.log(format$2(delta, left));
};



var jsonpatch = Object.freeze({
	default: JSONFormatter,
	partitionOps: partitionOps,
	format: format$2,
	log: log
});

function chalkColor(name) {
  return chalk && chalk[name] || function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return args;
  };
}

var colors = {
  added: chalkColor('green'),
  deleted: chalkColor('red'),
  movedestination: chalkColor('gray'),
  moved: chalkColor('yellow'),
  unchanged: chalkColor('gray'),
  error: chalkColor('white.bgRed'),
  textDiffLine: chalkColor('gray')
};

var ConsoleFormatter = function (_BaseFormatter) {
  inherits(ConsoleFormatter, _BaseFormatter);

  function ConsoleFormatter() {
    classCallCheck(this, ConsoleFormatter);

    var _this = possibleConstructorReturn(this, (ConsoleFormatter.__proto__ || Object.getPrototypeOf(ConsoleFormatter)).call(this));

    _this.includeMoveDestinations = false;
    return _this;
  }

  createClass(ConsoleFormatter, [{
    key: 'prepareContext',
    value: function prepareContext(context) {
      get(ConsoleFormatter.prototype.__proto__ || Object.getPrototypeOf(ConsoleFormatter.prototype), 'prepareContext', this).call(this, context);
      context.indent = function (levels) {
        this.indentLevel = (this.indentLevel || 0) + (typeof levels === 'undefined' ? 1 : levels);
        this.indentPad = new Array(this.indentLevel + 1).join('  ');
        this.outLine();
      };
      context.outLine = function () {
        this.buffer.push('\n' + (this.indentPad || ''));
      };
      context.out = function () {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        for (var i = 0, l = args.length; i < l; i++) {
          var lines = args[i].split('\n');
          var text = lines.join('\n' + (this.indentPad || ''));
          if (this.color && this.color[0]) {
            text = this.color[0](text);
          }
          this.buffer.push(text);
        }
      };
      context.pushColor = function (color) {
        this.color = this.color || [];
        this.color.unshift(color);
      };
      context.popColor = function () {
        this.color = this.color || [];
        this.color.shift();
      };
    }
  }, {
    key: 'typeFormattterErrorFormatter',
    value: function typeFormattterErrorFormatter(context, err) {
      context.pushColor(colors.error);
      context.out('[ERROR]' + err);
      context.popColor();
    }
  }, {
    key: 'formatValue',
    value: function formatValue(context, value) {
      context.out(JSON.stringify(value, null, 2));
    }
  }, {
    key: 'formatTextDiffString',
    value: function formatTextDiffString(context, value) {
      var lines = this.parseTextDiff(value);
      context.indent();
      for (var i = 0, l = lines.length; i < l; i++) {
        var line = lines[i];
        context.pushColor(colors.textDiffLine);
        context.out(line.location.line + ',' + line.location.chr + ' ');
        context.popColor();
        var pieces = line.pieces;
        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
          var piece = pieces[pieceIndex];
          context.pushColor(colors[piece.type]);
          context.out(piece.text);
          context.popColor();
        }
        if (i < l - 1) {
          context.outLine();
        }
      }
      context.indent(-1);
    }
  }, {
    key: 'rootBegin',
    value: function rootBegin(context, type, nodeType) {
      context.pushColor(colors[type]);
      if (type === 'node') {
        context.out(nodeType === 'array' ? '[' : '{');
        context.indent();
      }
    }
  }, {
    key: 'rootEnd',
    value: function rootEnd(context, type, nodeType) {
      if (type === 'node') {
        context.indent(-1);
        context.out(nodeType === 'array' ? ']' : '}');
      }
      context.popColor();
    }
  }, {
    key: 'nodeBegin',
    value: function nodeBegin(context, key, leftKey, type, nodeType) {
      context.pushColor(colors[type]);
      context.out(leftKey + ': ');
      if (type === 'node') {
        context.out(nodeType === 'array' ? '[' : '{');
        context.indent();
      }
    }
  }, {
    key: 'nodeEnd',
    value: function nodeEnd(context, key, leftKey, type, nodeType, isLast) {
      if (type === 'node') {
        context.indent(-1);
        context.out(nodeType === 'array' ? ']' : '}' + (isLast ? '' : ','));
      }
      if (!isLast) {
        context.outLine();
      }
      context.popColor();
    }

    /* jshint camelcase: false */
    /* eslint-disable camelcase */

  }, {
    key: 'format_unchanged',
    value: function format_unchanged(context, delta, left) {
      if (typeof left === 'undefined') {
        return;
      }
      this.formatValue(context, left);
    }
  }, {
    key: 'format_movedestination',
    value: function format_movedestination(context, delta, left) {
      if (typeof left === 'undefined') {
        return;
      }
      this.formatValue(context, left);
    }
  }, {
    key: 'format_node',
    value: function format_node(context, delta, left) {
      // recurse
      this.formatDeltaChildren(context, delta, left);
    }
  }, {
    key: 'format_added',
    value: function format_added(context, delta) {
      this.formatValue(context, delta[0]);
    }
  }, {
    key: 'format_modified',
    value: function format_modified(context, delta) {
      context.pushColor(colors.deleted);
      this.formatValue(context, delta[0]);
      context.popColor();
      context.out(' => ');
      context.pushColor(colors.added);
      this.formatValue(context, delta[1]);
      context.popColor();
    }
  }, {
    key: 'format_deleted',
    value: function format_deleted(context, delta) {
      this.formatValue(context, delta[0]);
    }
  }, {
    key: 'format_moved',
    value: function format_moved(context, delta) {
      context.out('==> ' + delta[1]);
    }
  }, {
    key: 'format_textdiff',
    value: function format_textdiff(context, delta) {
      this.formatTextDiffString(context, delta[0]);
    }
  }]);
  return ConsoleFormatter;
}(BaseFormatter);

var defaultInstance$3 = void 0;

var format$3 = function format(delta, left) {
  if (!defaultInstance$3) {
    defaultInstance$3 = new ConsoleFormatter();
  }
  return defaultInstance$3.format(delta, left);
};

function log$1(delta, left) {
  console.log(format$3(delta, left));
}



var console$1 = Object.freeze({
	default: ConsoleFormatter,
	format: format$3,
	log: log$1
});



var index = Object.freeze({
	base: base,
	html: html,
	annotated: annotated,
	jsonpatch: jsonpatch,
	console: console$1
});

// use as 2nd parameter for JSON.parse to revive Date instances
function dateReviver(key, value) {
  var parts = void 0;
  if (typeof value === 'string') {
    // eslint-disable-next-line max-len
    parts = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d*))?(Z|([+-])(\d{2}):(\d{2}))$/.exec(value);
    if (parts) {
      return new Date(Date.UTC(+parts[1], +parts[2] - 1, +parts[3], +parts[4], +parts[5], +parts[6], +(parts[7] || 0)));
    }
  }
  return value;
}

function create(options) {
  return new DiffPatcher(options);
}

var defaultInstance$4 = void 0;

function diff() {
  if (!defaultInstance$4) {
    defaultInstance$4 = new DiffPatcher();
  }
  return defaultInstance$4.diff.apply(defaultInstance$4, arguments);
}

function patch() {
  if (!defaultInstance$4) {
    defaultInstance$4 = new DiffPatcher();
  }
  return defaultInstance$4.patch.apply(defaultInstance$4, arguments);
}

function unpatch() {
  if (!defaultInstance$4) {
    defaultInstance$4 = new DiffPatcher();
  }
  return defaultInstance$4.unpatch.apply(defaultInstance$4, arguments);
}

function reverse() {
  if (!defaultInstance$4) {
    defaultInstance$4 = new DiffPatcher();
  }
  return defaultInstance$4.reverse.apply(defaultInstance$4, arguments);
}

function clone$1() {
  if (!defaultInstance$4) {
    defaultInstance$4 = new DiffPatcher();
  }
  return defaultInstance$4.clone.apply(defaultInstance$4, arguments);
}

exports.DiffPatcher = DiffPatcher;
exports.formatters = index;
exports.console = console$1;
exports.create = create;
exports.dateReviver = dateReviver;
exports.diff = diff;
exports.patch = patch;
exports.unpatch = unpatch;
exports.reverse = reverse;
exports.clone = clone$1;
//# sourceMappingURL=jsondiffpatch.cjs.js.map


/***/ }),

/***/ 38:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/* module decorator */ module = __nccwpck_require__.nmd(module);

const colorConvert = __nccwpck_require__(8449);

const wrapAnsi16 = (fn, offset) => function () {
	const code = fn.apply(colorConvert, arguments);
	return `\u001B[${code + offset}m`;
};

const wrapAnsi256 = (fn, offset) => function () {
	const code = fn.apply(colorConvert, arguments);
	return `\u001B[${38 + offset};5;${code}m`;
};

const wrapAnsi16m = (fn, offset) => function () {
	const rgb = fn.apply(colorConvert, arguments);
	return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};

function assembleStyles() {
	const codes = new Map();
	const styles = {
		modifier: {
			reset: [0, 0],
			// 21 isn't widely supported and 22 does the same thing
			bold: [1, 22],
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		color: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],
			gray: [90, 39],

			// Bright color
			redBright: [91, 39],
			greenBright: [92, 39],
			yellowBright: [93, 39],
			blueBright: [94, 39],
			magentaBright: [95, 39],
			cyanBright: [96, 39],
			whiteBright: [97, 39]
		},
		bgColor: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49],

			// Bright color
			bgBlackBright: [100, 49],
			bgRedBright: [101, 49],
			bgGreenBright: [102, 49],
			bgYellowBright: [103, 49],
			bgBlueBright: [104, 49],
			bgMagentaBright: [105, 49],
			bgCyanBright: [106, 49],
			bgWhiteBright: [107, 49]
		}
	};

	// Fix humans
	styles.color.grey = styles.color.gray;

	for (const groupName of Object.keys(styles)) {
		const group = styles[groupName];

		for (const styleName of Object.keys(group)) {
			const style = group[styleName];

			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};

			group[styleName] = styles[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});

		Object.defineProperty(styles, 'codes', {
			value: codes,
			enumerable: false
		});
	}

	const ansi2ansi = n => n;
	const rgb2rgb = (r, g, b) => [r, g, b];

	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';

	styles.color.ansi = {
		ansi: wrapAnsi16(ansi2ansi, 0)
	};
	styles.color.ansi256 = {
		ansi256: wrapAnsi256(ansi2ansi, 0)
	};
	styles.color.ansi16m = {
		rgb: wrapAnsi16m(rgb2rgb, 0)
	};

	styles.bgColor.ansi = {
		ansi: wrapAnsi16(ansi2ansi, 10)
	};
	styles.bgColor.ansi256 = {
		ansi256: wrapAnsi256(ansi2ansi, 10)
	};
	styles.bgColor.ansi16m = {
		rgb: wrapAnsi16m(rgb2rgb, 10)
	};

	for (let key of Object.keys(colorConvert)) {
		if (typeof colorConvert[key] !== 'object') {
			continue;
		}

		const suite = colorConvert[key];

		if (key === 'ansi16') {
			key = 'ansi';
		}

		if ('ansi16' in suite) {
			styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
			styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
		}

		if ('ansi256' in suite) {
			styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
			styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
		}

		if ('rgb' in suite) {
			styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
			styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
		}
	}

	return styles;
}

// Make the export immutable
Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});


/***/ }),

/***/ 137:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const escapeStringRegexp = __nccwpck_require__(6003);
const ansiStyles = __nccwpck_require__(38);
const stdoutColor = __nccwpck_require__(1813).stdout;

const template = __nccwpck_require__(4074);

const isSimpleWindowsTerm = process.platform === 'win32' && !(process.env.TERM || '').toLowerCase().startsWith('xterm');

// `supportsColor.level` → `ansiStyles.color[name]` mapping
const levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];

// `color-convert` models to exclude from the Chalk API due to conflicts and such
const skipModels = new Set(['gray']);

const styles = Object.create(null);

function applyOptions(obj, options) {
	options = options || {};

	// Detect level if not set manually
	const scLevel = stdoutColor ? stdoutColor.level : 0;
	obj.level = options.level === undefined ? scLevel : options.level;
	obj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;
}

function Chalk(options) {
	// We check for this.template here since calling `chalk.constructor()`
	// by itself will have a `this` of a previously constructed chalk object
	if (!this || !(this instanceof Chalk) || this.template) {
		const chalk = {};
		applyOptions(chalk, options);

		chalk.template = function () {
			const args = [].slice.call(arguments);
			return chalkTag.apply(null, [chalk.template].concat(args));
		};

		Object.setPrototypeOf(chalk, Chalk.prototype);
		Object.setPrototypeOf(chalk.template, chalk);

		chalk.template.constructor = Chalk;

		return chalk.template;
	}

	applyOptions(this, options);
}

// Use bright blue on Windows as the normal blue color is illegible
if (isSimpleWindowsTerm) {
	ansiStyles.blue.open = '\u001B[94m';
}

for (const key of Object.keys(ansiStyles)) {
	ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

	styles[key] = {
		get() {
			const codes = ansiStyles[key];
			return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
		}
	};
}

styles.visible = {
	get() {
		return build.call(this, this._styles || [], true, 'visible');
	}
};

ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), 'g');
for (const model of Object.keys(ansiStyles.color.ansi)) {
	if (skipModels.has(model)) {
		continue;
	}

	styles[model] = {
		get() {
			const level = this.level;
			return function () {
				const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
				const codes = {
					open,
					close: ansiStyles.color.close,
					closeRe: ansiStyles.color.closeRe
				};
				return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
			};
		}
	};
}

ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), 'g');
for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
	if (skipModels.has(model)) {
		continue;
	}

	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = {
		get() {
			const level = this.level;
			return function () {
				const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
				const codes = {
					open,
					close: ansiStyles.bgColor.close,
					closeRe: ansiStyles.bgColor.closeRe
				};
				return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
			};
		}
	};
}

const proto = Object.defineProperties(() => {}, styles);

function build(_styles, _empty, key) {
	const builder = function () {
		return applyStyle.apply(builder, arguments);
	};

	builder._styles = _styles;
	builder._empty = _empty;

	const self = this;

	Object.defineProperty(builder, 'level', {
		enumerable: true,
		get() {
			return self.level;
		},
		set(level) {
			self.level = level;
		}
	});

	Object.defineProperty(builder, 'enabled', {
		enumerable: true,
		get() {
			return self.enabled;
		},
		set(enabled) {
			self.enabled = enabled;
		}
	});

	// See below for fix regarding invisible grey/dim combination on Windows
	builder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey';

	// `__proto__` is used because we must return a function, but there is
	// no way to create a function with a different prototype
	builder.__proto__ = proto; // eslint-disable-line no-proto

	return builder;
}

function applyStyle() {
	// Support varags, but simply cast to string in case there's only one arg
	const args = arguments;
	const argsLen = args.length;
	let str = String(arguments[0]);

	if (argsLen === 0) {
		return '';
	}

	if (argsLen > 1) {
		// Don't slice `arguments`, it prevents V8 optimizations
		for (let a = 1; a < argsLen; a++) {
			str += ' ' + args[a];
		}
	}

	if (!this.enabled || this.level <= 0 || !str) {
		return this._empty ? '' : str;
	}

	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
	// see https://github.com/chalk/chalk/issues/58
	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
	const originalDim = ansiStyles.dim.open;
	if (isSimpleWindowsTerm && this.hasGrey) {
		ansiStyles.dim.open = '';
	}

	for (const code of this._styles.slice().reverse()) {
		// Replace any instances already present with a re-opening code
		// otherwise only the part of the string until said closing code
		// will be colored, and the rest will simply be 'plain'.
		str = code.open + str.replace(code.closeRe, code.open) + code.close;

		// Close the styling before a linebreak and reopen
		// after next line to fix a bleed issue on macOS
		// https://github.com/chalk/chalk/pull/92
		str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
	}

	// Reset the original `dim` if we changed it to work around the Windows dimmed gray issue
	ansiStyles.dim.open = originalDim;

	return str;
}

function chalkTag(chalk, strings) {
	if (!Array.isArray(strings)) {
		// If chalk() was called by itself or with a string,
		// return the string itself as a string.
		return [].slice.call(arguments, 1).join(' ');
	}

	const args = [].slice.call(arguments, 2);
	const parts = [strings.raw[0]];

	for (let i = 1; i < strings.length; i++) {
		parts.push(String(args[i - 1]).replace(/[{}\\]/g, '\\$&'));
		parts.push(String(strings.raw[i]));
	}

	return template(chalk, parts.join(''));
}

Object.defineProperties(Chalk.prototype, styles);

module.exports = Chalk(); // eslint-disable-line new-cap
module.exports.supportsColor = stdoutColor;
module.exports.default = module.exports; // For TypeScript


/***/ }),

/***/ 4074:
/***/ ((module) => {

"use strict";

const TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;

const ESCAPES = new Map([
	['n', '\n'],
	['r', '\r'],
	['t', '\t'],
	['b', '\b'],
	['f', '\f'],
	['v', '\v'],
	['0', '\0'],
	['\\', '\\'],
	['e', '\u001B'],
	['a', '\u0007']
]);

function unescape(c) {
	if ((c[0] === 'u' && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
		return String.fromCharCode(parseInt(c.slice(1), 16));
	}

	return ESCAPES.get(c) || c;
}

function parseArguments(name, args) {
	const results = [];
	const chunks = args.trim().split(/\s*,\s*/g);
	let matches;

	for (const chunk of chunks) {
		if (!isNaN(chunk)) {
			results.push(Number(chunk));
		} else if ((matches = chunk.match(STRING_REGEX))) {
			results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
		} else {
			throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
		}
	}

	return results;
}

function parseStyle(style) {
	STYLE_REGEX.lastIndex = 0;

	const results = [];
	let matches;

	while ((matches = STYLE_REGEX.exec(style)) !== null) {
		const name = matches[1];

		if (matches[2]) {
			const args = parseArguments(name, matches[2]);
			results.push([name].concat(args));
		} else {
			results.push([name]);
		}
	}

	return results;
}

function buildStyle(chalk, styles) {
	const enabled = {};

	for (const layer of styles) {
		for (const style of layer.styles) {
			enabled[style[0]] = layer.inverse ? null : style.slice(1);
		}
	}

	let current = chalk;
	for (const styleName of Object.keys(enabled)) {
		if (Array.isArray(enabled[styleName])) {
			if (!(styleName in current)) {
				throw new Error(`Unknown Chalk style: ${styleName}`);
			}

			if (enabled[styleName].length > 0) {
				current = current[styleName].apply(current, enabled[styleName]);
			} else {
				current = current[styleName];
			}
		}
	}

	return current;
}

module.exports = (chalk, tmp) => {
	const styles = [];
	const chunks = [];
	let chunk = [];

	// eslint-disable-next-line max-params
	tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
		if (escapeChar) {
			chunk.push(unescape(escapeChar));
		} else if (style) {
			const str = chunk.join('');
			chunk = [];
			chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
			styles.push({inverse, styles: parseStyle(style)});
		} else if (close) {
			if (styles.length === 0) {
				throw new Error('Found extraneous } in Chalk template literal');
			}

			chunks.push(buildStyle(chalk, styles)(chunk.join('')));
			chunk = [];
			styles.pop();
		} else {
			chunk.push(chr);
		}
	});

	chunks.push(chunk.join(''));

	if (styles.length > 0) {
		const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
		throw new Error(errMsg);
	}

	return chunks.join('');
};


/***/ }),

/***/ 9418:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/* MIT license */
var cssKeywords = __nccwpck_require__(9289);

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

var reverseKeywords = {};
for (var key in cssKeywords) {
	if (cssKeywords.hasOwnProperty(key)) {
		reverseKeywords[cssKeywords[key]] = key;
	}
}

var convert = module.exports = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

// hide .channels and .labels properties
for (var model in convert) {
	if (convert.hasOwnProperty(model)) {
		if (!('channels' in convert[model])) {
			throw new Error('missing channels property: ' + model);
		}

		if (!('labels' in convert[model])) {
			throw new Error('missing channel labels property: ' + model);
		}

		if (convert[model].labels.length !== convert[model].channels) {
			throw new Error('channel and label counts mismatch: ' + model);
		}

		var channels = convert[model].channels;
		var labels = convert[model].labels;
		delete convert[model].channels;
		delete convert[model].labels;
		Object.defineProperty(convert[model], 'channels', {value: channels});
		Object.defineProperty(convert[model], 'labels', {value: labels});
	}
}

convert.rgb.hsl = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var l;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	var rdif;
	var gdif;
	var bdif;
	var h;
	var s;

	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var v = Math.max(r, g, b);
	var diff = v - Math.min(r, g, b);
	var diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}
		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert.rgb.hwb = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var h = convert.rgb.hsl(rgb)[0];
	var w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var c;
	var m;
	var y;
	var k;

	k = Math.min(1 - r, 1 - g, 1 - b);
	c = (1 - r - k) / (1 - k) || 0;
	m = (1 - g - k) / (1 - k) || 0;
	y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

/**
 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
 * */
function comparativeDistance(x, y) {
	return (
		Math.pow(x[0] - y[0], 2) +
		Math.pow(x[1] - y[1], 2) +
		Math.pow(x[2] - y[2], 2)
	);
}

convert.rgb.keyword = function (rgb) {
	var reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	var currentClosestDistance = Infinity;
	var currentClosestKeyword;

	for (var keyword in cssKeywords) {
		if (cssKeywords.hasOwnProperty(keyword)) {
			var value = cssKeywords[keyword];

			// Compute comparative distance
			var distance = comparativeDistance(rgb, value);

			// Check if its less, if so set as closest
			if (distance < currentClosestDistance) {
				currentClosestDistance = distance;
				currentClosestKeyword = keyword;
			}
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;

	// assume sRGB
	r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	var xyz = convert.rgb.xyz(rgb);
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	var h = hsl[0] / 360;
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var t1;
	var t2;
	var t3;
	var rgb;
	var val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	t1 = 2 * l - t2;

	rgb = [0, 0, 0];
	for (var i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}
		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	var h = hsl[0];
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var smin = s;
	var lmin = Math.max(l, 0.01);
	var sv;
	var v;

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	v = (l + s) / 2;
	sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	var h = hsv[0] / 60;
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var hi = Math.floor(h) % 6;

	var f = h - Math.floor(h);
	var p = 255 * v * (1 - s);
	var q = 255 * v * (1 - (s * f));
	var t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	var h = hsv[0];
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var vmin = Math.max(v, 0.01);
	var lmin;
	var sl;
	var l;

	l = (2 - s) * v;
	lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	var h = hwb[0] / 360;
	var wh = hwb[1] / 100;
	var bl = hwb[2] / 100;
	var ratio = wh + bl;
	var i;
	var v;
	var f;
	var n;

	// wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	i = Math.floor(6 * h);
	v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	n = wh + f * (v - wh); // linear interpolation

	var r;
	var g;
	var b;
	switch (i) {
		default:
		case 6:
		case 0: r = v; g = n; b = wh; break;
		case 1: r = n; g = v; b = wh; break;
		case 2: r = wh; g = v; b = n; break;
		case 3: r = wh; g = n; b = v; break;
		case 4: r = n; g = wh; b = v; break;
		case 5: r = v; g = wh; b = n; break;
	}

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	var c = cmyk[0] / 100;
	var m = cmyk[1] / 100;
	var y = cmyk[2] / 100;
	var k = cmyk[3] / 100;
	var r;
	var g;
	var b;

	r = 1 - Math.min(1, c * (1 - k) + k);
	g = 1 - Math.min(1, m * (1 - k) + k);
	b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	var x = xyz[0] / 100;
	var y = xyz[1] / 100;
	var z = xyz[2] / 100;
	var r;
	var g;
	var b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// assume sRGB
	r = r > 0.0031308
		? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var x;
	var y;
	var z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	var y2 = Math.pow(y, 3);
	var x2 = Math.pow(x, 3);
	var z2 = Math.pow(z, 3);
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var hr;
	var h;
	var c;

	hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	var l = lch[0];
	var c = lch[1];
	var h = lch[2];
	var a;
	var b;
	var hr;

	hr = h / 360 * 2 * Math.PI;
	a = c * Math.cos(hr);
	b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];
	var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	var ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];

	// we use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	var ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	var color = args % 10;

	// handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	var mult = (~~(args > 50) + 1) * 0.5;
	var r = ((color & 1) * mult) * 255;
	var g = (((color >> 1) & 1) * mult) * 255;
	var b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// handle greyscale
	if (args >= 232) {
		var c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	var rem;
	var r = Math.floor(args / 36) / 5 * 255;
	var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	var b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	var integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	var colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(function (char) {
			return char + char;
		}).join('');
	}

	var integer = parseInt(colorString, 16);
	var r = (integer >> 16) & 0xFF;
	var g = (integer >> 8) & 0xFF;
	var b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var max = Math.max(Math.max(r, g), b);
	var min = Math.min(Math.min(r, g), b);
	var chroma = (max - min);
	var grayscale;
	var hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma + 4;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var c = 1;
	var f = 0;

	if (l < 0.5) {
		c = 2.0 * s * l;
	} else {
		c = 2.0 * s * (1.0 - l);
	}

	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;

	var c = s * v;
	var f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	var h = hcg[0] / 360;
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	var pure = [0, 0, 0];
	var hi = (h % 1) * 6;
	var v = hi % 1;
	var w = 1 - v;
	var mg = 0;

	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var v = c + g * (1.0 - c);
	var f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var l = g * (1.0 - c) + 0.5 * c;
	var s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;
	var v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	var w = hwb[1] / 100;
	var b = hwb[2] / 100;
	var v = 1 - b;
	var c = v - w;
	var g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = convert.gray.hsv = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	var val = Math.round(gray[0] / 100 * 255) & 0xFF;
	var integer = (val << 16) + (val << 8) + val;

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};


/***/ }),

/***/ 8449:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var conversions = __nccwpck_require__(9418);
var route = __nccwpck_require__(8892);

var convert = {};

var models = Object.keys(conversions);

function wrapRaw(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		return fn(args);
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		var result = fn(args);

		// we're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (var len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(function (fromModel) {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	var routes = route(fromModel);
	var routeModels = Object.keys(routes);

	routeModels.forEach(function (toModel) {
		var fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;


/***/ }),

/***/ 8892:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var conversions = __nccwpck_require__(9418);

/*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	var graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	var models = Object.keys(conversions);

	for (var len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	var graph = buildGraph();
	var queue = [fromModel]; // unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		var current = queue.pop();
		var adjacents = Object.keys(conversions[current]);

		for (var len = adjacents.length, i = 0; i < len; i++) {
			var adjacent = adjacents[i];
			var node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	var path = [graph[toModel].parent, toModel];
	var fn = conversions[graph[toModel].parent][toModel];

	var cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	var graph = deriveBFS(fromModel);
	var conversion = {};

	var models = Object.keys(graph);
	for (var len = models.length, i = 0; i < len; i++) {
		var toModel = models[i];
		var node = graph[toModel];

		if (node.parent === null) {
			// no possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};



/***/ }),

/***/ 9289:
/***/ ((module) => {

"use strict";


module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};


/***/ }),

/***/ 3526:
/***/ ((module) => {

"use strict";

module.exports = (flag, argv) => {
	argv = argv || process.argv;
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const pos = argv.indexOf(prefix + flag);
	const terminatorPos = argv.indexOf('--');
	return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
};


/***/ }),

/***/ 1813:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const os = __nccwpck_require__(2087);
const hasFlag = __nccwpck_require__(3526);

const env = process.env;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false')) {
	forceColor = false;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = true;
}
if ('FORCE_COLOR' in env) {
	forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(stream) {
	if (forceColor === false) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (stream && !stream.isTTY && forceColor !== true) {
		return 0;
	}

	const min = forceColor ? 1 : 0;

	if (process.platform === 'win32') {
		// Node.js 7.5.0 is the first version of Node.js to include a patch to
		// libuv that enables 256 color output on Windows. Anything earlier and it
		// won't work. However, here we target Node.js 8 at minimum as it is an LTS
		// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
		// release that supports 256 colors. Windows 10 build 14931 is the first release
		// that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(process.versions.node.split('.')[0]) >= 8 &&
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	if (env.TERM === 'dumb') {
		return min;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: getSupportLevel(process.stdout),
	stderr: getSupportLevel(process.stderr)
};


/***/ }),

/***/ 4487:
/***/ ((module) => {

/* Protocol - protocol constants */
const protocol = module.exports

/* Command code => mnemonic */
protocol.types = {
  0: 'reserved',
  1: 'connect',
  2: 'connack',
  3: 'publish',
  4: 'puback',
  5: 'pubrec',
  6: 'pubrel',
  7: 'pubcomp',
  8: 'subscribe',
  9: 'suback',
  10: 'unsubscribe',
  11: 'unsuback',
  12: 'pingreq',
  13: 'pingresp',
  14: 'disconnect',
  15: 'auth'
}

/* Mnemonic => Command code */
protocol.codes = {}
for (const k in protocol.types) {
  const v = protocol.types[k]
  protocol.codes[v] = k
}

/* Header */
protocol.CMD_SHIFT = 4
protocol.CMD_MASK = 0xF0
protocol.DUP_MASK = 0x08
protocol.QOS_MASK = 0x03
protocol.QOS_SHIFT = 1
protocol.RETAIN_MASK = 0x01

/* Length */
protocol.VARBYTEINT_MASK = 0x7F
protocol.VARBYTEINT_FIN_MASK = 0x80
protocol.VARBYTEINT_MAX = 268435455

/* Connack */
protocol.SESSIONPRESENT_MASK = 0x01
protocol.SESSIONPRESENT_HEADER = Buffer.from([protocol.SESSIONPRESENT_MASK])
protocol.CONNACK_HEADER = Buffer.from([protocol.codes.connack << protocol.CMD_SHIFT])

/* Connect */
protocol.USERNAME_MASK = 0x80
protocol.PASSWORD_MASK = 0x40
protocol.WILL_RETAIN_MASK = 0x20
protocol.WILL_QOS_MASK = 0x18
protocol.WILL_QOS_SHIFT = 3
protocol.WILL_FLAG_MASK = 0x04
protocol.CLEAN_SESSION_MASK = 0x02
protocol.CONNECT_HEADER = Buffer.from([protocol.codes.connect << protocol.CMD_SHIFT])

/* Properties */
protocol.properties = {
  sessionExpiryInterval: 17,
  willDelayInterval: 24,
  receiveMaximum: 33,
  maximumPacketSize: 39,
  topicAliasMaximum: 34,
  requestResponseInformation: 25,
  requestProblemInformation: 23,
  userProperties: 38,
  authenticationMethod: 21,
  authenticationData: 22,
  payloadFormatIndicator: 1,
  messageExpiryInterval: 2,
  contentType: 3,
  responseTopic: 8,
  correlationData: 9,
  maximumQoS: 36,
  retainAvailable: 37,
  assignedClientIdentifier: 18,
  reasonString: 31,
  wildcardSubscriptionAvailable: 40,
  subscriptionIdentifiersAvailable: 41,
  sharedSubscriptionAvailable: 42,
  serverKeepAlive: 19,
  responseInformation: 26,
  serverReference: 28,
  topicAlias: 35,
  subscriptionIdentifier: 11
}
protocol.propertiesCodes = {}
for (const prop in protocol.properties) {
  const id = protocol.properties[prop]
  protocol.propertiesCodes[id] = prop
}
protocol.propertiesTypes = {
  sessionExpiryInterval: 'int32',
  willDelayInterval: 'int32',
  receiveMaximum: 'int16',
  maximumPacketSize: 'int32',
  topicAliasMaximum: 'int16',
  requestResponseInformation: 'byte',
  requestProblemInformation: 'byte',
  userProperties: 'pair',
  authenticationMethod: 'string',
  authenticationData: 'binary',
  payloadFormatIndicator: 'byte',
  messageExpiryInterval: 'int32',
  contentType: 'string',
  responseTopic: 'string',
  correlationData: 'binary',
  maximumQoS: 'int8',
  retainAvailable: 'byte',
  assignedClientIdentifier: 'string',
  reasonString: 'string',
  wildcardSubscriptionAvailable: 'byte',
  subscriptionIdentifiersAvailable: 'byte',
  sharedSubscriptionAvailable: 'byte',
  serverKeepAlive: 'int16',
  responseInformation: 'string',
  serverReference: 'string',
  topicAlias: 'int16',
  subscriptionIdentifier: 'var'
}

function genHeader (type) {
  return [0, 1, 2].map(qos => {
    return [0, 1].map(dup => {
      return [0, 1].map(retain => {
        const buf = Buffer.alloc(1)
        buf.writeUInt8(
          protocol.codes[type] << protocol.CMD_SHIFT |
          (dup ? protocol.DUP_MASK : 0) |
          qos << protocol.QOS_SHIFT | retain, 0, true)
        return buf
      })
    })
  })
}

/* Publish */
protocol.PUBLISH_HEADER = genHeader('publish')

/* Subscribe */
protocol.SUBSCRIBE_HEADER = genHeader('subscribe')
protocol.SUBSCRIBE_OPTIONS_QOS_MASK = 0x03
protocol.SUBSCRIBE_OPTIONS_NL_MASK = 0x01
protocol.SUBSCRIBE_OPTIONS_NL_SHIFT = 2
protocol.SUBSCRIBE_OPTIONS_RAP_MASK = 0x01
protocol.SUBSCRIBE_OPTIONS_RAP_SHIFT = 3
protocol.SUBSCRIBE_OPTIONS_RH_MASK = 0x03
protocol.SUBSCRIBE_OPTIONS_RH_SHIFT = 4
protocol.SUBSCRIBE_OPTIONS_RH = [0x00, 0x10, 0x20]
protocol.SUBSCRIBE_OPTIONS_NL = 0x04
protocol.SUBSCRIBE_OPTIONS_RAP = 0x08
protocol.SUBSCRIBE_OPTIONS_QOS = [0x00, 0x01, 0x02]

/* Unsubscribe */
protocol.UNSUBSCRIBE_HEADER = genHeader('unsubscribe')

/* Confirmations */
protocol.ACKS = {
  unsuback: genHeader('unsuback'),
  puback: genHeader('puback'),
  pubcomp: genHeader('pubcomp'),
  pubrel: genHeader('pubrel'),
  pubrec: genHeader('pubrec')
}

protocol.SUBACK_HEADER = Buffer.from([protocol.codes.suback << protocol.CMD_SHIFT])

/* Protocol versions */
protocol.VERSION3 = Buffer.from([3])
protocol.VERSION4 = Buffer.from([4])
protocol.VERSION5 = Buffer.from([5])
protocol.VERSION131 = Buffer.from([131])
protocol.VERSION132 = Buffer.from([132])

/* QoS */
protocol.QOS = [0, 1, 2].map(qos => {
  return Buffer.from([qos])
})

/* Empty packets */
protocol.EMPTY = {
  pingreq: Buffer.from([protocol.codes.pingreq << 4, 0]),
  pingresp: Buffer.from([protocol.codes.pingresp << 4, 0]),
  disconnect: Buffer.from([protocol.codes.disconnect << 4, 0])
}


/***/ }),

/***/ 9756:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const writeToStream = __nccwpck_require__(457)
const EventEmitter = __nccwpck_require__(8614)

function generate (packet, opts) {
  const stream = new Accumulator()
  writeToStream(packet, stream, opts)
  return stream.concat()
}

class Accumulator extends EventEmitter {
  constructor () {
    super()
    this._array = new Array(20)
    this._i = 0
  }

  write (chunk) {
    this._array[this._i++] = chunk
    return true
  }

  concat () {
    let length = 0
    const lengths = new Array(this._array.length)
    const list = this._array
    let pos = 0
    let i

    for (i = 0; i < list.length && list[i] !== undefined; i++) {
      if (typeof list[i] !== 'string') lengths[i] = list[i].length
      else lengths[i] = Buffer.byteLength(list[i])

      length += lengths[i]
    }

    const result = Buffer.allocUnsafe(length)

    for (i = 0; i < list.length && list[i] !== undefined; i++) {
      if (typeof list[i] !== 'string') {
        list[i].copy(result, pos)
        pos += lengths[i]
      } else {
        result.write(list[i], pos)
        pos += lengths[i]
      }
    }

    return result
  }
}

module.exports = generate


/***/ }),

/***/ 9433:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

exports.parser = __nccwpck_require__(4448).parser
exports.generate = __nccwpck_require__(9756)
exports.writeToStream = __nccwpck_require__(457)


/***/ }),

/***/ 8927:
/***/ ((module) => {

const max = 65536
const cache = {}

// in node 6 Buffer.subarray returns a Uint8Array instead of a Buffer
// later versions return a Buffer
// alternative is Buffer.slice but that creates a new buffer
// creating new buffers takes time
// SubOk is only false on node < 8
const SubOk = Buffer.isBuffer(Buffer.from([1, 2]).subarray(0, 1))

function generateBuffer (i) {
  const buffer = Buffer.allocUnsafe(2)
  buffer.writeUInt8(i >> 8, 0)
  buffer.writeUInt8(i & 0x00FF, 0 + 1)

  return buffer
}

function generateCache () {
  for (let i = 0; i < max; i++) {
    cache[i] = generateBuffer(i)
  }
}

function genBufVariableByteInt (num) {
  const maxLength = 4 // max 4 bytes
  let digit = 0
  let pos = 0
  const buffer = Buffer.allocUnsafe(maxLength)

  do {
    digit = num % 128 | 0
    num = num / 128 | 0
    if (num > 0) digit = digit | 0x80

    buffer.writeUInt8(digit, pos++)
  } while (num > 0 && pos < maxLength)

  if (num > 0) {
    pos = 0
  }

  return SubOk ? buffer.subarray(0, pos) : buffer.slice(0, pos)
}

function generate4ByteBuffer (num) {
  const buffer = Buffer.allocUnsafe(4)
  buffer.writeUInt32BE(num, 0)
  return buffer
}

module.exports = {
  cache,
  generateCache,
  generateNumber: generateBuffer,
  genBufVariableByteInt,
  generate4ByteBuffer
}


/***/ }),

/***/ 9171:
/***/ ((module) => {

class Packet {
  constructor () {
    this.cmd = null
    this.retain = false
    this.qos = 0
    this.dup = false
    this.length = -1
    this.topic = null
    this.payload = null
  }
}

module.exports = Packet


/***/ }),

/***/ 4448:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const bl = __nccwpck_require__(5075)
const EventEmitter = __nccwpck_require__(8614)
const Packet = __nccwpck_require__(9171)
const constants = __nccwpck_require__(4487)
const debug = __nccwpck_require__(7984)('mqtt-packet:parser')

class Parser extends EventEmitter {
  constructor () {
    super()
    this.parser = this.constructor.parser
  }

  static parser (opt) {
    if (!(this instanceof Parser)) return (new Parser()).parser(opt)

    this.settings = opt || {}

    this._states = [
      '_parseHeader',
      '_parseLength',
      '_parsePayload',
      '_newPacket'
    ]

    this._resetState()
    return this
  }

  _resetState () {
    debug('_resetState: resetting packet, error, _list, and _stateCounter')
    this.packet = new Packet()
    this.error = null
    this._list = bl()
    this._stateCounter = 0
  }

  parse (buf) {
    if (this.error) this._resetState()

    this._list.append(buf)
    debug('parse: current state: %s', this._states[this._stateCounter])
    while ((this.packet.length !== -1 || this._list.length > 0) &&
      this[this._states[this._stateCounter]]() &&
      !this.error) {
      this._stateCounter++
      debug('parse: state complete. _stateCounter is now: %d', this._stateCounter)
      debug('parse: packet.length: %d, buffer list length: %d', this.packet.length, this._list.length)
      if (this._stateCounter >= this._states.length) this._stateCounter = 0
    }
    debug('parse: exited while loop. packet: %d, buffer list length: %d', this.packet.length, this._list.length)
    return this._list.length
  }

  _parseHeader () {
    // There is at least one byte in the buffer
    const zero = this._list.readUInt8(0)
    this.packet.cmd = constants.types[zero >> constants.CMD_SHIFT]
    this.packet.retain = (zero & constants.RETAIN_MASK) !== 0
    this.packet.qos = (zero >> constants.QOS_SHIFT) & constants.QOS_MASK
    this.packet.dup = (zero & constants.DUP_MASK) !== 0
    debug('_parseHeader: packet: %o', this.packet)

    this._list.consume(1)

    return true
  }

  _parseLength () {
    // There is at least one byte in the list
    const result = this._parseVarByteNum(true)

    if (result) {
      this.packet.length = result.value
      this._list.consume(result.bytes)
    }
    debug('_parseLength %d', result.value)
    return !!result
  }

  _parsePayload () {
    debug('_parsePayload: payload %O', this._list)
    let result = false

    // Do we have a payload? Do we have enough data to complete the payload?
    // PINGs have no payload
    if (this.packet.length === 0 || this._list.length >= this.packet.length) {
      this._pos = 0

      switch (this.packet.cmd) {
        case 'connect':
          this._parseConnect()
          break
        case 'connack':
          this._parseConnack()
          break
        case 'publish':
          this._parsePublish()
          break
        case 'puback':
        case 'pubrec':
        case 'pubrel':
        case 'pubcomp':
          this._parseConfirmation()
          break
        case 'subscribe':
          this._parseSubscribe()
          break
        case 'suback':
          this._parseSuback()
          break
        case 'unsubscribe':
          this._parseUnsubscribe()
          break
        case 'unsuback':
          this._parseUnsuback()
          break
        case 'pingreq':
        case 'pingresp':
          // These are empty, nothing to do
          break
        case 'disconnect':
          this._parseDisconnect()
          break
        case 'auth':
          this._parseAuth()
          break
        default:
          this._emitError(new Error('Not supported'))
      }

      result = true
    }
    debug('_parsePayload complete result: %s', result)
    return result
  }

  _parseConnect () {
    debug('_parseConnect')
    let topic // Will topic
    let payload // Will payload
    let password // Password
    let username // Username
    const flags = {}
    const packet = this.packet

    // Parse protocolId
    const protocolId = this._parseString()

    if (protocolId === null) return this._emitError(new Error('Cannot parse protocolId'))
    if (protocolId !== 'MQTT' && protocolId !== 'MQIsdp') {
      return this._emitError(new Error('Invalid protocolId'))
    }

    packet.protocolId = protocolId

    // Parse constants version number
    if (this._pos >= this._list.length) return this._emitError(new Error('Packet too short'))

    packet.protocolVersion = this._list.readUInt8(this._pos)

    if (packet.protocolVersion >= 128) {
      packet.bridgeMode = true
      packet.protocolVersion = packet.protocolVersion - 128
    }

    if (packet.protocolVersion !== 3 && packet.protocolVersion !== 4 && packet.protocolVersion !== 5) {
      return this._emitError(new Error('Invalid protocol version'))
    }

    this._pos++

    if (this._pos >= this._list.length) {
      return this._emitError(new Error('Packet too short'))
    }

    // Parse connect flags
    flags.username = (this._list.readUInt8(this._pos) & constants.USERNAME_MASK)
    flags.password = (this._list.readUInt8(this._pos) & constants.PASSWORD_MASK)
    flags.will = (this._list.readUInt8(this._pos) & constants.WILL_FLAG_MASK)

    if (flags.will) {
      packet.will = {}
      packet.will.retain = (this._list.readUInt8(this._pos) & constants.WILL_RETAIN_MASK) !== 0
      packet.will.qos = (this._list.readUInt8(this._pos) &
        constants.WILL_QOS_MASK) >> constants.WILL_QOS_SHIFT
    }

    packet.clean = (this._list.readUInt8(this._pos) & constants.CLEAN_SESSION_MASK) !== 0
    this._pos++

    // Parse keepalive
    packet.keepalive = this._parseNum()
    if (packet.keepalive === -1) return this._emitError(new Error('Packet too short'))

    // parse properties
    if (packet.protocolVersion === 5) {
      const properties = this._parseProperties()
      if (Object.getOwnPropertyNames(properties).length) {
        packet.properties = properties
      }
    }
    // Parse clientId
    const clientId = this._parseString()
    if (clientId === null) return this._emitError(new Error('Packet too short'))
    packet.clientId = clientId
    debug('_parseConnect: packet.clientId: %s', packet.clientId)

    if (flags.will) {
      if (packet.protocolVersion === 5) {
        const willProperties = this._parseProperties()
        if (Object.getOwnPropertyNames(willProperties).length) {
          packet.will.properties = willProperties
        }
      }
      // Parse will topic
      topic = this._parseString()
      if (topic === null) return this._emitError(new Error('Cannot parse will topic'))
      packet.will.topic = topic
      debug('_parseConnect: packet.will.topic: %s', packet.will.topic)

      // Parse will payload
      payload = this._parseBuffer()
      if (payload === null) return this._emitError(new Error('Cannot parse will payload'))
      packet.will.payload = payload
      debug('_parseConnect: packet.will.paylaod: %s', packet.will.payload)
    }

    // Parse username
    if (flags.username) {
      username = this._parseString()
      if (username === null) return this._emitError(new Error('Cannot parse username'))
      packet.username = username
      debug('_parseConnect: packet.username: %s', packet.username)
    }

    // Parse password
    if (flags.password) {
      password = this._parseBuffer()
      if (password === null) return this._emitError(new Error('Cannot parse password'))
      packet.password = password
    }
    // need for right parse auth packet and self set up
    this.settings = packet
    debug('_parseConnect: complete')
    return packet
  }

  _parseConnack () {
    debug('_parseConnack')
    const packet = this.packet

    if (this._list.length < 1) return null
    packet.sessionPresent = !!(this._list.readUInt8(this._pos++) & constants.SESSIONPRESENT_MASK)

    if (this.settings.protocolVersion === 5) {
      if (this._list.length >= 2) {
        packet.reasonCode = this._list.readUInt8(this._pos++)
      } else {
        packet.reasonCode = 0
      }
    } else {
      if (this._list.length < 2) return null
      packet.returnCode = this._list.readUInt8(this._pos++)
    }

    if (packet.returnCode === -1 || packet.reasonCode === -1) return this._emitError(new Error('Cannot parse return code'))
    // mqtt 5 properties
    if (this.settings.protocolVersion === 5) {
      const properties = this._parseProperties()
      if (Object.getOwnPropertyNames(properties).length) {
        packet.properties = properties
      }
    }
    debug('_parseConnack: complete')
  }

  _parsePublish () {
    debug('_parsePublish')
    const packet = this.packet
    packet.topic = this._parseString()

    if (packet.topic === null) return this._emitError(new Error('Cannot parse topic'))

    // Parse messageId
    if (packet.qos > 0) if (!this._parseMessageId()) { return }

    // Properties mqtt 5
    if (this.settings.protocolVersion === 5) {
      const properties = this._parseProperties()
      if (Object.getOwnPropertyNames(properties).length) {
        packet.properties = properties
      }
    }

    packet.payload = this._list.slice(this._pos, packet.length)
    debug('_parsePublish: payload from buffer list: %o', packet.payload)
  }

  _parseSubscribe () {
    debug('_parseSubscribe')
    const packet = this.packet
    let topic
    let options
    let qos
    let rh
    let rap
    let nl
    let subscription

    if (packet.qos !== 1) {
      return this._emitError(new Error('Wrong subscribe header'))
    }

    packet.subscriptions = []

    if (!this._parseMessageId()) { return }

    // Properties mqtt 5
    if (this.settings.protocolVersion === 5) {
      const properties = this._parseProperties()
      if (Object.getOwnPropertyNames(properties).length) {
        packet.properties = properties
      }
    }

    while (this._pos < packet.length) {
      // Parse topic
      topic = this._parseString()
      if (topic === null) return this._emitError(new Error('Cannot parse topic'))
      if (this._pos >= packet.length) return this._emitError(new Error('Malformed Subscribe Payload'))

      options = this._parseByte()
      qos = options & constants.SUBSCRIBE_OPTIONS_QOS_MASK
      nl = ((options >> constants.SUBSCRIBE_OPTIONS_NL_SHIFT) & constants.SUBSCRIBE_OPTIONS_NL_MASK) !== 0
      rap = ((options >> constants.SUBSCRIBE_OPTIONS_RAP_SHIFT) & constants.SUBSCRIBE_OPTIONS_RAP_MASK) !== 0
      rh = (options >> constants.SUBSCRIBE_OPTIONS_RH_SHIFT) & constants.SUBSCRIBE_OPTIONS_RH_MASK

      subscription = { topic, qos }

      // mqtt 5 options
      if (this.settings.protocolVersion === 5) {
        subscription.nl = nl
        subscription.rap = rap
        subscription.rh = rh
      } else if (this.settings.bridgeMode) {
        subscription.rh = 0
        subscription.rap = true
        subscription.nl = true
      }

      // Push pair to subscriptions
      debug('_parseSubscribe: push subscription `%s` to subscription', subscription)
      packet.subscriptions.push(subscription)
    }
  }

  _parseSuback () {
    debug('_parseSuback')
    const packet = this.packet
    this.packet.granted = []

    if (!this._parseMessageId()) { return }

    // Properties mqtt 5
    if (this.settings.protocolVersion === 5) {
      const properties = this._parseProperties()
      if (Object.getOwnPropertyNames(properties).length) {
        packet.properties = properties
      }
    }

    // Parse granted QoSes
    while (this._pos < this.packet.length) {
      this.packet.granted.push(this._list.readUInt8(this._pos++))
    }
  }

  _parseUnsubscribe () {
    debug('_parseUnsubscribe')
    const packet = this.packet

    packet.unsubscriptions = []

    // Parse messageId
    if (!this._parseMessageId()) { return }

    // Properties mqtt 5
    if (this.settings.protocolVersion === 5) {
      const properties = this._parseProperties()
      if (Object.getOwnPropertyNames(properties).length) {
        packet.properties = properties
      }
    }

    while (this._pos < packet.length) {
      // Parse topic
      const topic = this._parseString()
      if (topic === null) return this._emitError(new Error('Cannot parse topic'))

      // Push topic to unsubscriptions
      debug('_parseUnsubscribe: push topic `%s` to unsubscriptions', topic)
      packet.unsubscriptions.push(topic)
    }
  }

  _parseUnsuback () {
    debug('_parseUnsuback')
    const packet = this.packet
    if (!this._parseMessageId()) return this._emitError(new Error('Cannot parse messageId'))
    // Properties mqtt 5
    if (this.settings.protocolVersion === 5) {
      const properties = this._parseProperties()
      if (Object.getOwnPropertyNames(properties).length) {
        packet.properties = properties
      }
      // Parse granted QoSes
      packet.granted = []
      while (this._pos < this.packet.length) {
        this.packet.granted.push(this._list.readUInt8(this._pos++))
      }
    }
  }

  // parse packets like puback, pubrec, pubrel, pubcomp
  _parseConfirmation () {
    debug('_parseConfirmation: packet.cmd: `%s`', this.packet.cmd)
    const packet = this.packet

    this._parseMessageId()

    if (this.settings.protocolVersion === 5) {
      if (packet.length > 2) {
        // response code
        packet.reasonCode = this._parseByte()
        debug('_parseConfirmation: packet.reasonCode `%d`', packet.reasonCode)
      } else {
        packet.reasonCode = 0
      }

      if (packet.length > 3) {
        // properies mqtt 5
        const properties = this._parseProperties()
        if (Object.getOwnPropertyNames(properties).length) {
          packet.properties = properties
        }
      }
    }

    return true
  }

  // parse disconnect packet
  _parseDisconnect () {
    const packet = this.packet
    debug('_parseDisconnect')

    if (this.settings.protocolVersion === 5) {
      // response code
      if (this._list.length > 0) {
        packet.reasonCode = this._parseByte()
      } else {
        packet.reasonCode = 0
      }
      // properies mqtt 5
      const properties = this._parseProperties()
      if (Object.getOwnPropertyNames(properties).length) {
        packet.properties = properties
      }
    }

    debug('_parseDisconnect result: true')
    return true
  }

  // parse auth packet
  _parseAuth () {
    debug('_parseAuth')
    const packet = this.packet

    if (this.settings.protocolVersion !== 5) {
      return this._emitError(new Error('Not supported auth packet for this version MQTT'))
    }

    // response code
    packet.reasonCode = this._parseByte()
    // properies mqtt 5
    const properties = this._parseProperties()
    if (Object.getOwnPropertyNames(properties).length) {
      packet.properties = properties
    }

    debug('_parseAuth: result: true')
    return true
  }

  _parseMessageId () {
    const packet = this.packet

    packet.messageId = this._parseNum()

    if (packet.messageId === null) {
      this._emitError(new Error('Cannot parse messageId'))
      return false
    }

    debug('_parseMessageId: packet.messageId %d', packet.messageId)
    return true
  }

  _parseString (maybeBuffer) {
    const length = this._parseNum()
    const end = length + this._pos

    if (length === -1 || end > this._list.length || end > this.packet.length) return null

    const result = this._list.toString('utf8', this._pos, end)
    this._pos += length
    debug('_parseString: result: %s', result)
    return result
  }

  _parseStringPair () {
    debug('_parseStringPair')
    return {
      name: this._parseString(),
      value: this._parseString()
    }
  }

  _parseBuffer () {
    const length = this._parseNum()
    const end = length + this._pos

    if (length === -1 || end > this._list.length || end > this.packet.length) return null

    const result = this._list.slice(this._pos, end)

    this._pos += length
    debug('_parseBuffer: result: %o', result)
    return result
  }

  _parseNum () {
    if (this._list.length - this._pos < 2) return -1

    const result = this._list.readUInt16BE(this._pos)
    this._pos += 2
    debug('_parseNum: result: %s', result)
    return result
  }

  _parse4ByteNum () {
    if (this._list.length - this._pos < 4) return -1

    const result = this._list.readUInt32BE(this._pos)
    this._pos += 4
    debug('_parse4ByteNum: result: %s', result)
    return result
  }

  _parseVarByteNum (fullInfoFlag) {
    debug('_parseVarByteNum')
    const maxBytes = 4
    let bytes = 0
    let mul = 1
    let value = 0
    let result = false
    let current
    const padding = this._pos ? this._pos : 0

    while (bytes < maxBytes && (padding + bytes) < this._list.length) {
      current = this._list.readUInt8(padding + bytes++)
      value += mul * (current & constants.VARBYTEINT_MASK)
      mul *= 0x80

      if ((current & constants.VARBYTEINT_FIN_MASK) === 0) {
        result = true
        break
      }
      if (this._list.length <= bytes) {
        break
      }
    }

    if (!result && bytes === maxBytes && this._list.length >= bytes) {
      this._emitError(new Error('Invalid variable byte integer'))
    }

    if (padding) {
      this._pos += bytes
    }

    result = result
      ? fullInfoFlag ? {
        bytes,
        value
      } : value
      : false

    debug('_parseVarByteNum: result: %o', result)
    return result
  }

  _parseByte () {
    const result = this._list.readUInt8(this._pos)
    this._pos++
    debug('_parseByte: result: %o', result)
    return result
  }

  _parseByType (type) {
    debug('_parseByType: type: %s', type)
    switch (type) {
      case 'byte': {
        return this._parseByte() !== 0
      }
      case 'int8': {
        return this._parseByte()
      }
      case 'int16': {
        return this._parseNum()
      }
      case 'int32': {
        return this._parse4ByteNum()
      }
      case 'var': {
        return this._parseVarByteNum()
      }
      case 'string': {
        return this._parseString()
      }
      case 'pair': {
        return this._parseStringPair()
      }
      case 'binary': {
        return this._parseBuffer()
      }
    }
  }

  _parseProperties () {
    debug('_parseProperties')
    const length = this._parseVarByteNum()
    const start = this._pos
    const end = start + length
    const result = {}
    while (this._pos < end) {
      const type = this._parseByte()
      const name = constants.propertiesCodes[type]
      if (!name) {
        this._emitError(new Error('Unknown property'))
        return false
      }
      // user properties process
      if (name === 'userProperties') {
        if (!result[name]) {
          result[name] = Object.create(null)
        }
        const currentUserProperty = this._parseByType(constants.propertiesTypes[name])
        if (result[name][currentUserProperty.name]) {
          if (Array.isArray(result[name][currentUserProperty.name])) {
            result[name][currentUserProperty.name].push(currentUserProperty.value)
          } else {
            const currentValue = result[name][currentUserProperty.name]
            result[name][currentUserProperty.name] = [currentValue]
            result[name][currentUserProperty.name].push(currentUserProperty.value)
          }
        } else {
          result[name][currentUserProperty.name] = currentUserProperty.value
        }
        continue
      }
      if (result[name]) {
        if (Array.isArray(result[name])) {
          result[name].push(this._parseByType(constants.propertiesTypes[name]))
        } else {
          result[name] = [result[name]]
          result[name].push(this._parseByType(constants.propertiesTypes[name]))
        }
      } else {
        result[name] = this._parseByType(constants.propertiesTypes[name])
      }
    }
    return result
  }

  _newPacket () {
    debug('_newPacket')
    if (this.packet) {
      this._list.consume(this.packet.length)
      debug('_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d', this.packet.cmd, this.packet.payload, this.packet.length)
      this.emit('packet', this.packet)
    }
    debug('_newPacket: new packet')
    this.packet = new Packet()

    this._pos = 0

    return true
  }

  _emitError (err) {
    debug('_emitError')
    this.error = err
    this.emit('error', err)
  }
}

module.exports = Parser


/***/ }),

/***/ 457:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const protocol = __nccwpck_require__(4487)
const empty = Buffer.allocUnsafe(0)
const zeroBuf = Buffer.from([0])
const numbers = __nccwpck_require__(8927)
const nextTick = __nccwpck_require__(7843).nextTick
const debug = __nccwpck_require__(7984)('mqtt-packet:writeToStream')

const numCache = numbers.cache
const generateNumber = numbers.generateNumber
const generateCache = numbers.generateCache
const genBufVariableByteInt = numbers.genBufVariableByteInt
const generate4ByteBuffer = numbers.generate4ByteBuffer
let writeNumber = writeNumberCached
let toGenerate = true

function generate (packet, stream, opts) {
  debug('generate called')
  if (stream.cork) {
    stream.cork()
    nextTick(uncork, stream)
  }

  if (toGenerate) {
    toGenerate = false
    generateCache()
  }
  debug('generate: packet.cmd: %s', packet.cmd)
  switch (packet.cmd) {
    case 'connect':
      return connect(packet, stream, opts)
    case 'connack':
      return connack(packet, stream, opts)
    case 'publish':
      return publish(packet, stream, opts)
    case 'puback':
    case 'pubrec':
    case 'pubrel':
    case 'pubcomp':
      return confirmation(packet, stream, opts)
    case 'subscribe':
      return subscribe(packet, stream, opts)
    case 'suback':
      return suback(packet, stream, opts)
    case 'unsubscribe':
      return unsubscribe(packet, stream, opts)
    case 'unsuback':
      return unsuback(packet, stream, opts)
    case 'pingreq':
    case 'pingresp':
      return emptyPacket(packet, stream, opts)
    case 'disconnect':
      return disconnect(packet, stream, opts)
    case 'auth':
      return auth(packet, stream, opts)
    default:
      stream.emit('error', new Error('Unknown command'))
      return false
  }
}
/**
 * Controls numbers cache.
 * Set to "false" to allocate buffers on-the-flight instead of pre-generated cache
 */
Object.defineProperty(generate, 'cacheNumbers', {
  get () {
    return writeNumber === writeNumberCached
  },
  set (value) {
    if (value) {
      if (!numCache || Object.keys(numCache).length === 0) toGenerate = true
      writeNumber = writeNumberCached
    } else {
      toGenerate = false
      writeNumber = writeNumberGenerated
    }
  }
})

function uncork (stream) {
  stream.uncork()
}

function connect (packet, stream, opts) {
  const settings = packet || {}
  const protocolId = settings.protocolId || 'MQTT'
  let protocolVersion = settings.protocolVersion || 4
  const will = settings.will
  let clean = settings.clean
  const keepalive = settings.keepalive || 0
  const clientId = settings.clientId || ''
  const username = settings.username
  const password = settings.password
  /* mqtt5 new oprions */
  const properties = settings.properties

  if (clean === undefined) clean = true

  let length = 0

  // Must be a string and non-falsy
  if (!protocolId ||
     (typeof protocolId !== 'string' && !Buffer.isBuffer(protocolId))) {
    stream.emit('error', new Error('Invalid protocolId'))
    return false
  } else length += protocolId.length + 2

  // Must be 3 or 4 or 5
  if (protocolVersion !== 3 && protocolVersion !== 4 && protocolVersion !== 5) {
    stream.emit('error', new Error('Invalid protocol version'))
    return false
  } else length += 1

  // ClientId might be omitted in 3.1.1 and 5, but only if cleanSession is set to 1
  if ((typeof clientId === 'string' || Buffer.isBuffer(clientId)) &&
     (clientId || protocolVersion >= 4) && (clientId || clean)) {
    length += Buffer.byteLength(clientId) + 2
  } else {
    if (protocolVersion < 4) {
      stream.emit('error', new Error('clientId must be supplied before 3.1.1'))
      return false
    }
    if ((clean * 1) === 0) {
      stream.emit('error', new Error('clientId must be given if cleanSession set to 0'))
      return false
    }
  }

  // Must be a two byte number
  if (typeof keepalive !== 'number' ||
      keepalive < 0 ||
      keepalive > 65535 ||
      keepalive % 1 !== 0) {
    stream.emit('error', new Error('Invalid keepalive'))
    return false
  } else length += 2

  // Connect flags
  length += 1

  // Properties
  if (protocolVersion === 5) {
    var propertiesData = getProperties(stream, properties)
    if (!propertiesData) { return false }
    length += propertiesData.length
  }

  // If will exists...
  if (will) {
    // It must be an object
    if (typeof will !== 'object') {
      stream.emit('error', new Error('Invalid will'))
      return false
    }
    // It must have topic typeof string
    if (!will.topic || typeof will.topic !== 'string') {
      stream.emit('error', new Error('Invalid will topic'))
      return false
    } else {
      length += Buffer.byteLength(will.topic) + 2
    }

    // Payload
    length += 2 // payload length
    if (will.payload) {
      if (will.payload.length >= 0) {
        if (typeof will.payload === 'string') {
          length += Buffer.byteLength(will.payload)
        } else {
          length += will.payload.length
        }
      } else {
        stream.emit('error', new Error('Invalid will payload'))
        return false
      }
    }
    // will properties
    var willProperties = {}
    if (protocolVersion === 5) {
      willProperties = getProperties(stream, will.properties)
      if (!willProperties) { return false }
      length += willProperties.length
    }
  }

  // Username
  let providedUsername = false
  if (username != null) {
    if (isStringOrBuffer(username)) {
      providedUsername = true
      length += Buffer.byteLength(username) + 2
    } else {
      stream.emit('error', new Error('Invalid username'))
      return false
    }
  }

  // Password
  if (password != null) {
    if (!providedUsername) {
      stream.emit('error', new Error('Username is required to use password'))
      return false
    }

    if (isStringOrBuffer(password)) {
      length += byteLength(password) + 2
    } else {
      stream.emit('error', new Error('Invalid password'))
      return false
    }
  }

  // Generate header
  stream.write(protocol.CONNECT_HEADER)

  // Generate length
  writeVarByteInt(stream, length)

  // Generate protocol ID
  writeStringOrBuffer(stream, protocolId)

  if (settings.bridgeMode) {
    protocolVersion += 128
  }

  stream.write(
    protocolVersion === 131
      ? protocol.VERSION131
      : protocolVersion === 132
        ? protocol.VERSION132
        : protocolVersion === 4
          ? protocol.VERSION4
          : protocolVersion === 5
            ? protocol.VERSION5
            : protocol.VERSION3
  )

  // Connect flags
  let flags = 0
  flags |= (username != null) ? protocol.USERNAME_MASK : 0
  flags |= (password != null) ? protocol.PASSWORD_MASK : 0
  flags |= (will && will.retain) ? protocol.WILL_RETAIN_MASK : 0
  flags |= (will && will.qos) ? will.qos << protocol.WILL_QOS_SHIFT : 0
  flags |= will ? protocol.WILL_FLAG_MASK : 0
  flags |= clean ? protocol.CLEAN_SESSION_MASK : 0

  stream.write(Buffer.from([flags]))

  // Keepalive
  writeNumber(stream, keepalive)

  // Properties
  if (protocolVersion === 5) {
    propertiesData.write()
  }

  // Client ID
  writeStringOrBuffer(stream, clientId)

  // Will
  if (will) {
    if (protocolVersion === 5) {
      willProperties.write()
    }
    writeString(stream, will.topic)
    writeStringOrBuffer(stream, will.payload)
  }

  // Username and password
  if (username != null) {
    writeStringOrBuffer(stream, username)
  }
  if (password != null) {
    writeStringOrBuffer(stream, password)
  }
  // This is a small packet that happens only once on a stream
  // We assume the stream is always free to receive more data after this
  return true
}

function connack (packet, stream, opts) {
  const version = opts ? opts.protocolVersion : 4
  const settings = packet || {}
  const rc = version === 5 ? settings.reasonCode : settings.returnCode
  const properties = settings.properties
  let length = 2 // length of rc and sessionHeader

  // Check return code
  if (typeof rc !== 'number') {
    stream.emit('error', new Error('Invalid return code'))
    return false
  }
  // mqtt5 properties
  let propertiesData = null
  if (version === 5) {
    propertiesData = getProperties(stream, properties)
    if (!propertiesData) { return false }
    length += propertiesData.length
  }

  stream.write(protocol.CONNACK_HEADER)
  // length
  writeVarByteInt(stream, length)
  stream.write(settings.sessionPresent ? protocol.SESSIONPRESENT_HEADER : zeroBuf)

  stream.write(Buffer.from([rc]))
  if (propertiesData != null) {
    propertiesData.write()
  }
  return true
}

function publish (packet, stream, opts) {
  debug('publish: packet: %o', packet)
  const version = opts ? opts.protocolVersion : 4
  const settings = packet || {}
  const qos = settings.qos || 0
  const retain = settings.retain ? protocol.RETAIN_MASK : 0
  const topic = settings.topic
  const payload = settings.payload || empty
  const id = settings.messageId
  const properties = settings.properties

  let length = 0

  // Topic must be a non-empty string or Buffer
  if (typeof topic === 'string') length += Buffer.byteLength(topic) + 2
  else if (Buffer.isBuffer(topic)) length += topic.length + 2
  else {
    stream.emit('error', new Error('Invalid topic'))
    return false
  }

  // Get the payload length
  if (!Buffer.isBuffer(payload)) length += Buffer.byteLength(payload)
  else length += payload.length

  // Message ID must a number if qos > 0
  if (qos && typeof id !== 'number') {
    stream.emit('error', new Error('Invalid messageId'))
    return false
  } else if (qos) length += 2

  // mqtt5 properties
  let propertiesData = null
  if (version === 5) {
    propertiesData = getProperties(stream, properties)
    if (!propertiesData) { return false }
    length += propertiesData.length
  }

  // Header
  stream.write(protocol.PUBLISH_HEADER[qos][settings.dup ? 1 : 0][retain ? 1 : 0])

  // Remaining length
  writeVarByteInt(stream, length)

  // Topic
  writeNumber(stream, byteLength(topic))
  stream.write(topic)

  // Message ID
  if (qos > 0) writeNumber(stream, id)

  // Properties
  if (propertiesData != null) {
    propertiesData.write()
  }

  // Payload
  debug('publish: payload: %o', payload)
  return stream.write(payload)
}

/* Puback, pubrec, pubrel and pubcomp */
function confirmation (packet, stream, opts) {
  const version = opts ? opts.protocolVersion : 4
  const settings = packet || {}
  const type = settings.cmd || 'puback'
  const id = settings.messageId
  const dup = (settings.dup && type === 'pubrel') ? protocol.DUP_MASK : 0
  let qos = 0
  const reasonCode = settings.reasonCode
  const properties = settings.properties
  let length = version === 5 ? 3 : 2

  if (type === 'pubrel') qos = 1

  // Check message ID
  if (typeof id !== 'number') {
    stream.emit('error', new Error('Invalid messageId'))
    return false
  }

  // properies mqtt 5
  let propertiesData = null
  if (version === 5) {
    // Confirm should not add empty property length with no properties (rfc 3.4.2.2.1)
    if (typeof properties === 'object') {
      propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)
      if (!propertiesData) { return false }
      length += propertiesData.length
    }
  }

  // Header
  stream.write(protocol.ACKS[type][qos][dup][0])

  // Length
  writeVarByteInt(stream, length)

  // Message ID
  writeNumber(stream, id)

  // reason code in header
  if (version === 5) {
    stream.write(Buffer.from([reasonCode]))
  }

  // properies mqtt 5
  if (propertiesData !== null) {
    propertiesData.write()
  }
  return true
}

function subscribe (packet, stream, opts) {
  debug('subscribe: packet: ')
  const version = opts ? opts.protocolVersion : 4
  const settings = packet || {}
  const dup = settings.dup ? protocol.DUP_MASK : 0
  const id = settings.messageId
  const subs = settings.subscriptions
  const properties = settings.properties

  let length = 0

  // Check message ID
  if (typeof id !== 'number') {
    stream.emit('error', new Error('Invalid messageId'))
    return false
  } else length += 2

  // properies mqtt 5
  let propertiesData = null
  if (version === 5) {
    propertiesData = getProperties(stream, properties)
    if (!propertiesData) { return false }
    length += propertiesData.length
  }

  // Check subscriptions
  if (typeof subs === 'object' && subs.length) {
    for (let i = 0; i < subs.length; i += 1) {
      const itopic = subs[i].topic
      const iqos = subs[i].qos

      if (typeof itopic !== 'string') {
        stream.emit('error', new Error('Invalid subscriptions - invalid topic'))
        return false
      }
      if (typeof iqos !== 'number') {
        stream.emit('error', new Error('Invalid subscriptions - invalid qos'))
        return false
      }

      if (version === 5) {
        const nl = subs[i].nl || false
        if (typeof nl !== 'boolean') {
          stream.emit('error', new Error('Invalid subscriptions - invalid No Local'))
          return false
        }
        const rap = subs[i].rap || false
        if (typeof rap !== 'boolean') {
          stream.emit('error', new Error('Invalid subscriptions - invalid Retain as Published'))
          return false
        }
        const rh = subs[i].rh || 0
        if (typeof rh !== 'number' || rh > 2) {
          stream.emit('error', new Error('Invalid subscriptions - invalid Retain Handling'))
          return false
        }
      }

      length += Buffer.byteLength(itopic) + 2 + 1
    }
  } else {
    stream.emit('error', new Error('Invalid subscriptions'))
    return false
  }

  // Generate header
  debug('subscribe: writing to stream: %o', protocol.SUBSCRIBE_HEADER)
  stream.write(protocol.SUBSCRIBE_HEADER[1][dup ? 1 : 0][0])

  // Generate length
  writeVarByteInt(stream, length)

  // Generate message ID
  writeNumber(stream, id)

  // properies mqtt 5
  if (propertiesData !== null) {
    propertiesData.write()
  }

  let result = true

  // Generate subs
  for (const sub of subs) {
    const jtopic = sub.topic
    const jqos = sub.qos
    const jnl = +sub.nl
    const jrap = +sub.rap
    const jrh = sub.rh
    let joptions

    // Write topic string
    writeString(stream, jtopic)

    // options process
    joptions = protocol.SUBSCRIBE_OPTIONS_QOS[jqos]
    if (version === 5) {
      joptions |= jnl ? protocol.SUBSCRIBE_OPTIONS_NL : 0
      joptions |= jrap ? protocol.SUBSCRIBE_OPTIONS_RAP : 0
      joptions |= jrh ? protocol.SUBSCRIBE_OPTIONS_RH[jrh] : 0
    }
    // Write options
    result = stream.write(Buffer.from([joptions]))
  }

  return result
}

function suback (packet, stream, opts) {
  const version = opts ? opts.protocolVersion : 4
  const settings = packet || {}
  const id = settings.messageId
  const granted = settings.granted
  const properties = settings.properties
  let length = 0

  // Check message ID
  if (typeof id !== 'number') {
    stream.emit('error', new Error('Invalid messageId'))
    return false
  } else length += 2

  // Check granted qos vector
  if (typeof granted === 'object' && granted.length) {
    for (let i = 0; i < granted.length; i += 1) {
      if (typeof granted[i] !== 'number') {
        stream.emit('error', new Error('Invalid qos vector'))
        return false
      }
      length += 1
    }
  } else {
    stream.emit('error', new Error('Invalid qos vector'))
    return false
  }

  // properies mqtt 5
  let propertiesData = null
  if (version === 5) {
    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)
    if (!propertiesData) { return false }
    length += propertiesData.length
  }

  // header
  stream.write(protocol.SUBACK_HEADER)

  // Length
  writeVarByteInt(stream, length)

  // Message ID
  writeNumber(stream, id)

  // properies mqtt 5
  if (propertiesData !== null) {
    propertiesData.write()
  }

  return stream.write(Buffer.from(granted))
}

function unsubscribe (packet, stream, opts) {
  const version = opts ? opts.protocolVersion : 4
  const settings = packet || {}
  const id = settings.messageId
  const dup = settings.dup ? protocol.DUP_MASK : 0
  const unsubs = settings.unsubscriptions
  const properties = settings.properties

  let length = 0

  // Check message ID
  if (typeof id !== 'number') {
    stream.emit('error', new Error('Invalid messageId'))
    return false
  } else {
    length += 2
  }
  // Check unsubs
  if (typeof unsubs === 'object' && unsubs.length) {
    for (let i = 0; i < unsubs.length; i += 1) {
      if (typeof unsubs[i] !== 'string') {
        stream.emit('error', new Error('Invalid unsubscriptions'))
        return false
      }
      length += Buffer.byteLength(unsubs[i]) + 2
    }
  } else {
    stream.emit('error', new Error('Invalid unsubscriptions'))
    return false
  }
  // properies mqtt 5
  let propertiesData = null
  if (version === 5) {
    propertiesData = getProperties(stream, properties)
    if (!propertiesData) { return false }
    length += propertiesData.length
  }

  // Header
  stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup ? 1 : 0][0])

  // Length
  writeVarByteInt(stream, length)

  // Message ID
  writeNumber(stream, id)

  // properies mqtt 5
  if (propertiesData !== null) {
    propertiesData.write()
  }

  // Unsubs
  let result = true
  for (let j = 0; j < unsubs.length; j++) {
    result = writeString(stream, unsubs[j])
  }

  return result
}

function unsuback (packet, stream, opts) {
  const version = opts ? opts.protocolVersion : 4
  const settings = packet || {}
  const id = settings.messageId
  const dup = settings.dup ? protocol.DUP_MASK : 0
  const granted = settings.granted
  const properties = settings.properties
  const type = settings.cmd
  const qos = 0

  let length = 2

  // Check message ID
  if (typeof id !== 'number') {
    stream.emit('error', new Error('Invalid messageId'))
    return false
  }

  // Check granted
  if (version === 5) {
    if (typeof granted === 'object' && granted.length) {
      for (let i = 0; i < granted.length; i += 1) {
        if (typeof granted[i] !== 'number') {
          stream.emit('error', new Error('Invalid qos vector'))
          return false
        }
        length += 1
      }
    } else {
      stream.emit('error', new Error('Invalid qos vector'))
      return false
    }
  }

  // properies mqtt 5
  let propertiesData = null
  if (version === 5) {
    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)
    if (!propertiesData) { return false }
    length += propertiesData.length
  }

  // Header
  stream.write(protocol.ACKS[type][qos][dup][0])

  // Length
  writeVarByteInt(stream, length)

  // Message ID
  writeNumber(stream, id)

  // properies mqtt 5
  if (propertiesData !== null) {
    propertiesData.write()
  }

  // payload
  if (version === 5) {
    stream.write(Buffer.from(granted))
  }
  return true
}

function emptyPacket (packet, stream, opts) {
  return stream.write(protocol.EMPTY[packet.cmd])
}

function disconnect (packet, stream, opts) {
  const version = opts ? opts.protocolVersion : 4
  const settings = packet || {}
  const reasonCode = settings.reasonCode
  const properties = settings.properties
  let length = version === 5 ? 1 : 0

  // properies mqtt 5
  let propertiesData = null
  if (version === 5) {
    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)
    if (!propertiesData) { return false }
    length += propertiesData.length
  }

  // Header
  stream.write(Buffer.from([protocol.codes.disconnect << 4]))

  // Length
  writeVarByteInt(stream, length)

  // reason code in header
  if (version === 5) {
    stream.write(Buffer.from([reasonCode]))
  }

  // properies mqtt 5
  if (propertiesData !== null) {
    propertiesData.write()
  }

  return true
}

function auth (packet, stream, opts) {
  const version = opts ? opts.protocolVersion : 4
  const settings = packet || {}
  const reasonCode = settings.reasonCode
  const properties = settings.properties
  let length = version === 5 ? 1 : 0

  if (version !== 5) stream.emit('error', new Error('Invalid mqtt version for auth packet'))

  // properies mqtt 5
  const propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)
  if (!propertiesData) { return false }
  length += propertiesData.length

  // Header
  stream.write(Buffer.from([protocol.codes.auth << 4]))

  // Length
  writeVarByteInt(stream, length)

  // reason code in header
  stream.write(Buffer.from([reasonCode]))

  // properies mqtt 5
  if (propertiesData !== null) {
    propertiesData.write()
  }
  return true
}

/**
 * writeVarByteInt - write an MQTT style variable byte integer to the buffer
 *
 * @param <Buffer> buffer - destination
 * @param <Number> pos - offset
 * @param <Number> length - length (>0)
 * @returns <Number> number of bytes written
 *
 * @api private
 */

const varByteIntCache = {}
function writeVarByteInt (stream, num) {
  if (num > protocol.VARBYTEINT_MAX) {
    stream.emit('error', new Error(`Invalid variable byte integer: ${num}`))
    return false
  }

  let buffer = varByteIntCache[num]

  if (!buffer) {
    buffer = genBufVariableByteInt(num)
    if (num < 16384) varByteIntCache[num] = buffer
  }
  debug('writeVarByteInt: writing to stream: %o', buffer)
  return stream.write(buffer)
}

/**
 * writeString - write a utf8 string to the buffer
 *
 * @param <Buffer> buffer - destination
 * @param <Number> pos - offset
 * @param <String> string - string to write
 * @return <Number> number of bytes written
 *
 * @api private
 */

function writeString (stream, string) {
  const strlen = Buffer.byteLength(string)
  writeNumber(stream, strlen)

  debug('writeString: %s', string)
  return stream.write(string, 'utf8')
}

/**
 * writeStringPair - write a utf8 string pairs to the buffer
 *
 * @param <Buffer> buffer - destination
 * @param <String> name - string name to write
 * @param <String> value - string value to write
 * @return <Number> number of bytes written
 *
 * @api private
 */
function writeStringPair (stream, name, value) {
  writeString(stream, name)
  writeString(stream, value)
}

/**
 * writeNumber - write a two byte number to the buffer
 *
 * @param <Buffer> buffer - destination
 * @param <Number> pos - offset
 * @param <String> number - number to write
 * @return <Number> number of bytes written
 *
 * @api private
 */
function writeNumberCached (stream, number) {
  debug('writeNumberCached: number: %d', number)
  debug('writeNumberCached: %o', numCache[number])
  return stream.write(numCache[number])
}
function writeNumberGenerated (stream, number) {
  const generatedNumber = generateNumber(number)
  debug('writeNumberGenerated: %o', generatedNumber)
  return stream.write(generatedNumber)
}
function write4ByteNumber (stream, number) {
  const generated4ByteBuffer = generate4ByteBuffer(number)
  debug('write4ByteNumber: %o', generated4ByteBuffer)
  return stream.write(generated4ByteBuffer)
}
/**
 * writeStringOrBuffer - write a String or Buffer with the its length prefix
 *
 * @param <Buffer> buffer - destination
 * @param <Number> pos - offset
 * @param <String> toWrite - String or Buffer
 * @return <Number> number of bytes written
 */
function writeStringOrBuffer (stream, toWrite) {
  if (typeof toWrite === 'string') {
    writeString(stream, toWrite)
  } else if (toWrite) {
    writeNumber(stream, toWrite.length)
    stream.write(toWrite)
  } else writeNumber(stream, 0)
}

function getProperties (stream, properties) {
  /* connect properties */
  if (typeof properties !== 'object' || properties.length != null) {
    return {
      length: 1,
      write () {
        writeProperties(stream, {}, 0)
      }
    }
  }
  let propertiesLength = 0
  function getLengthProperty (name, value) {
    const type = protocol.propertiesTypes[name]
    let length = 0
    switch (type) {
      case 'byte': {
        if (typeof value !== 'boolean') {
          stream.emit('error', new Error(`Invalid ${name}: ${value}`))
          return false
        }
        length += 1 + 1
        break
      }
      case 'int8': {
        if (typeof value !== 'number' || value < 0 || value > 0xff) {
          stream.emit('error', new Error(`Invalid ${name}: ${value}`))
          return false
        }
        length += 1 + 1
        break
      }
      case 'binary': {
        if (value && value === null) {
          stream.emit('error', new Error(`Invalid ${name}: ${value}`))
          return false
        }
        length += 1 + Buffer.byteLength(value) + 2
        break
      }
      case 'int16': {
        if (typeof value !== 'number' || value < 0 || value > 0xffff) {
          stream.emit('error', new Error(`Invalid ${name}: ${value}`))
          return false
        }
        length += 1 + 2
        break
      }
      case 'int32': {
        if (typeof value !== 'number' || value < 0 || value > 0xffffffff) {
          stream.emit('error', new Error(`Invalid ${name}: ${value}`))
          return false
        }
        length += 1 + 4
        break
      }
      case 'var': {
        // var byte integer is max 24 bits packed in 32 bits
        if (typeof value !== 'number' || value < 0 || value > 0x0fffffff) {
          stream.emit('error', new Error(`Invalid ${name}: ${value}`))
          return false
        }
        length += 1 + Buffer.byteLength(genBufVariableByteInt(value))
        break
      }
      case 'string': {
        if (typeof value !== 'string') {
          stream.emit('error', new Error(`Invalid ${name}: ${value}`))
          return false
        }
        length += 1 + 2 + Buffer.byteLength(value.toString())
        break
      }
      case 'pair': {
        if (typeof value !== 'object') {
          stream.emit('error', new Error(`Invalid ${name}: ${value}`))
          return false
        }
        length += Object.getOwnPropertyNames(value).reduce((result, name) => {
          const currentValue = value[name]
          if (Array.isArray(currentValue)) {
            result += currentValue.reduce((currentLength, value) => {
              currentLength += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value.toString())
              return currentLength
            }, 0)
          } else {
            result += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value[name].toString())
          }
          return result
        }, 0)
        break
      }
      default: {
        stream.emit('error', new Error(`Invalid property ${name}: ${value}`))
        return false
      }
    }
    return length
  }
  if (properties) {
    for (const propName in properties) {
      let propLength = 0
      let propValueLength = 0
      const propValue = properties[propName]
      if (Array.isArray(propValue)) {
        for (let valueIndex = 0; valueIndex < propValue.length; valueIndex++) {
          propValueLength = getLengthProperty(propName, propValue[valueIndex])
          if (!propValueLength) { return false }
          propLength += propValueLength
        }
      } else {
        propValueLength = getLengthProperty(propName, propValue)
        if (!propValueLength) { return false }
        propLength = propValueLength
      }
      if (!propLength) return false
      propertiesLength += propLength
    }
  }
  const propertiesLengthLength = Buffer.byteLength(genBufVariableByteInt(propertiesLength))

  return {
    length: propertiesLengthLength + propertiesLength,
    write () {
      writeProperties(stream, properties, propertiesLength)
    }
  }
}

function getPropertiesByMaximumPacketSize (stream, properties, opts, length) {
  const mayEmptyProps = ['reasonString', 'userProperties']
  const maximumPacketSize = opts && opts.properties && opts.properties.maximumPacketSize ? opts.properties.maximumPacketSize : 0

  let propertiesData = getProperties(stream, properties)
  if (maximumPacketSize) {
    while (length + propertiesData.length > maximumPacketSize) {
      const currentMayEmptyProp = mayEmptyProps.shift()
      if (currentMayEmptyProp && properties[currentMayEmptyProp]) {
        delete properties[currentMayEmptyProp]
        propertiesData = getProperties(stream, properties)
      } else {
        return false
      }
    }
  }
  return propertiesData
}

function writeProperty (stream, propName, value) {
  const type = protocol.propertiesTypes[propName]
  switch (type) {
    case 'byte': {
      stream.write(Buffer.from([protocol.properties[propName]]))
      stream.write(Buffer.from([+value]))
      break
    }
    case 'int8': {
      stream.write(Buffer.from([protocol.properties[propName]]))
      stream.write(Buffer.from([value]))
      break
    }
    case 'binary': {
      stream.write(Buffer.from([protocol.properties[propName]]))
      writeStringOrBuffer(stream, value)
      break
    }
    case 'int16': {
      stream.write(Buffer.from([protocol.properties[propName]]))
      writeNumber(stream, value)
      break
    }
    case 'int32': {
      stream.write(Buffer.from([protocol.properties[propName]]))
      write4ByteNumber(stream, value)
      break
    }
    case 'var': {
      stream.write(Buffer.from([protocol.properties[propName]]))
      writeVarByteInt(stream, value)
      break
    }
    case 'string': {
      stream.write(Buffer.from([protocol.properties[propName]]))
      writeString(stream, value)
      break
    }
    case 'pair': {
      Object.getOwnPropertyNames(value).forEach(name => {
        const currentValue = value[name]
        if (Array.isArray(currentValue)) {
          currentValue.forEach(value => {
            stream.write(Buffer.from([protocol.properties[propName]]))
            writeStringPair(stream, name.toString(), value.toString())
          })
        } else {
          stream.write(Buffer.from([protocol.properties[propName]]))
          writeStringPair(stream, name.toString(), currentValue.toString())
        }
      })
      break
    }
    default: {
      stream.emit('error', new Error(`Invalid property ${propName} value: ${value}`))
      return false
    }
  }
}

function writeProperties (stream, properties, propertiesLength) {
  /* write properties to stream */
  writeVarByteInt(stream, propertiesLength)
  for (const propName in properties) {
    if (Object.prototype.hasOwnProperty.call(properties, propName) && properties[propName] !== null) {
      const value = properties[propName]
      if (Array.isArray(value)) {
        for (let valueIndex = 0; valueIndex < value.length; valueIndex++) {
          writeProperty(stream, propName, value[valueIndex])
        }
      } else {
        writeProperty(stream, propName, value)
      }
    }
  }
}

function byteLength (bufOrString) {
  if (!bufOrString) return 0
  else if (bufOrString instanceof Buffer) return bufOrString.length
  else return Buffer.byteLength(bufOrString)
}

function isStringOrBuffer (field) {
  return typeof field === 'string' || field instanceof Buffer
}

module.exports = generate


/***/ }),

/***/ 730:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


/**
 * Module dependencies
 */
var EventEmitter = __nccwpck_require__(8614).EventEmitter
var Store = __nccwpck_require__(3963)
var mqttPacket = __nccwpck_require__(9433)
var Writable = __nccwpck_require__(1394).Writable
var inherits = __nccwpck_require__(6919)
var reInterval = __nccwpck_require__(4652)
var validations = __nccwpck_require__(1768)
var xtend = __nccwpck_require__(6738)
var debug = __nccwpck_require__(7984)('mqttjs:client')
var nextTick = process ? process.nextTick : function (callback) { setTimeout(callback, 0) }
var setImmediate = global.setImmediate || function (callback) {
  // works in node v0.8
  nextTick(callback)
}
var defaultConnectOptions = {
  keepalive: 60,
  reschedulePings: true,
  protocolId: 'MQTT',
  protocolVersion: 4,
  reconnectPeriod: 1000,
  connectTimeout: 30 * 1000,
  clean: true,
  resubscribe: true
}

var socketErrors = [
  'ECONNREFUSED',
  'EADDRINUSE',
  'ECONNRESET',
  'ENOTFOUND'
]

// Other Socket Errors: EADDRINUSE, ECONNRESET, ENOTFOUND.

var errors = {
  0: '',
  1: 'Unacceptable protocol version',
  2: 'Identifier rejected',
  3: 'Server unavailable',
  4: 'Bad username or password',
  5: 'Not authorized',
  16: 'No matching subscribers',
  17: 'No subscription existed',
  128: 'Unspecified error',
  129: 'Malformed Packet',
  130: 'Protocol Error',
  131: 'Implementation specific error',
  132: 'Unsupported Protocol Version',
  133: 'Client Identifier not valid',
  134: 'Bad User Name or Password',
  135: 'Not authorized',
  136: 'Server unavailable',
  137: 'Server busy',
  138: 'Banned',
  139: 'Server shutting down',
  140: 'Bad authentication method',
  141: 'Keep Alive timeout',
  142: 'Session taken over',
  143: 'Topic Filter invalid',
  144: 'Topic Name invalid',
  145: 'Packet identifier in use',
  146: 'Packet Identifier not found',
  147: 'Receive Maximum exceeded',
  148: 'Topic Alias invalid',
  149: 'Packet too large',
  150: 'Message rate too high',
  151: 'Quota exceeded',
  152: 'Administrative action',
  153: 'Payload format invalid',
  154: 'Retain not supported',
  155: 'QoS not supported',
  156: 'Use another server',
  157: 'Server moved',
  158: 'Shared Subscriptions not supported',
  159: 'Connection rate exceeded',
  160: 'Maximum connect time',
  161: 'Subscription Identifiers not supported',
  162: 'Wildcard Subscriptions not supported'
}

function defaultId () {
  return 'mqttjs_' + Math.random().toString(16).substr(2, 8)
}

function sendPacket (client, packet, cb) {
  debug('sendPacket :: packet: %O', packet)
  debug('sendPacket :: emitting `packetsend`')
  client.emit('packetsend', packet)

  debug('sendPacket :: writing to stream')
  var result = mqttPacket.writeToStream(packet, client.stream, client.options)
  debug('sendPacket :: writeToStream result %s', result)
  if (!result && cb) {
    debug('sendPacket :: handle events on `drain` once through callback.')
    client.stream.once('drain', cb)
  } else if (cb) {
    debug('sendPacket :: invoking cb')
    cb()
  }
}

function flush (queue) {
  if (queue) {
    debug('flush: queue exists? %b', !!(queue))
    Object.keys(queue).forEach(function (messageId) {
      if (typeof queue[messageId].cb === 'function') {
        queue[messageId].cb(new Error('Connection closed'))
        delete queue[messageId]
      }
    })
  }
}

function flushVolatile (queue) {
  if (queue) {
    debug('flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function')
    Object.keys(queue).forEach(function (messageId) {
      if (queue[messageId].volatile && typeof queue[messageId].cb === 'function') {
        queue[messageId].cb(new Error('Connection closed'))
        delete queue[messageId]
      }
    })
  }
}

function storeAndSend (client, packet, cb, cbStorePut) {
  debug('storeAndSend :: store packet with cmd %s to outgoingStore', packet.cmd)
  client.outgoingStore.put(packet, function storedPacket (err) {
    if (err) {
      return cb && cb(err)
    }
    cbStorePut()
    sendPacket(client, packet, cb)
  })
}

function nop (error) {
  debug('nop ::', error)
}

/**
 * MqttClient constructor
 *
 * @param {Stream} stream - stream
 * @param {Object} [options] - connection options
 * (see Connection#connect)
 */
function MqttClient (streamBuilder, options) {
  var k
  var that = this

  if (!(this instanceof MqttClient)) {
    return new MqttClient(streamBuilder, options)
  }

  this.options = options || {}

  // Defaults
  for (k in defaultConnectOptions) {
    if (typeof this.options[k] === 'undefined') {
      this.options[k] = defaultConnectOptions[k]
    } else {
      this.options[k] = options[k]
    }
  }

  debug('MqttClient :: options.protocol', options.protocol)
  debug('MqttClient :: options.protocolVersion', options.protocolVersion)
  debug('MqttClient :: options.username', options.username)
  debug('MqttClient :: options.keepalive', options.keepalive)
  debug('MqttClient :: options.reconnectPeriod', options.reconnectPeriod)
  debug('MqttClient :: options.rejectUnauthorized', options.rejectUnauthorized)

  this.options.clientId = (typeof options.clientId === 'string') ? options.clientId : defaultId()

  debug('MqttClient :: clientId', this.options.clientId)

  this.options.customHandleAcks = (options.protocolVersion === 5 && options.customHandleAcks) ? options.customHandleAcks : function () { arguments[3](0) }

  this.streamBuilder = streamBuilder

  // Inflight message storages
  this.outgoingStore = options.outgoingStore || new Store()
  this.incomingStore = options.incomingStore || new Store()

  // Should QoS zero messages be queued when the connection is broken?
  this.queueQoSZero = options.queueQoSZero === undefined ? true : options.queueQoSZero

  // map of subscribed topics to support reconnection
  this._resubscribeTopics = {}

  // map of a subscribe messageId and a topic
  this.messageIdToTopic = {}

  // Ping timer, setup in _setupPingTimer
  this.pingTimer = null
  // Is the client connected?
  this.connected = false
  // Are we disconnecting?
  this.disconnecting = false
  // Packet queue
  this.queue = []
  // connack timer
  this.connackTimer = null
  // Reconnect timer
  this.reconnectTimer = null
  // Is processing store?
  this._storeProcessing = false
  // Packet Ids are put into the store during store processing
  this._packetIdsDuringStoreProcessing = {}
  /**
   * MessageIDs starting with 1
   * ensure that nextId is min. 1, see https://github.com/mqttjs/MQTT.js/issues/810
   */
  this.nextId = Math.max(1, Math.floor(Math.random() * 65535))

  // Inflight callbacks
  this.outgoing = {}

  // True if connection is first time.
  this._firstConnection = true

  // Send queued packets
  this.on('connect', function () {
    var queue = this.queue

    function deliver () {
      var entry = queue.shift()
      debug('deliver :: entry %o', entry)
      var packet = null

      if (!entry) {
        return
      }

      packet = entry.packet
      debug('deliver :: call _sendPacket for %o', packet)
      that._sendPacket(
        packet,
        function (err) {
          if (entry.cb) {
            entry.cb(err)
          }
          deliver()
        }
      )
    }

    debug('connect :: sending queued packets')
    deliver()
  })

  this.on('close', function () {
    debug('close :: connected set to `false`')
    this.connected = false

    debug('close :: clearing connackTimer')
    clearTimeout(this.connackTimer)

    debug('close :: clearing ping timer')
    if (that.pingTimer !== null) {
      that.pingTimer.clear()
      that.pingTimer = null
    }

    debug('close :: calling _setupReconnect')
    this._setupReconnect()
  })
  EventEmitter.call(this)

  debug('MqttClient :: setting up stream')
  this._setupStream()
}
inherits(MqttClient, EventEmitter)

/**
 * setup the event handlers in the inner stream.
 *
 * @api private
 */
MqttClient.prototype._setupStream = function () {
  var connectPacket
  var that = this
  var writable = new Writable()
  var parser = mqttPacket.parser(this.options)
  var completeParse = null
  var packets = []

  debug('_setupStream :: calling method to clear reconnect')
  this._clearReconnect()

  debug('_setupStream :: using streamBuilder provided to client to create stream')
  this.stream = this.streamBuilder(this)

  parser.on('packet', function (packet) {
    debug('parser :: on packet push to packets array.')
    packets.push(packet)
  })

  function nextTickWork () {
    if (packets.length) {
      nextTick(work)
    } else {
      var done = completeParse
      completeParse = null
      done()
    }
  }

  function work () {
    debug('work :: getting next packet in queue')
    var packet = packets.shift()

    if (packet) {
      debug('work :: packet pulled from queue')
      that._handlePacket(packet, nextTickWork)
    } else {
      debug('work :: no packets in queue')
      var done = completeParse
      completeParse = null
      debug('work :: done flag is %s', !!(done))
      if (done) done()
    }
  }

  writable._write = function (buf, enc, done) {
    completeParse = done
    debug('writable stream :: parsing buffer')
    parser.parse(buf)
    work()
  }

  function streamErrorHandler (error) {
    debug('streamErrorHandler :: error', error.message)
    if (socketErrors.includes(error.code)) {
      // handle error
      debug('streamErrorHandler :: emitting error')
      that.emit('error', error)
    } else {
      nop(error)
    }
  }

  debug('_setupStream :: pipe stream to writable stream')
  this.stream.pipe(writable)

  // Suppress connection errors
  this.stream.on('error', streamErrorHandler)

  // Echo stream close
  this.stream.on('close', function () {
    debug('(%s)stream :: on close', that.options.clientId)
    flushVolatile(that.outgoing)
    debug('stream: emit close to MqttClient')
    that.emit('close')
  })

  // Send a connect packet
  debug('_setupStream: sending packet `connect`')
  connectPacket = Object.create(this.options)
  connectPacket.cmd = 'connect'
  // avoid message queue
  sendPacket(this, connectPacket)

  // Echo connection errors
  parser.on('error', this.emit.bind(this, 'error'))

  // auth
  if (this.options.properties) {
    if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {
      that.end(() =>
        this.emit('error', new Error('Packet has no Authentication Method')
        ))
      return this
    }
    if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === 'object') {
      var authPacket = xtend({cmd: 'auth', reasonCode: 0}, this.options.authPacket)
      sendPacket(this, authPacket)
    }
  }

  // many drain listeners are needed for qos 1 callbacks if the connection is intermittent
  this.stream.setMaxListeners(1000)

  clearTimeout(this.connackTimer)
  this.connackTimer = setTimeout(function () {
    debug('!!connectTimeout hit!! Calling _cleanUp with force `true`')
    that._cleanUp(true)
  }, this.options.connectTimeout)
}

MqttClient.prototype._handlePacket = function (packet, done) {
  var options = this.options

  if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {
    this.emit('error', new Error('exceeding packets size ' + packet.cmd))
    this.end({reasonCode: 149, properties: { reasonString: 'Maximum packet size was exceeded' }})
    return this
  }
  debug('_handlePacket :: emitting packetreceive')
  this.emit('packetreceive', packet)

  switch (packet.cmd) {
    case 'publish':
      this._handlePublish(packet, done)
      break
    case 'puback':
    case 'pubrec':
    case 'pubcomp':
    case 'suback':
    case 'unsuback':
      this._handleAck(packet)
      done()
      break
    case 'pubrel':
      this._handlePubrel(packet, done)
      break
    case 'connack':
      this._handleConnack(packet)
      done()
      break
    case 'pingresp':
      this._handlePingresp(packet)
      done()
      break
    case 'disconnect':
      this._handleDisconnect(packet)
      done()
      break
    default:
      // do nothing
      // maybe we should do an error handling
      // or just log it
      break
  }
}

MqttClient.prototype._checkDisconnecting = function (callback) {
  if (this.disconnecting) {
    if (callback) {
      callback(new Error('client disconnecting'))
    } else {
      this.emit('error', new Error('client disconnecting'))
    }
  }
  return this.disconnecting
}

/**
 * publish - publish <message> to <topic>
 *
 * @param {String} topic - topic to publish to
 * @param {String, Buffer} message - message to publish
 * @param {Object} [opts] - publish options, includes:
 *    {Number} qos - qos level to publish on
 *    {Boolean} retain - whether or not to retain the message
 *    {Boolean} dup - whether or not mark a message as duplicate
 *    {Function} cbStorePut - function(){} called when message is put into `outgoingStore`
 * @param {Function} [callback] - function(err){}
 *    called when publish succeeds or fails
 * @returns {MqttClient} this - for chaining
 * @api public
 *
 * @example client.publish('topic', 'message');
 * @example
 *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});
 * @example client.publish('topic', 'message', console.log);
 */
MqttClient.prototype.publish = function (topic, message, opts, callback) {
  debug('publish :: message `%s` to topic `%s`', message, topic)
  var packet
  var options = this.options

  // .publish(topic, payload, cb);
  if (typeof opts === 'function') {
    callback = opts
    opts = null
  }

  // default opts
  var defaultOpts = {qos: 0, retain: false, dup: false}
  opts = xtend(defaultOpts, opts)

  if (this._checkDisconnecting(callback)) {
    return this
  }

  packet = {
    cmd: 'publish',
    topic: topic,
    payload: message,
    qos: opts.qos,
    retain: opts.retain,
    messageId: this._nextId(),
    dup: opts.dup
  }

  if (options.protocolVersion === 5) {
    packet.properties = opts.properties
    if ((!options.properties && packet.properties && packet.properties.topicAlias) || ((opts.properties && options.properties) &&
      ((opts.properties.topicAlias && options.properties.topicAliasMaximum && opts.properties.topicAlias > options.properties.topicAliasMaximum) ||
        (!options.properties.topicAliasMaximum && opts.properties.topicAlias)))) {
      /*
      if we are don`t setup topic alias or
      topic alias maximum less than topic alias or
      server don`t give topic alias maximum,
      we are removing topic alias from packet
      */
      delete packet.properties.topicAlias
    }
  }

  debug('publish :: qos', opts.qos)
  switch (opts.qos) {
    case 1:
    case 2:
      // Add to callbacks
      this.outgoing[packet.messageId] = {
        volatile: false,
        cb: callback || nop
      }
      if (this._storeProcessing) {
        debug('_storeProcessing enabled')
        this._packetIdsDuringStoreProcessing[packet.messageId] = false
        this._storePacket(packet, undefined, opts.cbStorePut)
      } else {
        debug('MqttClient:publish: packet cmd: %s', packet.cmd)
        this._sendPacket(packet, undefined, opts.cbStorePut)
      }
      break
    default:
      if (this._storeProcessing) {
        debug('_storeProcessing enabled')
        this._storePacket(packet, callback, opts.cbStorePut)
      } else {
        debug('MqttClient:publish: packet cmd: %s', packet.cmd)
        this._sendPacket(packet, callback, opts.cbStorePut)
      }
      break
  }

  return this
}

/**
 * subscribe - subscribe to <topic>
 *
 * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}
 * @param {Object} [opts] - optional subscription options, includes:
 *    {Number} qos - subscribe qos level
 * @param {Function} [callback] - function(err, granted){} where:
 *    {Error} err - subscription error (none at the moment!)
 *    {Array} granted - array of {topic: 't', qos: 0}
 * @returns {MqttClient} this - for chaining
 * @api public
 * @example client.subscribe('topic');
 * @example client.subscribe('topic', {qos: 1});
 * @example client.subscribe({'topic': {qos: 0}, 'topic2': {qos: 1}}, console.log);
 * @example client.subscribe('topic', console.log);
 */
MqttClient.prototype.subscribe = function () {
  var packet
  var args = new Array(arguments.length)
  for (var i = 0; i < arguments.length; i++) {
    args[i] = arguments[i]
  }
  var subs = []
  var obj = args.shift()
  var resubscribe = obj.resubscribe
  var callback = args.pop() || nop
  var opts = args.pop()
  var invalidTopic
  var that = this
  var version = this.options.protocolVersion

  delete obj.resubscribe

  if (typeof obj === 'string') {
    obj = [obj]
  }

  if (typeof callback !== 'function') {
    opts = callback
    callback = nop
  }

  invalidTopic = validations.validateTopics(obj)
  if (invalidTopic !== null) {
    setImmediate(callback, new Error('Invalid topic ' + invalidTopic))
    return this
  }

  if (this._checkDisconnecting(callback)) {
    debug('subscribe: discconecting true')
    return this
  }

  var defaultOpts = {
    qos: 0
  }
  if (version === 5) {
    defaultOpts.nl = false
    defaultOpts.rap = false
    defaultOpts.rh = 0
  }
  opts = xtend(defaultOpts, opts)

  if (Array.isArray(obj)) {
    obj.forEach(function (topic) {
      debug('subscribe: array topic %s', topic)
      if (!that._resubscribeTopics.hasOwnProperty(topic) ||
        that._resubscribeTopics[topic].qos < opts.qos ||
          resubscribe) {
        var currentOpts = {
          topic: topic,
          qos: opts.qos
        }
        if (version === 5) {
          currentOpts.nl = opts.nl
          currentOpts.rap = opts.rap
          currentOpts.rh = opts.rh
          currentOpts.properties = opts.properties
        }
        debug('subscribe: pushing topic `%s` and qos `%s` to subs list', currentOpts.topic, currentOpts.qos)
        subs.push(currentOpts)
      }
    })
  } else {
    Object
      .keys(obj)
      .forEach(function (k) {
        debug('subscribe: object topic %s', k)
        if (!that._resubscribeTopics.hasOwnProperty(k) ||
          that._resubscribeTopics[k].qos < obj[k].qos ||
            resubscribe) {
          var currentOpts = {
            topic: k,
            qos: obj[k].qos
          }
          if (version === 5) {
            currentOpts.nl = obj[k].nl
            currentOpts.rap = obj[k].rap
            currentOpts.rh = obj[k].rh
            currentOpts.properties = opts.properties
          }
          debug('subscribe: pushing `%s` to subs list', currentOpts)
          subs.push(currentOpts)
        }
      })
  }

  packet = {
    cmd: 'subscribe',
    subscriptions: subs,
    qos: 1,
    retain: false,
    dup: false,
    messageId: this._nextId()
  }

  if (opts.properties) {
    packet.properties = opts.properties
  }

  if (!subs.length) {
    callback(null, [])
    return
  }

  // subscriptions to resubscribe to in case of disconnect
  if (this.options.resubscribe) {
    debug('subscribe :: resubscribe true')
    var topics = []
    subs.forEach(function (sub) {
      if (that.options.reconnectPeriod > 0) {
        var topic = { qos: sub.qos }
        if (version === 5) {
          topic.nl = sub.nl || false
          topic.rap = sub.rap || false
          topic.rh = sub.rh || 0
          topic.properties = sub.properties
        }
        that._resubscribeTopics[sub.topic] = topic
        topics.push(sub.topic)
      }
    })
    that.messageIdToTopic[packet.messageId] = topics
  }

  this.outgoing[packet.messageId] = {
    volatile: true,
    cb: function (err, packet) {
      if (!err) {
        var granted = packet.granted
        for (var i = 0; i < granted.length; i += 1) {
          subs[i].qos = granted[i]
        }
      }

      callback(err, subs)
    }
  }
  debug('subscribe :: call _sendPacket')
  this._sendPacket(packet)

  return this
}

/**
 * unsubscribe - unsubscribe from topic(s)
 *
 * @param {String, Array} topic - topics to unsubscribe from
 * @param {Object} [opts] - optional subscription options, includes:
 *    {Object} properties - properties of unsubscribe packet
 * @param {Function} [callback] - callback fired on unsuback
 * @returns {MqttClient} this - for chaining
 * @api public
 * @example client.unsubscribe('topic');
 * @example client.unsubscribe('topic', console.log);
 */
MqttClient.prototype.unsubscribe = function () {
  var packet = {
    cmd: 'unsubscribe',
    qos: 1,
    messageId: this._nextId()
  }
  var that = this
  var args = new Array(arguments.length)
  for (var i = 0; i < arguments.length; i++) {
    args[i] = arguments[i]
  }
  var topic = args.shift()
  var callback = args.pop() || nop
  var opts = args.pop()

  if (typeof topic === 'string') {
    topic = [topic]
  }

  if (typeof callback !== 'function') {
    opts = callback
    callback = nop
  }

  if (this._checkDisconnecting(callback)) {
    return this
  }

  if (typeof topic === 'string') {
    packet.unsubscriptions = [topic]
  } else if (Array.isArray(topic)) {
    packet.unsubscriptions = topic
  }

  if (this.options.resubscribe) {
    packet.unsubscriptions.forEach(function (topic) {
      delete that._resubscribeTopics[topic]
    })
  }

  if (typeof opts === 'object' && opts.properties) {
    packet.properties = opts.properties
  }

  this.outgoing[packet.messageId] = {
    volatile: true,
    cb: callback
  }

  debug('unsubscribe: call _sendPacket')
  this._sendPacket(packet)

  return this
}

/**
 * end - close connection
 *
 * @returns {MqttClient} this - for chaining
 * @param {Boolean} force - do not wait for all in-flight messages to be acked
 * @param {Object} opts - added to the disconnect packet
 * @param {Function} cb - called when the client has been closed
 *
 * @api public
 */
MqttClient.prototype.end = function (force, opts, cb) {
  var that = this

  debug('end :: (%s)', this.options.clientId)

  if (force == null || typeof force !== 'boolean') {
    cb = opts || nop
    opts = force
    force = false
    if (typeof opts !== 'object') {
      cb = opts
      opts = null
      if (typeof cb !== 'function') {
        cb = nop
      }
    }
  }

  if (typeof opts !== 'object') {
    cb = opts
    opts = null
  }

  debug('end :: cb? %s', !!cb)
  cb = cb || nop

  function closeStores () {
    debug('end :: closeStores: closing incoming and outgoing stores')
    that.disconnected = true
    that.incomingStore.close(function (e1) {
      that.outgoingStore.close(function (e2) {
        debug('end :: closeStores: emitting end')
        that.emit('end')
        if (cb) {
          let err = e1 || e2
          debug('end :: closeStores: invoking callback with args')
          cb(err)
        }
      })
    })
    if (that._deferredReconnect) {
      that._deferredReconnect()
    }
  }

  function finish () {
    // defer closesStores of an I/O cycle,
    // just to make sure things are
    // ok for websockets
    debug('end :: (%s) :: finish :: calling _cleanUp with force %s', that.options.clientId, force)
    that._cleanUp(force, () => {
      debug('end :: finish :: calling process.nextTick on closeStores')
      // var boundProcess = nextTick.bind(null, closeStores)
      nextTick(closeStores.bind(that))
    }, opts)
  }

  if (this.disconnecting) {
    cb()
    return this
  }

  this._clearReconnect()

  this.disconnecting = true

  if (!force && Object.keys(this.outgoing).length > 0) {
    // wait 10ms, just to be sure we received all of it
    debug('end :: (%s) :: calling finish in 10ms once outgoing is empty', that.options.clientId)
    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10))
  } else {
    debug('end :: (%s) :: immediately calling finish', that.options.clientId)
    finish()
  }

  return this
}

/**
 * removeOutgoingMessage - remove a message in outgoing store
 * the outgoing callback will be called withe Error('Message removed') if the message is removed
 *
 * @param {Number} messageId - messageId to remove message
 * @returns {MqttClient} this - for chaining
 * @api public
 *
 * @example client.removeOutgoingMessage(client.getLastMessageId());
 */
MqttClient.prototype.removeOutgoingMessage = function (messageId) {
  var cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null
  delete this.outgoing[messageId]
  this.outgoingStore.del({messageId: messageId}, function () {
    cb(new Error('Message removed'))
  })
  return this
}

/**
 * reconnect - connect again using the same options as connect()
 *
 * @param {Object} [opts] - optional reconnect options, includes:
 *    {Store} incomingStore - a store for the incoming packets
 *    {Store} outgoingStore - a store for the outgoing packets
 *    if opts is not given, current stores are used
 * @returns {MqttClient} this - for chaining
 *
 * @api public
 */
MqttClient.prototype.reconnect = function (opts) {
  debug('client reconnect')
  var that = this
  var f = function () {
    if (opts) {
      that.options.incomingStore = opts.incomingStore
      that.options.outgoingStore = opts.outgoingStore
    } else {
      that.options.incomingStore = null
      that.options.outgoingStore = null
    }
    that.incomingStore = that.options.incomingStore || new Store()
    that.outgoingStore = that.options.outgoingStore || new Store()
    that.disconnecting = false
    that.disconnected = false
    that._deferredReconnect = null
    that._reconnect()
  }

  if (this.disconnecting && !this.disconnected) {
    this._deferredReconnect = f
  } else {
    f()
  }
  return this
}

/**
 * _reconnect - implement reconnection
 * @api privateish
 */
MqttClient.prototype._reconnect = function () {
  debug('_reconnect: emitting reconnect to client')
  this.emit('reconnect')
  if (this.connected) {
    this.end(() => { this._setupStream() })
    debug('client already connected. disconnecting first.')
  } else {
    debug('_reconnect: calling _setupStream')
    this._setupStream()
  }
}

/**
 * _setupReconnect - setup reconnect timer
 */
MqttClient.prototype._setupReconnect = function () {
  var that = this

  if (!that.disconnecting && !that.reconnectTimer && (that.options.reconnectPeriod > 0)) {
    if (!this.reconnecting) {
      debug('_setupReconnect :: emit `offline` state')
      this.emit('offline')
      debug('_setupReconnect :: set `reconnecting` to `true`')
      this.reconnecting = true
    }
    debug('_setupReconnect :: setting reconnectTimer for %d ms', that.options.reconnectPeriod)
    that.reconnectTimer = setInterval(function () {
      debug('reconnectTimer :: reconnect triggered!')
      that._reconnect()
    }, that.options.reconnectPeriod)
  } else {
    debug('_setupReconnect :: doing nothing...')
  }
}

/**
 * _clearReconnect - clear the reconnect timer
 */
MqttClient.prototype._clearReconnect = function () {
  debug('_clearReconnect : clearing reconnect timer')
  if (this.reconnectTimer) {
    clearInterval(this.reconnectTimer)
    this.reconnectTimer = null
  }
}

/**
 * _cleanUp - clean up on connection end
 * @api private
 */
MqttClient.prototype._cleanUp = function (forced, done) {
  var opts = arguments[2]
  if (done) {
    debug('_cleanUp :: done callback provided for on stream close')
    this.stream.on('close', done)
  }

  debug('_cleanUp :: forced? %s', forced)
  if (forced) {
    if ((this.options.reconnectPeriod === 0) && this.options.clean) {
      flush(this.outgoing)
    }
    debug('_cleanUp :: (%s) :: destroying stream', this.options.clientId)
    this.stream.destroy()
  } else {
    var packet = xtend({ cmd: 'disconnect' }, opts)
    debug('_cleanUp :: (%s) :: call _sendPacket with disconnect packet', this.options.clientId)
    this._sendPacket(
      packet,
      setImmediate.bind(
        null,
        this.stream.end.bind(this.stream)
      )
    )
  }

  if (!this.disconnecting) {
    debug('_cleanUp :: client not disconnecting. Clearing and resetting reconnect.')
    this._clearReconnect()
    this._setupReconnect()
  }

  if (this.pingTimer !== null) {
    debug('_cleanUp :: clearing pingTimer')
    this.pingTimer.clear()
    this.pingTimer = null
  }

  if (done && !this.connected) {
    debug('_cleanUp :: (%s) :: removing stream `done` callback `close` listener', this.options.clientId)
    this.stream.removeListener('close', done)
    done()
  }
}

/**
 * _sendPacket - send or queue a packet
 * @param {Object} packet - packet options
 * @param {Function} cb - callback when the packet is sent
 * @param {Function} cbStorePut - called when message is put into outgoingStore
 * @api private
 */
MqttClient.prototype._sendPacket = function (packet, cb, cbStorePut) {
  debug('_sendPacket :: (%s) ::  start', this.options.clientId)
  cbStorePut = cbStorePut || nop

  if (!this.connected) {
    debug('_sendPacket :: client not connected. Storing packet offline.')
    this._storePacket(packet, cb, cbStorePut)
    return
  }

  // When sending a packet, reschedule the ping timer
  this._shiftPingInterval()

  switch (packet.cmd) {
    case 'publish':
      break
    case 'pubrel':
      storeAndSend(this, packet, cb, cbStorePut)
      return
    default:
      sendPacket(this, packet, cb)
      return
  }

  switch (packet.qos) {
    case 2:
    case 1:
      storeAndSend(this, packet, cb, cbStorePut)
      break
    /**
     * no need of case here since it will be caught by default
     * and jshint comply that before default it must be a break
     * anyway it will result in -1 evaluation
     */
    case 0:
      /* falls through */
    default:
      sendPacket(this, packet, cb)
      break
  }
  debug('_sendPacket :: (%s) ::  end', this.options.clientId)
}

/**
 * _storePacket - queue a packet
 * @param {Object} packet - packet options
 * @param {Function} cb - callback when the packet is sent
 * @param {Function} cbStorePut - called when message is put into outgoingStore
 * @api private
 */
MqttClient.prototype._storePacket = function (packet, cb, cbStorePut) {
  debug('_storePacket :: packet: %o', packet)
  debug('_storePacket :: cb? %s', !!cb)
  cbStorePut = cbStorePut || nop

  // check that the packet is not a qos of 0, or that the command is not a publish
  if (((packet.qos || 0) === 0 && this.queueQoSZero) || packet.cmd !== 'publish') {
    this.queue.push({ packet: packet, cb: cb })
  } else if (packet.qos > 0) {
    cb = this.outgoing[packet.messageId] ? this.outgoing[packet.messageId].cb : null
    this.outgoingStore.put(packet, function (err) {
      if (err) {
        return cb && cb(err)
      }
      cbStorePut()
    })
  } else if (cb) {
    cb(new Error('No connection to broker'))
  }
}

/**
 * _setupPingTimer - setup the ping timer
 *
 * @api private
 */
MqttClient.prototype._setupPingTimer = function () {
  debug('_setupPingTimer :: keepalive %d (seconds)', this.options.keepalive)
  var that = this

  if (!this.pingTimer && this.options.keepalive) {
    this.pingResp = true
    this.pingTimer = reInterval(function () {
      that._checkPing()
    }, this.options.keepalive * 1000)
  }
}

/**
 * _shiftPingInterval - reschedule the ping interval
 *
 * @api private
 */
MqttClient.prototype._shiftPingInterval = function () {
  if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {
    this.pingTimer.reschedule(this.options.keepalive * 1000)
  }
}
/**
 * _checkPing - check if a pingresp has come back, and ping the server again
 *
 * @api private
 */
MqttClient.prototype._checkPing = function () {
  debug('_checkPing :: checking ping...')
  if (this.pingResp) {
    debug('_checkPing :: ping response received. Clearing flag and sending `pingreq`')
    this.pingResp = false
    this._sendPacket({ cmd: 'pingreq' })
  } else {
    // do a forced cleanup since socket will be in bad shape
    debug('_checkPing :: calling _cleanUp with force true')
    this._cleanUp(true)
  }
}

/**
 * _handlePingresp - handle a pingresp
 *
 * @api private
 */
MqttClient.prototype._handlePingresp = function () {
  this.pingResp = true
}

/**
 * _handleConnack
 *
 * @param {Object} packet
 * @api private
 */
MqttClient.prototype._handleConnack = function (packet) {
  debug('_handleConnack')
  var options = this.options
  var version = options.protocolVersion
  var rc = version === 5 ? packet.reasonCode : packet.returnCode

  clearTimeout(this.connackTimer)

  if (packet.properties) {
    if (packet.properties.topicAliasMaximum) {
      if (!options.properties) { options.properties = {} }
      options.properties.topicAliasMaximum = packet.properties.topicAliasMaximum
    }
    if (packet.properties.serverKeepAlive && options.keepalive) {
      options.keepalive = packet.properties.serverKeepAlive
      this._shiftPingInterval()
    }
    if (packet.properties.maximumPacketSize) {
      if (!options.properties) { options.properties = {} }
      options.properties.maximumPacketSize = packet.properties.maximumPacketSize
    }
  }

  if (rc === 0) {
    this.reconnecting = false
    this._onConnect(packet)
  } else if (rc > 0) {
    var err = new Error('Connection refused: ' + errors[rc])
    err.code = rc
    this.emit('error', err)
  }
}

/**
 * _handlePublish
 *
 * @param {Object} packet
 * @api private
 */
/*
those late 2 case should be rewrite to comply with coding style:

case 1:
case 0:
  // do not wait sending a puback
  // no callback passed
  if (1 === qos) {
    this._sendPacket({
      cmd: 'puback',
      messageId: messageId
    });
  }
  // emit the message event for both qos 1 and 0
  this.emit('message', topic, message, packet);
  this.handleMessage(packet, done);
  break;
default:
  // do nothing but every switch mus have a default
  // log or throw an error about unknown qos
  break;

for now i just suppressed the warnings
*/
MqttClient.prototype._handlePublish = function (packet, done) {
  debug('_handlePublish: packet %o', packet)
  done = typeof done !== 'undefined' ? done : nop
  var topic = packet.topic.toString()
  var message = packet.payload
  var qos = packet.qos
  var messageId = packet.messageId
  var that = this
  var options = this.options
  var validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153]
  debug('_handlePublish: qos %d', qos)
  switch (qos) {
    case 2: {
      options.customHandleAcks(topic, message, packet, function (error, code) {
        if (!(error instanceof Error)) {
          code = error
          error = null
        }
        if (error) { return that.emit('error', error) }
        if (validReasonCodes.indexOf(code) === -1) { return that.emit('error', new Error('Wrong reason code for pubrec')) }
        if (code) {
          that._sendPacket({cmd: 'pubrec', messageId: messageId, reasonCode: code}, done)
        } else {
          that.incomingStore.put(packet, function () {
            that._sendPacket({cmd: 'pubrec', messageId: messageId}, done)
          })
        }
      })
      break
    }
    case 1: {
      // emit the message event
      options.customHandleAcks(topic, message, packet, function (error, code) {
        if (!(error instanceof Error)) {
          code = error
          error = null
        }
        if (error) { return that.emit('error', error) }
        if (validReasonCodes.indexOf(code) === -1) { return that.emit('error', new Error('Wrong reason code for puback')) }
        if (!code) { that.emit('message', topic, message, packet) }
        that.handleMessage(packet, function (err) {
          if (err) {
            return done && done(err)
          }
          that._sendPacket({cmd: 'puback', messageId: messageId, reasonCode: code}, done)
        })
      })
      break
    }
    case 0:
      // emit the message event
      this.emit('message', topic, message, packet)
      this.handleMessage(packet, done)
      break
    default:
      // do nothing
      debug('_handlePublish: unknown QoS. Doing nothing.')
      // log or throw an error about unknown qos
      break
  }
}

/**
 * Handle messages with backpressure support, one at a time.
 * Override at will.
 *
 * @param Packet packet the packet
 * @param Function callback call when finished
 * @api public
 */
MqttClient.prototype.handleMessage = function (packet, callback) {
  callback()
}

/**
 * _handleAck
 *
 * @param {Object} packet
 * @api private
 */

MqttClient.prototype._handleAck = function (packet) {
  /* eslint no-fallthrough: "off" */
  var messageId = packet.messageId
  var type = packet.cmd
  var response = null
  var cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null
  var that = this
  var err

  if (!cb) {
    debug('_handleAck :: Server sent an ack in error. Ignoring.')
    // Server sent an ack in error, ignore it.
    return
  }

  // Process
  debug('_handleAck :: packet type', type)
  switch (type) {
    case 'pubcomp':
      // same thing as puback for QoS 2
    case 'puback':
      var pubackRC = packet.reasonCode
      // Callback - we're done
      if (pubackRC && pubackRC > 0 && pubackRC !== 16) {
        err = new Error('Publish error: ' + errors[pubackRC])
        err.code = pubackRC
        cb(err, packet)
      }
      delete this.outgoing[messageId]
      this.outgoingStore.del(packet, cb)
      break
    case 'pubrec':
      response = {
        cmd: 'pubrel',
        qos: 2,
        messageId: messageId
      }
      var pubrecRC = packet.reasonCode

      if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {
        err = new Error('Publish error: ' + errors[pubrecRC])
        err.code = pubrecRC
        cb(err, packet)
      } else {
        this._sendPacket(response)
      }
      break
    case 'suback':
      delete this.outgoing[messageId]
      for (var grantedI = 0; grantedI < packet.granted.length; grantedI++) {
        if ((packet.granted[grantedI] & 0x80) !== 0) {
          // suback with Failure status
          var topics = this.messageIdToTopic[messageId]
          if (topics) {
            topics.forEach(function (topic) {
              delete that._resubscribeTopics[topic]
            })
          }
        }
      }
      cb(null, packet)
      break
    case 'unsuback':
      delete this.outgoing[messageId]
      cb(null)
      break
    default:
      that.emit('error', new Error('unrecognized packet type'))
  }

  if (this.disconnecting &&
      Object.keys(this.outgoing).length === 0) {
    this.emit('outgoingEmpty')
  }
}

/**
 * _handlePubrel
 *
 * @param {Object} packet
 * @api private
 */
MqttClient.prototype._handlePubrel = function (packet, callback) {
  debug('handling pubrel packet')
  callback = typeof callback !== 'undefined' ? callback : nop
  var messageId = packet.messageId
  var that = this

  var comp = {cmd: 'pubcomp', messageId: messageId}

  that.incomingStore.get(packet, function (err, pub) {
    if (!err) {
      that.emit('message', pub.topic, pub.payload, pub)
      that.handleMessage(pub, function (err) {
        if (err) {
          return callback(err)
        }
        that.incomingStore.del(pub, nop)
        that._sendPacket(comp, callback)
      })
    } else {
      that._sendPacket(comp, callback)
    }
  })
}

/**
 * _handleDisconnect
 *
 * @param {Object} packet
 * @api private
 */
MqttClient.prototype._handleDisconnect = function (packet) {
  this.emit('disconnect', packet)
}

/**
 * _nextId
 * @return unsigned int
 */
MqttClient.prototype._nextId = function () {
  // id becomes current state of this.nextId and increments afterwards
  var id = this.nextId++
  // Ensure 16 bit unsigned int (max 65535, nextId got one higher)
  if (this.nextId === 65536) {
    this.nextId = 1
  }
  return id
}

/**
 * getLastMessageId
 * @return unsigned int
 */
MqttClient.prototype.getLastMessageId = function () {
  return (this.nextId === 1) ? 65535 : (this.nextId - 1)
}

/**
 * _resubscribe
 * @api private
 */
MqttClient.prototype._resubscribe = function (connack) {
  debug('_resubscribe')
  var _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics)
  if (!this._firstConnection &&
      (this.options.clean || (this.options.protocolVersion === 5 && !connack.sessionPresent)) &&
      _resubscribeTopicsKeys.length > 0) {
    if (this.options.resubscribe) {
      if (this.options.protocolVersion === 5) {
        debug('_resubscribe: protocolVersion 5')
        for (var topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {
          var resubscribeTopic = {}
          resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]]
          resubscribeTopic.resubscribe = true
          this.subscribe(resubscribeTopic, {properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties})
        }
      } else {
        this._resubscribeTopics.resubscribe = true
        this.subscribe(this._resubscribeTopics)
      }
    } else {
      this._resubscribeTopics = {}
    }
  }

  this._firstConnection = false
}

/**
 * _onConnect
 *
 * @api private
 */
MqttClient.prototype._onConnect = function (packet) {
  if (this.disconnected) {
    this.emit('connect', packet)
    return
  }

  var that = this

  this._setupPingTimer()
  this._resubscribe(packet)

  this.connected = true

  function startStreamProcess () {
    var outStore = that.outgoingStore.createStream()

    function clearStoreProcessing () {
      that._storeProcessing = false
      that._packetIdsDuringStoreProcessing = {}
    }

    that.once('close', remove)
    outStore.on('error', function (err) {
      clearStoreProcessing()
      that.removeListener('close', remove)
      that.emit('error', err)
    })

    function remove () {
      outStore.destroy()
      outStore = null
      clearStoreProcessing()
    }

    function storeDeliver () {
      // edge case, we wrapped this twice
      if (!outStore) {
        return
      }
      that._storeProcessing = true

      var packet = outStore.read(1)

      var cb

      if (!packet) {
        // read when data is available in the future
        outStore.once('readable', storeDeliver)
        return
      }

      // Skip already processed store packets
      if (that._packetIdsDuringStoreProcessing[packet.messageId]) {
        storeDeliver()
        return
      }

      // Avoid unnecessary stream read operations when disconnected
      if (!that.disconnecting && !that.reconnectTimer) {
        cb = that.outgoing[packet.messageId] ? that.outgoing[packet.messageId].cb : null
        that.outgoing[packet.messageId] = {
          volatile: false,
          cb: function (err, status) {
            // Ensure that the original callback passed in to publish gets invoked
            if (cb) {
              cb(err, status)
            }

            storeDeliver()
          }
        }
        that._packetIdsDuringStoreProcessing[packet.messageId] = true
        that._sendPacket(packet)
      } else if (outStore.destroy) {
        outStore.destroy()
      }
    }

    outStore.on('end', function () {
      var allProcessed = true
      for (var id in that._packetIdsDuringStoreProcessing) {
        if (!that._packetIdsDuringStoreProcessing[id]) {
          allProcessed = false
          break
        }
      }
      if (allProcessed) {
        clearStoreProcessing()
        that.removeListener('close', remove)
        that.emit('connect', packet)
      } else {
        startStreamProcess()
      }
    })
    storeDeliver()
  }
  // start flowing
  startStreamProcess()
}

module.exports = MqttClient


/***/ }),

/***/ 7730:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var Transform = __nccwpck_require__(1394).Transform
var duplexify = __nccwpck_require__(3265)

/* global FileReader */
var my
var proxy
var stream
var isInitialized = false

function buildProxy () {
  var proxy = new Transform()
  proxy._write = function (chunk, encoding, next) {
    my.sendSocketMessage({
      data: chunk.buffer,
      success: function () {
        next()
      },
      fail: function () {
        next(new Error())
      }
    })
  }
  proxy._flush = function socketEnd (done) {
    my.closeSocket({
      success: function () {
        done()
      }
    })
  }

  return proxy
}

function setDefaultOpts (opts) {
  if (!opts.hostname) {
    opts.hostname = 'localhost'
  }
  if (!opts.path) {
    opts.path = '/'
  }

  if (!opts.wsOptions) {
    opts.wsOptions = {}
  }
}

function buildUrl (opts, client) {
  var protocol = opts.protocol === 'alis' ? 'wss' : 'ws'
  var url = protocol + '://' + opts.hostname + opts.path
  if (opts.port && opts.port !== 80 && opts.port !== 443) {
    url = protocol + '://' + opts.hostname + ':' + opts.port + opts.path
  }
  if (typeof (opts.transformWsUrl) === 'function') {
    url = opts.transformWsUrl(url, opts, client)
  }
  return url
}

function bindEventHandler () {
  if (isInitialized) return

  isInitialized = true

  my.onSocketOpen(function () {
    stream.setReadable(proxy)
    stream.setWritable(proxy)
    stream.emit('connect')
  })

  my.onSocketMessage(function (res) {
    if (typeof res.data === 'string') {
      var buffer = Buffer.from(res.data, 'base64')
      proxy.push(buffer)
    } else {
      var reader = new FileReader()
      reader.addEventListener('load', function () {
        var data = reader.result

        if (data instanceof ArrayBuffer) data = Buffer.from(data)
        else data = Buffer.from(data, 'utf8')
        proxy.push(data)
      })
      reader.readAsArrayBuffer(res.data)
    }
  })

  my.onSocketClose(function () {
    stream.end()
    stream.destroy()
  })

  my.onSocketError(function (res) {
    stream.destroy(res)
  })
}

function buildStream (client, opts) {
  opts.hostname = opts.hostname || opts.host

  if (!opts.hostname) {
    throw new Error('Could not determine host. Specify host manually.')
  }

  var websocketSubProtocol =
    (opts.protocolId === 'MQIsdp') && (opts.protocolVersion === 3)
      ? 'mqttv3.1'
      : 'mqtt'

  setDefaultOpts(opts)

  var url = buildUrl(opts, client)
  my = opts.my
  my.connectSocket({
    url: url,
    protocols: websocketSubProtocol
  })

  proxy = buildProxy()
  stream = duplexify.obj()

  bindEventHandler()

  return stream
}

module.exports = buildStream


/***/ }),

/***/ 1745:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var MqttClient = __nccwpck_require__(730)
var Store = __nccwpck_require__(3963)
var url = __nccwpck_require__(8835)
var xtend = __nccwpck_require__(6738)
var debug = __nccwpck_require__(7984)('mqttjs')

var protocols = {}

// eslint-disable-next-line camelcase
if ((typeof process !== 'undefined' && process.title !== 'browser') || typeof __nccwpck_require__ !== 'function') {
  protocols.mqtt = __nccwpck_require__(8177)
  protocols.tcp = __nccwpck_require__(8177)
  protocols.ssl = __nccwpck_require__(6570)
  protocols.tls = __nccwpck_require__(6570)
  protocols.mqtts = __nccwpck_require__(6570)
} else {
  protocols.wx = __nccwpck_require__(4720)
  protocols.wxs = __nccwpck_require__(4720)

  protocols.ali = __nccwpck_require__(7730)
  protocols.alis = __nccwpck_require__(7730)
}

protocols.ws = __nccwpck_require__(1671)
protocols.wss = __nccwpck_require__(1671)

/**
 * Parse the auth attribute and merge username and password in the options object.
 *
 * @param {Object} [opts] option object
 */
function parseAuthOptions (opts) {
  var matches
  if (opts.auth) {
    matches = opts.auth.match(/^(.+):(.+)$/)
    if (matches) {
      opts.username = matches[1]
      opts.password = matches[2]
    } else {
      opts.username = opts.auth
    }
  }
}

/**
 * connect - connect to an MQTT broker.
 *
 * @param {String} [brokerUrl] - url of the broker, optional
 * @param {Object} opts - see MqttClient#constructor
 */
function connect (brokerUrl, opts) {
  debug('connecting to an MQTT broker...')
  if ((typeof brokerUrl === 'object') && !opts) {
    opts = brokerUrl
    brokerUrl = null
  }

  opts = opts || {}

  if (brokerUrl) {
    var parsed = url.parse(brokerUrl, true)
    if (parsed.port != null) {
      parsed.port = Number(parsed.port)
    }

    opts = xtend(parsed, opts)

    if (opts.protocol === null) {
      throw new Error('Missing protocol')
    }

    opts.protocol = opts.protocol.replace(/:$/, '')
  }

  // merge in the auth options if supplied
  parseAuthOptions(opts)

  // support clientId passed in the query string of the url
  if (opts.query && typeof opts.query.clientId === 'string') {
    opts.clientId = opts.query.clientId
  }

  if (opts.cert && opts.key) {
    if (opts.protocol) {
      if (['mqtts', 'wss', 'wxs', 'alis'].indexOf(opts.protocol) === -1) {
        switch (opts.protocol) {
          case 'mqtt':
            opts.protocol = 'mqtts'
            break
          case 'ws':
            opts.protocol = 'wss'
            break
          case 'wx':
            opts.protocol = 'wxs'
            break
          case 'ali':
            opts.protocol = 'alis'
            break
          default:
            throw new Error('Unknown protocol for secure connection: "' + opts.protocol + '"!')
        }
      }
    } else {
      // A cert and key was provided, however no protocol was specified, so we will throw an error.
      throw new Error('Missing secure protocol key')
    }
  }

  if (!protocols[opts.protocol]) {
    var isSecure = ['mqtts', 'wss'].indexOf(opts.protocol) !== -1
    opts.protocol = [
      'mqtt',
      'mqtts',
      'ws',
      'wss',
      'wx',
      'wxs',
      'ali',
      'alis'
    ].filter(function (key, index) {
      if (isSecure && index % 2 === 0) {
        // Skip insecure protocols when requesting a secure one.
        return false
      }
      return (typeof protocols[key] === 'function')
    })[0]
  }

  if (opts.clean === false && !opts.clientId) {
    throw new Error('Missing clientId for unclean clients')
  }

  if (opts.protocol) {
    opts.defaultProtocol = opts.protocol
  }

  function wrapper (client) {
    if (opts.servers) {
      if (!client._reconnectCount || client._reconnectCount === opts.servers.length) {
        client._reconnectCount = 0
      }

      opts.host = opts.servers[client._reconnectCount].host
      opts.port = opts.servers[client._reconnectCount].port
      opts.protocol = (!opts.servers[client._reconnectCount].protocol ? opts.defaultProtocol : opts.servers[client._reconnectCount].protocol)
      opts.hostname = opts.host

      client._reconnectCount++
    }

    debug('calling streambuilder for', opts.protocol)
    return protocols[opts.protocol](client, opts)
  }
  var client = new MqttClient(wrapper, opts)
  client.on('error', function () { /* Automatically set up client error handling */ })
  return client
}

module.exports = connect
module.exports.connect = connect
module.exports.MqttClient = MqttClient
module.exports.Store = Store


/***/ }),

/***/ 8177:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

var net = __nccwpck_require__(1631)
var debug = __nccwpck_require__(7984)('mqttjs:tcp')

/*
  variables port and host can be removed since
  you have all required information in opts object
*/
function streamBuilder (client, opts) {
  var port, host
  opts.port = opts.port || 1883
  opts.hostname = opts.hostname || opts.host || 'localhost'

  port = opts.port
  host = opts.hostname

  debug('port %d and host %s', port, host)
  return net.createConnection(port, host)
}

module.exports = streamBuilder


/***/ }),

/***/ 6570:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

var tls = __nccwpck_require__(4016)
var debug = __nccwpck_require__(7984)('mqttjs:tls')

function buildBuilder (mqttClient, opts) {
  var connection
  opts.port = opts.port || 8883
  opts.host = opts.hostname || opts.host || 'localhost'
  opts.servername = opts.host

  opts.rejectUnauthorized = opts.rejectUnauthorized !== false

  delete opts.path

  debug('port %d host %s rejectUnauthorized %b', opts.port, opts.host, opts.rejectUnauthorized)

  connection = tls.connect(opts)
  /* eslint no-use-before-define: [2, "nofunc"] */
  connection.on('secureConnect', function () {
    if (opts.rejectUnauthorized && !connection.authorized) {
      connection.emit('error', new Error('TLS not authorized'))
    } else {
      connection.removeListener('error', handleTLSerrors)
    }
  })

  function handleTLSerrors (err) {
    // How can I get verify this error is a tls error?
    if (opts.rejectUnauthorized) {
      mqttClient.emit('error', err)
    }

    // close this connection to match the behaviour of net
    // otherwise all we get is an error from the connection
    // and close event doesn't fire. This is a work around
    // to enable the reconnect code to work the same as with
    // net.createConnection
    connection.end()
  }

  connection.on('error', handleTLSerrors)
  return connection
}

module.exports = buildBuilder


/***/ }),

/***/ 1671:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const WS = __nccwpck_require__(5028)
const debug = __nccwpck_require__(7984)('mqttjs:ws')
const duplexify = __nccwpck_require__(3265)
const Transform = __nccwpck_require__(1394).Transform

let WSS_OPTIONS = [
  'rejectUnauthorized',
  'ca',
  'cert',
  'key',
  'pfx',
  'passphrase'
]
// eslint-disable-next-line camelcase
const IS_BROWSER = (typeof process !== 'undefined' && process.title === 'browser') || typeof __nccwpck_require__ === 'function'
function buildUrl (opts, client) {
  let url = opts.protocol + '://' + opts.hostname + ':' + opts.port + opts.path
  if (typeof (opts.transformWsUrl) === 'function') {
    url = opts.transformWsUrl(url, opts, client)
  }
  return url
}

function setDefaultOpts (opts) {
  let options = opts
  if (!opts.hostname) {
    options.hostname = 'localhost'
  }
  if (!opts.port) {
    if (opts.protocol === 'wss') {
      options.port = 443
    } else {
      options.port = 80
    }
  }
  if (!opts.path) {
    options.path = '/'
  }

  if (!opts.wsOptions) {
    options.wsOptions = {}
  }
  if (!IS_BROWSER && opts.protocol === 'wss') {
    // Add cert/key/ca etc options
    WSS_OPTIONS.forEach(function (prop) {
      if (opts.hasOwnProperty(prop) && !opts.wsOptions.hasOwnProperty(prop)) {
        options.wsOptions[prop] = opts[prop]
      }
    })
  }

  return options
}

function setDefaultBrowserOpts (opts) {
  let options = setDefaultOpts(opts)

  if (!options.hostname) {
    options.hostname = options.host
  }

  if (!options.hostname) {
    // Throwing an error in a Web Worker if no `hostname` is given, because we
    // can not determine the `hostname` automatically.  If connecting to
    // localhost, please supply the `hostname` as an argument.
    if (typeof (document) === 'undefined') {
      throw new Error('Could not determine host. Specify host manually.')
    }
    const parsed = new URL(document.URL)
    options.hostname = parsed.hostname

    if (!options.port) {
      options.port = parsed.port
    }
  }

  // objectMode should be defined for logic
  if (options.objectMode === undefined) {
    options.objectMode = !(options.binary === true || options.binary === undefined)
  }

  return options
}

function createWebSocket (client, url, opts) {
  debug('createWebSocket')
  debug('protocol: ' + opts.protocolId + ' ' + opts.protocolVersion)
  const websocketSubProtocol =
    (opts.protocolId === 'MQIsdp') && (opts.protocolVersion === 3)
      ? 'mqttv3.1'
      : 'mqtt'

  debug('creating new Websocket for url: ' + url + ' and protocol: ' + websocketSubProtocol)
  let socket = new WS(url, [websocketSubProtocol], opts.wsOptions)
  return socket
}

function createBrowserWebSocket (client, opts) {
  const websocketSubProtocol =
  (opts.protocolId === 'MQIsdp') && (opts.protocolVersion === 3)
    ? 'mqttv3.1'
    : 'mqtt'

  let url = buildUrl(opts, client)
  /* global WebSocket */
  let socket = new WebSocket(url, [websocketSubProtocol])
  socket.binaryType = 'arraybuffer'
  return socket
}

function streamBuilder (client, opts) {
  debug('streamBuilder')
  let options = setDefaultOpts(opts)
  const url = buildUrl(options, client)
  let socket = createWebSocket(client, url, options)
  let webSocketStream = WS.createWebSocketStream(socket, options.wsOptions)
  webSocketStream.url = url
  return webSocketStream
}

function browserStreamBuilder (client, opts) {
  debug('browserStreamBuilder')
  let stream
  let options = setDefaultBrowserOpts(opts)
  // sets the maximum socket buffer size before throttling
  const bufferSize = options.browserBufferSize || 1024 * 512

  const bufferTimeout = opts.browserBufferTimeout || 1000

  const coerceToBuffer = !opts.objectMode

  let socket = createBrowserWebSocket(client, opts)

  let proxy = buildProxy(opts, socketWriteBrowser, socketEndBrowser)

  if (!opts.objectMode) {
    proxy._writev = writev
  }
  proxy.on('close', () => { socket.close() })

  const eventListenerSupport = (typeof socket.addEventListener === 'undefined')

  // was already open when passed in
  if (socket.readyState === socket.OPEN) {
    stream = proxy
  } else {
    stream = stream = duplexify(undefined, undefined, opts)
    if (!opts.objectMode) {
      stream._writev = writev
    }

    if (eventListenerSupport) {
      socket.addEventListener('open', onopen)
    } else {
      socket.onopen = onopen
    }
  }

  stream.socket = socket

  if (eventListenerSupport) {
    socket.addEventListener('close', onclose)
    socket.addEventListener('error', onerror)
    socket.addEventListener('message', onmessage)
  } else {
    socket.onclose = onclose
    socket.onerror = onerror
    socket.onmessage = onmessage
  }

  // methods for browserStreamBuilder

  function buildProxy (options, socketWrite, socketEnd) {
    let proxy = new Transform({
      objectModeMode: options.objectMode
    })

    proxy._write = socketWrite
    proxy._flush = socketEnd

    return proxy
  }

  function onopen () {
    stream.setReadable(proxy)
    stream.setWritable(proxy)
    stream.emit('connect')
  }

  function onclose () {
    stream.end()
    stream.destroy()
  }

  function onerror (err) {
    stream.destroy(err)
  }

  function onmessage (event) {
    let data = event.data
    if (data instanceof ArrayBuffer) data = Buffer.from(data)
    else data = Buffer.from(data, 'utf8')
    proxy.push(data)
  }

  // this is to be enabled only if objectMode is false
  function writev (chunks, cb) {
    const buffers = new Array(chunks.length)
    for (let i = 0; i < chunks.length; i++) {
      if (typeof chunks[i].chunk === 'string') {
        buffers[i] = Buffer.from(chunks[i], 'utf8')
      } else {
        buffers[i] = chunks[i].chunk
      }
    }

    this._write(Buffer.concat(buffers), 'binary', cb)
  }

  function socketWriteBrowser (chunk, enc, next) {
    if (socket.bufferedAmount > bufferSize) {
      // throttle data until buffered amount is reduced.
      setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next)
    }

    if (coerceToBuffer && typeof chunk === 'string') {
      chunk = Buffer.from(chunk, 'utf8')
    }

    try {
      socket.send(chunk)
    } catch (err) {
      return next(err)
    }

    next()
  }

  function socketEndBrowser (done) {
    socket.close()
    done()
  }

  // end methods for browserStreamBuilder

  return stream
}

if (IS_BROWSER) {
  module.exports = browserStreamBuilder
} else {
  module.exports = streamBuilder
}


/***/ }),

/***/ 4720:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var Transform = __nccwpck_require__(1394).Transform
var duplexify = __nccwpck_require__(3265)

/* global wx */
var socketTask
var proxy
var stream

function buildProxy () {
  var proxy = new Transform()
  proxy._write = function (chunk, encoding, next) {
    socketTask.send({
      data: chunk.buffer,
      success: function () {
        next()
      },
      fail: function (errMsg) {
        next(new Error(errMsg))
      }
    })
  }
  proxy._flush = function socketEnd (done) {
    socketTask.close({
      success: function () {
        done()
      }
    })
  }

  return proxy
}

function setDefaultOpts (opts) {
  if (!opts.hostname) {
    opts.hostname = 'localhost'
  }
  if (!opts.path) {
    opts.path = '/'
  }

  if (!opts.wsOptions) {
    opts.wsOptions = {}
  }
}

function buildUrl (opts, client) {
  var protocol = opts.protocol === 'wxs' ? 'wss' : 'ws'
  var url = protocol + '://' + opts.hostname + opts.path
  if (opts.port && opts.port !== 80 && opts.port !== 443) {
    url = protocol + '://' + opts.hostname + ':' + opts.port + opts.path
  }
  if (typeof (opts.transformWsUrl) === 'function') {
    url = opts.transformWsUrl(url, opts, client)
  }
  return url
}

function bindEventHandler () {
  socketTask.onOpen(function () {
    stream.setReadable(proxy)
    stream.setWritable(proxy)
    stream.emit('connect')
  })

  socketTask.onMessage(function (res) {
    var data = res.data

    if (data instanceof ArrayBuffer) data = Buffer.from(data)
    else data = Buffer.from(data, 'utf8')
    proxy.push(data)
  })

  socketTask.onClose(function () {
    stream.end()
    stream.destroy()
  })

  socketTask.onError(function (res) {
    stream.destroy(new Error(res.errMsg))
  })
}

function buildStream (client, opts) {
  opts.hostname = opts.hostname || opts.host

  if (!opts.hostname) {
    throw new Error('Could not determine host. Specify host manually.')
  }

  var websocketSubProtocol =
    (opts.protocolId === 'MQIsdp') && (opts.protocolVersion === 3)
      ? 'mqttv3.1'
      : 'mqtt'

  setDefaultOpts(opts)

  var url = buildUrl(opts, client)
  socketTask = wx.connectSocket({
    url: url,
    protocols: [websocketSubProtocol]
  })

  proxy = buildProxy()
  stream = duplexify.obj()
  stream._destroy = function (err, cb) {
    socketTask.close({
      success: function () {
        cb && cb(err)
      }
    })
  }

  var destroyRef = stream.destroy
  stream.destroy = function () {
    stream.destroy = destroyRef

    var self = this
    setTimeout(function () {
      socketTask.close({
        fail: function () {
          self._destroy(new Error())
        }
      })
    }, 0)
  }.bind(stream)

  bindEventHandler()

  return stream
}

module.exports = buildStream


/***/ }),

/***/ 3963:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


/**
 * Module dependencies
 */
var xtend = __nccwpck_require__(6738)

var Readable = __nccwpck_require__(1394).Readable
var streamsOpts = { objectMode: true }
var defaultStoreOptions = {
  clean: true
}

/**
 * In-memory implementation of the message store
 * This can actually be saved into files.
 *
 * @param {Object} [options] - store options
 */
function Store (options) {
  if (!(this instanceof Store)) {
    return new Store(options)
  }

  this.options = options || {}

  // Defaults
  this.options = xtend(defaultStoreOptions, options)

  this._inflights = new Map()
}

/**
 * Adds a packet to the store, a packet is
 * anything that has a messageId property.
 *
 */
Store.prototype.put = function (packet, cb) {
  this._inflights.set(packet.messageId, packet)

  if (cb) {
    cb()
  }

  return this
}

/**
 * Creates a stream with all the packets in the store
 *
 */
Store.prototype.createStream = function () {
  var stream = new Readable(streamsOpts)
  var destroyed = false
  var values = []
  var i = 0

  this._inflights.forEach(function (value, key) {
    values.push(value)
  })

  stream._read = function () {
    if (!destroyed && i < values.length) {
      this.push(values[i++])
    } else {
      this.push(null)
    }
  }

  stream.destroy = function () {
    if (destroyed) {
      return
    }

    var self = this

    destroyed = true

    setTimeout(function () {
      self.emit('close')
    }, 0)
  }

  return stream
}

/**
 * deletes a packet from the store.
 */
Store.prototype.del = function (packet, cb) {
  packet = this._inflights.get(packet.messageId)
  if (packet) {
    this._inflights.delete(packet.messageId)
    cb(null, packet)
  } else if (cb) {
    cb(new Error('missing packet'))
  }

  return this
}

/**
 * get a packet from the store.
 */
Store.prototype.get = function (packet, cb) {
  packet = this._inflights.get(packet.messageId)
  if (packet) {
    cb(null, packet)
  } else if (cb) {
    cb(new Error('missing packet'))
  }

  return this
}

/**
 * Close the store
 */
Store.prototype.close = function (cb) {
  if (this.options.clean) {
    this._inflights = null
  }
  if (cb) {
    cb()
  }
}

module.exports = Store


/***/ }),

/***/ 1768:
/***/ ((module) => {

"use strict";


/**
 * Validate a topic to see if it's valid or not.
 * A topic is valid if it follow below rules:
 * - Rule #1: If any part of the topic is not `+` or `#`, then it must not contain `+` and '#'
 * - Rule #2: Part `#` must be located at the end of the mailbox
 *
 * @param {String} topic - A topic
 * @returns {Boolean} If the topic is valid, returns true. Otherwise, returns false.
 */
function validateTopic (topic) {
  var parts = topic.split('/')

  for (var i = 0; i < parts.length; i++) {
    if (parts[i] === '+') {
      continue
    }

    if (parts[i] === '#') {
      // for Rule #2
      return i === parts.length - 1
    }

    if (parts[i].indexOf('+') !== -1 || parts[i].indexOf('#') !== -1) {
      return false
    }
  }

  return true
}

/**
 * Validate an array of topics to see if any of them is valid or not
  * @param {Array} topics - Array of topics
 * @returns {String} If the topics is valid, returns null. Otherwise, returns the invalid one
 */
function validateTopics (topics) {
  if (topics.length === 0) {
    return 'empty_topic_list'
  }
  for (var i = 0; i < topics.length; i++) {
    if (!validateTopic(topics[i])) {
      return topics[i]
    }
  }
  return null
}

module.exports = {
  validateTopics: validateTopics
}


/***/ }),

/***/ 5173:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*
 * Copyright (c) 2015-2015 MQTT.js contributors.
 * Copyright (c) 2011-2014 Adam Rudd.
 *
 * See LICENSE for more information
 */

var MqttClient = __nccwpck_require__(730)
var connect = __nccwpck_require__(1745)
var Store = __nccwpck_require__(3963)

module.exports.connect = connect

// Expose MqttClient
module.exports.MqttClient = MqttClient
module.exports.Client = MqttClient
module.exports.Store = Store


/***/ }),

/***/ 3321:
/***/ ((module) => {

"use strict";


const codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error
  }

  function getMessage (arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message
    } else {
      return message(arg1, arg2, arg3)
    }
  }

  class NodeError extends Base {
    constructor (arg1, arg2, arg3) {
      super(getMessage(arg1, arg2, arg3));
    }
  }

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;

  codes[code] = NodeError;
}

// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    const len = expected.length;
    expected = expected.map((i) => String(i));
    if (len > 2) {
      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` +
             expected[len - 1];
    } else if (len === 2) {
      return `one of ${thing} ${expected[0]} or ${expected[1]}`;
    } else {
      return `of ${thing} ${expected[0]}`;
    }
  } else {
    return `of ${thing} ${String(expected)}`;
  }
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
	return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
	if (this_len === undefined || this_len > str.length) {
		this_len = str.length;
	}
	return str.substring(this_len - search.length, this_len) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"'
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  let determiner;
  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  let msg;
  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;
  } else {
    const type = includes(name, '.') ? 'property' : 'argument';
    msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, 'type')}`;
  }

  msg += `. Received type ${typeof actual}`;
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented'
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');

module.exports.q = codes;


/***/ }),

/***/ 5188:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = __nccwpck_require__(9274);

var Writable = __nccwpck_require__(2857);

__nccwpck_require__(6919)(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

/***/ }),

/***/ 8673:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.


module.exports = PassThrough;

var Transform = __nccwpck_require__(8419);

__nccwpck_require__(6919)(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ 9274:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = __nccwpck_require__(8614).EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = __nccwpck_require__(4207);
/*</replacement>*/


var Buffer = __nccwpck_require__(4293).Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = __nccwpck_require__(1669);

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = __nccwpck_require__(2448);

var destroyImpl = __nccwpck_require__(3397);

var _require = __nccwpck_require__(6729),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = __nccwpck_require__(3321)/* .codes */ .q,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

__nccwpck_require__(6919)(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || __nccwpck_require__(5188);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __nccwpck_require__(5280)/* .StringDecoder */ .s;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __nccwpck_require__(5188);
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __nccwpck_require__(5280)/* .StringDecoder */ .s;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = __nccwpck_require__(2972);
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = __nccwpck_require__(178);
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}

/***/ }),

/***/ 8419:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.


module.exports = Transform;

var _require$codes = __nccwpck_require__(3321)/* .codes */ .q,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = __nccwpck_require__(5188);

__nccwpck_require__(6919)(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}

/***/ }),

/***/ 2857:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: __nccwpck_require__(9209)
};
/*</replacement>*/

/*<replacement>*/

var Stream = __nccwpck_require__(4207);
/*</replacement>*/


var Buffer = __nccwpck_require__(4293).Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = __nccwpck_require__(3397);

var _require = __nccwpck_require__(6729),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = __nccwpck_require__(3321)/* .codes */ .q,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

__nccwpck_require__(6919)(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || __nccwpck_require__(5188);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __nccwpck_require__(5188); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};

/***/ }),

/***/ 2972:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = __nccwpck_require__(4340);

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;

/***/ }),

/***/ 2448:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = __nccwpck_require__(4293),
    Buffer = _require.Buffer;

var _require2 = __nccwpck_require__(1669),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();

/***/ }),

/***/ 3397:
/***/ ((module) => {

"use strict";
 // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};

/***/ }),

/***/ 4340:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).


var ERR_STREAM_PREMATURE_CLOSE = __nccwpck_require__(3321)/* .codes.ERR_STREAM_PREMATURE_CLOSE */ .q.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;

/***/ }),

/***/ 178:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ERR_INVALID_ARG_TYPE = __nccwpck_require__(3321)/* .codes.ERR_INVALID_ARG_TYPE */ .q.ERR_INVALID_ARG_TYPE;

function from(Readable, iterable, opts) {
  var iterator;

  if (iterable && typeof iterable.next === 'function') {
    iterator = iterable;
  } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();else throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable);

  var readable = new Readable(_objectSpread({
    objectMode: true
  }, opts)); // Reading boolean to protect against _read
  // being called before last iteration completion.

  var reading = false;

  readable._read = function () {
    if (!reading) {
      reading = true;
      next();
    }
  };

  function next() {
    return _next2.apply(this, arguments);
  }

  function _next2() {
    _next2 = _asyncToGenerator(function* () {
      try {
        var _ref = yield iterator.next(),
            value = _ref.value,
            done = _ref.done;

        if (done) {
          readable.push(null);
        } else if (readable.push((yield value))) {
          next();
        } else {
          reading = false;
        }
      } catch (err) {
        readable.destroy(err);
      }
    });
    return _next2.apply(this, arguments);
  }

  return readable;
}

module.exports = from;

/***/ }),

/***/ 9952:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).


var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = __nccwpck_require__(3321)/* .codes */ .q,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = __nccwpck_require__(4340);
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;

/***/ }),

/***/ 6729:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var ERR_INVALID_OPT_VALUE = __nccwpck_require__(3321)/* .codes.ERR_INVALID_OPT_VALUE */ .q.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};

/***/ }),

/***/ 4207:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(2413);


/***/ }),

/***/ 1394:
/***/ ((module, exports, __nccwpck_require__) => {

var Stream = __nccwpck_require__(2413);
if (process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream.Readable;
  Object.assign(module.exports, Stream);
  module.exports.Stream = Stream;
} else {
  exports = module.exports = __nccwpck_require__(9274);
  exports.Stream = Stream || exports;
  exports.Readable = exports;
  exports.Writable = __nccwpck_require__(2857);
  exports.Duplex = __nccwpck_require__(5188);
  exports.Transform = __nccwpck_require__(8419);
  exports.PassThrough = __nccwpck_require__(8673);
  exports.finished = __nccwpck_require__(4340);
  exports.pipeline = __nccwpck_require__(9952);
}


/***/ }),

/***/ 5280:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = __nccwpck_require__(3118).Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.s = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ 8634:
/***/ ((__unused_webpack_module, exports) => {

var prefix = function (name) {
  return '_' + name
}

var defined = function (name) {
  return name
}

exports.stringify = function (data) {
  if (typeof data === 'object' && data && data.name) return exports.stringify(data.name, data.protocol, data.subtypes)
  return Array.prototype.concat.apply([], arguments).filter(defined).map(prefix).join('.')
}

exports.parse = function (str) {
  var parts = str.split('.')

  for (var i = 0; i < parts.length; i++) {
    if (parts[i][0] !== '_') continue
    parts[i] = parts[i].slice(1)
  }

  return {
    name: parts.shift(),
    protocol: parts.shift() || null,
    subtypes: parts
  }
}

exports.tcp = function (name) {
  return exports.stringify(name, 'tcp', Array.prototype.concat.apply([], Array.prototype.slice.call(arguments, 1)))
}

exports.udp = function (name) {
  return exports.stringify(name, 'udp', Array.prototype.concat.apply([], Array.prototype.slice.call(arguments, 1)))
}


/***/ }),

/***/ 2870:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var packet = __nccwpck_require__(8667)
var dgram = __nccwpck_require__(6200)
var thunky = __nccwpck_require__(85)
var events = __nccwpck_require__(8614)
var os = __nccwpck_require__(2087)

var noop = function () {}

module.exports = function (opts) {
  if (!opts) opts = {}

  var that = new events.EventEmitter()
  var port = typeof opts.port === 'number' ? opts.port : 5353
  var type = opts.type || 'udp4'
  var ip = opts.ip || opts.host || (type === 'udp4' ? '224.0.0.251' : null)
  var me = {address: ip, port: port}
  var memberships = {}
  var destroyed = false
  var interval = null

  if (type === 'udp6' && (!ip || !opts.interface)) {
    throw new Error('For IPv6 multicast you must specify `ip` and `interface`')
  }

  var socket = opts.socket || dgram.createSocket({
    type: type,
    reuseAddr: opts.reuseAddr !== false,
    toString: function () {
      return type
    }
  })

  socket.on('error', function (err) {
    if (err.code === 'EACCES' || err.code === 'EADDRINUSE') that.emit('error', err)
    else that.emit('warning', err)
  })

  socket.on('message', function (message, rinfo) {
    try {
      message = packet.decode(message)
    } catch (err) {
      that.emit('warning', err)
      return
    }

    that.emit('packet', message, rinfo)

    if (message.type === 'query') that.emit('query', message, rinfo)
    if (message.type === 'response') that.emit('response', message, rinfo)
  })

  socket.on('listening', function () {
    if (!port) port = me.port = socket.address().port
    if (opts.multicast !== false) {
      that.update()
      interval = setInterval(that.update, 5000)
      socket.setMulticastTTL(opts.ttl || 255)
      socket.setMulticastLoopback(opts.loopback !== false)
    }
  })

  var bind = thunky(function (cb) {
    if (!port || opts.bind === false) return cb(null)
    socket.once('error', cb)
    socket.bind(port, opts.bind || opts.interface, function () {
      socket.removeListener('error', cb)
      cb(null)
    })
  })

  bind(function (err) {
    if (err) return that.emit('error', err)
    that.emit('ready')
  })

  that.send = function (value, rinfo, cb) {
    if (typeof rinfo === 'function') return that.send(value, null, rinfo)
    if (!cb) cb = noop
    if (!rinfo) rinfo = me
    else if (!rinfo.host && !rinfo.address) rinfo.address = me.address

    bind(onbind)

    function onbind (err) {
      if (destroyed) return cb()
      if (err) return cb(err)
      var message = packet.encode(value)
      socket.send(message, 0, message.length, rinfo.port, rinfo.address || rinfo.host, cb)
    }
  }

  that.response =
  that.respond = function (res, rinfo, cb) {
    if (Array.isArray(res)) res = {answers: res}

    res.type = 'response'
    res.flags = (res.flags || 0) | packet.AUTHORITATIVE_ANSWER
    that.send(res, rinfo, cb)
  }

  that.query = function (q, type, rinfo, cb) {
    if (typeof type === 'function') return that.query(q, null, null, type)
    if (typeof type === 'object' && type && type.port) return that.query(q, null, type, rinfo)
    if (typeof rinfo === 'function') return that.query(q, type, null, rinfo)
    if (!cb) cb = noop

    if (typeof q === 'string') q = [{name: q, type: type || 'ANY'}]
    if (Array.isArray(q)) q = {type: 'query', questions: q}

    q.type = 'query'
    that.send(q, rinfo, cb)
  }

  that.destroy = function (cb) {
    if (!cb) cb = noop
    if (destroyed) return process.nextTick(cb)
    destroyed = true
    clearInterval(interval)
    socket.once('close', cb)
    socket.close()
  }

  that.update = function () {
    var ifaces = opts.interface ? [].concat(opts.interface) : allInterfaces()
    var updated = false

    for (var i = 0; i < ifaces.length; i++) {
      var addr = ifaces[i]

      if (memberships[addr]) continue
      memberships[addr] = true
      updated = true

      try {
        socket.addMembership(ip, addr)
      } catch (err) {
        that.emit('warning', err)
      }
    }

    if (!updated || !socket.setMulticastInterface) return
    socket.setMulticastInterface(opts.interface || defaultInterface())
  }

  return that
}

function defaultInterface () {
  var networks = os.networkInterfaces()
  var names = Object.keys(networks)

  for (var i = 0; i < names.length; i++) {
    var net = networks[names[i]]
    for (var j = 0; j < net.length; j++) {
      var iface = net[j]
      if (iface.family === 'IPv4' && !iface.internal) {
        if (os.platform() === 'darwin' && names[i] === 'en0') return iface.address
        return '0.0.0.0'
      }
    }
  }

  return '127.0.0.1'
}

function allInterfaces () {
  var networks = os.networkInterfaces()
  var names = Object.keys(networks)
  var res = []

  for (var i = 0; i < names.length; i++) {
    var net = networks[names[i]]
    for (var j = 0; j < net.length; j++) {
      var iface = net[j]
      if (iface.family === 'IPv4') {
        res.push(iface.address)
        // could only addMembership once per interface (https://nodejs.org/api/dgram.html#dgram_socket_addmembership_multicastaddress_multicastinterface)
        break
      }
    }
  }

  return res
}


/***/ }),

/***/ 7137:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var path = __nccwpck_require__(5622);
var fs = __nccwpck_require__(5747);
var _0777 = parseInt('0777', 8);

module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

function mkdirP (p, opts, f, made) {
    if (typeof opts === 'function') {
        f = opts;
        opts = {};
    }
    else if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    
    if (mode === undefined) {
        mode = _0777
    }
    if (!made) made = null;
    
    var cb = f || function () {};
    p = path.resolve(p);
    
    xfs.mkdir(p, mode, function (er) {
        if (!er) {
            made = made || p;
            return cb(null, made);
        }
        switch (er.code) {
            case 'ENOENT':
                if (path.dirname(p) === p) return cb(er);
                mkdirP(path.dirname(p), opts, function (er, made) {
                    if (er) cb(er, made);
                    else mkdirP(p, opts, cb, made);
                });
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                xfs.stat(p, function (er2, stat) {
                    // if the stat fails, then that's super weird.
                    // let the original error be the failure reason.
                    if (er2 || !stat.isDirectory()) cb(er, made)
                    else cb(null, made);
                });
                break;
        }
    });
}

mkdirP.sync = function sync (p, opts, made) {
    if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    
    if (mode === undefined) {
        mode = _0777
    }
    if (!made) made = null;

    p = path.resolve(p);

    try {
        xfs.mkdirSync(p, mode);
        made = made || p;
    }
    catch (err0) {
        switch (err0.code) {
            case 'ENOENT' :
                made = sync(path.dirname(p), opts, made);
                sync(p, opts, made);
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                var stat;
                try {
                    stat = xfs.statSync(p);
                }
                catch (err1) {
                    throw err0;
                }
                if (!stat.isDirectory()) throw err0;
                break;
        }
    }

    return made;
};


/***/ }),

/***/ 6178:
/***/ ((module) => {

// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (true) {
        module.exports = definition();

    // RequireJS
    } else {}

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;

    function flush() {
        /* jshint loopfunc: true */

        while (head.next) {
            head = head.next;
            var task = head.task;
            head.task = void 0;
            var domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }

            try {
                task();

            } catch (e) {
                if (isNodeJS) {
                    // In node, uncaught exceptions are considered fatal errors.
                    // Re-throw them synchronously to interrupt flushing!

                    // Ensure continuation if the uncaught exception is suppressed
                    // listening "uncaughtException" events (as domains does).
                    // Continue in next event to avoid tick recursion.
                    if (domain) {
                        domain.exit();
                    }
                    setTimeout(flush, 0);
                    if (domain) {
                        domain.enter();
                    }

                    throw e;

                } else {
                    // In browsers, uncaught exceptions are not fatal.
                    // Re-throw them asynchronously to avoid slow-downs.
                    setTimeout(function() {
                       throw e;
                    }, 0);
                }
            }

            if (domain) {
                domain.exit();
            }
        }

        flushing = false;
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process !== "undefined" && process.nextTick) {
        // Node.js before 0.9. Note that some fake-Node environments, like the
        // Mocha test runner, introduce a `process` global without a `nextTick`.
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }

    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you don’t need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Miller’s explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack) {
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (value instanceof Promise) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

// enable long stacks if Q_DEBUG is set
if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
    Q.longStackSupport = true;
}

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            Q.nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    };

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, function (undefined, message) {
            Q.nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            Q.nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.Promise = promise; // ES6
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

promise.race = race; // ES6
promise.all = all; // ES6
promise.reject = reject; // ES6
promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become settled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be settled
 */
Q.race = race;
function race(answerPs) {
    return promise(function(resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function(answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        };
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    Q.nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

Q.tap = function (promise, callback) {
    return Q(promise).tap(callback);
};

/**
 * Works almost like "finally", but not called for rejections.
 * Original resolution value is passed through callback unaffected.
 * Callback may return a promise that will be awaited for.
 * @param {Function} callback
 * @returns {Q.Promise}
 * @example
 * doSomething()
 *   .then(...)
 *   .tap(console.log)
 *   .then(...);
 */
Promise.prototype.tap = function (callback) {
    callback = Q(callback);

    return this.then(function (value) {
        return callback.fcall(value).thenResolve(value);
    });
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If it’s a fulfilled promise, the fulfillment value is nearer.
 * If it’s a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return object instanceof Promise;
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var trackUnhandledRejections = true;

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    Q.nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;

            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
            // engine that has a deployed base of browsers that support generators.
            // However, SM's generators use the Python-inspired semantics of
            // outdated ES6 drafts.  We would like to support ES6, but we'd also
            // like to make it possible to use generators in deployed browsers, so
            // we also support Python-style generators.  At some point we can remove
            // this block.

            if (typeof StopIteration === "undefined") {
                // ES6 Generators
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return Q(result.value);
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // SpiderMonkey Generators
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return Q(exception.value);
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    Q.nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var countDown = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++countDown;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--countDown === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (countDown === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        Q.nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {Any*} custom error message or Error object (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, error) {
    return Q(object).timeout(ms, error);
};

Promise.prototype.timeout = function (ms, error) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            Q.nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            Q.nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});


/***/ }),

/***/ 3406:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*
 * Simon Last, Sept 2013
 * http://simonlast.org
 */

var fs     = __nccwpck_require__(5747),
    path   = __nccwpck_require__(5622),
    mkdirp = __nccwpck_require__(7137),
    Q      = __nccwpck_require__(6178),

    defaults = {
        dir: 'persist',
        stringify: JSON.stringify,
        parse: JSON.parse,
        encoding: 'utf8',
        logging: false,
        continuous: true,
        interval: false,
        ttl: false
    },

    defaultTTL = 24 * 60 * 60 * 1000 /* ttl is truthy but not a number ? 24h default */,

    isNumber = function(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    },

    isFunction = function(fn) {
        return typeof fn === 'function';
    },

    noop = function(err) {
        if (err) throw err;
    },

    /*
     * To support backward compatible callbacks,
     * i.e callback(data) vs callback(err, data);
     * replace with noop and fix args order, when ready to break backward compatibily for the following API functions
     * - values()
     * - valuesWithKeyMatch()
     * hint: look for 'todo-breaks-backward' in the source
     */
    noopWithoutError = function() {};

var LocalStorage = function (userOptions) {
    if(!(this instanceof LocalStorage)) {
        return new LocalStorage(userOptions);
    }
    this.data = {};
    this.ttls = {};
    this.changes = {};
    this.setOptions(userOptions);

    // we don't call init in the constructor because we can only so for the initSync
    // for init async, it returns a promise, and in order to maintain that API, we cannot return the promise in the constructor
    // so init must be called on the instance of new LocalStorage();
};

LocalStorage.prototype = {

    setOptions: function (userOptions) {
        var options = {};

        if (!userOptions) {
            options = defaults;
        } else {
            for (var key in defaults) {
                if (userOptions.hasOwnProperty(key)) {
                    options[key] = userOptions[key];
                } else {
                    options[key] = defaults[key];
                }
            }

            // dir is not absolute
            options.dir = this.resolveDir(options.dir);
            options.ttlDir = options.dir + '-ttl';
            options.ttl = options.ttl ? isNumber(options.ttl) && options.ttl > 0 ? options.ttl : defaultTTL : false;
        }

        // Check to see if we received an external logging function
        if (isFunction(options.logging)) {
            // Overwrite log function with external logging function
            this.log = options.logging;
            options.logging = true;
        }

        this.options = options;
    },

    init: function (userOptions, callback) {
        if (isFunction(userOptions)) {
            callback = userOptions;
            userOptions = null;
        }
        if (userOptions) {
            this.setOptions(userOptions);
        }
        callback = isFunction(callback) ? callback : noop;

        var deferred = Q.defer();
        var deferreds = [];

        var options = this.options;

        var result = {dir: options.dir};
        deferreds.push(this.parseDataDir());

        if (options.ttl) {
            result.ttlDir = options.ttlDir;
            deferreds.push(this.parseTTLDir());
        }

        //start persisting
        if (options.interval && options.interval > 0) {
            this._persistInterval = setInterval(this.persist.bind(this), options.interval);
        }

        Q.all(deferreds).then(
            function() {
                deferred.resolve(result);
                callback(null, result);
            },
            function(err) {
                deferred.reject(err);
                callback(err);
            });

        return deferred.promise;
    },

    initSync: function (userOptions) {
        if (userOptions) {
            this.setOptions(userOptions);
        }

        var options = this.options;

        if (options.logging) {
            this.log("options:");
            this.log(options.stringify(options));
        }

        this.parseDataDirSync();

        if (options.ttl) {
            this.parseTTLDirSync();
        }

        //start synchronous persisting,
        if (options.interval && options.interval > 0) {
            this._persistInterval = setInterval(this.persistSync.bind(this), options.interval);
        }
    },

    key: function (n) {
        // todo-breaks-backward: remove this function
        // this is fragile, keys are not guaranteed to be in a any order, so 2 calls using the same index could return a different result
        // http://stackoverflow.com/a/5525820/493756, see the ECMAScript source in that answer
        var keys = this.keys();
        if (keys.length <= n) {
            return null;
        }
        return keys[n];
    },

    keys: function () {
        return Object.keys(this.data);
    },

    length: function () {
        return this.keys().length;
    },

    forEach: function(callback) {
        return this.keys().forEach(function(key) {
            callback(key, this.data[key]);
        }.bind(this));
    },

    values: function(callback) {

        // todo-breaks-backward: remove callback option
        callback = isFunction(callback) ? callback : noopWithoutError;

        var values = this.keys().map(function(k) {
            return this.data[k];
        }.bind(this));

        // todo-breaks-backward: remove callback, no need, this is sync
        callback(values);

        return values;
    },


    valuesWithKeyMatch: function(match, callback) {
        // todo-breaks-backward: remove callback option
        callback = isFunction(callback) ? callback : noopWithoutError;

        match = match || /.*/;

        var filter = match instanceof RegExp ?
            function(key) {
                return match.test(key);
            } :
            function(key) {
                return match.indexOf(key) !== -1;
            };

        var values = [];
        this.keys().forEach(function(k) {
            if (filter(k)) {
                values.push(this.data[k]);
            }
        }.bind(this));

        // todo-breaks-backward: remove callback, no need this is sync
        callback(values);
        return values;
    },

    setItem: function (key, value, callback) {
        callback = isFunction(callback) ? callback : noop;

        var options = this.options;
        var result;
        var logmsg = "set (" + key + ": " + options.stringify(value) + ")";

        var deferred = Q.defer();
        var deferreds = [];

        this.data[key] = value;
        if (options.ttl) {
            this.ttls[key] = new Date().getTime() + options.ttl;
        }

        result = {key: key, value: value, queued: !!options.interval, manual: !options.interval && !options.continuous};

        var onSuccess = function () {
            callback(null, result);
            deferred.resolve(result);
        };

        var onError = function (err) {
            callback(err);
            deferred.reject(err);
        };

        this.log(logmsg);

        if (options.interval || !options.continuous) {
            this.changes[key] = {onSuccess: onSuccess, onError: onError};
        } else {
            deferreds.push(this.persistKey(key));

            Q.all(deferreds).then(
                function(result) {
                    deferred.resolve(result);
                    callback(null, result);
                }.bind(this),
                function(err) {
                    deferred.reject(err);
                    callback(err);
                });
        }

        return deferred.promise;
    },

    setItemSync: function (key, value) {
        this.data[key] = value;
        if (this.options.ttl) {
            this.ttls[key] = new Date().getTime() + this.options.ttl;
        }
        this.persistKeySync(key);
        this.log("set (" + key + ": " + this.options.stringify(value) + ")");
    },

    getItem: function (key, callback) {
        callback = isFunction(callback) ? callback : noop;
        if (this.isExpired(key)) {
            this.log(key + ' has expired');
            if (this.options.interval || !this.options.continuous) {
                callback(null, null);
                return;
            }
            this.removeItem(key, function() {
                callback(null, null);
            });
        } else {
            callback(null, this.data[key]);
            return this.data[key];
        }
    },

    getItemSync: function (key) {
        if (this.isExpired(key)) {
            this.removeItemSync(key);
        } else {
            return this.data[key];
        }
    },

    removeItem: function (key, callback) {
        callback = isFunction(callback) ? callback : noop;

        var deferred = Q.defer();
        var deferreds = [];

        deferreds.push(this.removePersistedKey(key));

        Q.all(deferreds).then(
            function() {
                delete this.data[key];
                delete this.ttls[key];
                this.log('removed: ' + key);
                callback(null, this.data);
                deferred.resolve(this.data);
            }.bind(this),
            function(err) {
                callback(err);
                deferred.reject(err);
            }
        );

        return deferred.promise;
    },

    removeItemSync: function (key) {
        this.removePersistedKeySync(key);
        delete this.data[key];
        delete this.ttls[key];
        this.log('removed: ' + key);
    },

    clear: function (callback) {
        callback = isFunction(callback) ? callback : noop;

        var deferred = Q.defer();
        var result;
        var deferreds = [];

        var keys = this.keys();
        for (var i = 0; i < keys.length; i++) {
            deferreds.push(this.removePersistedKey(keys[i]));
        }

        Q.all(deferreds).then(
            function(result) {
                this.data = {};
                this.ttls = {};
                this.changes = {};
                deferred.resolve(result);
                callback(null, result);
            }.bind(this),
            function(err) {
                deferred.reject(err);
                callback(err);
            });

        return deferred.promise;
    },

    clearSync: function () {
        var keys = this.keys(true);
        for (var i = 0; i < keys.length; i++) {
            this.removePersistedKeySync(keys[i]);
        }
        this.data = {};
        this.ttls = {};
        this.changes = {};
    },

    persist: function (callback) {
        callback = isFunction(callback) ? callback : noop;

        var deferred = Q.defer();
        var result;
        var deferreds = [];

        for (var key in this.data) {
            if (this.changes[key]) {
                deferreds.push(this.persistKey(key));
            }
        }

        Q.all(deferreds).then(
            function(result) {
                deferred.resolve(result);
                callback(null, result);
                this.log('persist done');
            }.bind(this),
            function(err) {
                deferred.reject(result);
                callback(err);
            });

        return deferred.promise;
    },

    persistSync: function () {
        for (var key in this.data) {
            if (this.changes[key]) {
                this.persistKeySync(key);
            }
        }
        this.log('persistSync done');
    },

    /*
     * This function triggers a key within the database to persist asynchronously.
     */
    persistKey: function (key, callback) {
        callback = isFunction(callback) ? callback : noop;

        var self = this;
        var options = this.options;
        var json = options.stringify(this.data[key]);

        var file = path.join(options.dir, key);
        var ttlFile;

        var deferred = Q.defer();
        var result;

        var fail = function(err) {
            self.changes[key] && self.changes[key].onError && self.changes[key].onError(err);
            deferred.reject(err);
            return callback(err);
        };

        var done = function() {
            self.changes[key] && self.changes[key].onSuccess && self.changes[key].onSuccess();
            delete self.changes[key];
            self.log("wrote: " + key);
            result = {key: key, data: json, file: file};
            deferred.resolve(result);
            callback(null, result);
        };

        mkdirp(path.dirname(file), function(err) {
            if (err) {
                fail(err);
            }
            fs.writeFile(file, json, options.encoding, function(err) {
                if (err) {
                    fail(err);
                }
                if (options.ttl) {
                    ttlFile = path.join(options.ttlDir, key);
                    mkdirp(path.dirname(ttlFile), function(err) {
                        fs.writeFile(ttlFile, options.stringify(self.ttls[key]), options.encoding, function() {
                            if (err) {
                                fail(err);
                            } else {
                                done();
                            }
                        });
                    });
                } else {
                    done();
                }
            }.bind(this));
        });

        return deferred.promise;
    },

    persistKeySync: function (key) {
        var options = this.options;
        var file = path.join(options.dir, key);
        try {
            mkdirp.sync(path.dirname(file));
            fs.writeFileSync(file, options.stringify(this.data[key]));
            this.changes[key] && this.changes[key].onSuccess && this.changes[key].onSuccess();
        } catch (e) {
            this.changes[key] && this.changes[key].onError && this.changes[key].onError(e);
            throw e;
        }

        var ttlFile;
        if (options.ttl) {
            ttlFile = path.join(options.ttlDir, key);
            mkdirp.sync(path.dirname(ttlFile));
            fs.writeFileSync(ttlFile, options.stringify(this.ttls[key]));
        }

        delete this.changes[key];
        this.log("wrote: " + key);
    },

    removePersistedKey: function (key, callback) {
        callback = isFunction(callback) ? callback : noop;

        var options = this.options;
        var deferred = Q.defer();
        var result;

        //check to see if key has been persisted
        var file = path.join(options.dir, key);
        fs.exists(file, function (exists) {
            if (exists) {
                fs.unlink(file, function (err) {
                    result = {key: key, removed: !err, exists: true};

                    var fail = function(err) {
                        deferred.reject(err);
                        callback(err);
                    };

                    var done = function() {
                        deferred.resolve(result);
                        callback(null, result);
                    };

                    if (err) {
                        return fail(err);
                    }

                    if (options.ttl) {
                        var ttlFile = path.join(options.ttlDir, key);
                        fs.exists(ttlFile, function (exists) {
                            if (exists) {
                                fs.unlink(ttlFile, function (err) {
                                    if (err) {
                                        fail(err);
                                    }
                                    done();
                                });
                            } else {
                                done();
                            }
                        });
                    } else {
                        done();
                    }
                });
            } else {
                result = {key: key, removed: false, exists: false};
                deferred.resolve(result);
                callback(null, result);
            }
        });

        return deferred.promise;
    },

    parseString: function(str){
        try {
            return this.options.parse(str);
        } catch(e) {
            this.log("parse error: ", this.options.stringify(e));
            return undefined;
        }
    },

    parseTTLDir: function(callback) {
        return this.parseDir(this.options.ttlDir, this.parseTTLFile.bind(this), callback);
    },

    parseTTLDirSync: function() {
        return this.parseDirSync(this.options.ttlDir, this.ttls);
    },

    parseDataDir: function(callback) {
        return this.parseDir(this.options.dir, this.parseDataFile.bind(this), callback);
    },

    parseDataDirSync: function() {
        return this.parseDirSync(this.options.dir, this.data);
    },

    parseDir: function(dir, parseFn, callback) {
        callback = isFunction(callback) ? callback : noop;

        var deferred = Q.defer();
        var deferreds = [];

        var result = {dir: dir};
        //check to see if dir is present
        fs.exists(dir, function (exists) {
            if (exists) {
                //load data
                fs.readdir(dir, function (err, arr) {
                    if (err) {
                        deferred.reject(err);
                        callback(err);
                    }

                    for (var i in arr) {
                        var curr = arr[i];
                        if (curr[0] !== '.') {
                            deferreds.push(parseFn(curr));
                        }
                    }

                    Q.all(deferreds).then(
                        function() {
                            deferred.resolve(result);
                            callback(null, result);
                        },
                        function(err) {
                            deferred.reject(err);
                            callback(err);
                        });

                }.bind(this));
            } else {
                //create the directory
                mkdirp(dir, function (err) {
                    if (err) {
                        console.error(err);
                        deferred.reject(err);
                        callback(err);
                    } else {
                        this.log('created ' + dir);
                        deferred.resolve(result);
                        callback(null, result);
                    }
                }.bind(this));
            }
        }.bind(this));

        return deferred.promise;
    },

    parseDirSync: function(dir, hash) {
        var exists = fs.existsSync(dir);

        if (exists) { //load data
            var arr = fs.readdirSync(dir);
            for (var i = 0; i < arr.length; i++) {
                var curr = arr[i];
                if (arr[i] && curr[0] !== '.') {
                    var json = fs.readFileSync(path.join(dir, curr), this.options.encoding);
                    hash[curr] = this.parseString(json);
                }
            }
        } else { //create the directory
            mkdirp.sync(dir);
        }
    },

    parseDataFile: function(key, callback) {
        return this.parseFile(key, this.options.dir, this.data, callback);
    },

    parseDataFileSync: function(key) {
        return this.parseFileSync(key, this.options.dir, this.data);
    },

    parseTTLFile : function(key, callback) {
        return this.parseFile(key, this.options.ttlDir, this.ttls, callback);
    },

    parseTTLFileSync: function(key) {
        return this.parseFileSync(key, this.options.ttlDir, this.ttls);
    },

    parseFile: function (key, dir, hash, callback) {
        callback = isFunction(callback) ? callback : noop;

        var deferred = Q.defer();
        var result;
        var file = path.join(dir, key);
        var options = this.options;

        fs.readFile(file, options.encoding, function (err, json) {
            if (err) {
                deferred.reject(err);
                return callback(err);
            }

            var value = this.parseString(json);

            hash[key] = value;

            this.log("loaded: " + dir + "/" + key);

            result = {key: key, value: value, file: file};
            deferred.resolve(result);
            callback(null, result);

        }.bind(this));

        return deferred.promise;
    },

    parseFileSync: function(key, dir, hash) {
        var file = path.join(dir, key);
        hash[key] = fs.readFileSync(file, this.options.encoding);
        this.log("loaded: " + dir + "/" + key);
        return hash[key];
    },

    isExpired: function (key) {
        if (!this.options.ttl) return false;
        return this.ttls[key] < (new Date()).getTime();
    },

    removePersistedKeySync: function(key) {
        var options = this.options;

        var file = path.join(options.dir, key);
        if (fs.existsSync(file)) {
            fs.unlinkSync(file);
        }
        if (options.ttl) {
            var ttlFile = path.join(options.ttlDir, key);
            if (fs.existsSync(ttlFile)) {
                fs.unlinkSync(ttlFile);
            }
        }
    },

    resolveDir: function(dir) {
        dir = path.normalize(dir);
        if (dir !== path.resolve(dir)) {
            dir = path.join(__dirname, "storage", dir || "");
            this.log("Made dir absolute: " + dir);
        }
        return dir;
    },

    stopInterval: function () {
        clearInterval(this._persistInterval);
    },

    log: function () {
        this.options && this.options.logging && console.log.apply(console, arguments);
    }
};

module.exports = LocalStorage;


/***/ }),

/***/ 9923:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*
 * Simon Last, Sept 2013
 * http://simonlast.org
 */

var LocalStorage = __nccwpck_require__(3406);

(function(nodePersist) {
    var localStorage;

    /*
     * This function just creates a localStorage instance, incase you don't plan on using the default one
     * i.e.
     * var myStorage = nodePersist.create();
     * myStorage.init(myOptions);  // you still have to call init or initSync();
     */
    nodePersist.create = function (userOptions) {
        return LocalStorage(userOptions);
    };

    /*
     * All functions below are just helpers to use the default storage instance
     * and to maintain backward compatibility
     */


    /*
     * This function, (or init) must be called before the library can be used.
     * An options hash can be optionally passed.
     */
    nodePersist.init = function (userOptions, callback) {
        localStorage = nodePersist.create(userOptions);
        return localStorage.init(callback);
    };
    /*
     * This function, (or initSync) must be called before the library can be used.
     * An options hash can be optionally passed.
     */
    nodePersist.initSync = function (userOptions) {
        localStorage = nodePersist.create(userOptions);
        return localStorage.initSync();
    };

    /*
     * This function returns a key with index n in the database, or null if
     *  it is not present.
     * This function runs in 0(k), where k is the number of keys in the
     *  database. You probably shouldn't use it.
     */
    nodePersist.key = function (n) {
        return localStorage.key(n);
    };

    /*
     * This function returns an array of all the keys in the database
     *
     */
    nodePersist.keys = function () {
        return localStorage.keys();
    };

    /*
     * This function returns the number of keys stored in the database.
     */
    nodePersist.length = function () {
        return localStorage.length();
    };

    /*
     * This function iterates over each key/value pair and executes a callback
     */
    nodePersist.forEach = function(callback) {
        return localStorage.forEach(callback);
    };

    /*
     * This function returns all the values in the database.
     */
    nodePersist.values = function(callback) {
        return localStorage.values(callback);
    };


    nodePersist.valuesWithKeyMatch = function(match, callback) {
        return localStorage.valuesWithKeyMatch(match, callback);
    };

    /*
     * This function sets a key to a given value in the database.
     */
    nodePersist.setItem = function (key, value, callback) {
        return localStorage.setItem(key, value, callback);
    };

    /*
     * This function sets a key to a given value in the database.
     */
    nodePersist.setItemSync = function (key, value) {
        return localStorage.setItemSync(key, value);
    };

    /*
     * This function returns the value associated with a key in the database,
     *  or undefined if it is not present.
     */
    nodePersist.getItem = function (key, callback) {
        return localStorage.getItem(key, callback);
    };

    nodePersist.getItemSync = function (key) {
        return localStorage.getItemSync(key);
    };

    /*
     * This function removes key in the database if it is present, and
     *  immediately deletes it from the file system asynchronously.
     */
    nodePersist.removeItem = function (key, callback) {
        return localStorage.removeItem(key, callback);
    };

    /*
     * This function removes key in the database if it is present, and
     *  immediately deletes it from the file system synchronously.
     */
    nodePersist.removeItemSync = function (key) {
        return localStorage.removeItemSync(key);
    };

    /*
     * This function removes all keys in the database, and immediately
     *  deletes all keys from the file system asynchronously.
     */
    nodePersist.clear = function (callback) {
        return localStorage.clear(callback);
    };

    /*
     * This function removes all keys in the database, and immediately
     *  deletes all keys from the file system synchronously.
     */
    nodePersist.clearSync = function () {
        return localStorage.clearSync();
    };

    /*
     * This function triggers the database to persist asynchronously.
     */
    nodePersist.persist = function (callback) {
        return localStorage.persist(callback);
    };

    /*
     * This function triggers the database to persist synchronously.
     */
    nodePersist.persistSync = function () {
        return localStorage.persistSync();
    };

    /*
     * This function triggers a key within the database to persist asynchronously.
     */
    nodePersist.persistKey = function (key, callback) {
        return localStorage.persistKey(key, callback);
    };

    /*
     * This function triggers a key within the database to persist synchronously.
     */
    nodePersist.persistKeySync = function (key) {
        return localStorage.persistKeySync(key);
    };

}(module.exports));


/***/ }),

/***/ 8853:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var match = String.prototype.match;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' ? Symbol.prototype.toString : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;

var inspectCustom = __nccwpck_require__(4536).custom;
var inspectSymbol = inspectCustom && isSymbol(inspectCustom) ? inspectCustom : null;

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean') {
        throw new TypeError('option "customInspect", if provided, must be `true` or `false`');
    }

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('options "indent" must be "\\t", an integer > 0, or `null`');
    }

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        return String(obj);
    }
    if (typeof obj === 'bigint') {
        return String(obj) + 'n';
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = seen.slice();
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function') {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + keys.join(', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = symToString.call(obj);
        return typeof obj === 'object' ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + String(obj.nodeName).toLowerCase();
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + String(obj.nodeName).toLowerCase() + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + xs.join(', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + parts.join(', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function') {
            return obj[inspectSymbol]();
        } else if (typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        mapForEach.call(obj, function (value, key) {
            mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
        });
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        setForEach.call(obj, function (value) {
            setParts.push(inspect(value, obj));
        });
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        if (ys.length === 0) { return '{}'; }
        if (indent) {
            return '{' + indentedJoin(ys, indent) + '}';
        }
        return '{ ' + ys.join(', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return String(s).replace(/"/g, '&quot;');
}

function isArray(obj) { return toStr(obj) === '[object Array]'; }
function isDate(obj) { return toStr(obj) === '[object Date]'; }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]'; }
function isError(obj) { return toStr(obj) === '[object Error]'; }
function isSymbol(obj) { return toStr(obj) === '[object Symbol]'; }
function isString(obj) { return toStr(obj) === '[object String]'; }
function isNumber(obj) { return toStr(obj) === '[object Number]'; }
function isBigInt(obj) { return toStr(obj) === '[object BigInt]'; }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]'; }

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString(str.slice(0, opts.maxStringLength), opts) + trailer;
    }
    // eslint-disable-next-line no-control-regex
    var s = str.replace(/(['\\])/g, '\\$1').replace(/[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + n.toString(16).toUpperCase();
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : entries.join(', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = Array(opts.indent + 1).join(' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: Array(depth + 1).join(baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + xs.join(',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if ((/[^\w$]/).test(key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        var syms = gOPS(obj);
        for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}


/***/ }),

/***/ 4536:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(1669).inspect;


/***/ }),

/***/ 7925:
/***/ ((module) => {

"use strict";


var numberIsNaN = function (value) {
	return value !== value;
};

module.exports = function is(a, b) {
	if (a === 0 && b === 0) {
		return 1 / a === 1 / b;
	}
	if (a === b) {
		return true;
	}
	if (numberIsNaN(a) && numberIsNaN(b)) {
		return true;
	}
	return false;
};



/***/ }),

/***/ 5450:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var define = __nccwpck_require__(8961);
var callBind = __nccwpck_require__(3112);

var implementation = __nccwpck_require__(7925);
var getPolyfill = __nccwpck_require__(3721);
var shim = __nccwpck_require__(2854);

var polyfill = callBind(getPolyfill(), Object);

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


/***/ }),

/***/ 3721:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var implementation = __nccwpck_require__(7925);

module.exports = function getPolyfill() {
	return typeof Object.is === 'function' ? Object.is : implementation;
};


/***/ }),

/***/ 2854:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var getPolyfill = __nccwpck_require__(3721);
var define = __nccwpck_require__(8961);

module.exports = function shimObjectIs() {
	var polyfill = getPolyfill();
	define(Object, { is: polyfill }, {
		is: function testObjectIs() {
			return Object.is !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ 6595:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = __nccwpck_require__(5750); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;


/***/ }),

/***/ 5283:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var slice = Array.prototype.slice;
var isArgs = __nccwpck_require__(5750);

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : __nccwpck_require__(6595);

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;


/***/ }),

/***/ 5750:
/***/ ((module) => {

"use strict";


var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};


/***/ }),

/***/ 4921:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


// modified from https://github.com/es-shims/es6-shim
var keys = __nccwpck_require__(5283);
var canBeObject = function (obj) {
	return typeof obj !== 'undefined' && obj !== null;
};
var hasSymbols = __nccwpck_require__(2545)();
var callBound = __nccwpck_require__(8749);
var toObject = Object;
var $push = callBound('Array.prototype.push');
var $propIsEnumerable = callBound('Object.prototype.propertyIsEnumerable');
var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;

// eslint-disable-next-line no-unused-vars
module.exports = function assign(target, source1) {
	if (!canBeObject(target)) { throw new TypeError('target must be an object'); }
	var objTarget = toObject(target);
	var s, source, i, props, syms, value, key;
	for (s = 1; s < arguments.length; ++s) {
		source = toObject(arguments[s]);
		props = keys(source);
		var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
		if (getSymbols) {
			syms = getSymbols(source);
			for (i = 0; i < syms.length; ++i) {
				key = syms[i];
				if ($propIsEnumerable(source, key)) {
					$push(props, key);
				}
			}
		}
		for (i = 0; i < props.length; ++i) {
			key = props[i];
			value = source[key];
			if ($propIsEnumerable(source, key)) {
				objTarget[key] = value;
			}
		}
	}
	return objTarget;
};


/***/ }),

/***/ 5599:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var defineProperties = __nccwpck_require__(8961);
var callBind = __nccwpck_require__(3112);

var implementation = __nccwpck_require__(4921);
var getPolyfill = __nccwpck_require__(3255);
var shim = __nccwpck_require__(7513);

var polyfill = callBind.apply(getPolyfill());
// eslint-disable-next-line no-unused-vars
var bound = function assign(target, source1) {
	return polyfill(Object, arguments);
};

defineProperties(bound, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = bound;


/***/ }),

/***/ 3255:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var implementation = __nccwpck_require__(4921);

var lacksProperEnumerationOrder = function () {
	if (!Object.assign) {
		return false;
	}
	/*
	 * v8, specifically in node 4.x, has a bug with incorrect property enumeration order
	 * note: this does not detect the bug unless there's 20 characters
	 */
	var str = 'abcdefghijklmnopqrst';
	var letters = str.split('');
	var map = {};
	for (var i = 0; i < letters.length; ++i) {
		map[letters[i]] = letters[i];
	}
	var obj = Object.assign({}, map);
	var actual = '';
	for (var k in obj) {
		actual += k;
	}
	return str !== actual;
};

var assignHasPendingExceptions = function () {
	if (!Object.assign || !Object.preventExtensions) {
		return false;
	}
	/*
	 * Firefox 37 still has "pending exception" logic in its Object.assign implementation,
	 * which is 72% slower than our shim, and Firefox 40's native implementation.
	 */
	var thrower = Object.preventExtensions({ 1: 2 });
	try {
		Object.assign(thrower, 'xy');
	} catch (e) {
		return thrower[1] === 'y';
	}
	return false;
};

module.exports = function getPolyfill() {
	if (!Object.assign) {
		return implementation;
	}
	if (lacksProperEnumerationOrder()) {
		return implementation;
	}
	if (assignHasPendingExceptions()) {
		return implementation;
	}
	return Object.assign;
};


/***/ }),

/***/ 7513:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var define = __nccwpck_require__(8961);
var getPolyfill = __nccwpck_require__(3255);

module.exports = function shimAssign() {
	var polyfill = getPolyfill();
	define(
		Object,
		{ assign: polyfill },
		{ assign: function () { return Object.assign !== polyfill; } }
	);
	return polyfill;
};


/***/ }),

/***/ 7197:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var wrappy = __nccwpck_require__(4586)
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}


/***/ }),

/***/ 7843:
/***/ ((module) => {

"use strict";


if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}



/***/ }),

/***/ 8393:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var pna = __nccwpck_require__(7843);
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(__nccwpck_require__(3487));
util.inherits = __nccwpck_require__(6919);
/*</replacement>*/

var Readable = __nccwpck_require__(284);
var Writable = __nccwpck_require__(6100);

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};

/***/ }),

/***/ 5125:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __nccwpck_require__(5469);

/*<replacement>*/
var util = Object.create(__nccwpck_require__(3487));
util.inherits = __nccwpck_require__(6919);
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ 284:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var pna = __nccwpck_require__(7843);
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = __nccwpck_require__(9842);
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = __nccwpck_require__(8614).EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __nccwpck_require__(5016);
/*</replacement>*/

/*<replacement>*/

var Buffer = __nccwpck_require__(4810).Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(__nccwpck_require__(3487));
util.inherits = __nccwpck_require__(6919);
/*</replacement>*/

/*<replacement>*/
var debugUtil = __nccwpck_require__(1669);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = __nccwpck_require__(8739);
var destroyImpl = __nccwpck_require__(3090);
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __nccwpck_require__(8393);

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __nccwpck_require__(642)/* .StringDecoder */ .s;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __nccwpck_require__(8393);

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __nccwpck_require__(642)/* .StringDecoder */ .s;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

/***/ }),

/***/ 5469:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __nccwpck_require__(8393);

/*<replacement>*/
var util = Object.create(__nccwpck_require__(3487));
util.inherits = __nccwpck_require__(6919);
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),

/***/ 6100:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



/*<replacement>*/

var pna = __nccwpck_require__(7843);
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(__nccwpck_require__(3487));
util.inherits = __nccwpck_require__(6919);
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __nccwpck_require__(9209)
};
/*</replacement>*/

/*<replacement>*/
var Stream = __nccwpck_require__(5016);
/*</replacement>*/

/*<replacement>*/

var Buffer = __nccwpck_require__(4810).Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = __nccwpck_require__(3090);

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __nccwpck_require__(8393);

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __nccwpck_require__(8393);

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};

/***/ }),

/***/ 8739:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = __nccwpck_require__(4810).Buffer;
var util = __nccwpck_require__(1669);

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),

/***/ 3090:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


/*<replacement>*/

var pna = __nccwpck_require__(7843);
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),

/***/ 5016:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(2413);


/***/ }),

/***/ 4810:
/***/ ((module, exports, __nccwpck_require__) => {

/* eslint-disable node/no-deprecated-api */
var buffer = __nccwpck_require__(4293)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ 675:
/***/ ((module, exports, __nccwpck_require__) => {

var Stream = __nccwpck_require__(2413);
if (process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream;
  exports = module.exports = Stream.Readable;
  exports.Readable = Stream.Readable;
  exports.Writable = Stream.Writable;
  exports.Duplex = Stream.Duplex;
  exports.Transform = Stream.Transform;
  exports.PassThrough = Stream.PassThrough;
  exports.Stream = Stream;
} else {
  exports = module.exports = __nccwpck_require__(284);
  exports.Stream = Stream || exports;
  exports.Readable = exports;
  exports.Writable = __nccwpck_require__(6100);
  exports.Duplex = __nccwpck_require__(8393);
  exports.Transform = __nccwpck_require__(5469);
  exports.PassThrough = __nccwpck_require__(5125);
}


/***/ }),

/***/ 6805:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var $$observable = _interopDefault(__nccwpck_require__(5395));

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var randomString = function randomString() {
  return Math.random().toString(36).substring(7).split('').join('.');
};

var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};

/**
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */
function isPlainObject(obj) {
  if (typeof obj !== 'object' || obj === null) return false;
  var proto = obj;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(obj) === proto;
}

/**
 * Creates a Redux store that holds the state tree.
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} [enhancer] The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */

function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
    throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function.');
  }

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  /**
   * This makes a shallow copy of currentListeners so we can use
   * nextListeners as a temporary list while dispatching.
   *
   * This prevents any bugs around consumers calling
   * subscribe/unsubscribe in the middle of a dispatch.
   */

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */


  function getState() {
    if (isDispatching) {
      throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');
    }

    return currentState;
  }
  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */


  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected the listener to be a function.');
    }

    if (isDispatching) {
      throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribelistener for more details.');
    }

    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      if (isDispatching) {
        throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribelistener for more details.');
      }

      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
      currentListeners = null;
    };
  }
  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing “what changed”. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */


  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;

    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }
  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */


  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.
    // Any reducers that existed in both the new and old rootReducer
    // will receive the previous state. This effectively populates
    // the new state tree with any relevant data from the old one.

    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */


  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object' || observer === null) {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe: unsubscribe
        };
      }
    }, _ref[$$observable] = function () {
      return this;
    }, _ref;
  } // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.


  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}

/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */


  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
  } catch (e) {} // eslint-disable-line no-empty

}

function getUndefinedStateErrorMessage(key, action) {
  var actionType = action && action.type;
  var actionDescription = actionType && "action \"" + String(actionType) + "\"" || 'an action';
  return "Given " + actionDescription + ", reducer \"" + key + "\" returned undefined. " + "To ignore an action, you must explicitly return the previous state. " + "If you want this reducer to hold no value, you can return null instead of undefined.";
}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!isPlainObject(inputState)) {
    return "The " + argumentName + " has unexpected type of \"" + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + "\". Expected argument to be an object with the following " + ("keys: \"" + reducerKeys.join('", "') + "\"");
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });
  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });
  if (action && action.type === ActionTypes.REPLACE) return;

  if (unexpectedKeys.length > 0) {
    return "Unexpected " + (unexpectedKeys.length > 1 ? 'keys' : 'key') + " " + ("\"" + unexpectedKeys.join('", "') + "\" found in " + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ("\"" + reducerKeys.join('", "') + "\". Unexpected keys will be ignored.");
  }
}

function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, {
      type: ActionTypes.INIT
    });

    if (typeof initialState === 'undefined') {
      throw new Error("Reducer \"" + key + "\" returned undefined during initialization. " + "If the state passed to the reducer is undefined, you must " + "explicitly return the initial state. The initial state may " + "not be undefined. If you don't want to set a value for this reducer, " + "you can use null instead of undefined.");
    }

    if (typeof reducer(undefined, {
      type: ActionTypes.PROBE_UNKNOWN_ACTION()
    }) === 'undefined') {
      throw new Error("Reducer \"" + key + "\" returned undefined when probed with a random type. " + ("Don't try to handle " + ActionTypes.INIT + " or other actions in \"redux/*\" ") + "namespace. They are considered private. Instead, you must return the " + "current state for any unknown actions, unless it is undefined, " + "in which case you must return the initial state, regardless of the " + "action type. The initial state may not be undefined, but can be null.");
    }
  });
}
/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */


function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};

  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (process.env.NODE_ENV !== 'production') {
      if (typeof reducers[key] === 'undefined') {
        warning("No reducer provided for key \"" + key + "\"");
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }

  var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same
  // keys multiple times.

  var unexpectedKeyCache;

  if (process.env.NODE_ENV !== 'production') {
    unexpectedKeyCache = {};
  }

  var shapeAssertionError;

  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination(state, action) {
    if (state === void 0) {
      state = {};
    }

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    if (process.env.NODE_ENV !== 'production') {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);

      if (warningMessage) {
        warning(warningMessage);
      }
    }

    var hasChanged = false;
    var nextState = {};

    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);

      if (typeof nextStateForKey === 'undefined') {
        var errorMessage = getUndefinedStateErrorMessage(_key, action);
        throw new Error(errorMessage);
      }

      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }

    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}

function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(this, arguments));
  };
}
/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass an action creator as the first argument,
 * and get a dispatch wrapped function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */


function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error("bindActionCreators expected an object or a function, instead received " + (actionCreators === null ? 'null' : typeof actionCreators) + ". " + "Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?");
  }

  var boundActionCreators = {};

  for (var key in actionCreators) {
    var actionCreator = actionCreators[key];

    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }

  return boundActionCreators;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    keys.push.apply(keys, Object.getOwnPropertySymbols(object));
  }

  if (enumerableOnly) keys = keys.filter(function (sym) {
    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
  });
  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */
function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(void 0, arguments));
    };
  });
}

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */

function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function () {
      var store = createStore.apply(void 0, arguments);

      var _dispatch = function dispatch() {
        throw new Error('Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');
      };

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(void 0, chain)(store.dispatch);
      return _objectSpread2({}, store, {
        dispatch: _dispatch
      });
    };
  };
}

/*
 * This is a dummy function to check if the function name has been altered by minification.
 * If the function has been minified and NODE_ENV !== 'production', warn the user.
 */

function isCrushed() {}

if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  warning('You are currently using minified code outside of NODE_ENV === "production". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');
}

exports.__DO_NOT_USE__ActionTypes = ActionTypes;
exports.applyMiddleware = applyMiddleware;
exports.bindActionCreators = bindActionCreators;
exports.combineReducers = combineReducers;
exports.compose = compose;
exports.createStore = createStore;


/***/ }),

/***/ 9694:
/***/ ((module) => {

"use strict";


var $Object = Object;
var $TypeError = TypeError;

module.exports = function flags() {
	if (this != null && this !== $Object(this)) {
		throw new $TypeError('RegExp.prototype.flags getter called on non-object');
	}
	var result = '';
	if (this.global) {
		result += 'g';
	}
	if (this.ignoreCase) {
		result += 'i';
	}
	if (this.multiline) {
		result += 'm';
	}
	if (this.dotAll) {
		result += 's';
	}
	if (this.unicode) {
		result += 'u';
	}
	if (this.sticky) {
		result += 'y';
	}
	return result;
};


/***/ }),

/***/ 8495:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var define = __nccwpck_require__(8961);
var callBind = __nccwpck_require__(3112);

var implementation = __nccwpck_require__(9694);
var getPolyfill = __nccwpck_require__(414);
var shim = __nccwpck_require__(7300);

var flagsBound = callBind(implementation);

define(flagsBound, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = flagsBound;


/***/ }),

/***/ 414:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var implementation = __nccwpck_require__(9694);

var supportsDescriptors = __nccwpck_require__(8961).supportsDescriptors;
var $gOPD = Object.getOwnPropertyDescriptor;
var $TypeError = TypeError;

module.exports = function getPolyfill() {
	if (!supportsDescriptors) {
		throw new $TypeError('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');
	}
	if ((/a/mig).flags === 'gim') {
		var descriptor = $gOPD(RegExp.prototype, 'flags');
		if (descriptor && typeof descriptor.get === 'function' && typeof (/a/).dotAll === 'boolean') {
			return descriptor.get;
		}
	}
	return implementation;
};


/***/ }),

/***/ 7300:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var supportsDescriptors = __nccwpck_require__(8961).supportsDescriptors;
var getPolyfill = __nccwpck_require__(414);
var gOPD = Object.getOwnPropertyDescriptor;
var defineProperty = Object.defineProperty;
var TypeErr = TypeError;
var getProto = Object.getPrototypeOf;
var regex = /a/;

module.exports = function shimFlags() {
	if (!supportsDescriptors || !getProto) {
		throw new TypeErr('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');
	}
	var polyfill = getPolyfill();
	var proto = getProto(regex);
	var descriptor = gOPD(proto, 'flags');
	if (!descriptor || descriptor.get !== polyfill) {
		defineProperty(proto, 'flags', {
			configurable: true,
			enumerable: false,
			get: polyfill
		});
	}
	return polyfill;
};


/***/ }),

/***/ 4652:
/***/ ((module) => {

"use strict";


function ReInterval (callback, interval, args) {
  var self = this;

  this._callback = callback;
  this._args = args;

  this._interval = setInterval(callback, interval, this._args);

  this.reschedule = function (interval) {
    // if no interval entered, use the interval passed in on creation
    if (!interval)
      interval = self._interval;

    if (self._interval)
      clearInterval(self._interval);
    self._interval = setInterval(self._callback, interval, self._args);
  };

  this.clear = function () {
    if (self._interval) {
      clearInterval(self._interval);
      self._interval = undefined;
    }
  };
  
  this.destroy = function () {
    if (self._interval) {
      clearInterval(self._interval);
    }
    self._callback = undefined;
    self._interval = undefined;
    self._args = undefined;
  };
}

function reInterval () {
  if (typeof arguments[0] !== 'function')
    throw new Error('callback needed');
  if (typeof arguments[1] !== 'number')
    throw new Error('interval needed');

  var args;

  if (arguments.length > 0) {
    args = new Array(arguments.length - 2);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 2];
    }
  }

  return new ReInterval(arguments[0], arguments[1], args);
}

module.exports = reInterval;


/***/ }),

/***/ 3118:
/***/ ((module, exports, __nccwpck_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __nccwpck_require__(4293)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ 3616:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var GetIntrinsic = __nccwpck_require__(9879);
var callBound = __nccwpck_require__(8749);
var inspect = __nccwpck_require__(8853);

var $TypeError = GetIntrinsic('%TypeError%');
var $WeakMap = GetIntrinsic('%WeakMap%', true);
var $Map = GetIntrinsic('%Map%', true);

var $weakMapGet = callBound('WeakMap.prototype.get', true);
var $weakMapSet = callBound('WeakMap.prototype.set', true);
var $weakMapHas = callBound('WeakMap.prototype.has', true);
var $mapGet = callBound('Map.prototype.get', true);
var $mapSet = callBound('Map.prototype.set', true);
var $mapHas = callBound('Map.prototype.has', true);

/*
 * This function traverses the list returning the node corresponding to the
 * given key.
 *
 * That node is also moved to the head of the list, so that if it's accessed
 * again we don't need to traverse the whole list. By doing so, all the recently
 * used nodes can be accessed relatively quickly.
 */
var listGetNode = function (list, key) { // eslint-disable-line consistent-return
	for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			curr.next = list.next;
			list.next = curr; // eslint-disable-line no-param-reassign
			return curr;
		}
	}
};

var listGet = function (objects, key) {
	var node = listGetNode(objects, key);
	return node && node.value;
};
var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	} else {
		// Prepend the new node to the beginning of the list
		objects.next = { // eslint-disable-line no-param-reassign
			key: key,
			next: objects.next,
			value: value
		};
	}
};
var listHas = function (objects, key) {
	return !!listGetNode(objects, key);
};

module.exports = function getSideChannel() {
	var $wm;
	var $m;
	var $o;
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		get: function (key) { // eslint-disable-line consistent-return
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapGet($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapGet($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listGet($o, key);
				}
			}
		},
		has: function (key) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapHas($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapHas($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listHas($o, key);
				}
			}
			return false;
		},
		set: function (key, value) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if (!$wm) {
					$wm = new $WeakMap();
				}
				$weakMapSet($wm, key, value);
			} else if ($Map) {
				if (!$m) {
					$m = new $Map();
				}
				$mapSet($m, key, value);
			} else {
				if (!$o) {
					/*
					 * Initialize the linked list as an empty node, so that we don't have
					 * to special-case handling of the first node: we can always refer to
					 * it as (previous node).next, instead of something like (list).head
					 */
					$o = { key: {}, next: null };
				}
				listSet($o, key, value);
			}
		}
	};
	return channel;
};


/***/ }),

/***/ 3418:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __nccwpck_require__) => {

__nccwpck_require__(793).install();


/***/ }),

/***/ 793:
/***/ ((module, exports, __nccwpck_require__) => {

/* module decorator */ module = __nccwpck_require__.nmd(module);
var SourceMapConsumer = __nccwpck_require__(5018).SourceMapConsumer;
var path = __nccwpck_require__(5622);

var fs;
try {
  fs = __nccwpck_require__(5747);
  if (!fs.existsSync || !fs.readFileSync) {
    // fs doesn't have all methods we need
    fs = null;
  }
} catch (err) {
  /* nop */
}

var bufferFrom = __nccwpck_require__(2420);

/**
 * Requires a module which is protected against bundler minification.
 *
 * @param {NodeModule} mod
 * @param {string} request
 */
function dynamicRequire(mod, request) {
  return mod.require(request);
}

// Only install once if called multiple times
var errorFormatterInstalled = false;
var uncaughtShimInstalled = false;

// If true, the caches are reset before a stack trace formatting operation
var emptyCacheBetweenOperations = false;

// Supports {browser, node, auto}
var environment = "auto";

// Maps a file path to a string containing the file contents
var fileContentsCache = {};

// Maps a file path to a source map for that file
var sourceMapCache = {};

// Regex for detecting source maps
var reSourceMap = /^data:application\/json[^,]+base64,/;

// Priority list of retrieve handlers
var retrieveFileHandlers = [];
var retrieveMapHandlers = [];

function isInBrowser() {
  if (environment === "browser")
    return true;
  if (environment === "node")
    return false;
  return ((typeof window !== 'undefined') && (typeof XMLHttpRequest === 'function') && !(window.require && window.module && window.process && window.process.type === "renderer"));
}

function hasGlobalProcessEventEmitter() {
  return ((typeof process === 'object') && (process !== null) && (typeof process.on === 'function'));
}

function handlerExec(list) {
  return function(arg) {
    for (var i = 0; i < list.length; i++) {
      var ret = list[i](arg);
      if (ret) {
        return ret;
      }
    }
    return null;
  };
}

var retrieveFile = handlerExec(retrieveFileHandlers);

retrieveFileHandlers.push(function(path) {
  // Trim the path to make sure there is no extra whitespace.
  path = path.trim();
  if (/^file:/.test(path)) {
    // existsSync/readFileSync can't handle file protocol, but once stripped, it works
    path = path.replace(/file:\/\/\/(\w:)?/, function(protocol, drive) {
      return drive ?
        '' : // file:///C:/dir/file -> C:/dir/file
        '/'; // file:///root-dir/file -> /root-dir/file
    });
  }
  if (path in fileContentsCache) {
    return fileContentsCache[path];
  }

  var contents = '';
  try {
    if (!fs) {
      // Use SJAX if we are in the browser
      var xhr = new XMLHttpRequest();
      xhr.open('GET', path, /** async */ false);
      xhr.send(null);
      if (xhr.readyState === 4 && xhr.status === 200) {
        contents = xhr.responseText;
      }
    } else if (fs.existsSync(path)) {
      // Otherwise, use the filesystem
      contents = fs.readFileSync(path, 'utf8');
    }
  } catch (er) {
    /* ignore any errors */
  }

  return fileContentsCache[path] = contents;
});

// Support URLs relative to a directory, but be careful about a protocol prefix
// in case we are in the browser (i.e. directories may start with "http://" or "file:///")
function supportRelativeURL(file, url) {
  if (!file) return url;
  var dir = path.dirname(file);
  var match = /^\w+:\/\/[^\/]*/.exec(dir);
  var protocol = match ? match[0] : '';
  var startPath = dir.slice(protocol.length);
  if (protocol && /^\/\w\:/.test(startPath)) {
    // handle file:///C:/ paths
    protocol += '/';
    return protocol + path.resolve(dir.slice(protocol.length), url).replace(/\\/g, '/');
  }
  return protocol + path.resolve(dir.slice(protocol.length), url);
}

function retrieveSourceMapURL(source) {
  var fileData;

  if (isInBrowser()) {
     try {
       var xhr = new XMLHttpRequest();
       xhr.open('GET', source, false);
       xhr.send(null);
       fileData = xhr.readyState === 4 ? xhr.responseText : null;

       // Support providing a sourceMappingURL via the SourceMap header
       var sourceMapHeader = xhr.getResponseHeader("SourceMap") ||
                             xhr.getResponseHeader("X-SourceMap");
       if (sourceMapHeader) {
         return sourceMapHeader;
       }
     } catch (e) {
     }
  }

  // Get the URL of the source map
  fileData = retrieveFile(source);
  var re = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/mg;
  // Keep executing the search to find the *last* sourceMappingURL to avoid
  // picking up sourceMappingURLs from comments, strings, etc.
  var lastMatch, match;
  while (match = re.exec(fileData)) lastMatch = match;
  if (!lastMatch) return null;
  return lastMatch[1];
};

// Can be overridden by the retrieveSourceMap option to install. Takes a
// generated source filename; returns a {map, optional url} object, or null if
// there is no source map.  The map field may be either a string or the parsed
// JSON object (ie, it must be a valid argument to the SourceMapConsumer
// constructor).
var retrieveSourceMap = handlerExec(retrieveMapHandlers);
retrieveMapHandlers.push(function(source) {
  var sourceMappingURL = retrieveSourceMapURL(source);
  if (!sourceMappingURL) return null;

  // Read the contents of the source map
  var sourceMapData;
  if (reSourceMap.test(sourceMappingURL)) {
    // Support source map URL as a data url
    var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1);
    sourceMapData = bufferFrom(rawData, "base64").toString();
    sourceMappingURL = source;
  } else {
    // Support source map URLs relative to the source URL
    sourceMappingURL = supportRelativeURL(source, sourceMappingURL);
    sourceMapData = retrieveFile(sourceMappingURL);
  }

  if (!sourceMapData) {
    return null;
  }

  return {
    url: sourceMappingURL,
    map: sourceMapData
  };
});

function mapSourcePosition(position) {
  var sourceMap = sourceMapCache[position.source];
  if (!sourceMap) {
    // Call the (overrideable) retrieveSourceMap function to get the source map.
    var urlAndMap = retrieveSourceMap(position.source);
    if (urlAndMap) {
      sourceMap = sourceMapCache[position.source] = {
        url: urlAndMap.url,
        map: new SourceMapConsumer(urlAndMap.map)
      };

      // Load all sources stored inline with the source map into the file cache
      // to pretend like they are already loaded. They may not exist on disk.
      if (sourceMap.map.sourcesContent) {
        sourceMap.map.sources.forEach(function(source, i) {
          var contents = sourceMap.map.sourcesContent[i];
          if (contents) {
            var url = supportRelativeURL(sourceMap.url, source);
            fileContentsCache[url] = contents;
          }
        });
      }
    } else {
      sourceMap = sourceMapCache[position.source] = {
        url: null,
        map: null
      };
    }
  }

  // Resolve the source URL relative to the URL of the source map
  if (sourceMap && sourceMap.map && typeof sourceMap.map.originalPositionFor === 'function') {
    var originalPosition = sourceMap.map.originalPositionFor(position);

    // Only return the original position if a matching line was found. If no
    // matching line is found then we return position instead, which will cause
    // the stack trace to print the path and line for the compiled file. It is
    // better to give a precise location in the compiled file than a vague
    // location in the original file.
    if (originalPosition.source !== null) {
      originalPosition.source = supportRelativeURL(
        sourceMap.url, originalPosition.source);
      return originalPosition;
    }
  }

  return position;
}

// Parses code generated by FormatEvalOrigin(), a function inside V8:
// https://code.google.com/p/v8/source/browse/trunk/src/messages.js
function mapEvalOrigin(origin) {
  // Most eval() calls are in this format
  var match = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
  if (match) {
    var position = mapSourcePosition({
      source: match[2],
      line: +match[3],
      column: match[4] - 1
    });
    return 'eval at ' + match[1] + ' (' + position.source + ':' +
      position.line + ':' + (position.column + 1) + ')';
  }

  // Parse nested eval() calls using recursion
  match = /^eval at ([^(]+) \((.+)\)$/.exec(origin);
  if (match) {
    return 'eval at ' + match[1] + ' (' + mapEvalOrigin(match[2]) + ')';
  }

  // Make sure we still return useful information if we didn't find anything
  return origin;
}

// This is copied almost verbatim from the V8 source code at
// https://code.google.com/p/v8/source/browse/trunk/src/messages.js. The
// implementation of wrapCallSite() used to just forward to the actual source
// code of CallSite.prototype.toString but unfortunately a new release of V8
// did something to the prototype chain and broke the shim. The only fix I
// could find was copy/paste.
function CallSiteToString() {
  var fileName;
  var fileLocation = "";
  if (this.isNative()) {
    fileLocation = "native";
  } else {
    fileName = this.getScriptNameOrSourceURL();
    if (!fileName && this.isEval()) {
      fileLocation = this.getEvalOrigin();
      fileLocation += ", ";  // Expecting source position to follow.
    }

    if (fileName) {
      fileLocation += fileName;
    } else {
      // Source code does not originate from a file and is not native, but we
      // can still get the source position inside the source string, e.g. in
      // an eval string.
      fileLocation += "<anonymous>";
    }
    var lineNumber = this.getLineNumber();
    if (lineNumber != null) {
      fileLocation += ":" + lineNumber;
      var columnNumber = this.getColumnNumber();
      if (columnNumber) {
        fileLocation += ":" + columnNumber;
      }
    }
  }

  var line = "";
  var functionName = this.getFunctionName();
  var addSuffix = true;
  var isConstructor = this.isConstructor();
  var isMethodCall = !(this.isToplevel() || isConstructor);
  if (isMethodCall) {
    var typeName = this.getTypeName();
    // Fixes shim to be backward compatable with Node v0 to v4
    if (typeName === "[object Object]") {
      typeName = "null";
    }
    var methodName = this.getMethodName();
    if (functionName) {
      if (typeName && functionName.indexOf(typeName) != 0) {
        line += typeName + ".";
      }
      line += functionName;
      if (methodName && functionName.indexOf("." + methodName) != functionName.length - methodName.length - 1) {
        line += " [as " + methodName + "]";
      }
    } else {
      line += typeName + "." + (methodName || "<anonymous>");
    }
  } else if (isConstructor) {
    line += "new " + (functionName || "<anonymous>");
  } else if (functionName) {
    line += functionName;
  } else {
    line += fileLocation;
    addSuffix = false;
  }
  if (addSuffix) {
    line += " (" + fileLocation + ")";
  }
  return line;
}

function cloneCallSite(frame) {
  var object = {};
  Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {
    object[name] = /^(?:is|get)/.test(name) ? function() { return frame[name].call(frame); } : frame[name];
  });
  object.toString = CallSiteToString;
  return object;
}

function wrapCallSite(frame, state) {
  // provides interface backward compatibility
  if (state === undefined) {
    state = { nextPosition: null, curPosition: null }
  }
  if(frame.isNative()) {
    state.curPosition = null;
    return frame;
  }

  // Most call sites will return the source file from getFileName(), but code
  // passed to eval() ending in "//# sourceURL=..." will return the source file
  // from getScriptNameOrSourceURL() instead
  var source = frame.getFileName() || frame.getScriptNameOrSourceURL();
  if (source) {
    var line = frame.getLineNumber();
    var column = frame.getColumnNumber() - 1;

    // Fix position in Node where some (internal) code is prepended.
    // See https://github.com/evanw/node-source-map-support/issues/36
    // Header removed in node at ^10.16 || >=11.11.0
    // v11 is not an LTS candidate, we can just test the one version with it.
    // Test node versions for: 10.16-19, 10.20+, 12-19, 20-99, 100+, or 11.11
    var noHeader = /^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/;
    var headerLength = noHeader.test(process.version) ? 0 : 62;
    if (line === 1 && column > headerLength && !isInBrowser() && !frame.isEval()) {
      column -= headerLength;
    }

    var position = mapSourcePosition({
      source: source,
      line: line,
      column: column
    });
    state.curPosition = position;
    frame = cloneCallSite(frame);
    var originalFunctionName = frame.getFunctionName;
    frame.getFunctionName = function() {
      if (state.nextPosition == null) {
        return originalFunctionName();
      }
      return state.nextPosition.name || originalFunctionName();
    };
    frame.getFileName = function() { return position.source; };
    frame.getLineNumber = function() { return position.line; };
    frame.getColumnNumber = function() { return position.column + 1; };
    frame.getScriptNameOrSourceURL = function() { return position.source; };
    return frame;
  }

  // Code called using eval() needs special handling
  var origin = frame.isEval() && frame.getEvalOrigin();
  if (origin) {
    origin = mapEvalOrigin(origin);
    frame = cloneCallSite(frame);
    frame.getEvalOrigin = function() { return origin; };
    return frame;
  }

  // If we get here then we were unable to change the source position
  return frame;
}

// This function is part of the V8 stack trace API, for more info see:
// https://v8.dev/docs/stack-trace-api
function prepareStackTrace(error, stack) {
  if (emptyCacheBetweenOperations) {
    fileContentsCache = {};
    sourceMapCache = {};
  }

  var name = error.name || 'Error';
  var message = error.message || '';
  var errorString = name + ": " + message;

  var state = { nextPosition: null, curPosition: null };
  var processedStack = [];
  for (var i = stack.length - 1; i >= 0; i--) {
    processedStack.push('\n    at ' + wrapCallSite(stack[i], state));
    state.nextPosition = state.curPosition;
  }
  state.curPosition = state.nextPosition = null;
  return errorString + processedStack.reverse().join('');
}

// Generate position and snippet of original source with pointer
function getErrorSource(error) {
  var match = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(error.stack);
  if (match) {
    var source = match[1];
    var line = +match[2];
    var column = +match[3];

    // Support the inline sourceContents inside the source map
    var contents = fileContentsCache[source];

    // Support files on disk
    if (!contents && fs && fs.existsSync(source)) {
      try {
        contents = fs.readFileSync(source, 'utf8');
      } catch (er) {
        contents = '';
      }
    }

    // Format the line from the original source code like node does
    if (contents) {
      var code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
      if (code) {
        return source + ':' + line + '\n' + code + '\n' +
          new Array(column).join(' ') + '^';
      }
    }
  }
  return null;
}

function printErrorAndExit (error) {
  var source = getErrorSource(error);

  // Ensure error is printed synchronously and not truncated
  if (process.stderr._handle && process.stderr._handle.setBlocking) {
    process.stderr._handle.setBlocking(true);
  }

  if (source) {
    console.error();
    console.error(source);
  }

  console.error(error.stack);
  process.exit(1);
}

function shimEmitUncaughtException () {
  var origEmit = process.emit;

  process.emit = function (type) {
    if (type === 'uncaughtException') {
      var hasStack = (arguments[1] && arguments[1].stack);
      var hasListeners = (this.listeners(type).length > 0);

      if (hasStack && !hasListeners) {
        return printErrorAndExit(arguments[1]);
      }
    }

    return origEmit.apply(this, arguments);
  };
}

var originalRetrieveFileHandlers = retrieveFileHandlers.slice(0);
var originalRetrieveMapHandlers = retrieveMapHandlers.slice(0);

exports.wrapCallSite = wrapCallSite;
exports.getErrorSource = getErrorSource;
exports.mapSourcePosition = mapSourcePosition;
exports.retrieveSourceMap = retrieveSourceMap;

exports.install = function(options) {
  options = options || {};

  if (options.environment) {
    environment = options.environment;
    if (["node", "browser", "auto"].indexOf(environment) === -1) {
      throw new Error("environment " + environment + " was unknown. Available options are {auto, browser, node}")
    }
  }

  // Allow sources to be found by methods other than reading the files
  // directly from disk.
  if (options.retrieveFile) {
    if (options.overrideRetrieveFile) {
      retrieveFileHandlers.length = 0;
    }

    retrieveFileHandlers.unshift(options.retrieveFile);
  }

  // Allow source maps to be found by methods other than reading the files
  // directly from disk.
  if (options.retrieveSourceMap) {
    if (options.overrideRetrieveSourceMap) {
      retrieveMapHandlers.length = 0;
    }

    retrieveMapHandlers.unshift(options.retrieveSourceMap);
  }

  // Support runtime transpilers that include inline source maps
  if (options.hookRequire && !isInBrowser()) {
    // Use dynamicRequire to avoid including in browser bundles
    var Module = dynamicRequire(module, 'module');
    var $compile = Module.prototype._compile;

    if (!$compile.__sourceMapSupport) {
      Module.prototype._compile = function(content, filename) {
        fileContentsCache[filename] = content;
        sourceMapCache[filename] = undefined;
        return $compile.call(this, content, filename);
      };

      Module.prototype._compile.__sourceMapSupport = true;
    }
  }

  // Configure options
  if (!emptyCacheBetweenOperations) {
    emptyCacheBetweenOperations = 'emptyCacheBetweenOperations' in options ?
      options.emptyCacheBetweenOperations : false;
  }

  // Install the error reformatter
  if (!errorFormatterInstalled) {
    errorFormatterInstalled = true;
    Error.prepareStackTrace = prepareStackTrace;
  }

  if (!uncaughtShimInstalled) {
    var installHandler = 'handleUncaughtExceptions' in options ?
      options.handleUncaughtExceptions : true;

    // Do not override 'uncaughtException' with our own handler in Node.js
    // Worker threads. Workers pass the error to the main thread as an event,
    // rather than printing something to stderr and exiting.
    try {
      // We need to use `dynamicRequire` because `require` on it's own will be optimized by WebPack/Browserify.
      var worker_threads = dynamicRequire(module, 'worker_threads');
      if (worker_threads.isMainThread === false) {
        installHandler = false;
      }
    } catch(e) {}

    // Provide the option to not install the uncaught exception handler. This is
    // to support other uncaught exception handlers (in test frameworks, for
    // example). If this handler is not installed and there are no other uncaught
    // exception handlers, uncaught exceptions will be caught by node's built-in
    // exception handler and the process will still be terminated. However, the
    // generated JavaScript code will be shown above the stack trace instead of
    // the original source code.
    if (installHandler && hasGlobalProcessEventEmitter()) {
      uncaughtShimInstalled = true;
      shimEmitUncaughtException();
    }
  }
};

exports.resetRetrieveHandlers = function() {
  retrieveFileHandlers.length = 0;
  retrieveMapHandlers.length = 0;

  retrieveFileHandlers = originalRetrieveFileHandlers.slice(0);
  retrieveMapHandlers = originalRetrieveMapHandlers.slice(0);

  retrieveSourceMap = handlerExec(retrieveMapHandlers);
  retrieveFile = handlerExec(retrieveFileHandlers);
}


/***/ }),

/***/ 2989:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __nccwpck_require__(358);
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.I = ArraySet;


/***/ }),

/***/ 9202:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = __nccwpck_require__(5756);

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};


/***/ }),

/***/ 5756:
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};


/***/ }),

/***/ 1063:
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};


/***/ }),

/***/ 8397:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __nccwpck_require__(358);

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.H = MappingList;


/***/ }),

/***/ 6467:
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.U = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};


/***/ }),

/***/ 3161:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

var __webpack_unused_export__;
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __nccwpck_require__(358);
var binarySearch = __nccwpck_require__(1063);
var ArraySet = __nccwpck_require__(2989)/* .ArraySet */ .I;
var base64VLQ = __nccwpck_require__(9202);
var quickSort = __nccwpck_require__(6467)/* .quickSort */ .U;

function SourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  if (sourceRoot) {
    sourceRoot = util.normalize(sourceRoot);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this._absoluteSources = this._sources.toArray().map(function (s) {
    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
  });

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */
BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  }

  // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.
  var i;
  for (i = 0; i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }

  return -1;
};

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function (s) {
      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._absoluteSources.slice();
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }

    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

__webpack_unused_export__ = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

__webpack_unused_export__ = IndexedSourceMapConsumer;


/***/ }),

/***/ 826:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = __nccwpck_require__(9202);
var util = __nccwpck_require__(358);
var ArraySet = __nccwpck_require__(2989)/* .ArraySet */ .I;
var MappingList = __nccwpck_require__(8397)/* .MappingList */ .H;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.h = SourceMapGenerator;


/***/ }),

/***/ 2767:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

var __webpack_unused_export__;
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = __nccwpck_require__(826)/* .SourceMapGenerator */ .h;
var util = __nccwpck_require__(358);

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      // The last line of a file might not have a newline.
      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ?
            remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex] || '';
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || '';
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

__webpack_unused_export__ = SourceNode;


/***/ }),

/***/ 358:
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   “sources” entry.  This value is prepended to the individual
    //   entries in the “source” field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   “sourceRoot”, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;


/***/ }),

/***/ 5018:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
/* unused reexport */ __nccwpck_require__(826)/* .SourceMapGenerator */ .h;
exports.SourceMapConsumer = __nccwpck_require__(3161).SourceMapConsumer;
/* unused reexport */ __nccwpck_require__(2767);


/***/ }),

/***/ 662:
/***/ ((module) => {

module.exports = shift

function shift (stream) {
  var rs = stream._readableState
  if (!rs) return null
  return (rs.objectMode || typeof stream._duplexState === 'number') ? stream.read() : stream.read(getStateLength(rs))
}

function getStateLength (state) {
  if (state.buffer.length) {
    // Since node 6.3.0 state.buffer is a BufferList not an array
    if (state.buffer.head) {
      return state.buffer.head.data.length
    }

    return state.buffer[0].length
  }

  return state.length
}


/***/ }),

/***/ 642:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = __nccwpck_require__(265).Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.s = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ 265:
/***/ ((module, exports, __nccwpck_require__) => {

/* eslint-disable node/no-deprecated-api */
var buffer = __nccwpck_require__(4293)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ 395:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const os = __nccwpck_require__(2087);
const tty = __nccwpck_require__(3867);
const hasFlag = __nccwpck_require__(4250);

const {env} = process;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false') ||
	hasFlag('color=never')) {
	forceColor = 0;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = 1;
}

if ('FORCE_COLOR' in env) {
	if (env.FORCE_COLOR === 'true') {
		forceColor = 1;
	} else if (env.FORCE_COLOR === 'false') {
		forceColor = 0;
	} else {
		forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(haveStream, streamIsTTY) {
	if (forceColor === 0) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream, stream && stream.isTTY);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};


/***/ }),

/***/ 5395:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";
/* module decorator */ module = __nccwpck_require__.nmd(module);


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _ponyfill = __nccwpck_require__(5170);

var _ponyfill2 = _interopRequireDefault(_ponyfill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var root; /* global window */


if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (true) {
  root = module;
} else {}

var result = (0, _ponyfill2['default'])(root);
exports.default = result;

/***/ }),

/***/ 5170:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
	value: true
}));
exports.default = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
	var result;
	var _Symbol = root.Symbol;

	if (typeof _Symbol === 'function') {
		if (_Symbol.observable) {
			result = _Symbol.observable;
		} else {
			result = _Symbol('observable');
			_Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};

/***/ }),

/***/ 85:
/***/ ((module) => {

"use strict";


var nextTick = nextTickArgs
process.nextTick(upgrade, 42) // pass 42 and see if upgrade is called with it

module.exports = thunky

function thunky (fn) {
  var state = run
  return thunk

  function thunk (callback) {
    state(callback || noop)
  }

  function run (callback) {
    var stack = [callback]
    state = wait
    fn(done)

    function wait (callback) {
      stack.push(callback)
    }

    function done (err) {
      var args = arguments
      state = isError(err) ? run : finished
      while (stack.length) finished(stack.shift())

      function finished (callback) {
        nextTick(apply, callback, args)
      }
    }
  }
}

function isError (err) { // inlined from util so this works in the browser
  return Object.prototype.toString.call(err) === '[object Error]'
}

function noop () {}

function apply (callback, args) {
  callback.apply(null, args)
}

function upgrade (val) {
  if (val === 42) nextTick = process.nextTick
}

function nextTickArgs (fn, a, b) {
  process.nextTick(function () {
    fn(a, b)
  })
}


/***/ }),

/***/ 4290:
/***/ ((__unused_webpack_module, __webpack_exports__, __nccwpck_require__) => {

"use strict";
__nccwpck_require__.r(__webpack_exports__);
/* harmony export */ __nccwpck_require__.d(__webpack_exports__, {
/* harmony export */   "__extends": () => /* binding */ __extends,
/* harmony export */   "__assign": () => /* binding */ __assign,
/* harmony export */   "__rest": () => /* binding */ __rest,
/* harmony export */   "__decorate": () => /* binding */ __decorate,
/* harmony export */   "__param": () => /* binding */ __param,
/* harmony export */   "__metadata": () => /* binding */ __metadata,
/* harmony export */   "__awaiter": () => /* binding */ __awaiter,
/* harmony export */   "__generator": () => /* binding */ __generator,
/* harmony export */   "__createBinding": () => /* binding */ __createBinding,
/* harmony export */   "__exportStar": () => /* binding */ __exportStar,
/* harmony export */   "__values": () => /* binding */ __values,
/* harmony export */   "__read": () => /* binding */ __read,
/* harmony export */   "__spread": () => /* binding */ __spread,
/* harmony export */   "__spreadArrays": () => /* binding */ __spreadArrays,
/* harmony export */   "__spreadArray": () => /* binding */ __spreadArray,
/* harmony export */   "__await": () => /* binding */ __await,
/* harmony export */   "__asyncGenerator": () => /* binding */ __asyncGenerator,
/* harmony export */   "__asyncDelegator": () => /* binding */ __asyncDelegator,
/* harmony export */   "__asyncValues": () => /* binding */ __asyncValues,
/* harmony export */   "__makeTemplateObject": () => /* binding */ __makeTemplateObject,
/* harmony export */   "__importStar": () => /* binding */ __importStar,
/* harmony export */   "__importDefault": () => /* binding */ __importDefault,
/* harmony export */   "__classPrivateFieldGet": () => /* binding */ __classPrivateFieldGet,
/* harmony export */   "__classPrivateFieldSet": () => /* binding */ __classPrivateFieldSet
/* harmony export */ });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function __spreadArray(to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),

/***/ 9209:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {


/**
 * For Node.js, simply re-export the core `util.deprecate` function.
 */

module.exports = __nccwpck_require__(1669).deprecate;


/***/ }),

/***/ 481:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var isString = __nccwpck_require__(3482);
var isNumber = __nccwpck_require__(6671);
var isBoolean = __nccwpck_require__(3428);
var isSymbol = __nccwpck_require__(7992);
var isBigInt = __nccwpck_require__(5454);

// eslint-disable-next-line consistent-return
module.exports = function whichBoxedPrimitive(value) {
	// eslint-disable-next-line eqeqeq
	if (value == null || (typeof value !== 'object' && typeof value !== 'function')) {
		return null;
	}
	if (isString(value)) {
		return 'String';
	}
	if (isNumber(value)) {
		return 'Number';
	}
	if (isBoolean(value)) {
		return 'Boolean';
	}
	if (isSymbol(value)) {
		return 'Symbol';
	}
	if (isBigInt(value)) {
		return 'BigInt';
	}
};


/***/ }),

/***/ 2454:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var isMap = __nccwpck_require__(8120);
var isSet = __nccwpck_require__(7936);
var isWeakMap = __nccwpck_require__(4010);
var isWeakSet = __nccwpck_require__(4689);

module.exports = function whichCollection(value) {
	if (value && typeof value === 'object') {
		if (isMap(value)) {
			return 'Map';
		}
		if (isSet(value)) {
			return 'Set';
		}
		if (isWeakMap(value)) {
			return 'WeakMap';
		}
		if (isWeakSet(value)) {
			return 'WeakSet';
		}
	}
	return false;
};


/***/ }),

/***/ 2715:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var forEach = __nccwpck_require__(3219);
var availableTypedArrays = __nccwpck_require__(3308);
var callBound = __nccwpck_require__(8749);

var $toString = callBound('Object.prototype.toString');
var hasSymbols = __nccwpck_require__(3805)();
var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === 'symbol';

var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = __nccwpck_require__(9850);
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		if (typeof global[typedArray] === 'function') {
			var arr = new global[typedArray]();
			if (!(Symbol.toStringTag in arr)) {
				throw new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');
			}
			var proto = getPrototypeOf(arr);
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor) {
				var superProto = getPrototypeOf(proto);
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			toStrTags[typedArray] = descriptor.get;
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var foundName = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!foundName) {
			try {
				var name = getter.call(value);
				if (name === typedArray) {
					foundName = name;
				}
			} catch (e) {}
		}
	});
	return foundName;
};

var isTypedArray = __nccwpck_require__(8234);

module.exports = function whichTypedArray(value) {
	if (!isTypedArray(value)) { return false; }
	if (!hasToStringTag) { return $slice($toString(value), 8, -1); }
	return tryTypedArrays(value);
};


/***/ }),

/***/ 9850:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var GetIntrinsic = __nccwpck_require__(9879);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%');
if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ 4586:
/***/ ((module) => {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}


/***/ }),

/***/ 5028:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const WebSocket = __nccwpck_require__(9427);

WebSocket.createWebSocketStream = __nccwpck_require__(8162);
WebSocket.Server = __nccwpck_require__(7350);
WebSocket.Receiver = __nccwpck_require__(2212);
WebSocket.Sender = __nccwpck_require__(2288);

module.exports = WebSocket;


/***/ }),

/***/ 5439:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { EMPTY_BUFFER } = __nccwpck_require__(7508);

/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
function concat(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER;
  if (list.length === 1) return list[0];

  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;

  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    target.set(buf, offset);
    offset += buf.length;
  }

  if (offset < totalLength) return target.slice(0, offset);

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
function _mask(source, mask, output, offset, length) {
  for (let i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
function _unmask(buffer, mask) {
  // Required until https://github.com/nodejs/node/issues/9006 is resolved.
  const length = buffer.length;
  for (let i = 0; i < length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */
function toArrayBuffer(buf) {
  if (buf.byteLength === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
}

/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */
function toBuffer(data) {
  toBuffer.readOnly = true;

  if (Buffer.isBuffer(data)) return data;

  let buf;

  if (data instanceof ArrayBuffer) {
    buf = Buffer.from(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer.readOnly = false;
  }

  return buf;
}

try {
  const bufferUtil = __nccwpck_require__(1421);
  const bu = bufferUtil.BufferUtil || bufferUtil;

  module.exports = {
    concat,
    mask(source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bu.mask(source, mask, output, offset, length);
    },
    toArrayBuffer,
    toBuffer,
    unmask(buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bu.unmask(buffer, mask);
    }
  };
} catch (e) /* istanbul ignore next */ {
  module.exports = {
    concat,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
  };
}


/***/ }),

/***/ 7508:
/***/ ((module) => {

"use strict";


module.exports = {
  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  EMPTY_BUFFER: Buffer.alloc(0),
  NOOP: () => {}
};


/***/ }),

/***/ 7817:
/***/ ((module) => {

"use strict";


/**
 * Class representing an event.
 *
 * @private
 */
class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @param {Object} target A reference to the target to which the event was
   *     dispatched
   */
  constructor(type, target) {
    this.target = target;
    this.type = type;
  }
}

/**
 * Class representing a message event.
 *
 * @extends Event
 * @private
 */
class MessageEvent extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data
   * @param {WebSocket} target A reference to the target to which the event was
   *     dispatched
   */
  constructor(data, target) {
    super('message', target);

    this.data = data;
  }
}

/**
 * Class representing a close event.
 *
 * @extends Event
 * @private
 */
class CloseEvent extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {Number} code The status code explaining why the connection is being
   *     closed
   * @param {String} reason A human-readable string explaining why the
   *     connection is closing
   * @param {WebSocket} target A reference to the target to which the event was
   *     dispatched
   */
  constructor(code, reason, target) {
    super('close', target);

    this.wasClean = target._closeFrameReceived && target._closeFrameSent;
    this.reason = reason;
    this.code = code;
  }
}

/**
 * Class representing an open event.
 *
 * @extends Event
 * @private
 */
class OpenEvent extends Event {
  /**
   * Create a new `OpenEvent`.
   *
   * @param {WebSocket} target A reference to the target to which the event was
   *     dispatched
   */
  constructor(target) {
    super('open', target);
  }
}

/**
 * Class representing an error event.
 *
 * @extends Event
 * @private
 */
class ErrorEvent extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {Object} error The error that generated this event
   * @param {WebSocket} target A reference to the target to which the event was
   *     dispatched
   */
  constructor(error, target) {
    super('error', target);

    this.message = error.message;
    this.error = error;
  }
}

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {Function} listener The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean`` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, listener, options) {
    if (typeof listener !== 'function') return;

    function onMessage(data) {
      listener.call(this, new MessageEvent(data, this));
    }

    function onClose(code, message) {
      listener.call(this, new CloseEvent(code, message, this));
    }

    function onError(error) {
      listener.call(this, new ErrorEvent(error, this));
    }

    function onOpen() {
      listener.call(this, new OpenEvent(this));
    }

    const method = options && options.once ? 'once' : 'on';

    if (type === 'message') {
      onMessage._listener = listener;
      this[method](type, onMessage);
    } else if (type === 'close') {
      onClose._listener = listener;
      this[method](type, onClose);
    } else if (type === 'error') {
      onError._listener = listener;
      this[method](type, onError);
    } else if (type === 'open') {
      onOpen._listener = listener;
      this[method](type, onOpen);
    } else {
      this[method](type, listener);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {Function} listener The listener to remove
   * @public
   */
  removeEventListener(type, listener) {
    const listeners = this.listeners(type);

    for (let i = 0; i < listeners.length; i++) {
      if (listeners[i] === listener || listeners[i]._listener === listener) {
        this.removeListener(type, listeners[i]);
      }
    }
  }
};

module.exports = EventTarget;


/***/ }),

/***/ 6130:
/***/ ((module) => {

"use strict";


//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];
  else dest[name].push(elem);
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse(header) {
  const offers = Object.create(null);

  if (header === undefined || header === '') return offers;

  let params = Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let end = -1;
  let i = 0;

  for (; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 /* ' ' */ || code === 0x09 /* '\t' */) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = Object.create(null);
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22 /* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c /* '\' */) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        let value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }
        push(params, paramName, value);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }

  if (start === -1 || inQuotes) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push(offers, token, params);
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }

  return offers;
}

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */
function format(extensions) {
  return Object.keys(extensions)
    .map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations
        .map((params) => {
          return [extension]
            .concat(
              Object.keys(params).map((k) => {
                let values = params[k];
                if (!Array.isArray(values)) values = [values];
                return values
                  .map((v) => (v === true ? k : `${k}=${v}`))
                  .join('; ');
              })
            )
            .join('; ');
        })
        .join(', ');
    })
    .join(', ');
}

module.exports = { format, parse };


/***/ }),

/***/ 5233:
/***/ ((module) => {

"use strict";


const kDone = Symbol('kDone');
const kRun = Symbol('kRun');

/**
 * A very simple job queue with adjustable concurrency. Adapted from
 * https://github.com/STRML/async-limiter
 */
class Limiter {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */
  constructor(concurrency) {
    this[kDone] = () => {
      this.pending--;
      this[kRun]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }

  /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */
  add(job) {
    this.jobs.push(job);
    this[kRun]();
  }

  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [kRun]() {
    if (this.pending === this.concurrency) return;

    if (this.jobs.length) {
      const job = this.jobs.shift();

      this.pending++;
      job(this[kDone]);
    }
  }
}

module.exports = Limiter;


/***/ }),

/***/ 3301:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const zlib = __nccwpck_require__(8761);

const bufferUtil = __nccwpck_require__(5439);
const Limiter = __nccwpck_require__(5233);
const { kStatusCode, NOOP } = __nccwpck_require__(7508);

const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const kPerMessageDeflate = Symbol('permessage-deflate');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;

/**
 * permessage-deflate implementation.
 */
class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold =
      this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter) {
      const concurrency =
        this._options.concurrencyLimit !== undefined
          ? this._options.concurrencyLimit
          : 10;
      zlibLimiter = new Limiter(concurrency);
    }
  }

  /**
   * @type {String}
   */
  static get extensionName() {
    return 'permessage-deflate';
  }

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }

    return params;
  }

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  }

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }

    if (this._deflate) {
      const callback = this._deflate[kCallback];

      this._deflate.close();
      this._deflate = null;

      if (callback) {
        callback(
          new Error(
            'The deflate stream was closed while data was being processed'
          )
        );
      }
    }
  }

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      }

      return true;
    });

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    }

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    }

    return accepted;
  }

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }

    return params;
  }

  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }

        params[key] = value;
      });
    });

    return configurations;
  }

  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Compress data. Concurrency limited.
   *
   * @param {Buffer} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on('error', inflateOnError);
      this._inflate.on('data', inflateOnData);
    }

    this._inflate[kCallback] = callback;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);

    this._inflate.flush(() => {
      const err = this._inflate[kError];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }

      const data = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );

      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._inflate.reset();
      }

      callback(null, data);
    });
  }

  /**
   * Compress data.
   *
   * @param {Buffer} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      //
      // An `'error'` event is emitted, only on Node.js < 10.0.0, if the
      // `zlib.DeflateRaw` instance is closed while data is being processed.
      // This can happen if `PerMessageDeflate#cleanup()` is called at the wrong
      // time due to an abnormal WebSocket closure.
      //
      this._deflate.on('error', NOOP);
      this._deflate.on('data', deflateOnData);
    }

    this._deflate[kCallback] = callback;

    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        //
        // The deflate stream was closed while data was being processed.
        //
        return;
      }

      let data = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );

      if (fin) data = data.slice(0, data.length - 4);

      //
      // Ensure that the callback will not be called again in
      // `PerMessageDeflate#cleanup()`.
      //
      this._deflate[kCallback] = null;

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.reset();
      }

      callback(null, data);
    });
  }
}

module.exports = PerMessageDeflate;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (
    this[kPerMessageDeflate]._maxPayload < 1 ||
    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
  ) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError] = new RangeError('Max payload size exceeded');
  this[kError][kStatusCode] = 1009;
  this.removeListener('data', inflateOnData);
  this.reset();
}

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */
function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode] = 1007;
  this[kCallback](err);
}


/***/ }),

/***/ 2212:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { Writable } = __nccwpck_require__(2413);

const PerMessageDeflate = __nccwpck_require__(3301);
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  kStatusCode,
  kWebSocket
} = __nccwpck_require__(7508);
const { concat, toArrayBuffer, unmask } = __nccwpck_require__(5439);
const { isValidStatusCode, isValidUTF8 } = __nccwpck_require__(750);

const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;

/**
 * HyBi Receiver implementation.
 *
 * @extends stream.Writable
 */
class Receiver extends Writable {
  /**
   * Creates a Receiver instance.
   *
   * @param {String} [binaryType=nodebuffer] The type for binary data
   * @param {Object} [extensions] An object containing the negotiated extensions
   * @param {Boolean} [isServer=false] Specifies whether to operate in client or
   *     server mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(binaryType, extensions, isServer, maxPayload) {
    super();

    this._binaryType = binaryType || BINARY_TYPES[0];
    this[kWebSocket] = undefined;
    this._extensions = extensions || {};
    this._isServer = !!isServer;
    this._maxPayload = maxPayload | 0;

    this._bufferedBytes = 0;
    this._buffers = [];

    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];

    this._state = GET_INFO;
    this._loop = false;
  }

  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }

  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n) {
    this._bufferedBytes -= n;

    if (n === this._buffers[0].length) return this._buffers.shift();

    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = buf.slice(n);
      return buf.slice(0, n);
    }

    const dst = Buffer.allocUnsafe(n);

    do {
      const buf = this._buffers[0];
      const offset = dst.length - n;

      if (n >= buf.length) {
        dst.set(this._buffers.shift(), offset);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
        this._buffers[0] = buf.slice(n);
      }

      n -= buf.length;
    } while (n > 0);

    return dst;
  }

  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    let err;
    this._loop = true;

    do {
      switch (this._state) {
        case GET_INFO:
          err = this.getInfo();
          break;
        case GET_PAYLOAD_LENGTH_16:
          err = this.getPayloadLength16();
          break;
        case GET_PAYLOAD_LENGTH_64:
          err = this.getPayloadLength64();
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          err = this.getData(cb);
          break;
        default:
          // `INFLATING`
          this._loop = false;
          return;
      }
    } while (this._loop);

    cb(err);
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getInfo() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    const buf = this.consume(2);

    if ((buf[0] & 0x30) !== 0x00) {
      this._loop = false;
      return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002);
    }

    const compressed = (buf[0] & 0x40) === 0x40;

    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
      this._loop = false;
      return error(RangeError, 'RSV1 must be clear', true, 1002);
    }

    this._fin = (buf[0] & 0x80) === 0x80;
    this._opcode = buf[0] & 0x0f;
    this._payloadLength = buf[1] & 0x7f;

    if (this._opcode === 0x00) {
      if (compressed) {
        this._loop = false;
        return error(RangeError, 'RSV1 must be clear', true, 1002);
      }

      if (!this._fragmented) {
        this._loop = false;
        return error(RangeError, 'invalid opcode 0', true, 1002);
      }

      this._opcode = this._fragmented;
    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
      if (this._fragmented) {
        this._loop = false;
        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
      }

      this._compressed = compressed;
    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
      if (!this._fin) {
        this._loop = false;
        return error(RangeError, 'FIN must be set', true, 1002);
      }

      if (compressed) {
        this._loop = false;
        return error(RangeError, 'RSV1 must be clear', true, 1002);
      }

      if (this._payloadLength > 0x7d) {
        this._loop = false;
        return error(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002
        );
      }
    } else {
      this._loop = false;
      return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
    }

    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 0x80) === 0x80;

    if (this._isServer) {
      if (!this._masked) {
        this._loop = false;
        return error(RangeError, 'MASK must be set', true, 1002);
      }
    } else if (this._masked) {
      this._loop = false;
      return error(RangeError, 'MASK must be clear', true, 1002);
    }

    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
    else return this.haveLength();
  }

  /**
   * Gets extended payload length (7+16).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength16() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    this._payloadLength = this.consume(2).readUInt16BE(0);
    return this.haveLength();
  }

  /**
   * Gets extended payload length (7+64).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength64() {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }

    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);

    //
    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
    // if payload length is greater than this number.
    //
    if (num > Math.pow(2, 53 - 32) - 1) {
      this._loop = false;
      return error(
        RangeError,
        'Unsupported WebSocket frame: payload length > 2^53 - 1',
        false,
        1009
      );
    }

    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    return this.haveLength();
  }

  /**
   * Payload length has been read.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  haveLength() {
    if (this._payloadLength && this._opcode < 0x08) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        this._loop = false;
        return error(RangeError, 'Max payload size exceeded', false, 1009);
      }
    }

    if (this._masked) this._state = GET_MASK;
    else this._state = GET_DATA;
  }

  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }

    this._mask = this.consume(4);
    this._state = GET_DATA;
  }

  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  getData(cb) {
    let data = EMPTY_BUFFER;

    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }

      data = this.consume(this._payloadLength);
      if (this._masked) unmask(data, this._mask);
    }

    if (this._opcode > 0x07) return this.controlMessage(data);

    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }

    if (data.length) {
      //
      // This message is not compressed so its lenght is the sum of the payload
      // length of all fragments.
      //
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }

    return this.dataMessage();
  }

  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err) return cb(err);

      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          return cb(
            error(RangeError, 'Max payload size exceeded', false, 1009)
          );
        }

        this._fragments.push(buf);
      }

      const er = this.dataMessage();
      if (er) return cb(er);

      this.startLoop(cb);
    });
  }

  /**
   * Handles a data message.
   *
   * @return {(Error|undefined)} A possible error
   * @private
   */
  dataMessage() {
    if (this._fin) {
      const messageLength = this._messageLength;
      const fragments = this._fragments;

      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];

      if (this._opcode === 2) {
        let data;

        if (this._binaryType === 'nodebuffer') {
          data = concat(fragments, messageLength);
        } else if (this._binaryType === 'arraybuffer') {
          data = toArrayBuffer(concat(fragments, messageLength));
        } else {
          data = fragments;
        }

        this.emit('message', data);
      } else {
        const buf = concat(fragments, messageLength);

        if (!isValidUTF8(buf)) {
          this._loop = false;
          return error(Error, 'invalid UTF-8 sequence', true, 1007);
        }

        this.emit('message', buf.toString());
      }
    }

    this._state = GET_INFO;
  }

  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data) {
    if (this._opcode === 0x08) {
      this._loop = false;

      if (data.length === 0) {
        this.emit('conclude', 1005, '');
        this.end();
      } else if (data.length === 1) {
        return error(RangeError, 'invalid payload length 1', true, 1002);
      } else {
        const code = data.readUInt16BE(0);

        if (!isValidStatusCode(code)) {
          return error(RangeError, `invalid status code ${code}`, true, 1002);
        }

        const buf = data.slice(2);

        if (!isValidUTF8(buf)) {
          return error(Error, 'invalid UTF-8 sequence', true, 1007);
        }

        this.emit('conclude', code, buf.toString());
        this.end();
      }
    } else if (this._opcode === 0x09) {
      this.emit('ping', data);
    } else {
      this.emit('pong', data);
    }

    this._state = GET_INFO;
  }
}

module.exports = Receiver;

/**
 * Builds an error object.
 *
 * @param {(Error|RangeError)} ErrorCtor The error constructor
 * @param {String} message The error message
 * @param {Boolean} prefix Specifies whether or not to add a default prefix to
 *     `message`
 * @param {Number} statusCode The status code
 * @return {(Error|RangeError)} The error
 * @private
 */
function error(ErrorCtor, message, prefix, statusCode) {
  const err = new ErrorCtor(
    prefix ? `Invalid WebSocket frame: ${message}` : message
  );

  Error.captureStackTrace(err, error);
  err[kStatusCode] = statusCode;
  return err;
}


/***/ }),

/***/ 2288:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { randomFillSync } = __nccwpck_require__(6417);

const PerMessageDeflate = __nccwpck_require__(3301);
const { EMPTY_BUFFER } = __nccwpck_require__(7508);
const { isValidStatusCode } = __nccwpck_require__(750);
const { mask: applyMask, toBuffer } = __nccwpck_require__(5439);

const mask = Buffer.alloc(4);

/**
 * HyBi Sender implementation.
 */
class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {net.Socket} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   */
  constructor(socket, extensions) {
    this._extensions = extensions || {};
    this._socket = socket;

    this._firstFragment = true;
    this._compress = false;

    this._bufferedBytes = 0;
    this._deflating = false;
    this._queue = [];
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {Buffer} data The data to frame
   * @param {Object} options Options object
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {Buffer[]} The framed data as a list of `Buffer` instances
   * @public
   */
  static frame(data, options) {
    const merge = options.mask && options.readOnly;
    let offset = options.mask ? 6 : 2;
    let payloadLength = data.length;

    if (data.length >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (data.length > 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    target[1] = payloadLength;

    if (payloadLength === 126) {
      target.writeUInt16BE(data.length, 2);
    } else if (payloadLength === 127) {
      target.writeUInt32BE(0, 2);
      target.writeUInt32BE(data.length, 6);
    }

    if (!options.mask) return [target, data];

    randomFillSync(mask, 0, 4);

    target[1] |= 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (merge) {
      applyMask(data, mask, target, offset, data.length);
      return [target];
    }

    applyMask(data, mask, data, 0, data.length);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {Number} [code] The status code component of the body
   * @param {String} [data] The message component of the body
   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
   * @param {Function} [cb] Callback
   * @public
   */
  close(code, data, mask, cb) {
    let buf;

    if (code === undefined) {
      buf = EMPTY_BUFFER;
    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
      throw new TypeError('First argument must be a valid error code number');
    } else if (data === undefined || data === '') {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length = Buffer.byteLength(data);

      if (length > 123) {
        throw new RangeError('The message must not be greater than 123 bytes');
      }

      buf = Buffer.allocUnsafe(2 + length);
      buf.writeUInt16BE(code, 0);
      buf.write(data, 2);
    }

    if (this._deflating) {
      this.enqueue([this.doClose, buf, mask, cb]);
    } else {
      this.doClose(buf, mask, cb);
    }
  }

  /**
   * Frames and sends a close message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @private
   */
  doClose(data, mask, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x08,
        mask,
        readOnly: false
      }),
      cb
    );
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  ping(data, mask, cb) {
    const buf = toBuffer(data);

    if (buf.length > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    if (this._deflating) {
      this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);
    } else {
      this.doPing(buf, mask, toBuffer.readOnly, cb);
    }
  }

  /**
   * Frames and sends a ping message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
   * @param {Function} [cb] Callback
   * @private
   */
  doPing(data, mask, readOnly, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x09,
        mask,
        readOnly
      }),
      cb
    );
  }

  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  pong(data, mask, cb) {
    const buf = toBuffer(data);

    if (buf.length > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    if (this._deflating) {
      this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);
    } else {
      this.doPong(buf, mask, toBuffer.readOnly, cb);
    }
  }

  /**
   * Frames and sends a pong message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
   * @param {Function} [cb] Callback
   * @private
   */
  doPong(data, mask, readOnly, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x0a,
        mask,
        readOnly
      }),
      cb
    );
  }

  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} [options.compress=false] Specifies whether or not to
   *     compress `data`
   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
   *     or text
   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Function} [cb] Callback
   * @public
   */
  send(data, options, cb) {
    const buf = toBuffer(data);
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
    let opcode = options.binary ? 2 : 1;
    let rsv1 = options.compress;

    if (this._firstFragment) {
      this._firstFragment = false;
      if (rsv1 && perMessageDeflate) {
        rsv1 = buf.length >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }

    if (options.fin) this._firstFragment = true;

    if (perMessageDeflate) {
      const opts = {
        fin: options.fin,
        rsv1,
        opcode,
        mask: options.mask,
        readOnly: toBuffer.readOnly
      };

      if (this._deflating) {
        this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
      } else {
        this.dispatch(buf, this._compress, opts, cb);
      }
    } else {
      this.sendFrame(
        Sender.frame(buf, {
          fin: options.fin,
          rsv1: false,
          opcode,
          mask: options.mask,
          readOnly: toBuffer.readOnly
        }),
        cb
      );
    }
  }

  /**
   * Dispatches a data message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     `data`
   * @param {Object} options Options object
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  dispatch(data, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options), cb);
      return;
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    this._bufferedBytes += data.length;
    this._deflating = true;
    perMessageDeflate.compress(data, options.fin, (_, buf) => {
      if (this._socket.destroyed) {
        const err = new Error(
          'The socket was closed while data was being compressed'
        );

        if (typeof cb === 'function') cb(err);

        for (let i = 0; i < this._queue.length; i++) {
          const callback = this._queue[i][4];

          if (typeof callback === 'function') callback(err);
        }

        return;
      }

      this._bufferedBytes -= data.length;
      this._deflating = false;
      options.readOnly = false;
      this.sendFrame(Sender.frame(buf, options), cb);
      this.dequeue();
    });
  }

  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (!this._deflating && this._queue.length) {
      const params = this._queue.shift();

      this._bufferedBytes -= params[1].length;
      Reflect.apply(params[0], this, params.slice(1));
    }
  }

  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[1].length;
    this._queue.push(params);
  }

  /**
   * Sends a frame.
   *
   * @param {Buffer[]} list The frame to send
   * @param {Function} [cb] Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
}

module.exports = Sender;


/***/ }),

/***/ 8162:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { Duplex } = __nccwpck_require__(2413);

/**
 * Emits the `'close'` event on a stream.
 *
 * @param {stream.Duplex} The stream.
 * @private
 */
function emitClose(stream) {
  stream.emit('close');
}

/**
 * The listener of the `'end'` event.
 *
 * @private
 */
function duplexOnEnd() {
  if (!this.destroyed && this._writableState.finished) {
    this.destroy();
  }
}

/**
 * The listener of the `'error'` event.
 *
 * @param {Error} err The error
 * @private
 */
function duplexOnError(err) {
  this.removeListener('error', duplexOnError);
  this.destroy();
  if (this.listenerCount('error') === 0) {
    // Do not suppress the throwing behavior.
    this.emit('error', err);
  }
}

/**
 * Wraps a `WebSocket` in a duplex stream.
 *
 * @param {WebSocket} ws The `WebSocket` to wrap
 * @param {Object} [options] The options for the `Duplex` constructor
 * @return {stream.Duplex} The duplex stream
 * @public
 */
function createWebSocketStream(ws, options) {
  let resumeOnReceiverDrain = true;

  function receiverOnDrain() {
    if (resumeOnReceiverDrain) ws._socket.resume();
  }

  if (ws.readyState === ws.CONNECTING) {
    ws.once('open', function open() {
      ws._receiver.removeAllListeners('drain');
      ws._receiver.on('drain', receiverOnDrain);
    });
  } else {
    ws._receiver.removeAllListeners('drain');
    ws._receiver.on('drain', receiverOnDrain);
  }

  const duplex = new Duplex({
    ...options,
    autoDestroy: false,
    emitClose: false,
    objectMode: false,
    writableObjectMode: false
  });

  ws.on('message', function message(msg) {
    if (!duplex.push(msg)) {
      resumeOnReceiverDrain = false;
      ws._socket.pause();
    }
  });

  ws.once('error', function error(err) {
    if (duplex.destroyed) return;

    duplex.destroy(err);
  });

  ws.once('close', function close() {
    if (duplex.destroyed) return;

    duplex.push(null);
  });

  duplex._destroy = function (err, callback) {
    if (ws.readyState === ws.CLOSED) {
      callback(err);
      process.nextTick(emitClose, duplex);
      return;
    }

    let called = false;

    ws.once('error', function error(err) {
      called = true;
      callback(err);
    });

    ws.once('close', function close() {
      if (!called) callback(err);
      process.nextTick(emitClose, duplex);
    });
    ws.terminate();
  };

  duplex._final = function (callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._final(callback);
      });
      return;
    }

    // If the value of the `_socket` property is `null` it means that `ws` is a
    // client websocket and the handshake failed. In fact, when this happens, a
    // socket is never assigned to the websocket. Wait for the `'error'` event
    // that will be emitted by the websocket.
    if (ws._socket === null) return;

    if (ws._socket._writableState.finished) {
      callback();
      if (duplex._readableState.endEmitted) duplex.destroy();
    } else {
      ws._socket.once('finish', function finish() {
        // `duplex` is not destroyed here because the `'end'` event will be
        // emitted on `duplex` after this `'finish'` event. The EOF signaling
        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
        callback();
      });
      ws.close();
    }
  };

  duplex._read = function () {
    if (ws.readyState === ws.OPEN && !resumeOnReceiverDrain) {
      resumeOnReceiverDrain = true;
      if (!ws._receiver._writableState.needDrain) ws._socket.resume();
    }
  };

  duplex._write = function (chunk, encoding, callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._write(chunk, encoding, callback);
      });
      return;
    }

    ws.send(chunk, callback);
  };

  duplex.on('end', duplexOnEnd);
  duplex.on('error', duplexOnError);
  return duplex;
}

module.exports = createWebSocketStream;


/***/ }),

/***/ 750:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


try {
  const isValidUTF8 = __nccwpck_require__(7187);

  exports.isValidUTF8 =
    typeof isValidUTF8 === 'object'
      ? isValidUTF8.Validation.isValidUTF8 // utf-8-validate@<3.0.0
      : isValidUTF8;
} catch (e) /* istanbul ignore next */ {
  exports.isValidUTF8 = () => true;
}

/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */
exports.isValidStatusCode = (code) => {
  return (
    (code >= 1000 &&
      code <= 1014 &&
      code !== 1004 &&
      code !== 1005 &&
      code !== 1006) ||
    (code >= 3000 && code <= 4999)
  );
};


/***/ }),

/***/ 7350:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const EventEmitter = __nccwpck_require__(8614);
const { createHash } = __nccwpck_require__(6417);
const { createServer, STATUS_CODES } = __nccwpck_require__(8605);

const PerMessageDeflate = __nccwpck_require__(3301);
const WebSocket = __nccwpck_require__(9427);
const { format, parse } = __nccwpck_require__(6130);
const { GUID, kWebSocket } = __nccwpck_require__(7508);

const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Number} [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param {Function} [options.handleProtocols] A hook to handle protocols
   * @param {String} [options.host] The hostname where to bind the server
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.noServer=false] Enable no server mode
   * @param {String} [options.path] Accept only connections matching this path
   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.port] The port where to bind the server
   * @param {http.Server} [options.server] A pre-created HTTP/S server to use
   * @param {Function} [options.verifyClient] A hook to reject connections
   * @param {Function} [callback] A listener for the `listening` event
   */
  constructor(options, callback) {
    super();

    options = {
      maxPayload: 100 * 1024 * 1024,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      ...options
    };

    if (options.port == null && !options.server && !options.noServer) {
      throw new TypeError(
        'One of the "port", "server", or "noServer" options must be specified'
      );
    }

    if (options.port != null) {
      this._server = createServer((req, res) => {
        const body = STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      const emitConnection = this.emit.bind(this, 'connection');

      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, emitConnection);
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
    if (options.clientTracking) this.clients = new Set();
    this.options = options;
  }

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }

    if (!this._server) return null;
    return this._server.address();
  }

  /**
   * Close the server.
   *
   * @param {Function} [cb] Callback
   * @public
   */
  close(cb) {
    if (cb) this.once('close', cb);

    //
    // Terminate all associated clients.
    //
    if (this.clients) {
      for (const client of this.clients) client.terminate();
    }

    const server = this._server;

    if (server) {
      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // Close the http server if it was internally created.
      //
      if (this.options.port != null) {
        server.close(() => this.emit('close'));
        return;
      }
    }

    process.nextTick(emitClose, this);
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) {
    if (this.options.path) {
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) {
    socket.on('error', socketOnError);

    const key =
      req.headers['sec-websocket-key'] !== undefined
        ? req.headers['sec-websocket-key'].trim()
        : false;
    const version = +req.headers['sec-websocket-version'];
    const extensions = {};

    if (
      req.method !== 'GET' ||
      req.headers.upgrade.toLowerCase() !== 'websocket' ||
      !key ||
      !keyRegex.test(key) ||
      (version !== 8 && version !== 13) ||
      !this.shouldHandle(req)
    ) {
      return abortHandshake(socket, 400);
    }

    if (this.options.perMessageDeflate) {
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try {
        const offers = parse(req.headers['sec-websocket-extensions']);

        if (offers[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        return abortHandshake(socket, 400);
      }
    }

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) {
      const info = {
        origin:
          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
        secure: !!(req.socket.authorized || req.socket.encrypted),
        req
      };

      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }

          this.completeUpgrade(key, extensions, req, socket, head, cb);
        });
        return;
      }

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    }

    this.completeUpgrade(key, extensions, req, socket, head, cb);
  }

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Object} extensions The accepted extensions
   * @param {http.IncomingMessage} req The request object
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */
  completeUpgrade(key, extensions, req, socket, head, cb) {
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    if (socket[kWebSocket]) {
      throw new Error(
        'server.handleUpgrade() was called more than once with the same ' +
          'socket, possibly due to a misconfiguration'
      );
    }

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${digest}`
    ];

    const ws = new WebSocket(null);
    let protocol = req.headers['sec-websocket-protocol'];

    if (protocol) {
      protocol = protocol.trim().split(/ *, */);

      //
      // Optionally call external protocol selection handler.
      //
      if (this.options.handleProtocols) {
        protocol = this.options.handleProtocols(protocol, req);
      } else {
        protocol = protocol[0];
      }

      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws._protocol = protocol;
      }
    }

    if (extensions[PerMessageDeflate.extensionName]) {
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = format({
        [PerMessageDeflate.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, this.options.maxPayload);

    if (this.clients) {
      this.clients.add(ws);
      ws.on('close', () => this.clients.delete(ws));
    }

    cb(ws, req);
  }
}

module.exports = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when
 *     called
 * @private
 */
function addListeners(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */
function emitClose(server) {
  server.emit('close');
}

/**
 * Handle premature socket errors.
 *
 * @private
 */
function socketOnError() {
  this.destroy();
}

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {net.Socket} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake(socket, code, message, headers) {
  if (socket.writable) {
    message = message || STATUS_CODES[code];
    headers = {
      Connection: 'close',
      'Content-Type': 'text/html',
      'Content-Length': Buffer.byteLength(message),
      ...headers
    };

    socket.write(
      `HTTP/1.1 ${code} ${STATUS_CODES[code]}\r\n` +
        Object.keys(headers)
          .map((h) => `${h}: ${headers[h]}`)
          .join('\r\n') +
        '\r\n\r\n' +
        message
    );
  }

  socket.removeListener('error', socketOnError);
  socket.destroy();
}


/***/ }),

/***/ 9427:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const EventEmitter = __nccwpck_require__(8614);
const https = __nccwpck_require__(7211);
const http = __nccwpck_require__(8605);
const net = __nccwpck_require__(1631);
const tls = __nccwpck_require__(4016);
const { randomBytes, createHash } = __nccwpck_require__(6417);
const { URL } = __nccwpck_require__(8835);

const PerMessageDeflate = __nccwpck_require__(3301);
const Receiver = __nccwpck_require__(2212);
const Sender = __nccwpck_require__(2288);
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID,
  kStatusCode,
  kWebSocket,
  NOOP
} = __nccwpck_require__(7508);
const { addEventListener, removeEventListener } = __nccwpck_require__(7817);
const { format, parse } = __nccwpck_require__(6130);
const { toBuffer } = __nccwpck_require__(5439);

const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const protocolVersions = [8, 13];
const closeTimeout = 30 * 1000;

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
class WebSocket extends EventEmitter {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|url.URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  constructor(address, protocols, options) {
    super();

    this._binaryType = BINARY_TYPES[0];
    this._closeCode = 1006;
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = '';
    this._closeTimer = null;
    this._extensions = {};
    this._protocol = '';
    this._readyState = WebSocket.CONNECTING;
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;

      if (Array.isArray(protocols)) {
        protocols = protocols.join(', ');
      } else if (typeof protocols === 'object' && protocols !== null) {
        options = protocols;
        protocols = undefined;
      }

      initAsClient(this, address, protocols, options);
    } else {
      this._isServer = true;
    }
  }

  /**
   * This deviates from the WHATWG interface since ws doesn't support the
   * required default "blob" type (instead we define a custom "nodebuffer"
   * type).
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }

  set binaryType(type) {
    if (!BINARY_TYPES.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return this._bufferedAmount;

    return this._socket._writableState.length + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }

  /**
   * @type {String}
   */
  get protocol() {
    return this._protocol;
  }

  /**
   * @type {Number}
   */
  get readyState() {
    return this._readyState;
  }

  /**
   * @type {String}
   */
  get url() {
    return this._url;
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Number} [maxPayload=0] The maximum allowed message size
   * @private
   */
  setSocket(socket, head, maxPayload) {
    const receiver = new Receiver(
      this.binaryType,
      this._extensions,
      this._isServer,
      maxPayload
    );

    this._sender = new Sender(socket, this._extensions);
    this._receiver = receiver;
    this._socket = socket;

    receiver[kWebSocket] = this;
    socket[kWebSocket] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    socket.setTimeout(0);
    socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError);

    this._readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this._readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate.extensionName]) {
      this._extensions[PerMessageDeflate.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this._readyState = WebSocket.CLOSED;
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} [code] Status code explaining why the connection is closing
   * @param {String} [data] A string explaining why the connection is closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();
      return;
    }

    this._readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;
      if (this._closeFrameReceived) this._socket.end();
    });

    //
    // Specify a timeout for the closing handshake to complete.
    //
    this._closeTimer = setTimeout(
      this._socket.destroy.bind(this._socket),
      closeTimeout
    );
  }

  /**
   * Send a ping.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} [options] Options object
   * @param {Boolean} [options.compress] Specifies whether or not to compress
   *     `data`
   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
   *     text
   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    const opts = {
      binary: typeof data !== 'string',
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options
    };

    if (!this._extensions[PerMessageDeflate.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || EMPTY_BUFFER, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this._socket) {
      this._readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
}

readyStates.forEach((readyState, i) => {
  const descriptor = { enumerable: true, value: i };

  Object.defineProperty(WebSocket.prototype, readyState, descriptor);
  Object.defineProperty(WebSocket, readyState, descriptor);
});

[
  'binaryType',
  'bufferedAmount',
  'extensions',
  'protocol',
  'readyState',
  'url'
].forEach((property) => {
  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket.prototype, `on${method}`, {
    configurable: true,
    enumerable: true,
    /**
     * Return the listener of the event.
     *
     * @return {(Function|undefined)} The event listener or `undefined`
     * @public
     */
    get() {
      const listeners = this.listeners(method);
      for (let i = 0; i < listeners.length; i++) {
        if (listeners[i]._listener) return listeners[i]._listener;
      }

      return undefined;
    },
    /**
     * Add a listener for the event.
     *
     * @param {Function} listener The listener to add
     * @public
     */
    set(listener) {
      const listeners = this.listeners(method);
      for (let i = 0; i < listeners.length; i++) {
        //
        // Remove only the listeners added via `addEventListener`.
        //
        if (listeners[i]._listener) this.removeListener(method, listeners[i]);
      }
      this.addEventListener(method, listener);
    }
  });
});

WebSocket.prototype.addEventListener = addEventListener;
WebSocket.prototype.removeEventListener = removeEventListener;

module.exports = WebSocket;

/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|url.URL)} address The URL to which to connect
 * @param {String} [protocols] The subprotocols
 * @param {Object} [options] Connection options
 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
 *     permessage-deflate
 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
 *     handshake request
 * @param {Number} [options.protocolVersion=13] Value of the
 *     `Sec-WebSocket-Version` header
 * @param {String} [options.origin] Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
 *     size
 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
 *     redirects
 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
 *     allowed
 * @private
 */
function initAsClient(websocket, address, protocols, options) {
  const opts = {
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options,
    createConnection: undefined,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: undefined,
    host: undefined,
    path: undefined,
    port: undefined
  };

  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} ` +
        `(supported versions: ${protocolVersions.join(', ')})`
    );
  }

  let parsedUrl;

  if (address instanceof URL) {
    parsedUrl = address;
    websocket._url = address.href;
  } else {
    parsedUrl = new URL(address);
    websocket._url = address;
  }

  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';

  if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
    throw new Error(`Invalid URL: ${websocket.url}`);
  }

  const isSecure =
    parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';
  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString('base64');
  const get = isSecure ? https.get : http.get;
  let perMessageDeflate;

  opts.createConnection = isSecure ? tlsConnect : netConnect;
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  opts.headers = {
    'Sec-WebSocket-Version': opts.protocolVersion,
    'Sec-WebSocket-Key': key,
    Connection: 'Upgrade',
    Upgrade: 'websocket',
    ...opts.headers
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers['Sec-WebSocket-Extensions'] = format({
      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols) {
    opts.headers['Sec-WebSocket-Protocol'] = protocols;
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isUnixSocket) {
    const parts = opts.path.split(':');

    opts.socketPath = parts[0];
    opts.path = parts[1];
  }

  let req = (websocket._req = get(opts));

  if (opts.timeout) {
    req.on('timeout', () => {
      abortHandshake(websocket, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', (err) => {
    if (req === null || req.aborted) return;

    req = websocket._req = null;
    websocket._readyState = WebSocket.CLOSING;
    websocket.emit('error', err);
    websocket.emitClose();
  });

  req.on('response', (res) => {
    const location = res.headers.location;
    const statusCode = res.statusCode;

    if (
      location &&
      opts.followRedirects &&
      statusCode >= 300 &&
      statusCode < 400
    ) {
      if (++websocket._redirects > opts.maxRedirects) {
        abortHandshake(websocket, req, 'Maximum redirects exceeded');
        return;
      }

      req.abort();

      const addr = new URL(location, address);

      initAsClient(websocket, addr, protocols, options);
    } else if (!websocket.emit('unexpected-response', req, res)) {
      abortHandshake(
        websocket,
        req,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });

  req.on('upgrade', (res, socket, head) => {
    websocket.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the `upgrade`
    // event.
    //
    if (websocket.readyState !== WebSocket.CONNECTING) return;

    req = websocket._req = null;

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    const serverProt = res.headers['sec-websocket-protocol'];
    const protList = (protocols || '').split(/, */);
    let protError;

    if (!protocols && serverProt) {
      protError = 'Server sent a subprotocol but none was requested';
    } else if (protocols && !serverProt) {
      protError = 'Server sent no subprotocol';
    } else if (serverProt && !protList.includes(serverProt)) {
      protError = 'Server sent an invalid subprotocol';
    }

    if (protError) {
      abortHandshake(websocket, socket, protError);
      return;
    }

    if (serverProt) websocket._protocol = serverProt;

    if (perMessageDeflate) {
      try {
        const extensions = parse(res.headers['sec-websocket-extensions']);

        if (extensions[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          websocket._extensions[
            PerMessageDeflate.extensionName
          ] = perMessageDeflate;
        }
      } catch (err) {
        abortHandshake(
          websocket,
          socket,
          'Invalid Sec-WebSocket-Extensions header'
        );
        return;
      }
    }

    websocket.setSocket(socket, head, opts.maxPayload);
  });
}

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */
function netConnect(options) {
  options.path = options.socketPath;
  return net.connect(options);
}

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */
function tlsConnect(options) {
  options.path = undefined;

  if (!options.servername && options.servername !== '') {
    options.servername = net.isIP(options.host) ? '' : options.host;
  }

  return tls.connect(options);
}

/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket)} stream The request to abort or the
 *     socket to destroy
 * @param {String} message The error message
 * @private
 */
function abortHandshake(websocket, stream, message) {
  websocket._readyState = WebSocket.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);

  if (stream.setHeader) {
    stream.abort();
    stream.once('abort', websocket.emitClose.bind(websocket));
    websocket.emit('error', err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}

/**
 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {*} [data] The data to send
 * @param {Function} [cb] Callback
 * @private
 */
function sendAfterClose(websocket, data, cb) {
  if (data) {
    const length = toBuffer(data).length;

    //
    // The `_bufferedAmount` property is used only when the peer is a client and
    // the opening handshake fails. Under these circumstances, in fact, the
    // `setSocket()` method is not called, so the `_socket` and `_sender`
    // properties are set to `null`.
    //
    if (websocket._socket) websocket._sender._bufferedBytes += length;
    else websocket._bufferedAmount += length;
  }

  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket.readyState} ` +
        `(${readyStates[websocket.readyState]})`
    );
    cb(err);
  }
}

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {String} reason The reason for closing
 * @private
 */
function receiverOnConclude(code, reason) {
  const websocket = this[kWebSocket];

  websocket._socket.removeListener('data', socketOnData);
  websocket._socket.resume();

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
}

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain() {
  this[kWebSocket]._socket.resume();
}

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */
function receiverOnError(err) {
  const websocket = this[kWebSocket];

  websocket._socket.removeListener('data', socketOnData);

  websocket._readyState = WebSocket.CLOSING;
  websocket._closeCode = err[kStatusCode];
  websocket.emit('error', err);
  websocket._socket.destroy();
}

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish() {
  this[kWebSocket].emitClose();
}

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message
 * @private
 */
function receiverOnMessage(data) {
  this[kWebSocket].emit('message', data);
}

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */
function receiverOnPing(data) {
  const websocket = this[kWebSocket];

  websocket.pong(data, !websocket._isServer, NOOP);
  websocket.emit('ping', data);
}

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */
function receiverOnPong(data) {
  this[kWebSocket].emit('pong', data);
}

/**
 * The listener of the `net.Socket` `'close'` event.
 *
 * @private
 */
function socketOnClose() {
  const websocket = this[kWebSocket];

  this.removeListener('close', socketOnClose);
  this.removeListener('end', socketOnEnd);

  websocket._readyState = WebSocket.CLOSING;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk and emitted synchronously in a single
  // `'data'` event.
  //
  websocket._socket.read();
  websocket._receiver.end();

  this.removeListener('data', socketOnData);
  this[kWebSocket] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  }
}

/**
 * The listener of the `net.Socket` `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData(chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the `net.Socket` `'end'` event.
 *
 * @private
 */
function socketOnEnd() {
  const websocket = this[kWebSocket];

  websocket._readyState = WebSocket.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the `net.Socket` `'error'` event.
 *
 * @private
 */
function socketOnError() {
  const websocket = this[kWebSocket];

  this.removeListener('error', socketOnError);
  this.on('error', NOOP);

  if (websocket) {
    websocket._readyState = WebSocket.CLOSING;
    this.destroy();
  }
}


/***/ }),

/***/ 6738:
/***/ ((module) => {

module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}


/***/ }),

/***/ 9268:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class Platform {
    constructor(api) {
        this._api = api;
    }
    get api() {
        return this._api;
    }
}
exports.default = Platform;
//# sourceMappingURL=Platform.js.map

/***/ }),

/***/ 3611:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.update = exports.setAccessories = exports.setDeviceGroups = exports.setGroupSettings = void 0;
const actionNames_1 = __nccwpck_require__(9129);
const setGroupSettings = (payload) => ({
    type: actionNames_1.GROUPS.SET_GROUP_SETTINGS,
    payload,
});
exports.setGroupSettings = setGroupSettings;
const setDeviceGroups = (payload) => ({
    type: actionNames_1.GROUPS.SET_DEVICE_GROUPS,
    payload,
});
exports.setDeviceGroups = setDeviceGroups;
const setAccessories = (payload) => ({
    type: actionNames_1.GROUPS.SET_ACCESSORIES,
    payload,
});
exports.setAccessories = setAccessories;
const update = (payload) => ({
    type: actionNames_1.GROUPS.UPDATE,
    payload,
});
exports.update = update;
//# sourceMappingURL=groups.js.map

/***/ }),

/***/ 8658:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const create = (store) => {
    const setDeviceGroups = async (device, groups) => {
        const state = store.getState();
        const current = state.deviceGroups || {};
        await Promise.resolve(store.dispatch({
            type: '@@MQTT/publish',
            payload: {
                ...current,
                [device]: groups,
            },
            meta: {
                topic: 'groups/devices',
                retain: true,
            },
        }));
    };
    const setGroupSettings = async (groups, settings) => {
        const state = store.getState();
        const current = state.groupSettings || {};
        const next = groups.reduce((output, group) => ({
            ...output,
            [group]: settings,
        }), current);
        await Promise.resolve(store.dispatch({
            type: '@@MQTT/publish',
            payload: next,
            meta: {
                topic: 'groups/settings',
                retain: true,
            },
        }));
    };
    return {
        setDeviceGroups,
        setGroupSettings,
    };
};
exports.default = create;
//# sourceMappingURL=scripts.js.map

/***/ }),

/***/ 9129:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PLATFORM = exports.GROUPS = void 0;
exports.GROUPS = {
    SET_DEVICE_GROUPS: '@@GROUPS/setDeviceGroups',
    SET_GROUP_SETTINGS: '@@GROUPS/setGroupSettings',
    SET_ACCESSORIES: '@@GROUPS/setAccessories',
    UPDATE: '@@GROUPS/update',
};
exports.PLATFORM = {
    SET_DEVICE: '@@PLATFORM/addDevice',
    REMOVE_DEVICE: '@@PLATFORM/removeDevice',
};
//# sourceMappingURL=actionNames.js.map

/***/ }),

/***/ 6186:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.actionNames = exports.createDefaultState = exports.groupActions = exports.Platform = exports.createScriptActions = void 0;
const scripts_1 = __importDefault(__nccwpck_require__(8658));
exports.createScriptActions = scripts_1.default;
const Platform_1 = __importDefault(__nccwpck_require__(9268));
exports.Platform = Platform_1.default;
const groupActions = __importStar(__nccwpck_require__(3611));
exports.groupActions = groupActions;
const actionNames = __importStar(__nccwpck_require__(9129));
exports.actionNames = actionNames;
const createDefaultState = () => ({
    devices: {},
    accessories: {},
    deviceGroups: {},
    deviceStates: {},
    groupSettings: {},
    accessoryStates: {},
});
exports.createDefaultState = createDefaultState;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 6581:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const rolighed_common_1 = __nccwpck_require__(6186);
const mqtt_1 = __importDefault(__nccwpck_require__(5173));
class PlatformZigbee2MQTT extends rolighed_common_1.Platform {
    constructor(api) {
        super(api);
        this._topic = 'zigbee2mqtt';
        this._onMessage = (topic, message) => {
            const data = JSON.parse(message);
            if (topic === `${this._topic}/bridge/devices`) {
                const topics = Object.values(data).map((device) => `${this._topic}/${device.friendly_name}`);
                this._client.subscribe(topics);
            }
            else {
                const name = topic.substring(this._topic.length + 1);
                this.api.setDevice(name, data);
            }
        };
        this.setup = async () => {
        };
        this.onSetDeviceState = async (name, state) => {
            this._client.publish(`${this._topic}/${name}/set`, JSON.stringify(state));
        };
        this._client = mqtt_1.default.connect('mqtt://localhost');
        this._client.subscribe(`${this._topic}/bridge/devices`);
        this._client.on('message', this._onMessage);
    }
}
exports.default = PlatformZigbee2MQTT;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7589:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const hap = __importStar(__nccwpck_require__(7585));
const rolighed_common_1 = __nccwpck_require__(6186);
const accessoryTypes_1 = __importDefault(__nccwpck_require__(2023));
class Accessories {
    constructor(bridge, store) {
        this._accessories = {};
        this._setupAccessory = (name) => {
            if (this._accessories[name]) {
                return;
            }
            const definition = this._store.getState().accessories[name];
            const type = accessoryTypes_1.default[definition.type];
            const newAccessory = new hap.Accessory(name, hap.uuid.generate(name));
            this._bridge.addBridgedAccessory(newAccessory);
            this._accessories[name] = newAccessory;
            type.services.forEach((serviceType) => {
                const service = new serviceType.type(name, hap.uuid.generate(name));
                Object.entries(serviceType.props).map(([prop, propDefinition]) => {
                    if (!definition.bind[prop])
                        return;
                    const charactaristic = service.getCharacteristic(propDefinition.type);
                    charactaristic.on("set" /* SET */, (value, callback) => {
                        const definition = this._store.getState().accessories[name];
                        const group = definition.bind[prop];
                        const rolighedValue = propDefinition.to(value);
                        this._store.dispatch(rolighed_common_1.groupActions.setGroupSettings({
                            [group]: {
                                [prop]: rolighedValue,
                            }
                        }));
                        callback();
                    });
                    charactaristic.on("get" /* GET */, (callback) => {
                        const state = this._store.getState();
                        const current = state.accessoryStates[name][prop];
                        const homekitValue = propDefinition.from(current);
                        callback(undefined, homekitValue);
                    });
                });
                newAccessory.addService(service);
            });
        };
        this._updateAccessory = (name, next = {}, previous = {}) => {
            this._setupAccessory(name);
            const definition = this._store.getState().accessories[name];
            const accessory = this._accessories[name];
            const type = accessoryTypes_1.default[definition.type];
            type.services.forEach((serviceType) => {
                const service = accessory.getService(serviceType.type);
                Object.entries(serviceType.props).map(([prop, propDefinition]) => {
                    if (!definition.bind[prop])
                        return;
                    if (next[prop] === previous[prop])
                        return;
                    const homekitValue = propDefinition.from(next[prop]);
                    service.setCharacteristic(propDefinition.type, homekitValue);
                });
            });
        };
        this.update = (next, previous) => {
            const previousAccessoryStates = previous.accessoryStates;
            const nextAccessoryStates = next.accessoryStates;
            Object.entries(nextAccessoryStates).forEach(([name, next]) => {
                const previous = previousAccessoryStates[name];
                this._updateAccessory(name, next, previous);
            });
        };
        this._bridge = bridge;
        this._store = store;
    }
}
exports.default = Accessories;
//# sourceMappingURL=Accessories.js.map

/***/ }),

/***/ 2023:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const hap = __importStar(__nccwpck_require__(7585));
const types = {
    lightbulb: {
        services: [{
                type: hap.Service.Lightbulb,
                props: {
                    state: {
                        type: hap.Characteristic.On,
                        from: input => input === 'ON',
                        to: input => input ? 'ON' : 'OFF',
                    },
                    brightness: {
                        type: hap.Characteristic.Brightness,
                        from: input => (input || 10) / 2.55,
                        to: input => Math.max(1, input * 2.55),
                    },
                }
            }],
    },
    door: {
        services: [{
                type: hap.Service.Outlet,
                props: {
                    open: {
                        type: hap.Characteristic.On,
                        to: a => a,
                        from: a => a !== null && a !== void 0 ? a : false,
                    },
                },
            }],
    },
};
exports.default = types;
//# sourceMappingURL=accessoryTypes.js.map

/***/ }),

/***/ 5163:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const hap = __importStar(__nccwpck_require__(7585));
const Accessories_1 = __importDefault(__nccwpck_require__(7589));
const homekitPlugin = async (options) => (store) => (next) => {
    const bridge = new hap.Bridge(options.name || 'Rolighed', hap.uuid.generate(options.username));
    const accessories = new Accessories_1.default(bridge, store);
    let previousState = store.getState();
    bridge.getService(hap.Service.AccessoryInformation)
        .setCharacteristic(hap.Characteristic.Manufacturer, 'Rolighed')
        .setCharacteristic(hap.Characteristic.Model, 'Rolighed Homekit')
        .setCharacteristic(hap.Characteristic.SerialNumber, options.username);
    bridge.publish({
        username: options.username,
        port: options.port || 51882,
        pincode: options.pincode,
        category: 2 /* BRIDGE */,
    }, options.allowInsecureRequest);
    return async (action) => {
        const result = await next(action);
        const nextState = store.getState();
        accessories.update(nextState, previousState);
        previousState = nextState;
        return result;
    };
};
exports.default = homekitPlugin;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 221:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const redux_1 = __nccwpck_require__(6805);
const scripts_1 = __importDefault(__nccwpck_require__(7857));
const socket_1 = __importDefault(__nccwpck_require__(7021));
const platforms_1 = __importDefault(__nccwpck_require__(3806));
const reducers_1 = __importDefault(__nccwpck_require__(3665));
const buildIn = {
    scripts: scripts_1.default,
    platforms: platforms_1.default,
    socket: socket_1.default,
};
const create = async (options) => {
    const middlewares = Object.entries(options.plugins).map(async ([_, config]) => {
        let pkgMiddleware;
        if (typeof config.pkg === 'string' && buildIn[config.pkg]) {
            pkgMiddleware = buildIn[config.pkg];
        }
        else if (typeof config.pkg === 'string') {
            const pkg = require(config.pkg);
            pkgMiddleware = pkg.default || pkg;
        }
        else {
            pkgMiddleware = config.pkg;
        }
        const instance = await pkgMiddleware(config.config);
        return instance;
    });
    const store = redux_1.createStore(reducers_1.default(), options.initialState, redux_1.applyMiddleware(...await Promise.all(middlewares)));
    return store;
};
exports.default = create;
//# sourceMappingURL=createStore.js.map

/***/ }),

/***/ 3175:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.scripts = exports.websocket = exports.platforms = exports.createScriptActions = void 0;
const createStore_1 = __importDefault(__nccwpck_require__(221));
const platforms_1 = __importDefault(__nccwpck_require__(3806));
exports.platforms = platforms_1.default;
const socket_1 = __importDefault(__nccwpck_require__(7021));
exports.websocket = socket_1.default;
const scripts_1 = __importDefault(__nccwpck_require__(7857));
exports.scripts = scripts_1.default;
const rolighed_common_1 = __nccwpck_require__(6186);
Object.defineProperty(exports, "createScriptActions", ({ enumerable: true, get: function () { return rolighed_common_1.createScriptActions; } }));
exports.default = createStore_1.default;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 54:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const jsondiffpatch = __importStar(__nccwpck_require__(3392));
class SocketClient {
    constructor(socket, store) {
        this._setup = () => {
            this._send('core/setup', {
                state: this._state,
            });
        };
        this._onmessage = ({ data }) => {
            const msg = JSON.parse(data.toString());
            switch (msg.type) {
                case 'dispatch': {
                    this._store.dispatch(msg.payload);
                }
            }
        };
        this._send = (type, payload) => {
            this._socket.send(JSON.stringify({
                type,
                payload,
            }));
        };
        this.updateState = (action) => {
            const next = this._store.getState();
            const diff = jsondiffpatch.diff(next, this._state);
            this._send('state/partial', {
                diff,
                action,
            });
            this._store = next;
        };
        this._socket = socket;
        this._store = store;
        this._state = store.getState();
        socket.onmessage = this._onmessage;
        this._setup();
    }
}
exports.default = SocketClient;
//# sourceMappingURL=SocketClient.js.map

/***/ }),

/***/ 3806:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const rolighed_common_1 = __nccwpck_require__(6186);
const createApi = (next, controller) => ({
    removeDevice: (name) => Promise.resolve(next({
        type: rolighed_common_1.actionNames.PLATFORM.REMOVE_DEVICE,
        payload: name,
        meta: {
            name,
            controller,
        },
    })),
    setDevice: (name, state, config) => Promise.resolve(next({
        type: rolighed_common_1.actionNames.PLATFORM.SET_DEVICE,
        payload: {
            state,
            config,
        },
        meta: {
            name,
            controller,
        },
    })),
});
const createPlatforms = async (options) => (store) => (next) => {
    const platforms = Object.entries(options).reduce((output, [name, definition]) => {
        let PlatformClass;
        if (typeof definition.pkg === 'string') {
            const pkg = require(definition.pkg);
            PlatformClass = pkg.default || pkg;
        }
        else {
            PlatformClass = definition.pkg;
        }
        const api = createApi(next, name);
        const instance = new PlatformClass(api);
        return {
            ...output,
            [name]: instance,
        };
    }, {});
    let deviceCache = {};
    return async (action) => {
        const result = await next(action);
        const state = store.getState();
        const devices = state.deviceStates;
        const running = Object.entries(devices).map(async ([name, deviceState]) => {
            if (deviceState === deviceCache[name])
                return;
            const device = state.devices[name];
            if (!device)
                return;
            const platform = platforms[device.controller];
            if (!platform)
                return;
            await platform.onSetDeviceState(name, deviceState);
            deviceCache[name] = deviceState;
        });
        await Promise.all(running);
        return result;
    };
};
exports.default = createPlatforms;
//# sourceMappingURL=platforms.js.map

/***/ }),

/***/ 7857:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const createScripts = async (scripts) => (store) => (next) => {
    const scriptList = Object.entries(scripts).map(([_, definition]) => {
        let script;
        if (typeof definition.pkg === 'string') {
            const pkg = require(definition.pkg);
            script = pkg.default || pkg;
        }
        else {
            script = definition.pkg;
        }
        return script(definition.config, {
            dispatch: store.dispatch,
            getState: store.getState,
        });
    });
    return async (action) => {
        const result = await Promise.resolve(next(action));
        await Promise.all(scriptList.map((script) => script(action)));
        return result;
    };
};
exports.default = createScripts;
//# sourceMappingURL=scripts.js.map

/***/ }),

/***/ 7021:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ws_1 = __importDefault(__nccwpck_require__(3268));
const SocketClient_1 = __importDefault(__nccwpck_require__(54));
const socketMiddleware = async (options) => (store) => (next) => {
    let clients = [];
    const server = new ws_1.default.Server({
        port: options.port || 8081,
    });
    server.on('connection', (socket) => {
        const client = new SocketClient_1.default(socket, store);
        clients.push(client);
        socket.onclose = () => {
            clients = clients.filter(c => c !== client);
        };
    });
    server.on('error', (err) => {
        console.error('err', err);
    });
    return async (action) => {
        const result = await next(action);
        clients.forEach((client) => client.updateState(action));
        return result;
    };
};
exports.default = socketMiddleware;
//# sourceMappingURL=socket.js.map

/***/ }),

/***/ 5335:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const rolighed_common_1 = __nccwpck_require__(6186);
const createDefaultState = () => ({
    devices: {},
    deviceGroups: {},
    groupSettings: {},
    deviceStates: {},
    accessories: {},
    accessoryStates: {},
});
const createDeviceStates = (state) => {
    const { deviceGroups, groupSettings } = state;
    const deviceStates = Object.entries(deviceGroups).reduce((output, [device, groups]) => {
        const deviceState = groups.reduce((output, group) => ({
            ...output,
            ...(groupSettings[group] || {}),
        }), {});
        return {
            ...output,
            [device]: deviceState,
        };
    }, {});
    return deviceStates;
};
const createAccessoryStates = (state) => {
    const { accessories, groupSettings } = state;
    const accessoryStates = Object.entries(accessories).reduce((output, [name, { bind }]) => {
        const accessoryState = Object.entries(bind).reduce((output, [prop, group]) => ({
            ...output,
            [prop]: (groupSettings[group] || {})[prop],
        }), {});
        return {
            ...output,
            [name]: accessoryState,
        };
    }, {});
    return accessoryStates;
};
const groups = () => (state = createDefaultState(), action) => {
    switch (action.type) {
        case rolighed_common_1.actionNames.PLATFORM.SET_DEVICE:
            {
                return {
                    ...state,
                    devices: {
                        ...state.devices,
                        [action.meta.name]: {
                            ...state.devices[action.meta.name],
                            ...action.payload,
                            controller: action.meta.controller,
                        },
                    },
                };
            }
            ;
        case rolighed_common_1.actionNames.PLATFORM.REMOVE_DEVICE:
            {
                const newState = {
                    ...state,
                    devices: {
                        ...state.devices,
                    },
                };
                delete newState.devices[action.payload];
                return newState;
            }
            ;
        case rolighed_common_1.actionNames.GROUPS.SET_GROUP_SETTINGS: {
            const newState = {
                ...state,
                groupSettings: {
                    ...state.groupSettings,
                    ...Object.entries(action.payload).reduce((output, [name, values]) => ({
                        ...output,
                        [name]: {
                            ...(state.groupSettings[name] || {}),
                            ...values,
                        },
                    }), {}),
                },
            };
            return {
                ...newState,
                deviceStates: createDeviceStates(newState),
                accessoryStates: createAccessoryStates(newState),
            };
        }
        case rolighed_common_1.actionNames.GROUPS.SET_DEVICE_GROUPS: {
            const newState = {
                ...state,
                deviceGroups: {
                    ...state.deviceGroups,
                    ...action.payload,
                },
            };
            return {
                ...newState,
                deviceStates: createDeviceStates(newState),
            };
        }
        case rolighed_common_1.actionNames.GROUPS.SET_ACCESSORIES: {
            const newState = {
                ...state,
                accessories: action.payload,
            };
            return {
                ...newState,
                accessoryStates: createAccessoryStates(newState),
            };
        }
        case rolighed_common_1.actionNames.GROUPS.UPDATE: {
            const newState = {
                ...state,
                accessories: {
                    ...state.accessories,
                    ...(action.payload.accessories || {}),
                },
                deviceGroups: {
                    ...state.deviceGroups,
                    ...(action.payload.deviceGroups || {}),
                },
                groupSettings: {
                    ...state.groupSettings,
                    ...(action.payload.groupSettings || {}),
                },
            };
            return {
                ...newState,
                accessoryStates: createAccessoryStates(newState),
                deviceStates: createDeviceStates(newState),
            };
        }
        default: {
            return state;
        }
    }
    ;
};
exports.default = groups;
//# sourceMappingURL=groups.js.map

/***/ }),

/***/ 3665:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const groups_1 = __importDefault(__nccwpck_require__(5335));
exports.default = groups_1.default;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 3268:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const WebSocket = __nccwpck_require__(6702);

WebSocket.createWebSocketStream = __nccwpck_require__(6643);
WebSocket.Server = __nccwpck_require__(6943);
WebSocket.Receiver = __nccwpck_require__(1233);
WebSocket.Sender = __nccwpck_require__(1404);

module.exports = WebSocket;


/***/ }),

/***/ 5827:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { EMPTY_BUFFER } = __nccwpck_require__(2596);

/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
function concat(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER;
  if (list.length === 1) return list[0];

  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;

  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    target.set(buf, offset);
    offset += buf.length;
  }

  if (offset < totalLength) return target.slice(0, offset);

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
function _mask(source, mask, output, offset, length) {
  for (let i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
function _unmask(buffer, mask) {
  // Required until https://github.com/nodejs/node/issues/9006 is resolved.
  const length = buffer.length;
  for (let i = 0; i < length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */
function toArrayBuffer(buf) {
  if (buf.byteLength === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
}

/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */
function toBuffer(data) {
  toBuffer.readOnly = true;

  if (Buffer.isBuffer(data)) return data;

  let buf;

  if (data instanceof ArrayBuffer) {
    buf = Buffer.from(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer.readOnly = false;
  }

  return buf;
}

try {
  const bufferUtil = __nccwpck_require__(1421);
  const bu = bufferUtil.BufferUtil || bufferUtil;

  module.exports = {
    concat,
    mask(source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bu.mask(source, mask, output, offset, length);
    },
    toArrayBuffer,
    toBuffer,
    unmask(buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bu.unmask(buffer, mask);
    }
  };
} catch (e) /* istanbul ignore next */ {
  module.exports = {
    concat,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
  };
}


/***/ }),

/***/ 2596:
/***/ ((module) => {

"use strict";


module.exports = {
  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  EMPTY_BUFFER: Buffer.alloc(0),
  NOOP: () => {}
};


/***/ }),

/***/ 1706:
/***/ ((module) => {

"use strict";


/**
 * Class representing an event.
 *
 * @private
 */
class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @param {Object} target A reference to the target to which the event was
   *     dispatched
   */
  constructor(type, target) {
    this.target = target;
    this.type = type;
  }
}

/**
 * Class representing a message event.
 *
 * @extends Event
 * @private
 */
class MessageEvent extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data
   * @param {WebSocket} target A reference to the target to which the event was
   *     dispatched
   */
  constructor(data, target) {
    super('message', target);

    this.data = data;
  }
}

/**
 * Class representing a close event.
 *
 * @extends Event
 * @private
 */
class CloseEvent extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {Number} code The status code explaining why the connection is being
   *     closed
   * @param {String} reason A human-readable string explaining why the
   *     connection is closing
   * @param {WebSocket} target A reference to the target to which the event was
   *     dispatched
   */
  constructor(code, reason, target) {
    super('close', target);

    this.wasClean = target._closeFrameReceived && target._closeFrameSent;
    this.reason = reason;
    this.code = code;
  }
}

/**
 * Class representing an open event.
 *
 * @extends Event
 * @private
 */
class OpenEvent extends Event {
  /**
   * Create a new `OpenEvent`.
   *
   * @param {WebSocket} target A reference to the target to which the event was
   *     dispatched
   */
  constructor(target) {
    super('open', target);
  }
}

/**
 * Class representing an error event.
 *
 * @extends Event
 * @private
 */
class ErrorEvent extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {Object} error The error that generated this event
   * @param {WebSocket} target A reference to the target to which the event was
   *     dispatched
   */
  constructor(error, target) {
    super('error', target);

    this.message = error.message;
    this.error = error;
  }
}

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {Function} listener The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean`` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, listener, options) {
    if (typeof listener !== 'function') return;

    function onMessage(data) {
      listener.call(this, new MessageEvent(data, this));
    }

    function onClose(code, message) {
      listener.call(this, new CloseEvent(code, message, this));
    }

    function onError(error) {
      listener.call(this, new ErrorEvent(error, this));
    }

    function onOpen() {
      listener.call(this, new OpenEvent(this));
    }

    const method = options && options.once ? 'once' : 'on';

    if (type === 'message') {
      onMessage._listener = listener;
      this[method](type, onMessage);
    } else if (type === 'close') {
      onClose._listener = listener;
      this[method](type, onClose);
    } else if (type === 'error') {
      onError._listener = listener;
      this[method](type, onError);
    } else if (type === 'open') {
      onOpen._listener = listener;
      this[method](type, onOpen);
    } else {
      this[method](type, listener);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {Function} listener The listener to remove
   * @public
   */
  removeEventListener(type, listener) {
    const listeners = this.listeners(type);

    for (let i = 0; i < listeners.length; i++) {
      if (listeners[i] === listener || listeners[i]._listener === listener) {
        this.removeListener(type, listeners[i]);
      }
    }
  }
};

module.exports = EventTarget;


/***/ }),

/***/ 1380:
/***/ ((module) => {

"use strict";


//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];
  else dest[name].push(elem);
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse(header) {
  const offers = Object.create(null);

  if (header === undefined || header === '') return offers;

  let params = Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let end = -1;
  let i = 0;

  for (; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 /* ' ' */ || code === 0x09 /* '\t' */) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = Object.create(null);
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22 /* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c /* '\' */) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        let value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }
        push(params, paramName, value);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }

  if (start === -1 || inQuotes) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push(offers, token, params);
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }

  return offers;
}

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */
function format(extensions) {
  return Object.keys(extensions)
    .map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations
        .map((params) => {
          return [extension]
            .concat(
              Object.keys(params).map((k) => {
                let values = params[k];
                if (!Array.isArray(values)) values = [values];
                return values
                  .map((v) => (v === true ? k : `${k}=${v}`))
                  .join('; ');
              })
            )
            .join('; ');
        })
        .join(', ');
    })
    .join(', ');
}

module.exports = { format, parse };


/***/ }),

/***/ 1024:
/***/ ((module) => {

"use strict";


const kDone = Symbol('kDone');
const kRun = Symbol('kRun');

/**
 * A very simple job queue with adjustable concurrency. Adapted from
 * https://github.com/STRML/async-limiter
 */
class Limiter {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */
  constructor(concurrency) {
    this[kDone] = () => {
      this.pending--;
      this[kRun]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }

  /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */
  add(job) {
    this.jobs.push(job);
    this[kRun]();
  }

  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [kRun]() {
    if (this.pending === this.concurrency) return;

    if (this.jobs.length) {
      const job = this.jobs.shift();

      this.pending++;
      job(this[kDone]);
    }
  }
}

module.exports = Limiter;


/***/ }),

/***/ 9317:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const zlib = __nccwpck_require__(8761);

const bufferUtil = __nccwpck_require__(5827);
const Limiter = __nccwpck_require__(1024);
const { kStatusCode, NOOP } = __nccwpck_require__(2596);

const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const kPerMessageDeflate = Symbol('permessage-deflate');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;

/**
 * permessage-deflate implementation.
 */
class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold =
      this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter) {
      const concurrency =
        this._options.concurrencyLimit !== undefined
          ? this._options.concurrencyLimit
          : 10;
      zlibLimiter = new Limiter(concurrency);
    }
  }

  /**
   * @type {String}
   */
  static get extensionName() {
    return 'permessage-deflate';
  }

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }

    return params;
  }

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  }

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }

    if (this._deflate) {
      const callback = this._deflate[kCallback];

      this._deflate.close();
      this._deflate = null;

      if (callback) {
        callback(
          new Error(
            'The deflate stream was closed while data was being processed'
          )
        );
      }
    }
  }

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      }

      return true;
    });

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    }

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    }

    return accepted;
  }

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }

    return params;
  }

  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }

        params[key] = value;
      });
    });

    return configurations;
  }

  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Compress data. Concurrency limited.
   *
   * @param {Buffer} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on('error', inflateOnError);
      this._inflate.on('data', inflateOnData);
    }

    this._inflate[kCallback] = callback;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);

    this._inflate.flush(() => {
      const err = this._inflate[kError];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }

      const data = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );

      if (this._inflate._readableState.endEmitted) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];

        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._inflate.reset();
        }
      }

      callback(null, data);
    });
  }

  /**
   * Compress data.
   *
   * @param {Buffer} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      //
      // An `'error'` event is emitted, only on Node.js < 10.0.0, if the
      // `zlib.DeflateRaw` instance is closed while data is being processed.
      // This can happen if `PerMessageDeflate#cleanup()` is called at the wrong
      // time due to an abnormal WebSocket closure.
      //
      this._deflate.on('error', NOOP);
      this._deflate.on('data', deflateOnData);
    }

    this._deflate[kCallback] = callback;

    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        //
        // The deflate stream was closed while data was being processed.
        //
        return;
      }

      let data = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );

      if (fin) data = data.slice(0, data.length - 4);

      //
      // Ensure that the callback will not be called again in
      // `PerMessageDeflate#cleanup()`.
      //
      this._deflate[kCallback] = null;

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.reset();
      }

      callback(null, data);
    });
  }
}

module.exports = PerMessageDeflate;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (
    this[kPerMessageDeflate]._maxPayload < 1 ||
    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
  ) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError] = new RangeError('Max payload size exceeded');
  this[kError][kStatusCode] = 1009;
  this.removeListener('data', inflateOnData);
  this.reset();
}

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */
function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode] = 1007;
  this[kCallback](err);
}


/***/ }),

/***/ 1233:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { Writable } = __nccwpck_require__(2413);

const PerMessageDeflate = __nccwpck_require__(9317);
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  kStatusCode,
  kWebSocket
} = __nccwpck_require__(2596);
const { concat, toArrayBuffer, unmask } = __nccwpck_require__(5827);
const { isValidStatusCode, isValidUTF8 } = __nccwpck_require__(1013);

const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;

/**
 * HyBi Receiver implementation.
 *
 * @extends stream.Writable
 */
class Receiver extends Writable {
  /**
   * Creates a Receiver instance.
   *
   * @param {String} [binaryType=nodebuffer] The type for binary data
   * @param {Object} [extensions] An object containing the negotiated extensions
   * @param {Boolean} [isServer=false] Specifies whether to operate in client or
   *     server mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(binaryType, extensions, isServer, maxPayload) {
    super();

    this._binaryType = binaryType || BINARY_TYPES[0];
    this[kWebSocket] = undefined;
    this._extensions = extensions || {};
    this._isServer = !!isServer;
    this._maxPayload = maxPayload | 0;

    this._bufferedBytes = 0;
    this._buffers = [];

    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];

    this._state = GET_INFO;
    this._loop = false;
  }

  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }

  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n) {
    this._bufferedBytes -= n;

    if (n === this._buffers[0].length) return this._buffers.shift();

    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = buf.slice(n);
      return buf.slice(0, n);
    }

    const dst = Buffer.allocUnsafe(n);

    do {
      const buf = this._buffers[0];
      const offset = dst.length - n;

      if (n >= buf.length) {
        dst.set(this._buffers.shift(), offset);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
        this._buffers[0] = buf.slice(n);
      }

      n -= buf.length;
    } while (n > 0);

    return dst;
  }

  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    let err;
    this._loop = true;

    do {
      switch (this._state) {
        case GET_INFO:
          err = this.getInfo();
          break;
        case GET_PAYLOAD_LENGTH_16:
          err = this.getPayloadLength16();
          break;
        case GET_PAYLOAD_LENGTH_64:
          err = this.getPayloadLength64();
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          err = this.getData(cb);
          break;
        default:
          // `INFLATING`
          this._loop = false;
          return;
      }
    } while (this._loop);

    cb(err);
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getInfo() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    const buf = this.consume(2);

    if ((buf[0] & 0x30) !== 0x00) {
      this._loop = false;
      return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002);
    }

    const compressed = (buf[0] & 0x40) === 0x40;

    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
      this._loop = false;
      return error(RangeError, 'RSV1 must be clear', true, 1002);
    }

    this._fin = (buf[0] & 0x80) === 0x80;
    this._opcode = buf[0] & 0x0f;
    this._payloadLength = buf[1] & 0x7f;

    if (this._opcode === 0x00) {
      if (compressed) {
        this._loop = false;
        return error(RangeError, 'RSV1 must be clear', true, 1002);
      }

      if (!this._fragmented) {
        this._loop = false;
        return error(RangeError, 'invalid opcode 0', true, 1002);
      }

      this._opcode = this._fragmented;
    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
      if (this._fragmented) {
        this._loop = false;
        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
      }

      this._compressed = compressed;
    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
      if (!this._fin) {
        this._loop = false;
        return error(RangeError, 'FIN must be set', true, 1002);
      }

      if (compressed) {
        this._loop = false;
        return error(RangeError, 'RSV1 must be clear', true, 1002);
      }

      if (this._payloadLength > 0x7d) {
        this._loop = false;
        return error(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002
        );
      }
    } else {
      this._loop = false;
      return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
    }

    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 0x80) === 0x80;

    if (this._isServer) {
      if (!this._masked) {
        this._loop = false;
        return error(RangeError, 'MASK must be set', true, 1002);
      }
    } else if (this._masked) {
      this._loop = false;
      return error(RangeError, 'MASK must be clear', true, 1002);
    }

    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
    else return this.haveLength();
  }

  /**
   * Gets extended payload length (7+16).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength16() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    this._payloadLength = this.consume(2).readUInt16BE(0);
    return this.haveLength();
  }

  /**
   * Gets extended payload length (7+64).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength64() {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }

    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);

    //
    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
    // if payload length is greater than this number.
    //
    if (num > Math.pow(2, 53 - 32) - 1) {
      this._loop = false;
      return error(
        RangeError,
        'Unsupported WebSocket frame: payload length > 2^53 - 1',
        false,
        1009
      );
    }

    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    return this.haveLength();
  }

  /**
   * Payload length has been read.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  haveLength() {
    if (this._payloadLength && this._opcode < 0x08) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        this._loop = false;
        return error(RangeError, 'Max payload size exceeded', false, 1009);
      }
    }

    if (this._masked) this._state = GET_MASK;
    else this._state = GET_DATA;
  }

  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }

    this._mask = this.consume(4);
    this._state = GET_DATA;
  }

  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  getData(cb) {
    let data = EMPTY_BUFFER;

    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }

      data = this.consume(this._payloadLength);
      if (this._masked) unmask(data, this._mask);
    }

    if (this._opcode > 0x07) return this.controlMessage(data);

    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }

    if (data.length) {
      //
      // This message is not compressed so its lenght is the sum of the payload
      // length of all fragments.
      //
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }

    return this.dataMessage();
  }

  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err) return cb(err);

      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          return cb(
            error(RangeError, 'Max payload size exceeded', false, 1009)
          );
        }

        this._fragments.push(buf);
      }

      const er = this.dataMessage();
      if (er) return cb(er);

      this.startLoop(cb);
    });
  }

  /**
   * Handles a data message.
   *
   * @return {(Error|undefined)} A possible error
   * @private
   */
  dataMessage() {
    if (this._fin) {
      const messageLength = this._messageLength;
      const fragments = this._fragments;

      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];

      if (this._opcode === 2) {
        let data;

        if (this._binaryType === 'nodebuffer') {
          data = concat(fragments, messageLength);
        } else if (this._binaryType === 'arraybuffer') {
          data = toArrayBuffer(concat(fragments, messageLength));
        } else {
          data = fragments;
        }

        this.emit('message', data);
      } else {
        const buf = concat(fragments, messageLength);

        if (!isValidUTF8(buf)) {
          this._loop = false;
          return error(Error, 'invalid UTF-8 sequence', true, 1007);
        }

        this.emit('message', buf.toString());
      }
    }

    this._state = GET_INFO;
  }

  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data) {
    if (this._opcode === 0x08) {
      this._loop = false;

      if (data.length === 0) {
        this.emit('conclude', 1005, '');
        this.end();
      } else if (data.length === 1) {
        return error(RangeError, 'invalid payload length 1', true, 1002);
      } else {
        const code = data.readUInt16BE(0);

        if (!isValidStatusCode(code)) {
          return error(RangeError, `invalid status code ${code}`, true, 1002);
        }

        const buf = data.slice(2);

        if (!isValidUTF8(buf)) {
          return error(Error, 'invalid UTF-8 sequence', true, 1007);
        }

        this.emit('conclude', code, buf.toString());
        this.end();
      }
    } else if (this._opcode === 0x09) {
      this.emit('ping', data);
    } else {
      this.emit('pong', data);
    }

    this._state = GET_INFO;
  }
}

module.exports = Receiver;

/**
 * Builds an error object.
 *
 * @param {(Error|RangeError)} ErrorCtor The error constructor
 * @param {String} message The error message
 * @param {Boolean} prefix Specifies whether or not to add a default prefix to
 *     `message`
 * @param {Number} statusCode The status code
 * @return {(Error|RangeError)} The error
 * @private
 */
function error(ErrorCtor, message, prefix, statusCode) {
  const err = new ErrorCtor(
    prefix ? `Invalid WebSocket frame: ${message}` : message
  );

  Error.captureStackTrace(err, error);
  err[kStatusCode] = statusCode;
  return err;
}


/***/ }),

/***/ 1404:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { randomFillSync } = __nccwpck_require__(6417);

const PerMessageDeflate = __nccwpck_require__(9317);
const { EMPTY_BUFFER } = __nccwpck_require__(2596);
const { isValidStatusCode } = __nccwpck_require__(1013);
const { mask: applyMask, toBuffer } = __nccwpck_require__(5827);

const mask = Buffer.alloc(4);

/**
 * HyBi Sender implementation.
 */
class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {net.Socket} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   */
  constructor(socket, extensions) {
    this._extensions = extensions || {};
    this._socket = socket;

    this._firstFragment = true;
    this._compress = false;

    this._bufferedBytes = 0;
    this._deflating = false;
    this._queue = [];
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {Buffer} data The data to frame
   * @param {Object} options Options object
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {Buffer[]} The framed data as a list of `Buffer` instances
   * @public
   */
  static frame(data, options) {
    const merge = options.mask && options.readOnly;
    let offset = options.mask ? 6 : 2;
    let payloadLength = data.length;

    if (data.length >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (data.length > 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    target[1] = payloadLength;

    if (payloadLength === 126) {
      target.writeUInt16BE(data.length, 2);
    } else if (payloadLength === 127) {
      target.writeUInt32BE(0, 2);
      target.writeUInt32BE(data.length, 6);
    }

    if (!options.mask) return [target, data];

    randomFillSync(mask, 0, 4);

    target[1] |= 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (merge) {
      applyMask(data, mask, target, offset, data.length);
      return [target];
    }

    applyMask(data, mask, data, 0, data.length);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {Number} [code] The status code component of the body
   * @param {String} [data] The message component of the body
   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
   * @param {Function} [cb] Callback
   * @public
   */
  close(code, data, mask, cb) {
    let buf;

    if (code === undefined) {
      buf = EMPTY_BUFFER;
    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
      throw new TypeError('First argument must be a valid error code number');
    } else if (data === undefined || data === '') {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length = Buffer.byteLength(data);

      if (length > 123) {
        throw new RangeError('The message must not be greater than 123 bytes');
      }

      buf = Buffer.allocUnsafe(2 + length);
      buf.writeUInt16BE(code, 0);
      buf.write(data, 2);
    }

    if (this._deflating) {
      this.enqueue([this.doClose, buf, mask, cb]);
    } else {
      this.doClose(buf, mask, cb);
    }
  }

  /**
   * Frames and sends a close message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @private
   */
  doClose(data, mask, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x08,
        mask,
        readOnly: false
      }),
      cb
    );
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  ping(data, mask, cb) {
    const buf = toBuffer(data);

    if (buf.length > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    if (this._deflating) {
      this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);
    } else {
      this.doPing(buf, mask, toBuffer.readOnly, cb);
    }
  }

  /**
   * Frames and sends a ping message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
   * @param {Function} [cb] Callback
   * @private
   */
  doPing(data, mask, readOnly, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x09,
        mask,
        readOnly
      }),
      cb
    );
  }

  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  pong(data, mask, cb) {
    const buf = toBuffer(data);

    if (buf.length > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    if (this._deflating) {
      this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);
    } else {
      this.doPong(buf, mask, toBuffer.readOnly, cb);
    }
  }

  /**
   * Frames and sends a pong message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
   * @param {Function} [cb] Callback
   * @private
   */
  doPong(data, mask, readOnly, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x0a,
        mask,
        readOnly
      }),
      cb
    );
  }

  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} [options.compress=false] Specifies whether or not to
   *     compress `data`
   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
   *     or text
   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Function} [cb] Callback
   * @public
   */
  send(data, options, cb) {
    const buf = toBuffer(data);
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
    let opcode = options.binary ? 2 : 1;
    let rsv1 = options.compress;

    if (this._firstFragment) {
      this._firstFragment = false;
      if (rsv1 && perMessageDeflate) {
        rsv1 = buf.length >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }

    if (options.fin) this._firstFragment = true;

    if (perMessageDeflate) {
      const opts = {
        fin: options.fin,
        rsv1,
        opcode,
        mask: options.mask,
        readOnly: toBuffer.readOnly
      };

      if (this._deflating) {
        this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
      } else {
        this.dispatch(buf, this._compress, opts, cb);
      }
    } else {
      this.sendFrame(
        Sender.frame(buf, {
          fin: options.fin,
          rsv1: false,
          opcode,
          mask: options.mask,
          readOnly: toBuffer.readOnly
        }),
        cb
      );
    }
  }

  /**
   * Dispatches a data message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     `data`
   * @param {Object} options Options object
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  dispatch(data, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options), cb);
      return;
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    this._bufferedBytes += data.length;
    this._deflating = true;
    perMessageDeflate.compress(data, options.fin, (_, buf) => {
      if (this._socket.destroyed) {
        const err = new Error(
          'The socket was closed while data was being compressed'
        );

        if (typeof cb === 'function') cb(err);

        for (let i = 0; i < this._queue.length; i++) {
          const callback = this._queue[i][4];

          if (typeof callback === 'function') callback(err);
        }

        return;
      }

      this._bufferedBytes -= data.length;
      this._deflating = false;
      options.readOnly = false;
      this.sendFrame(Sender.frame(buf, options), cb);
      this.dequeue();
    });
  }

  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (!this._deflating && this._queue.length) {
      const params = this._queue.shift();

      this._bufferedBytes -= params[1].length;
      Reflect.apply(params[0], this, params.slice(1));
    }
  }

  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[1].length;
    this._queue.push(params);
  }

  /**
   * Sends a frame.
   *
   * @param {Buffer[]} list The frame to send
   * @param {Function} [cb] Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
}

module.exports = Sender;


/***/ }),

/***/ 6643:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { Duplex } = __nccwpck_require__(2413);

/**
 * Emits the `'close'` event on a stream.
 *
 * @param {stream.Duplex} The stream.
 * @private
 */
function emitClose(stream) {
  stream.emit('close');
}

/**
 * The listener of the `'end'` event.
 *
 * @private
 */
function duplexOnEnd() {
  if (!this.destroyed && this._writableState.finished) {
    this.destroy();
  }
}

/**
 * The listener of the `'error'` event.
 *
 * @param {Error} err The error
 * @private
 */
function duplexOnError(err) {
  this.removeListener('error', duplexOnError);
  this.destroy();
  if (this.listenerCount('error') === 0) {
    // Do not suppress the throwing behavior.
    this.emit('error', err);
  }
}

/**
 * Wraps a `WebSocket` in a duplex stream.
 *
 * @param {WebSocket} ws The `WebSocket` to wrap
 * @param {Object} [options] The options for the `Duplex` constructor
 * @return {stream.Duplex} The duplex stream
 * @public
 */
function createWebSocketStream(ws, options) {
  let resumeOnReceiverDrain = true;

  function receiverOnDrain() {
    if (resumeOnReceiverDrain) ws._socket.resume();
  }

  if (ws.readyState === ws.CONNECTING) {
    ws.once('open', function open() {
      ws._receiver.removeAllListeners('drain');
      ws._receiver.on('drain', receiverOnDrain);
    });
  } else {
    ws._receiver.removeAllListeners('drain');
    ws._receiver.on('drain', receiverOnDrain);
  }

  const duplex = new Duplex({
    ...options,
    autoDestroy: false,
    emitClose: false,
    objectMode: false,
    writableObjectMode: false
  });

  ws.on('message', function message(msg) {
    if (!duplex.push(msg)) {
      resumeOnReceiverDrain = false;
      ws._socket.pause();
    }
  });

  ws.once('error', function error(err) {
    if (duplex.destroyed) return;

    duplex.destroy(err);
  });

  ws.once('close', function close() {
    if (duplex.destroyed) return;

    duplex.push(null);
  });

  duplex._destroy = function (err, callback) {
    if (ws.readyState === ws.CLOSED) {
      callback(err);
      process.nextTick(emitClose, duplex);
      return;
    }

    let called = false;

    ws.once('error', function error(err) {
      called = true;
      callback(err);
    });

    ws.once('close', function close() {
      if (!called) callback(err);
      process.nextTick(emitClose, duplex);
    });
    ws.terminate();
  };

  duplex._final = function (callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._final(callback);
      });
      return;
    }

    // If the value of the `_socket` property is `null` it means that `ws` is a
    // client websocket and the handshake failed. In fact, when this happens, a
    // socket is never assigned to the websocket. Wait for the `'error'` event
    // that will be emitted by the websocket.
    if (ws._socket === null) return;

    if (ws._socket._writableState.finished) {
      callback();
      if (duplex._readableState.endEmitted) duplex.destroy();
    } else {
      ws._socket.once('finish', function finish() {
        // `duplex` is not destroyed here because the `'end'` event will be
        // emitted on `duplex` after this `'finish'` event. The EOF signaling
        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
        callback();
      });
      ws.close();
    }
  };

  duplex._read = function () {
    if (ws.readyState === ws.OPEN && !resumeOnReceiverDrain) {
      resumeOnReceiverDrain = true;
      if (!ws._receiver._writableState.needDrain) ws._socket.resume();
    }
  };

  duplex._write = function (chunk, encoding, callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._write(chunk, encoding, callback);
      });
      return;
    }

    ws.send(chunk, callback);
  };

  duplex.on('end', duplexOnEnd);
  duplex.on('error', duplexOnError);
  return duplex;
}

module.exports = createWebSocketStream;


/***/ }),

/***/ 1013:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


try {
  const isValidUTF8 = __nccwpck_require__(7187);

  exports.isValidUTF8 =
    typeof isValidUTF8 === 'object'
      ? isValidUTF8.Validation.isValidUTF8 // utf-8-validate@<3.0.0
      : isValidUTF8;
} catch (e) /* istanbul ignore next */ {
  exports.isValidUTF8 = () => true;
}

/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */
exports.isValidStatusCode = (code) => {
  return (
    (code >= 1000 &&
      code <= 1014 &&
      code !== 1004 &&
      code !== 1005 &&
      code !== 1006) ||
    (code >= 3000 && code <= 4999)
  );
};


/***/ }),

/***/ 6943:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const EventEmitter = __nccwpck_require__(8614);
const { createHash } = __nccwpck_require__(6417);
const { createServer, STATUS_CODES } = __nccwpck_require__(8605);

const PerMessageDeflate = __nccwpck_require__(9317);
const WebSocket = __nccwpck_require__(6702);
const { format, parse } = __nccwpck_require__(1380);
const { GUID, kWebSocket } = __nccwpck_require__(2596);

const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Number} [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param {Function} [options.handleProtocols] A hook to handle protocols
   * @param {String} [options.host] The hostname where to bind the server
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.noServer=false] Enable no server mode
   * @param {String} [options.path] Accept only connections matching this path
   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.port] The port where to bind the server
   * @param {http.Server} [options.server] A pre-created HTTP/S server to use
   * @param {Function} [options.verifyClient] A hook to reject connections
   * @param {Function} [callback] A listener for the `listening` event
   */
  constructor(options, callback) {
    super();

    options = {
      maxPayload: 100 * 1024 * 1024,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      ...options
    };

    if (options.port == null && !options.server && !options.noServer) {
      throw new TypeError(
        'One of the "port", "server", or "noServer" options must be specified'
      );
    }

    if (options.port != null) {
      this._server = createServer((req, res) => {
        const body = STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      const emitConnection = this.emit.bind(this, 'connection');

      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, emitConnection);
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
    if (options.clientTracking) this.clients = new Set();
    this.options = options;
  }

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }

    if (!this._server) return null;
    return this._server.address();
  }

  /**
   * Close the server.
   *
   * @param {Function} [cb] Callback
   * @public
   */
  close(cb) {
    if (cb) this.once('close', cb);

    //
    // Terminate all associated clients.
    //
    if (this.clients) {
      for (const client of this.clients) client.terminate();
    }

    const server = this._server;

    if (server) {
      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // Close the http server if it was internally created.
      //
      if (this.options.port != null) {
        server.close(() => this.emit('close'));
        return;
      }
    }

    process.nextTick(emitClose, this);
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) {
    if (this.options.path) {
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) {
    socket.on('error', socketOnError);

    const key =
      req.headers['sec-websocket-key'] !== undefined
        ? req.headers['sec-websocket-key'].trim()
        : false;
    const version = +req.headers['sec-websocket-version'];
    const extensions = {};

    if (
      req.method !== 'GET' ||
      req.headers.upgrade.toLowerCase() !== 'websocket' ||
      !key ||
      !keyRegex.test(key) ||
      (version !== 8 && version !== 13) ||
      !this.shouldHandle(req)
    ) {
      return abortHandshake(socket, 400);
    }

    if (this.options.perMessageDeflate) {
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try {
        const offers = parse(req.headers['sec-websocket-extensions']);

        if (offers[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        return abortHandshake(socket, 400);
      }
    }

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) {
      const info = {
        origin:
          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
        secure: !!(req.socket.authorized || req.socket.encrypted),
        req
      };

      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }

          this.completeUpgrade(key, extensions, req, socket, head, cb);
        });
        return;
      }

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    }

    this.completeUpgrade(key, extensions, req, socket, head, cb);
  }

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Object} extensions The accepted extensions
   * @param {http.IncomingMessage} req The request object
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */
  completeUpgrade(key, extensions, req, socket, head, cb) {
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    if (socket[kWebSocket]) {
      throw new Error(
        'server.handleUpgrade() was called more than once with the same ' +
          'socket, possibly due to a misconfiguration'
      );
    }

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${digest}`
    ];

    const ws = new WebSocket(null);
    let protocol = req.headers['sec-websocket-protocol'];

    if (protocol) {
      protocol = protocol.trim().split(/ *, */);

      //
      // Optionally call external protocol selection handler.
      //
      if (this.options.handleProtocols) {
        protocol = this.options.handleProtocols(protocol, req);
      } else {
        protocol = protocol[0];
      }

      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws._protocol = protocol;
      }
    }

    if (extensions[PerMessageDeflate.extensionName]) {
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = format({
        [PerMessageDeflate.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, this.options.maxPayload);

    if (this.clients) {
      this.clients.add(ws);
      ws.on('close', () => this.clients.delete(ws));
    }

    cb(ws, req);
  }
}

module.exports = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when
 *     called
 * @private
 */
function addListeners(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */
function emitClose(server) {
  server.emit('close');
}

/**
 * Handle premature socket errors.
 *
 * @private
 */
function socketOnError() {
  this.destroy();
}

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {net.Socket} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake(socket, code, message, headers) {
  if (socket.writable) {
    message = message || STATUS_CODES[code];
    headers = {
      Connection: 'close',
      'Content-Type': 'text/html',
      'Content-Length': Buffer.byteLength(message),
      ...headers
    };

    socket.write(
      `HTTP/1.1 ${code} ${STATUS_CODES[code]}\r\n` +
        Object.keys(headers)
          .map((h) => `${h}: ${headers[h]}`)
          .join('\r\n') +
        '\r\n\r\n' +
        message
    );
  }

  socket.removeListener('error', socketOnError);
  socket.destroy();
}


/***/ }),

/***/ 6702:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const EventEmitter = __nccwpck_require__(8614);
const https = __nccwpck_require__(7211);
const http = __nccwpck_require__(8605);
const net = __nccwpck_require__(1631);
const tls = __nccwpck_require__(4016);
const { randomBytes, createHash } = __nccwpck_require__(6417);
const { URL } = __nccwpck_require__(8835);

const PerMessageDeflate = __nccwpck_require__(9317);
const Receiver = __nccwpck_require__(1233);
const Sender = __nccwpck_require__(1404);
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID,
  kStatusCode,
  kWebSocket,
  NOOP
} = __nccwpck_require__(2596);
const { addEventListener, removeEventListener } = __nccwpck_require__(1706);
const { format, parse } = __nccwpck_require__(1380);
const { toBuffer } = __nccwpck_require__(5827);

const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const protocolVersions = [8, 13];
const closeTimeout = 30 * 1000;

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
class WebSocket extends EventEmitter {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|url.URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  constructor(address, protocols, options) {
    super();

    this._binaryType = BINARY_TYPES[0];
    this._closeCode = 1006;
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = '';
    this._closeTimer = null;
    this._extensions = {};
    this._protocol = '';
    this._readyState = WebSocket.CONNECTING;
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;

      if (Array.isArray(protocols)) {
        protocols = protocols.join(', ');
      } else if (typeof protocols === 'object' && protocols !== null) {
        options = protocols;
        protocols = undefined;
      }

      initAsClient(this, address, protocols, options);
    } else {
      this._isServer = true;
    }
  }

  /**
   * This deviates from the WHATWG interface since ws doesn't support the
   * required default "blob" type (instead we define a custom "nodebuffer"
   * type).
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }

  set binaryType(type) {
    if (!BINARY_TYPES.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return this._bufferedAmount;

    return this._socket._writableState.length + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }

  /**
   * @type {String}
   */
  get protocol() {
    return this._protocol;
  }

  /**
   * @type {Number}
   */
  get readyState() {
    return this._readyState;
  }

  /**
   * @type {String}
   */
  get url() {
    return this._url;
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Number} [maxPayload=0] The maximum allowed message size
   * @private
   */
  setSocket(socket, head, maxPayload) {
    const receiver = new Receiver(
      this.binaryType,
      this._extensions,
      this._isServer,
      maxPayload
    );

    this._sender = new Sender(socket, this._extensions);
    this._receiver = receiver;
    this._socket = socket;

    receiver[kWebSocket] = this;
    socket[kWebSocket] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    socket.setTimeout(0);
    socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError);

    this._readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this._readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate.extensionName]) {
      this._extensions[PerMessageDeflate.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this._readyState = WebSocket.CLOSED;
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} [code] Status code explaining why the connection is closing
   * @param {String} [data] A string explaining why the connection is closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();
      return;
    }

    this._readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;
      if (this._closeFrameReceived) this._socket.end();
    });

    //
    // Specify a timeout for the closing handshake to complete.
    //
    this._closeTimer = setTimeout(
      this._socket.destroy.bind(this._socket),
      closeTimeout
    );
  }

  /**
   * Send a ping.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} [options] Options object
   * @param {Boolean} [options.compress] Specifies whether or not to compress
   *     `data`
   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
   *     text
   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    const opts = {
      binary: typeof data !== 'string',
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options
    };

    if (!this._extensions[PerMessageDeflate.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || EMPTY_BUFFER, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this._socket) {
      this._readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
}

readyStates.forEach((readyState, i) => {
  const descriptor = { enumerable: true, value: i };

  Object.defineProperty(WebSocket.prototype, readyState, descriptor);
  Object.defineProperty(WebSocket, readyState, descriptor);
});

[
  'binaryType',
  'bufferedAmount',
  'extensions',
  'protocol',
  'readyState',
  'url'
].forEach((property) => {
  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket.prototype, `on${method}`, {
    configurable: true,
    enumerable: true,
    /**
     * Return the listener of the event.
     *
     * @return {(Function|undefined)} The event listener or `undefined`
     * @public
     */
    get() {
      const listeners = this.listeners(method);
      for (let i = 0; i < listeners.length; i++) {
        if (listeners[i]._listener) return listeners[i]._listener;
      }

      return undefined;
    },
    /**
     * Add a listener for the event.
     *
     * @param {Function} listener The listener to add
     * @public
     */
    set(listener) {
      const listeners = this.listeners(method);
      for (let i = 0; i < listeners.length; i++) {
        //
        // Remove only the listeners added via `addEventListener`.
        //
        if (listeners[i]._listener) this.removeListener(method, listeners[i]);
      }
      this.addEventListener(method, listener);
    }
  });
});

WebSocket.prototype.addEventListener = addEventListener;
WebSocket.prototype.removeEventListener = removeEventListener;

module.exports = WebSocket;

/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|url.URL)} address The URL to which to connect
 * @param {String} [protocols] The subprotocols
 * @param {Object} [options] Connection options
 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
 *     permessage-deflate
 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
 *     handshake request
 * @param {Number} [options.protocolVersion=13] Value of the
 *     `Sec-WebSocket-Version` header
 * @param {String} [options.origin] Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
 *     size
 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
 *     redirects
 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
 *     allowed
 * @private
 */
function initAsClient(websocket, address, protocols, options) {
  const opts = {
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options,
    createConnection: undefined,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: undefined,
    host: undefined,
    path: undefined,
    port: undefined
  };

  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} ` +
        `(supported versions: ${protocolVersions.join(', ')})`
    );
  }

  let parsedUrl;

  if (address instanceof URL) {
    parsedUrl = address;
    websocket._url = address.href;
  } else {
    parsedUrl = new URL(address);
    websocket._url = address;
  }

  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';

  if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
    throw new Error(`Invalid URL: ${websocket.url}`);
  }

  const isSecure =
    parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';
  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString('base64');
  const get = isSecure ? https.get : http.get;
  let perMessageDeflate;

  opts.createConnection = isSecure ? tlsConnect : netConnect;
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  opts.headers = {
    'Sec-WebSocket-Version': opts.protocolVersion,
    'Sec-WebSocket-Key': key,
    Connection: 'Upgrade',
    Upgrade: 'websocket',
    ...opts.headers
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers['Sec-WebSocket-Extensions'] = format({
      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols) {
    opts.headers['Sec-WebSocket-Protocol'] = protocols;
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isUnixSocket) {
    const parts = opts.path.split(':');

    opts.socketPath = parts[0];
    opts.path = parts[1];
  }

  let req = (websocket._req = get(opts));

  if (opts.timeout) {
    req.on('timeout', () => {
      abortHandshake(websocket, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', (err) => {
    if (req === null || req.aborted) return;

    req = websocket._req = null;
    websocket._readyState = WebSocket.CLOSING;
    websocket.emit('error', err);
    websocket.emitClose();
  });

  req.on('response', (res) => {
    const location = res.headers.location;
    const statusCode = res.statusCode;

    if (
      location &&
      opts.followRedirects &&
      statusCode >= 300 &&
      statusCode < 400
    ) {
      if (++websocket._redirects > opts.maxRedirects) {
        abortHandshake(websocket, req, 'Maximum redirects exceeded');
        return;
      }

      req.abort();

      const addr = new URL(location, address);

      initAsClient(websocket, addr, protocols, options);
    } else if (!websocket.emit('unexpected-response', req, res)) {
      abortHandshake(
        websocket,
        req,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });

  req.on('upgrade', (res, socket, head) => {
    websocket.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the `upgrade`
    // event.
    //
    if (websocket.readyState !== WebSocket.CONNECTING) return;

    req = websocket._req = null;

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    const serverProt = res.headers['sec-websocket-protocol'];
    const protList = (protocols || '').split(/, */);
    let protError;

    if (!protocols && serverProt) {
      protError = 'Server sent a subprotocol but none was requested';
    } else if (protocols && !serverProt) {
      protError = 'Server sent no subprotocol';
    } else if (serverProt && !protList.includes(serverProt)) {
      protError = 'Server sent an invalid subprotocol';
    }

    if (protError) {
      abortHandshake(websocket, socket, protError);
      return;
    }

    if (serverProt) websocket._protocol = serverProt;

    if (perMessageDeflate) {
      try {
        const extensions = parse(res.headers['sec-websocket-extensions']);

        if (extensions[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          websocket._extensions[
            PerMessageDeflate.extensionName
          ] = perMessageDeflate;
        }
      } catch (err) {
        abortHandshake(
          websocket,
          socket,
          'Invalid Sec-WebSocket-Extensions header'
        );
        return;
      }
    }

    websocket.setSocket(socket, head, opts.maxPayload);
  });
}

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */
function netConnect(options) {
  options.path = options.socketPath;
  return net.connect(options);
}

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */
function tlsConnect(options) {
  options.path = undefined;

  if (!options.servername && options.servername !== '') {
    options.servername = net.isIP(options.host) ? '' : options.host;
  }

  return tls.connect(options);
}

/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket)} stream The request to abort or the
 *     socket to destroy
 * @param {String} message The error message
 * @private
 */
function abortHandshake(websocket, stream, message) {
  websocket._readyState = WebSocket.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);

  if (stream.setHeader) {
    stream.abort();
    stream.once('abort', websocket.emitClose.bind(websocket));
    websocket.emit('error', err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}

/**
 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {*} [data] The data to send
 * @param {Function} [cb] Callback
 * @private
 */
function sendAfterClose(websocket, data, cb) {
  if (data) {
    const length = toBuffer(data).length;

    //
    // The `_bufferedAmount` property is used only when the peer is a client and
    // the opening handshake fails. Under these circumstances, in fact, the
    // `setSocket()` method is not called, so the `_socket` and `_sender`
    // properties are set to `null`.
    //
    if (websocket._socket) websocket._sender._bufferedBytes += length;
    else websocket._bufferedAmount += length;
  }

  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket.readyState} ` +
        `(${readyStates[websocket.readyState]})`
    );
    cb(err);
  }
}

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {String} reason The reason for closing
 * @private
 */
function receiverOnConclude(code, reason) {
  const websocket = this[kWebSocket];

  websocket._socket.removeListener('data', socketOnData);
  websocket._socket.resume();

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
}

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain() {
  this[kWebSocket]._socket.resume();
}

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */
function receiverOnError(err) {
  const websocket = this[kWebSocket];

  websocket._socket.removeListener('data', socketOnData);

  websocket._readyState = WebSocket.CLOSING;
  websocket._closeCode = err[kStatusCode];
  websocket.emit('error', err);
  websocket._socket.destroy();
}

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish() {
  this[kWebSocket].emitClose();
}

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message
 * @private
 */
function receiverOnMessage(data) {
  this[kWebSocket].emit('message', data);
}

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */
function receiverOnPing(data) {
  const websocket = this[kWebSocket];

  websocket.pong(data, !websocket._isServer, NOOP);
  websocket.emit('ping', data);
}

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */
function receiverOnPong(data) {
  this[kWebSocket].emit('pong', data);
}

/**
 * The listener of the `net.Socket` `'close'` event.
 *
 * @private
 */
function socketOnClose() {
  const websocket = this[kWebSocket];

  this.removeListener('close', socketOnClose);
  this.removeListener('end', socketOnEnd);

  websocket._readyState = WebSocket.CLOSING;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk and emitted synchronously in a single
  // `'data'` event.
  //
  websocket._socket.read();
  websocket._receiver.end();

  this.removeListener('data', socketOnData);
  this[kWebSocket] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  }
}

/**
 * The listener of the `net.Socket` `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData(chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the `net.Socket` `'end'` event.
 *
 * @private
 */
function socketOnEnd() {
  const websocket = this[kWebSocket];

  websocket._readyState = WebSocket.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the `net.Socket` `'error'` event.
 *
 * @private
 */
function socketOnError() {
  const websocket = this[kWebSocket];

  this.removeListener('error', socketOnError);
  this.on('error', NOOP);

  if (websocket) {
    websocket._readyState = WebSocket.CLOSING;
    this.destroy();
  }
}


/***/ }),

/***/ 2855:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const rolighed_server_1 = __importStar(__nccwpck_require__(3175));
const rolighed_common_1 = __nccwpck_require__(6186);
const rolighed_platform_zigbee2mqtt_1 = __importDefault(__nccwpck_require__(6581));
const rolighed_plugin_homekit_1 = __importDefault(__nccwpck_require__(5163));
const groupNames = {
    livingroomLights: 'livingroom_lights',
    libraryLights: 'library_lights',
    libraryDoor: 'library_door',
    upstairsLights: 'upstairs_lights',
};
const accessoryNames = {
    tvroomLights: 'Living Room Lights',
    libraryLights: 'Library Lights',
    libraryDoor: 'Library Door',
};
const deviceNames = {
    libraryLight1: 'Library Light 1 a',
    tvroomLight1: 'Living Room Light',
    doorSwitch: '0x5c0272fffe835bc2',
};
const doorOpenState = {
    accessories: {
        [accessoryNames.libraryLights]: {
            type: 'lightbulb',
            bind: {
                state: groupNames.livingroomLights,
                brightness: groupNames.upstairsLights,
            },
        },
        [accessoryNames.tvroomLights]: {
            type: 'lightbulb',
            bind: {
                state: groupNames.livingroomLights,
                brightness: groupNames.upstairsLights,
            },
        },
        [accessoryNames.libraryDoor]: {
            type: 'door',
            bind: {
                open: groupNames.libraryDoor,
            },
        },
    },
    deviceGroups: {
        [deviceNames.tvroomLight1]: [groupNames.upstairsLights, groupNames.livingroomLights],
        [deviceNames.libraryLight1]: [groupNames.upstairsLights, groupNames.livingroomLights],
    },
};
const doorCloseState = {
    accessories: {
        [accessoryNames.libraryLights]: {
            type: 'lightbulb',
            bind: {
                state: groupNames.libraryLights,
                brightness: groupNames.libraryLights,
            },
        },
        [accessoryNames.tvroomLights]: {
            type: 'lightbulb',
            bind: {
                state: groupNames.livingroomLights,
                brightness: groupNames.upstairsLights,
            },
        },
        [accessoryNames.libraryDoor]: {
            type: 'door',
            bind: {
                open: groupNames.libraryDoor,
            },
        },
    },
    deviceGroups: {
        [deviceNames.tvroomLight1]: [groupNames.livingroomLights, groupNames.upstairsLights],
        [deviceNames.libraryLight1]: [groupNames.libraryLights],
    },
};
const doorOpenStateEvening = {
    accessories: {
        [accessoryNames.libraryLights]: {
            type: 'lightbulb',
            bind: {
                state: groupNames.libraryLights,
                brightness: groupNames.libraryLights,
            },
        },
        [accessoryNames.tvroomLights]: {
            type: 'lightbulb',
            bind: {
                state: groupNames.libraryLights,
                brightness: groupNames.libraryLights,
            },
        },
        [accessoryNames.libraryDoor]: {
            type: 'door',
            bind: {
                open: groupNames.libraryDoor,
            },
        },
    },
    deviceGroups: {
        [deviceNames.tvroomLight1]: [groupNames.libraryLights],
        [deviceNames.libraryLight1]: [groupNames.libraryLights],
    },
};
const motionSensor = (config, { dispatch }) => {
    let timer;
    return async ({ type, payload, meta }) => {
        if (type === rolighed_common_1.actionNames.PLATFORM.SET_DEVICE && (meta === null || meta === void 0 ? void 0 : meta.name) === config.device) {
            const occupancy = payload.state.occupancy;
            if (occupancy) {
                clearTimeout(timer);
                dispatch(rolighed_common_1.groupActions.setGroupSettings({
                    hallway: {
                        state: 'ON',
                    },
                }));
                timer = setTimeout(() => {
                    dispatch(rolighed_common_1.groupActions.setGroupSettings({
                        hallway: {
                            state: 'OFF',
                        },
                    }));
                }, config.timeout || 10 * 60 * 1000);
            }
        }
    };
};
const doorButton = (config, { dispatch }) => {
    return async ({ type, payload, meta }) => {
        if (type === rolighed_common_1.actionNames.PLATFORM.SET_DEVICE && (meta === null || meta === void 0 ? void 0 : meta.name) === config.device) {
            const action = payload.state.action;
            dispatch(rolighed_common_1.groupActions.setGroupSettings({
                library_door: {
                    open: action === 'on',
                },
            }));
        }
    };
};
const libraryDoor = (config, { dispatch }) => {
    return async (action) => {
        if (action.type === rolighed_common_1.actionNames.GROUPS.SET_GROUP_SETTINGS
            && typeof action.payload.library_door !== 'undefined') {
            const state = action.payload.library_door.open;
            if (!state) {
                await Promise.resolve(dispatch(rolighed_common_1.groupActions.update(doorCloseState)));
            }
            else if (new Date().getHours() < 19) {
                await Promise.resolve(dispatch(rolighed_common_1.groupActions.update(doorOpenState)));
            }
            else {
                await Promise.resolve(dispatch(rolighed_common_1.groupActions.update(doorOpenStateEvening)));
            }
        }
    };
};
const config = {
    plugins: {
        platforms: {
            pkg: rolighed_server_1.platforms,
            config: {
                zigbee2mqtt: {
                    pkg: rolighed_platform_zigbee2mqtt_1.default,
                    config: {},
                },
            },
        },
        scripts: {
            pkg: rolighed_server_1.scripts,
            config: {
                libraryDoor: { pkg: libraryDoor, config: {} },
                doorButton: { pkg: doorButton, config: { device: deviceNames.doorSwitch } },
            },
        },
        homekit: {
            pkg: rolighed_plugin_homekit_1.default,
            config: {
                username: '17:51:07:F4:AC:8A',
                pincode: '678-90-875',
                port: 41802,
            },
        },
    }
};
const run = async () => {
    const store = await rolighed_server_1.default(config);
    store.subscribe(() => {
        console.log('state', store.getState().deviceStates);
    });
    await Promise.resolve(store.dispatch(rolighed_common_1.groupActions.update(doorOpenState)));
};
run().catch(console.error);


/***/ }),

/***/ 1421:
/***/ ((module) => {

module.exports = eval("require")("bufferutil");


/***/ }),

/***/ 7187:
/***/ ((module) => {

module.exports = eval("require")("utf-8-validate");


/***/ }),

/***/ 7308:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse("{\"name\":\"hap-nodejs\",\"version\":\"0.9.2\",\"description\":\"HAP-NodeJS is a Node.js implementation of HomeKit Accessory Server.\",\"main\":\"dist/index.js\",\"types\":\"dist/index.d.ts\",\"maintainers\":[\"Andreas Bauer <mail@anderl-bauer.de>\"],\"author\":\"Khaos Tian <khaos.tian@gmail.com> (https://tz.is/)\",\"homepage\":\"https://github.com/homebridge/HAP-NodeJS\",\"license\":\"Apache-2.0\",\"scripts\":{\"clean\":\"rimraf dist && rimraf coverage\",\"build\":\"rimraf dist && tsc && node .github/workflows/node-persist-ignore.js\",\"prepublishOnly\":\"npm run build\",\"postpublish\":\"npm run clean\",\"test\":\"jest\",\"test-coverage\":\"jest --coverage\",\"start\":\"node dist/BridgedCore.js\",\"docs\":\"typedoc src/index.ts\"},\"keywords\":[\"hap-nodejs\",\"hap\",\"homekit\",\"homekit-accessory-protocol\",\"homekit-server\",\"homekit-protocol\",\"homekit-device\",\"homekit-accessory\",\"hap-server\",\"homekit-support\",\"siri\"],\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/homebridge/HAP-NodeJS.git\"},\"bugs\":{\"url\":\"https://github.com/homebridge/HAP-NodeJS/issues\"},\"engines\":{\"node\":\">=10.17.0\"},\"files\":[\"README.md\",\"LICENSE\",\"dist\",\"@types\"],\"dependencies\":{\"@homebridge/ciao\":\"~1.1.2\",\"bonjour-hap\":\"~3.6.2\",\"debug\":\"^4.3.1\",\"fast-srp-hap\":\"2.0.3\",\"futoin-hkdf\":\"~1.3.2\",\"ip\":\"^1.1.3\",\"node-persist\":\"^0.0.11\",\"source-map-support\":\"^0.5.19\",\"tslib\":\"^2.1.0\",\"tweetnacl\":\"^1.0.3\"},\"devDependencies\":{\"@types/debug\":\"^4.1.5\",\"@types/escape-html\":\"^1.0.0\",\"@types/jest\":\"^26.0.20\",\"@types/node\":\"^10.17.50\",\"commander\":\"^6.2.1\",\"escape-html\":\"^1.0.3\",\"jest\":\"^26.6.3\",\"rimraf\":\"^3.0.2\",\"semver\":\"^7.3.4\",\"simple-plist\":\"^1.1.1\",\"ts-jest\":\"^26.4.4\",\"ts-node\":\"^9.1.1\",\"typedoc\":\"0.20.25\",\"typescript\":\"^4.1.3\"}}");

/***/ }),

/***/ 2357:
/***/ ((module) => {

"use strict";
module.exports = require("assert");;

/***/ }),

/***/ 4293:
/***/ ((module) => {

"use strict";
module.exports = require("buffer");;

/***/ }),

/***/ 3129:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");;

/***/ }),

/***/ 6417:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");;

/***/ }),

/***/ 6200:
/***/ ((module) => {

"use strict";
module.exports = require("dgram");;

/***/ }),

/***/ 8614:
/***/ ((module) => {

"use strict";
module.exports = require("events");;

/***/ }),

/***/ 5747:
/***/ ((module) => {

"use strict";
module.exports = require("fs");;

/***/ }),

/***/ 8605:
/***/ ((module) => {

"use strict";
module.exports = require("http");;

/***/ }),

/***/ 7211:
/***/ ((module) => {

"use strict";
module.exports = require("https");;

/***/ }),

/***/ 1631:
/***/ ((module) => {

"use strict";
module.exports = require("net");;

/***/ }),

/***/ 2087:
/***/ ((module) => {

"use strict";
module.exports = require("os");;

/***/ }),

/***/ 5622:
/***/ ((module) => {

"use strict";
module.exports = require("path");;

/***/ }),

/***/ 2413:
/***/ ((module) => {

"use strict";
module.exports = require("stream");;

/***/ }),

/***/ 4016:
/***/ ((module) => {

"use strict";
module.exports = require("tls");;

/***/ }),

/***/ 3867:
/***/ ((module) => {

"use strict";
module.exports = require("tty");;

/***/ }),

/***/ 8835:
/***/ ((module) => {

"use strict";
module.exports = require("url");;

/***/ }),

/***/ 1669:
/***/ ((module) => {

"use strict";
module.exports = require("util");;

/***/ }),

/***/ 8761:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__nccwpck_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__nccwpck_require__.o(definition, key) && !__nccwpck_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__nccwpck_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__nccwpck_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__nccwpck_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	__nccwpck_require__.ab = __dirname + "/";/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __nccwpck_require__(2855);
/******/ })()
;